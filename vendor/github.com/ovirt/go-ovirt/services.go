//
// Copyright (c) 2017 Joey <majunjiev@gmail.com>.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package ovirtsdk

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/httputil"
	"net/url"
	"strings"
)

//
// Provides a way for clients to list available files.
// This service is specifically targeted to ISO storage domains, which contain ISO images and virtual floppy disks
// (VFDs) that an administrator uploads.
// The addition of a CD-ROM device to a virtual machine requires an ISO image from the files of an ISO storage domain.
//
type FilesService struct {
	BaseService
}

func NewFilesService(connection *Connection, path string) *FilesService {
	var result FilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of ISO images and virtual floppy disks available in the storage domain. The order of
// the returned list is not guaranteed.
// If the `refresh` parameter is `false`, the returned list may not reflect recent changes to the storage domain;
// for example, it may not contain a new ISO file that was recently added. This is because the
// server caches the list of files to improve performance. To get the very latest results, set the `refresh`
// parameter to `true`.
// The default value of the `refresh` parameter is `true`, but it can be changed using the configuration value
// `ForceRefreshDomainFilesByDefault`:
// [source]
// ----
// # engine-config -s ForceRefreshDomainFilesByDefault=false
// ----
// IMPORTANT: Setting the value of the `refresh` parameter to `true` has an impact on the performance of the
// server. Use it only if necessary.
//
type FilesServiceListRequest struct {
	FilesService  *FilesService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	refresh       *bool
	search        *string
}

func (p *FilesServiceListRequest) Header(key, value string) *FilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilesServiceListRequest) Query(key, value string) *FilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilesServiceListRequest) CaseSensitive(caseSensitive bool) *FilesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *FilesServiceListRequest) Follow(follow string) *FilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *FilesServiceListRequest) Max(max int64) *FilesServiceListRequest {
	p.max = &max
	return p
}

func (p *FilesServiceListRequest) Refresh(refresh bool) *FilesServiceListRequest {
	p.refresh = &refresh
	return p
}

func (p *FilesServiceListRequest) Search(search string) *FilesServiceListRequest {
	p.search = &search
	return p
}

func (p *FilesServiceListRequest) Send() (*FilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FilesService.connection.URL(), p.FilesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.refresh != nil {
		values["refresh"] = []string{fmt.Sprintf("%v", *p.refresh)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &FilesServiceListResponse{file: result}, nil
}

func (p *FilesServiceListRequest) MustSend() *FilesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of ISO images and virtual floppy disks available in the storage domain. The order of
// the returned list is not guaranteed.
// If the `refresh` parameter is `false`, the returned list may not reflect recent changes to the storage domain;
// for example, it may not contain a new ISO file that was recently added. This is because the
// server caches the list of files to improve performance. To get the very latest results, set the `refresh`
// parameter to `true`.
// The default value of the `refresh` parameter is `true`, but it can be changed using the configuration value
// `ForceRefreshDomainFilesByDefault`:
// [source]
// ----
// # engine-config -s ForceRefreshDomainFilesByDefault=false
// ----
// IMPORTANT: Setting the value of the `refresh` parameter to `true` has an impact on the performance of the
// server. Use it only if necessary.
//
type FilesServiceListResponse struct {
	file *FileSlice
}

func (p *FilesServiceListResponse) File() (*FileSlice, bool) {
	if p.file != nil {
		return p.file, true
	}
	return nil, false
}

func (p *FilesServiceListResponse) MustFile() *FileSlice {
	if p.file == nil {
		panic("file in response does not exist")
	}
	return p.file
}

//
// Returns the list of ISO images and virtual floppy disks available in the storage domain. The order of
// the returned list is not guaranteed.
// If the `refresh` parameter is `false`, the returned list may not reflect recent changes to the storage domain;
// for example, it may not contain a new ISO file that was recently added. This is because the
// server caches the list of files to improve performance. To get the very latest results, set the `refresh`
// parameter to `true`.
// The default value of the `refresh` parameter is `true`, but it can be changed using the configuration value
// `ForceRefreshDomainFilesByDefault`:
// [source]
// ----
// # engine-config -s ForceRefreshDomainFilesByDefault=false
// ----
// IMPORTANT: Setting the value of the `refresh` parameter to `true` has an impact on the performance of the
// server. Use it only if necessary.
//
func (p *FilesService) List() *FilesServiceListRequest {
	return &FilesServiceListRequest{FilesService: p}
}

//
//
func (op *FilesService) FileService(id string) *FileService {
	return NewFileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.FileService(path), nil
	}
	return op.FileService(path[:index]).Service(path[index+1:])
}

func (op *FilesService) String() string {
	return fmt.Sprintf("FilesService:%s", op.path)
}

//
// This service manages the set of disks attached to a template. Each attached disk is represented by a
// <<types/disk_attachment,DiskAttachment>>.
//
type TemplateDiskAttachmentsService struct {
	BaseService
}

func NewTemplateDiskAttachmentsService(connection *Connection, path string) *TemplateDiskAttachmentsService {
	var result TemplateDiskAttachmentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// List the disks that are attached to the template.
// The order of the returned list of attachments isn't guaranteed.
//
type TemplateDiskAttachmentsServiceListRequest struct {
	TemplateDiskAttachmentsService *TemplateDiskAttachmentsService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *TemplateDiskAttachmentsServiceListRequest) Header(key, value string) *TemplateDiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentsServiceListRequest) Query(key, value string) *TemplateDiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentsServiceListRequest) Follow(follow string) *TemplateDiskAttachmentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *TemplateDiskAttachmentsServiceListRequest) Send() (*TemplateDiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateDiskAttachmentsService.connection.URL(), p.TemplateDiskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateDiskAttachmentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateDiskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateDiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateDiskAttachmentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateDiskAttachmentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &TemplateDiskAttachmentsServiceListResponse{attachments: result}, nil
}

func (p *TemplateDiskAttachmentsServiceListRequest) MustSend() *TemplateDiskAttachmentsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the disks that are attached to the template.
// The order of the returned list of attachments isn't guaranteed.
//
type TemplateDiskAttachmentsServiceListResponse struct {
	attachments *DiskAttachmentSlice
}

func (p *TemplateDiskAttachmentsServiceListResponse) Attachments() (*DiskAttachmentSlice, bool) {
	if p.attachments != nil {
		return p.attachments, true
	}
	return nil, false
}

func (p *TemplateDiskAttachmentsServiceListResponse) MustAttachments() *DiskAttachmentSlice {
	if p.attachments == nil {
		panic("attachments in response does not exist")
	}
	return p.attachments
}

//
// List the disks that are attached to the template.
// The order of the returned list of attachments isn't guaranteed.
//
func (p *TemplateDiskAttachmentsService) List() *TemplateDiskAttachmentsServiceListRequest {
	return &TemplateDiskAttachmentsServiceListRequest{TemplateDiskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *TemplateDiskAttachmentsService) AttachmentService(id string) *TemplateDiskAttachmentService {
	return NewTemplateDiskAttachmentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskAttachmentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AttachmentService(path), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *TemplateDiskAttachmentsService) String() string {
	return fmt.Sprintf("TemplateDiskAttachmentsService:%s", op.path)
}

//
//
type TemplateNicService struct {
	BaseService
}

func NewTemplateNicService(connection *Connection, path string) *TemplateNicService {
	var result TemplateNicService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type TemplateNicServiceGetRequest struct {
	TemplateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *TemplateNicServiceGetRequest) Header(key, value string) *TemplateNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceGetRequest) Query(key, value string) *TemplateNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceGetRequest) Follow(follow string) *TemplateNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *TemplateNicServiceGetRequest) Send() (*TemplateNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateNicService.connection.URL(), p.TemplateNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateNicServiceGetResponse{nic: result}, nil
}

func (p *TemplateNicServiceGetRequest) MustSend() *TemplateNicServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type TemplateNicServiceGetResponse struct {
	nic *Nic
}

func (p *TemplateNicServiceGetResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *TemplateNicServiceGetResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
//
func (p *TemplateNicService) Get() *TemplateNicServiceGetRequest {
	return &TemplateNicServiceGetRequest{TemplateNicService: p}
}

//
//
type TemplateNicServiceRemoveRequest struct {
	TemplateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *TemplateNicServiceRemoveRequest) Header(key, value string) *TemplateNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceRemoveRequest) Query(key, value string) *TemplateNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceRemoveRequest) Async(async bool) *TemplateNicServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *TemplateNicServiceRemoveRequest) Send() (*TemplateNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateNicService.connection.URL(), p.TemplateNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateNicServiceRemoveResponse), nil
}

func (p *TemplateNicServiceRemoveRequest) MustSend() *TemplateNicServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type TemplateNicServiceRemoveResponse struct {
}

//
//
func (p *TemplateNicService) Remove() *TemplateNicServiceRemoveRequest {
	return &TemplateNicServiceRemoveRequest{TemplateNicService: p}
}

//
// Update the specified network interface card attached to the template.
//
type TemplateNicServiceUpdateRequest struct {
	TemplateNicService *TemplateNicService
	header             map[string]string
	query              map[string]string
	async              *bool
	nic                *Nic
}

func (p *TemplateNicServiceUpdateRequest) Header(key, value string) *TemplateNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicServiceUpdateRequest) Query(key, value string) *TemplateNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicServiceUpdateRequest) Async(async bool) *TemplateNicServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *TemplateNicServiceUpdateRequest) Nic(nic *Nic) *TemplateNicServiceUpdateRequest {
	p.nic = nic
	return p
}

func (p *TemplateNicServiceUpdateRequest) Send() (*TemplateNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateNicService.connection.URL(), p.TemplateNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateNicServiceUpdateResponse{nic: result}, nil
}

func (p *TemplateNicServiceUpdateRequest) MustSend() *TemplateNicServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified network interface card attached to the template.
//
type TemplateNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *TemplateNicServiceUpdateResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *TemplateNicServiceUpdateResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Update the specified network interface card attached to the template.
//
func (p *TemplateNicService) Update() *TemplateNicServiceUpdateRequest {
	return &TemplateNicServiceUpdateRequest{TemplateNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateNicService) String() string {
	return fmt.Sprintf("TemplateNicService:%s", op.path)
}

//
//
type NetworkLabelService struct {
	BaseService
}

func NewNetworkLabelService(connection *Connection, path string) *NetworkLabelService {
	var result NetworkLabelService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type NetworkLabelServiceGetRequest struct {
	NetworkLabelService *NetworkLabelService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *NetworkLabelServiceGetRequest) Header(key, value string) *NetworkLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelServiceGetRequest) Query(key, value string) *NetworkLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelServiceGetRequest) Follow(follow string) *NetworkLabelServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *NetworkLabelServiceGetRequest) Send() (*NetworkLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkLabelService.connection.URL(), p.NetworkLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworkLabelServiceGetResponse{label: result}, nil
}

func (p *NetworkLabelServiceGetRequest) MustSend() *NetworkLabelServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type NetworkLabelServiceGetResponse struct {
	label *NetworkLabel
}

func (p *NetworkLabelServiceGetResponse) Label() (*NetworkLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *NetworkLabelServiceGetResponse) MustLabel() *NetworkLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
//
func (p *NetworkLabelService) Get() *NetworkLabelServiceGetRequest {
	return &NetworkLabelServiceGetRequest{NetworkLabelService: p}
}

//
// Removes a label from a logical network.
// For example, to remove the label `exemplary` from a logical network having id `123` send the following request:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123/networklabels/exemplary
// ----
//
type NetworkLabelServiceRemoveRequest struct {
	NetworkLabelService *NetworkLabelService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *NetworkLabelServiceRemoveRequest) Header(key, value string) *NetworkLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelServiceRemoveRequest) Query(key, value string) *NetworkLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelServiceRemoveRequest) Async(async bool) *NetworkLabelServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *NetworkLabelServiceRemoveRequest) Send() (*NetworkLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkLabelService.connection.URL(), p.NetworkLabelService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(NetworkLabelServiceRemoveResponse), nil
}

func (p *NetworkLabelServiceRemoveRequest) MustSend() *NetworkLabelServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a label from a logical network.
// For example, to remove the label `exemplary` from a logical network having id `123` send the following request:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123/networklabels/exemplary
// ----
//
type NetworkLabelServiceRemoveResponse struct {
}

//
// Removes a label from a logical network.
// For example, to remove the label `exemplary` from a logical network having id `123` send the following request:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123/networklabels/exemplary
// ----
//
func (p *NetworkLabelService) Remove() *NetworkLabelServiceRemoveRequest {
	return &NetworkLabelServiceRemoveRequest{NetworkLabelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkLabelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkLabelService) String() string {
	return fmt.Sprintf("NetworkLabelService:%s", op.path)
}

//
// Represents a service to manage collection of event-subscription of a user.
//
type EventSubscriptionsService struct {
	BaseService
}

func NewEventSubscriptionsService(connection *Connection, path string) *EventSubscriptionsService {
	var result EventSubscriptionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new event-subscription to the system.
// An event-subscription is always added in the context of a user. For example, to add new
// event-subscription for `host_high_cpu_use` for user `123`, and have the notification
// sent to the e-mail address: `a@b.com`, send a request like this:
// ....
// POST /ovirt-engine/api/users/123/eventsubscriptions
// ....
// With a request body like this:
// [source,xml]
// ----
// <event_subscription>
//     <event>host_high_cpu_use</event>
//     <address>a@b.com</address>
// </event_subscription>
// ----
// The event name will become the ID of the new event-subscription entity:
// GET .../api/users/123/eventsubscriptions/host_high_cpu_use
// Note that no user id is provided in the request body. This is because the user-id (in this case 123)
// is already known to the API from the context. Note also that event-subscription entity contains
// notification-method field, but it is not provided either in the request body. This is because currently
// it's always set to SMTP as SNMP notifications are still unsupported by the API layer.
//
type EventSubscriptionsServiceAddRequest struct {
	EventSubscriptionsService *EventSubscriptionsService
	header                    map[string]string
	query                     map[string]string
	eventSubscription         *EventSubscription
}

func (p *EventSubscriptionsServiceAddRequest) Header(key, value string) *EventSubscriptionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventSubscriptionsServiceAddRequest) Query(key, value string) *EventSubscriptionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventSubscriptionsServiceAddRequest) EventSubscription(eventSubscription *EventSubscription) *EventSubscriptionsServiceAddRequest {
	p.eventSubscription = eventSubscription
	return p
}

func (p *EventSubscriptionsServiceAddRequest) Send() (*EventSubscriptionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EventSubscriptionsService.connection.URL(), p.EventSubscriptionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLEventSubscriptionWriteOne(writer, p.eventSubscription, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventSubscriptionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventSubscriptionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventSubscriptionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventSubscriptionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventSubscriptionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventSubscriptionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &EventSubscriptionsServiceAddResponse{eventSubscription: result}, nil
}

func (p *EventSubscriptionsServiceAddRequest) MustSend() *EventSubscriptionsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new event-subscription to the system.
// An event-subscription is always added in the context of a user. For example, to add new
// event-subscription for `host_high_cpu_use` for user `123`, and have the notification
// sent to the e-mail address: `a@b.com`, send a request like this:
// ....
// POST /ovirt-engine/api/users/123/eventsubscriptions
// ....
// With a request body like this:
// [source,xml]
// ----
// <event_subscription>
//     <event>host_high_cpu_use</event>
//     <address>a@b.com</address>
// </event_subscription>
// ----
// The event name will become the ID of the new event-subscription entity:
// GET .../api/users/123/eventsubscriptions/host_high_cpu_use
// Note that no user id is provided in the request body. This is because the user-id (in this case 123)
// is already known to the API from the context. Note also that event-subscription entity contains
// notification-method field, but it is not provided either in the request body. This is because currently
// it's always set to SMTP as SNMP notifications are still unsupported by the API layer.
//
type EventSubscriptionsServiceAddResponse struct {
	eventSubscription *EventSubscription
}

func (p *EventSubscriptionsServiceAddResponse) EventSubscription() (*EventSubscription, bool) {
	if p.eventSubscription != nil {
		return p.eventSubscription, true
	}
	return nil, false
}

func (p *EventSubscriptionsServiceAddResponse) MustEventSubscription() *EventSubscription {
	if p.eventSubscription == nil {
		panic("eventSubscription in response does not exist")
	}
	return p.eventSubscription
}

//
// Add a new event-subscription to the system.
// An event-subscription is always added in the context of a user. For example, to add new
// event-subscription for `host_high_cpu_use` for user `123`, and have the notification
// sent to the e-mail address: `a@b.com`, send a request like this:
// ....
// POST /ovirt-engine/api/users/123/eventsubscriptions
// ....
// With a request body like this:
// [source,xml]
// ----
// <event_subscription>
//     <event>host_high_cpu_use</event>
//     <address>a@b.com</address>
// </event_subscription>
// ----
// The event name will become the ID of the new event-subscription entity:
// GET .../api/users/123/eventsubscriptions/host_high_cpu_use
// Note that no user id is provided in the request body. This is because the user-id (in this case 123)
// is already known to the API from the context. Note also that event-subscription entity contains
// notification-method field, but it is not provided either in the request body. This is because currently
// it's always set to SMTP as SNMP notifications are still unsupported by the API layer.
//
func (p *EventSubscriptionsService) Add() *EventSubscriptionsServiceAddRequest {
	return &EventSubscriptionsServiceAddRequest{EventSubscriptionsService: p}
}

//
// List the event-subscriptions for the provided user.
// For example to list event-subscriptions for user `123`:
// ....
// GET /ovirt-engine/api/users/123/event-subscriptions
// ....
// [source,xml]
// ----
// <event-subscriptions>
//   <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/host_install_failed">
//     <event>host_install_failed</event>
//     <notification_method>smtp</notification_method>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//     <address>a@b.com</address>
//   </event-subscription>
//   <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/vm_paused">
//     <event>vm_paused</event>
//     <notification_method>smtp</notification_method>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//     <address>a@b.com</address>
//   </event-subscription>
// </event-subscriptions>
// ----
//
type EventSubscriptionsServiceListRequest struct {
	EventSubscriptionsService *EventSubscriptionsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *EventSubscriptionsServiceListRequest) Header(key, value string) *EventSubscriptionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventSubscriptionsServiceListRequest) Query(key, value string) *EventSubscriptionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventSubscriptionsServiceListRequest) Follow(follow string) *EventSubscriptionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *EventSubscriptionsServiceListRequest) Max(max int64) *EventSubscriptionsServiceListRequest {
	p.max = &max
	return p
}

func (p *EventSubscriptionsServiceListRequest) Send() (*EventSubscriptionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EventSubscriptionsService.connection.URL(), p.EventSubscriptionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventSubscriptionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventSubscriptionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventSubscriptionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventSubscriptionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventSubscriptionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventSubscriptionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &EventSubscriptionsServiceListResponse{eventSubscriptions: result}, nil
}

func (p *EventSubscriptionsServiceListRequest) MustSend() *EventSubscriptionsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the event-subscriptions for the provided user.
// For example to list event-subscriptions for user `123`:
// ....
// GET /ovirt-engine/api/users/123/event-subscriptions
// ....
// [source,xml]
// ----
// <event-subscriptions>
//   <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/host_install_failed">
//     <event>host_install_failed</event>
//     <notification_method>smtp</notification_method>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//     <address>a@b.com</address>
//   </event-subscription>
//   <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/vm_paused">
//     <event>vm_paused</event>
//     <notification_method>smtp</notification_method>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//     <address>a@b.com</address>
//   </event-subscription>
// </event-subscriptions>
// ----
//
type EventSubscriptionsServiceListResponse struct {
	eventSubscriptions *EventSubscriptionSlice
}

func (p *EventSubscriptionsServiceListResponse) EventSubscriptions() (*EventSubscriptionSlice, bool) {
	if p.eventSubscriptions != nil {
		return p.eventSubscriptions, true
	}
	return nil, false
}

func (p *EventSubscriptionsServiceListResponse) MustEventSubscriptions() *EventSubscriptionSlice {
	if p.eventSubscriptions == nil {
		panic("eventSubscriptions in response does not exist")
	}
	return p.eventSubscriptions
}

//
// List the event-subscriptions for the provided user.
// For example to list event-subscriptions for user `123`:
// ....
// GET /ovirt-engine/api/users/123/event-subscriptions
// ....
// [source,xml]
// ----
// <event-subscriptions>
//   <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/host_install_failed">
//     <event>host_install_failed</event>
//     <notification_method>smtp</notification_method>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//     <address>a@b.com</address>
//   </event-subscription>
//   <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/vm_paused">
//     <event>vm_paused</event>
//     <notification_method>smtp</notification_method>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//     <address>a@b.com</address>
//   </event-subscription>
// </event-subscriptions>
// ----
//
func (p *EventSubscriptionsService) List() *EventSubscriptionsServiceListRequest {
	return &EventSubscriptionsServiceListRequest{EventSubscriptionsService: p}
}

//
// Reference to the service that manages a specific event-subscription.
//
func (op *EventSubscriptionsService) EventSubscriptionService(id string) *EventSubscriptionService {
	return NewEventSubscriptionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EventSubscriptionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.EventSubscriptionService(path), nil
	}
	return op.EventSubscriptionService(path[:index]).Service(path[index+1:])
}

func (op *EventSubscriptionsService) String() string {
	return fmt.Sprintf("EventSubscriptionsService:%s", op.path)
}

//
// This service represents one label to entity assignment
// when accessed using the entities/affinitylabels subcollection.
//
type AssignedAffinityLabelService struct {
	BaseService
}

func NewAssignedAffinityLabelService(connection *Connection, path string) *AssignedAffinityLabelService {
	var result AssignedAffinityLabelService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves details about the attached label.
//
type AssignedAffinityLabelServiceGetRequest struct {
	AssignedAffinityLabelService *AssignedAffinityLabelService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
}

func (p *AssignedAffinityLabelServiceGetRequest) Header(key, value string) *AssignedAffinityLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceGetRequest) Query(key, value string) *AssignedAffinityLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceGetRequest) Follow(follow string) *AssignedAffinityLabelServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AssignedAffinityLabelServiceGetRequest) Send() (*AssignedAffinityLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedAffinityLabelService.connection.URL(), p.AssignedAffinityLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedAffinityLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedAffinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedAffinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedAffinityLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedAffinityLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedAffinityLabelServiceGetResponse{label: result}, nil
}

func (p *AssignedAffinityLabelServiceGetRequest) MustSend() *AssignedAffinityLabelServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves details about the attached label.
//
type AssignedAffinityLabelServiceGetResponse struct {
	label *AffinityLabel
}

func (p *AssignedAffinityLabelServiceGetResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *AssignedAffinityLabelServiceGetResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Retrieves details about the attached label.
//
func (p *AssignedAffinityLabelService) Get() *AssignedAffinityLabelServiceGetRequest {
	return &AssignedAffinityLabelServiceGetRequest{AssignedAffinityLabelService: p}
}

//
// Removes the label from an entity. Does not touch the label itself.
//
type AssignedAffinityLabelServiceRemoveRequest struct {
	AssignedAffinityLabelService *AssignedAffinityLabelService
	header                       map[string]string
	query                        map[string]string
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Header(key, value string) *AssignedAffinityLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Query(key, value string) *AssignedAffinityLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelServiceRemoveRequest) Send() (*AssignedAffinityLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedAffinityLabelService.connection.URL(), p.AssignedAffinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedAffinityLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedAffinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedAffinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedAffinityLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedAffinityLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedAffinityLabelServiceRemoveResponse), nil
}

func (p *AssignedAffinityLabelServiceRemoveRequest) MustSend() *AssignedAffinityLabelServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the label from an entity. Does not touch the label itself.
//
type AssignedAffinityLabelServiceRemoveResponse struct {
}

//
// Removes the label from an entity. Does not touch the label itself.
//
func (p *AssignedAffinityLabelService) Remove() *AssignedAffinityLabelServiceRemoveRequest {
	return &AssignedAffinityLabelServiceRemoveRequest{AssignedAffinityLabelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedAffinityLabelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedAffinityLabelService) String() string {
	return fmt.Sprintf("AssignedAffinityLabelService:%s", op.path)
}

//
// Manages the ser of labels attached to a network or to a host NIC.
//
type NetworkLabelsService struct {
	BaseService
}

func NewNetworkLabelsService(connection *Connection, path string) *NetworkLabelsService {
	var result NetworkLabelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Attaches label to logical network.
// You can attach labels to a logical network to automate the association of that logical network with physical host
// network interfaces to which the same label has been attached.
// For example, to attach the label `mylabel` to a logical network having id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks/123/networklabels
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_label id="mylabel"/>
// ----
//
type NetworkLabelsServiceAddRequest struct {
	NetworkLabelsService *NetworkLabelsService
	header               map[string]string
	query                map[string]string
	label                *NetworkLabel
}

func (p *NetworkLabelsServiceAddRequest) Header(key, value string) *NetworkLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelsServiceAddRequest) Query(key, value string) *NetworkLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelsServiceAddRequest) Label(label *NetworkLabel) *NetworkLabelsServiceAddRequest {
	p.label = label
	return p
}

func (p *NetworkLabelsServiceAddRequest) Send() (*NetworkLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkLabelsService.connection.URL(), p.NetworkLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworkLabelsServiceAddResponse{label: result}, nil
}

func (p *NetworkLabelsServiceAddRequest) MustSend() *NetworkLabelsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Attaches label to logical network.
// You can attach labels to a logical network to automate the association of that logical network with physical host
// network interfaces to which the same label has been attached.
// For example, to attach the label `mylabel` to a logical network having id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks/123/networklabels
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_label id="mylabel"/>
// ----
//
type NetworkLabelsServiceAddResponse struct {
	label *NetworkLabel
}

func (p *NetworkLabelsServiceAddResponse) Label() (*NetworkLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *NetworkLabelsServiceAddResponse) MustLabel() *NetworkLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Attaches label to logical network.
// You can attach labels to a logical network to automate the association of that logical network with physical host
// network interfaces to which the same label has been attached.
// For example, to attach the label `mylabel` to a logical network having id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks/123/networklabels
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_label id="mylabel"/>
// ----
//
func (p *NetworkLabelsService) Add() *NetworkLabelsServiceAddRequest {
	return &NetworkLabelsServiceAddRequest{NetworkLabelsService: p}
}

//
// Returns the list of labels attached to the network or host NIC.
// The order of the returned list of labels isn't guaranteed.
//
type NetworkLabelsServiceListRequest struct {
	NetworkLabelsService *NetworkLabelsService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *NetworkLabelsServiceListRequest) Header(key, value string) *NetworkLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkLabelsServiceListRequest) Query(key, value string) *NetworkLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkLabelsServiceListRequest) Follow(follow string) *NetworkLabelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *NetworkLabelsServiceListRequest) Max(max int64) *NetworkLabelsServiceListRequest {
	p.max = &max
	return p
}

func (p *NetworkLabelsServiceListRequest) Send() (*NetworkLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkLabelsService.connection.URL(), p.NetworkLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkLabelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &NetworkLabelsServiceListResponse{labels: result}, nil
}

func (p *NetworkLabelsServiceListRequest) MustSend() *NetworkLabelsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of labels attached to the network or host NIC.
// The order of the returned list of labels isn't guaranteed.
//
type NetworkLabelsServiceListResponse struct {
	labels *NetworkLabelSlice
}

func (p *NetworkLabelsServiceListResponse) Labels() (*NetworkLabelSlice, bool) {
	if p.labels != nil {
		return p.labels, true
	}
	return nil, false
}

func (p *NetworkLabelsServiceListResponse) MustLabels() *NetworkLabelSlice {
	if p.labels == nil {
		panic("labels in response does not exist")
	}
	return p.labels
}

//
// Returns the list of labels attached to the network or host NIC.
// The order of the returned list of labels isn't guaranteed.
//
func (p *NetworkLabelsService) List() *NetworkLabelsServiceListRequest {
	return &NetworkLabelsServiceListRequest{NetworkLabelsService: p}
}

//
//
func (op *NetworkLabelsService) LabelService(id string) *NetworkLabelService {
	return NewNetworkLabelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkLabelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LabelService(path), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *NetworkLabelsService) String() string {
	return fmt.Sprintf("NetworkLabelsService:%s", op.path)
}

//
//
type SnapshotDiskService struct {
	BaseService
}

func NewSnapshotDiskService(connection *Connection, path string) *SnapshotDiskService {
	var result SnapshotDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type SnapshotDiskServiceGetRequest struct {
	SnapshotDiskService *SnapshotDiskService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *SnapshotDiskServiceGetRequest) Header(key, value string) *SnapshotDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotDiskServiceGetRequest) Query(key, value string) *SnapshotDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotDiskServiceGetRequest) Follow(follow string) *SnapshotDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *SnapshotDiskServiceGetRequest) Send() (*SnapshotDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotDiskService.connection.URL(), p.SnapshotDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SnapshotDiskServiceGetResponse{disk: result}, nil
}

func (p *SnapshotDiskServiceGetRequest) MustSend() *SnapshotDiskServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SnapshotDiskServiceGetResponse struct {
	disk *Disk
}

func (p *SnapshotDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *SnapshotDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *SnapshotDiskService) Get() *SnapshotDiskServiceGetRequest {
	return &SnapshotDiskServiceGetRequest{SnapshotDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotDiskService) String() string {
	return fmt.Sprintf("SnapshotDiskService:%s", op.path)
}

//
// Manages a group of users. Use this service to either get groups details or remove groups. In order
// to add new groups please use <<services/groups, service>> that manages the collection of groups.
//
type GroupService struct {
	BaseService
}

func NewGroupService(connection *Connection, path string) *GroupService {
	var result GroupService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the system group information.
// Usage:
// ....
// GET /ovirt-engine/api/groups/123
// ....
// Will return the group information:
// [source,xml]
// ----
// <group href="/ovirt-engine/api/groups/123" id="123">
//   <name>mygroup</name>
//   <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//   <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//   <namespace>DC=example,DC=com</namespace>
//   <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//     <name>myextension-authz</name>
//   </domain>
// </group>
// ----
//
type GroupServiceGetRequest struct {
	GroupService *GroupService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *GroupServiceGetRequest) Header(key, value string) *GroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupServiceGetRequest) Query(key, value string) *GroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupServiceGetRequest) Follow(follow string) *GroupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *GroupServiceGetRequest) Send() (*GroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GroupService.connection.URL(), p.GroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GroupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GroupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GroupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &GroupServiceGetResponse{get: result}, nil
}

func (p *GroupServiceGetRequest) MustSend() *GroupServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the system group information.
// Usage:
// ....
// GET /ovirt-engine/api/groups/123
// ....
// Will return the group information:
// [source,xml]
// ----
// <group href="/ovirt-engine/api/groups/123" id="123">
//   <name>mygroup</name>
//   <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//   <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//   <namespace>DC=example,DC=com</namespace>
//   <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//     <name>myextension-authz</name>
//   </domain>
// </group>
// ----
//
type GroupServiceGetResponse struct {
	get *Group
}

func (p *GroupServiceGetResponse) Get() (*Group, bool) {
	if p.get != nil {
		return p.get, true
	}
	return nil, false
}

func (p *GroupServiceGetResponse) MustGet() *Group {
	if p.get == nil {
		panic("get in response does not exist")
	}
	return p.get
}

//
// Gets the system group information.
// Usage:
// ....
// GET /ovirt-engine/api/groups/123
// ....
// Will return the group information:
// [source,xml]
// ----
// <group href="/ovirt-engine/api/groups/123" id="123">
//   <name>mygroup</name>
//   <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//   <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//   <namespace>DC=example,DC=com</namespace>
//   <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//     <name>myextension-authz</name>
//   </domain>
// </group>
// ----
//
func (p *GroupService) Get() *GroupServiceGetRequest {
	return &GroupServiceGetRequest{GroupService: p}
}

//
// Removes the system group.
// Usage:
// ....
// DELETE /ovirt-engine/api/groups/123
// ....
//
type GroupServiceRemoveRequest struct {
	GroupService *GroupService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *GroupServiceRemoveRequest) Header(key, value string) *GroupServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupServiceRemoveRequest) Query(key, value string) *GroupServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupServiceRemoveRequest) Async(async bool) *GroupServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *GroupServiceRemoveRequest) Send() (*GroupServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GroupService.connection.URL(), p.GroupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GroupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GroupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GroupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GroupServiceRemoveResponse), nil
}

func (p *GroupServiceRemoveRequest) MustSend() *GroupServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the system group.
// Usage:
// ....
// DELETE /ovirt-engine/api/groups/123
// ....
//
type GroupServiceRemoveResponse struct {
}

//
// Removes the system group.
// Usage:
// ....
// DELETE /ovirt-engine/api/groups/123
// ....
//
func (p *GroupService) Remove() *GroupServiceRemoveRequest {
	return &GroupServiceRemoveRequest{GroupService: p}
}

//
// Reference to the service that manages the collection of permissions assigned to this system group.
//
func (op *GroupService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Reference to the service that manages the collection of roles assigned to this system group.
//
func (op *GroupService) RolesService() *AssignedRolesService {
	return NewAssignedRolesService(op.connection, fmt.Sprintf("%s/roles", op.path))
}

//
// Reference to the service that manages the collection of tags assigned to this system group.
//
func (op *GroupService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GroupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GroupService) String() string {
	return fmt.Sprintf("GroupService:%s", op.path)
}

//
// A service to list all authentication domains in the system.
//
type DomainsService struct {
	BaseService
}

func NewDomainsService(connection *Connection, path string) *DomainsService {
	var result DomainsService
	result.connection = connection
	result.path = path
	return &result
}

//
// List all the authentication domains in the system.
// Usage:
// ....
// GET /ovirt-engine/api/domains
// ....
// Will return the list of domains:
// [source,xml]
// ----
// <domains>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//     <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//     <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//     <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//     <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
//   </domain>
// </domains>
// ----
// The order of the returned list of domains isn't guaranteed.
//
type DomainsServiceListRequest struct {
	DomainsService *DomainsService
	header         map[string]string
	query          map[string]string
	follow         *string
	max            *int64
}

func (p *DomainsServiceListRequest) Header(key, value string) *DomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainsServiceListRequest) Query(key, value string) *DomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainsServiceListRequest) Follow(follow string) *DomainsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DomainsServiceListRequest) Max(max int64) *DomainsServiceListRequest {
	p.max = &max
	return p
}

func (p *DomainsServiceListRequest) Send() (*DomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DomainsService.connection.URL(), p.DomainsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDomainReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DomainsServiceListResponse{domains: result}, nil
}

func (p *DomainsServiceListRequest) MustSend() *DomainsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all the authentication domains in the system.
// Usage:
// ....
// GET /ovirt-engine/api/domains
// ....
// Will return the list of domains:
// [source,xml]
// ----
// <domains>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//     <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//     <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//     <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//     <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
//   </domain>
// </domains>
// ----
// The order of the returned list of domains isn't guaranteed.
//
type DomainsServiceListResponse struct {
	domains *DomainSlice
}

func (p *DomainsServiceListResponse) Domains() (*DomainSlice, bool) {
	if p.domains != nil {
		return p.domains, true
	}
	return nil, false
}

func (p *DomainsServiceListResponse) MustDomains() *DomainSlice {
	if p.domains == nil {
		panic("domains in response does not exist")
	}
	return p.domains
}

//
// List all the authentication domains in the system.
// Usage:
// ....
// GET /ovirt-engine/api/domains
// ....
// Will return the list of domains:
// [source,xml]
// ----
// <domains>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//     <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//     <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//     <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//     <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
//   </domain>
// </domains>
// ----
// The order of the returned list of domains isn't guaranteed.
//
func (p *DomainsService) List() *DomainsServiceListRequest {
	return &DomainsServiceListRequest{DomainsService: p}
}

//
// Reference to a service to view details of a domain.
//
func (op *DomainsService) DomainService(id string) *DomainService {
	return NewDomainService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DomainService(path), nil
	}
	return op.DomainService(path[:index]).Service(path[index+1:])
}

func (op *DomainsService) String() string {
	return fmt.Sprintf("DomainsService:%s", op.path)
}

//
//
type SshPublicKeysService struct {
	BaseService
}

func NewSshPublicKeysService(connection *Connection, path string) *SshPublicKeysService {
	var result SshPublicKeysService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type SshPublicKeysServiceAddRequest struct {
	SshPublicKeysService *SshPublicKeysService
	header               map[string]string
	query                map[string]string
	key                  *SshPublicKey
}

func (p *SshPublicKeysServiceAddRequest) Header(key, value string) *SshPublicKeysServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeysServiceAddRequest) Query(key, value string) *SshPublicKeysServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeysServiceAddRequest) Key(key *SshPublicKey) *SshPublicKeysServiceAddRequest {
	p.key = key
	return p
}

func (p *SshPublicKeysServiceAddRequest) Send() (*SshPublicKeysServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SshPublicKeysService.connection.URL(), p.SshPublicKeysService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSshPublicKeyWriteOne(writer, p.key, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SshPublicKeysService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SshPublicKeysService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SshPublicKeysService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SshPublicKeysService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SshPublicKeysService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SshPublicKeysServiceAddResponse{key: result}, nil
}

func (p *SshPublicKeysServiceAddRequest) MustSend() *SshPublicKeysServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SshPublicKeysServiceAddResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeysServiceAddResponse) Key() (*SshPublicKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *SshPublicKeysServiceAddResponse) MustKey() *SshPublicKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
//
func (p *SshPublicKeysService) Add() *SshPublicKeysServiceAddRequest {
	return &SshPublicKeysServiceAddRequest{SshPublicKeysService: p}
}

//
// Returns a list of SSH public keys of the user.
// For example, to retrieve the list of SSH keys of user with identifier `123`,
// send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/users/123/sshpublickeys
// ----
// The result will be the following XML document:
// [source,xml]
// ----
// <ssh_public_keys>
//   <ssh_public_key href="/ovirt-engine/api/users/123/sshpublickeys/456" id="456">
//     <content>ssh-rsa ...</content>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//   </ssh_public_key>
// </ssh_public_keys>
// ----
// Or the following JSON object
// [source,json]
// ----
// {
//   "ssh_public_key": [
//     {
//       "content": "ssh-rsa ...",
//       "user": {
//         "href": "/ovirt-engine/api/users/123",
//         "id": "123"
//       },
//       "href": "/ovirt-engine/api/users/123/sshpublickeys/456",
//       "id": "456"
//     }
//   ]
// }
// ----
// The order of the returned list of keys is not guaranteed.
//
type SshPublicKeysServiceListRequest struct {
	SshPublicKeysService *SshPublicKeysService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *SshPublicKeysServiceListRequest) Header(key, value string) *SshPublicKeysServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeysServiceListRequest) Query(key, value string) *SshPublicKeysServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeysServiceListRequest) Follow(follow string) *SshPublicKeysServiceListRequest {
	p.follow = &follow
	return p
}

func (p *SshPublicKeysServiceListRequest) Max(max int64) *SshPublicKeysServiceListRequest {
	p.max = &max
	return p
}

func (p *SshPublicKeysServiceListRequest) Send() (*SshPublicKeysServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SshPublicKeysService.connection.URL(), p.SshPublicKeysService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SshPublicKeysService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SshPublicKeysService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SshPublicKeysService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SshPublicKeysService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SshPublicKeysService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &SshPublicKeysServiceListResponse{keys: result}, nil
}

func (p *SshPublicKeysServiceListRequest) MustSend() *SshPublicKeysServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns a list of SSH public keys of the user.
// For example, to retrieve the list of SSH keys of user with identifier `123`,
// send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/users/123/sshpublickeys
// ----
// The result will be the following XML document:
// [source,xml]
// ----
// <ssh_public_keys>
//   <ssh_public_key href="/ovirt-engine/api/users/123/sshpublickeys/456" id="456">
//     <content>ssh-rsa ...</content>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//   </ssh_public_key>
// </ssh_public_keys>
// ----
// Or the following JSON object
// [source,json]
// ----
// {
//   "ssh_public_key": [
//     {
//       "content": "ssh-rsa ...",
//       "user": {
//         "href": "/ovirt-engine/api/users/123",
//         "id": "123"
//       },
//       "href": "/ovirt-engine/api/users/123/sshpublickeys/456",
//       "id": "456"
//     }
//   ]
// }
// ----
// The order of the returned list of keys is not guaranteed.
//
type SshPublicKeysServiceListResponse struct {
	keys *SshPublicKeySlice
}

func (p *SshPublicKeysServiceListResponse) Keys() (*SshPublicKeySlice, bool) {
	if p.keys != nil {
		return p.keys, true
	}
	return nil, false
}

func (p *SshPublicKeysServiceListResponse) MustKeys() *SshPublicKeySlice {
	if p.keys == nil {
		panic("keys in response does not exist")
	}
	return p.keys
}

//
// Returns a list of SSH public keys of the user.
// For example, to retrieve the list of SSH keys of user with identifier `123`,
// send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/users/123/sshpublickeys
// ----
// The result will be the following XML document:
// [source,xml]
// ----
// <ssh_public_keys>
//   <ssh_public_key href="/ovirt-engine/api/users/123/sshpublickeys/456" id="456">
//     <content>ssh-rsa ...</content>
//     <user href="/ovirt-engine/api/users/123" id="123"/>
//   </ssh_public_key>
// </ssh_public_keys>
// ----
// Or the following JSON object
// [source,json]
// ----
// {
//   "ssh_public_key": [
//     {
//       "content": "ssh-rsa ...",
//       "user": {
//         "href": "/ovirt-engine/api/users/123",
//         "id": "123"
//       },
//       "href": "/ovirt-engine/api/users/123/sshpublickeys/456",
//       "id": "456"
//     }
//   ]
// }
// ----
// The order of the returned list of keys is not guaranteed.
//
func (p *SshPublicKeysService) List() *SshPublicKeysServiceListRequest {
	return &SshPublicKeysServiceListRequest{SshPublicKeysService: p}
}

//
//
func (op *SshPublicKeysService) KeyService(id string) *SshPublicKeyService {
	return NewSshPublicKeyService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SshPublicKeysService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.KeyService(path), nil
	}
	return op.KeyService(path[:index]).Service(path[index+1:])
}

func (op *SshPublicKeysService) String() string {
	return fmt.Sprintf("SshPublicKeysService:%s", op.path)
}

//
// A service to view a domain user in the system.
//
type DomainUserService struct {
	BaseService
}

func NewDomainUserService(connection *Connection, path string) *DomainUserService {
	var result DomainUserService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the domain user information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users/1234
// ....
// Will return the domain user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <namespace>*</namespace>
//   <principal>admin</principal>
//   <user_name>admin@internal-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//   </domain>
//   <groups/>
// </user>
// ----
//
type DomainUserServiceGetRequest struct {
	DomainUserService *DomainUserService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *DomainUserServiceGetRequest) Header(key, value string) *DomainUserServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainUserServiceGetRequest) Query(key, value string) *DomainUserServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainUserServiceGetRequest) Follow(follow string) *DomainUserServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DomainUserServiceGetRequest) Send() (*DomainUserServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DomainUserService.connection.URL(), p.DomainUserService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DomainUserService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DomainUserService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DomainUserService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DomainUserService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DomainUserService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DomainUserServiceGetResponse{user: result}, nil
}

func (p *DomainUserServiceGetRequest) MustSend() *DomainUserServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the domain user information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users/1234
// ....
// Will return the domain user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <namespace>*</namespace>
//   <principal>admin</principal>
//   <user_name>admin@internal-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//   </domain>
//   <groups/>
// </user>
// ----
//
type DomainUserServiceGetResponse struct {
	user *User
}

func (p *DomainUserServiceGetResponse) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

func (p *DomainUserServiceGetResponse) MustUser() *User {
	if p.user == nil {
		panic("user in response does not exist")
	}
	return p.user
}

//
// Gets the domain user information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users/1234
// ....
// Will return the domain user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <namespace>*</namespace>
//   <principal>admin</principal>
//   <user_name>admin@internal-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/5678" id="5678">
//     <name>internal-authz</name>
//   </domain>
//   <groups/>
// </user>
// ----
//
func (p *DomainUserService) Get() *DomainUserServiceGetRequest {
	return &DomainUserServiceGetRequest{DomainUserService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainUserService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainUserService) String() string {
	return fmt.Sprintf("DomainUserService:%s", op.path)
}

//
//
type DomainGroupsService struct {
	BaseService
}

func NewDomainGroupsService(connection *Connection, path string) *DomainGroupsService {
	var result DomainGroupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of groups.
// The order of the returned list of groups isn't guaranteed.
//
type DomainGroupsServiceListRequest struct {
	DomainGroupsService *DomainGroupsService
	header              map[string]string
	query               map[string]string
	caseSensitive       *bool
	follow              *string
	max                 *int64
	search              *string
}

func (p *DomainGroupsServiceListRequest) Header(key, value string) *DomainGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainGroupsServiceListRequest) Query(key, value string) *DomainGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainGroupsServiceListRequest) CaseSensitive(caseSensitive bool) *DomainGroupsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *DomainGroupsServiceListRequest) Follow(follow string) *DomainGroupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DomainGroupsServiceListRequest) Max(max int64) *DomainGroupsServiceListRequest {
	p.max = &max
	return p
}

func (p *DomainGroupsServiceListRequest) Search(search string) *DomainGroupsServiceListRequest {
	p.search = &search
	return p
}

func (p *DomainGroupsServiceListRequest) Send() (*DomainGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DomainGroupsService.connection.URL(), p.DomainGroupsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DomainGroupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DomainGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DomainGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DomainGroupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DomainGroupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DomainGroupsServiceListResponse{groups: result}, nil
}

func (p *DomainGroupsServiceListRequest) MustSend() *DomainGroupsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of groups.
// The order of the returned list of groups isn't guaranteed.
//
type DomainGroupsServiceListResponse struct {
	groups *GroupSlice
}

func (p *DomainGroupsServiceListResponse) Groups() (*GroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *DomainGroupsServiceListResponse) MustGroups() *GroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// Returns the list of groups.
// The order of the returned list of groups isn't guaranteed.
//
func (p *DomainGroupsService) List() *DomainGroupsServiceListRequest {
	return &DomainGroupsServiceListRequest{DomainGroupsService: p}
}

//
//
func (op *DomainGroupsService) GroupService(id string) *DomainGroupService {
	return NewDomainGroupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainGroupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.GroupService(path), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *DomainGroupsService) String() string {
	return fmt.Sprintf("DomainGroupsService:%s", op.path)
}

//
// A service to manage a user in the system.
// Use this service to either get users details or remove users.
// In order to add new users please use
// <<services/users>>.
//
type UserService struct {
	BaseService
}

func NewUserService(connection *Connection, path string) *UserService {
	var result UserService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the system user information.
// Usage:
// ....
// GET /ovirt-engine/api/users/1234
// ....
// Will return the user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//   <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//   <department></department>
//   <domain_entry_id>23456</domain_entry_id>
//   <email>user1@domain.com</email>
//   <last_name>Lastname</last_name>
//   <namespace>*</namespace>
//   <principal>user1</principal>
//   <user_name>user1@domain-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/45678" id="45678">
//     <name>domain-authz</name>
//   </domain>
// </user>
// ----
//
type UserServiceGetRequest struct {
	UserService *UserService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *UserServiceGetRequest) Header(key, value string) *UserServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UserServiceGetRequest) Query(key, value string) *UserServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UserServiceGetRequest) Follow(follow string) *UserServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *UserServiceGetRequest) Send() (*UserServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.UserService.connection.URL(), p.UserService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.UserService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.UserService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.UserService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.UserService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.UserService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &UserServiceGetResponse{user: result}, nil
}

func (p *UserServiceGetRequest) MustSend() *UserServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the system user information.
// Usage:
// ....
// GET /ovirt-engine/api/users/1234
// ....
// Will return the user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//   <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//   <department></department>
//   <domain_entry_id>23456</domain_entry_id>
//   <email>user1@domain.com</email>
//   <last_name>Lastname</last_name>
//   <namespace>*</namespace>
//   <principal>user1</principal>
//   <user_name>user1@domain-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/45678" id="45678">
//     <name>domain-authz</name>
//   </domain>
// </user>
// ----
//
type UserServiceGetResponse struct {
	user *User
}

func (p *UserServiceGetResponse) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

func (p *UserServiceGetResponse) MustUser() *User {
	if p.user == nil {
		panic("user in response does not exist")
	}
	return p.user
}

//
// Gets the system user information.
// Usage:
// ....
// GET /ovirt-engine/api/users/1234
// ....
// Will return the user information:
// [source,xml]
// ----
// <user href="/ovirt-engine/api/users/1234" id="1234">
//   <name>admin</name>
//   <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//   <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//   <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//   <department></department>
//   <domain_entry_id>23456</domain_entry_id>
//   <email>user1@domain.com</email>
//   <last_name>Lastname</last_name>
//   <namespace>*</namespace>
//   <principal>user1</principal>
//   <user_name>user1@domain-authz</user_name>
//   <domain href="/ovirt-engine/api/domains/45678" id="45678">
//     <name>domain-authz</name>
//   </domain>
// </user>
// ----
//
func (p *UserService) Get() *UserServiceGetRequest {
	return &UserServiceGetRequest{UserService: p}
}

//
// Removes the system user.
// Usage:
// ....
// DELETE /ovirt-engine/api/users/1234
// ....
//
type UserServiceRemoveRequest struct {
	UserService *UserService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *UserServiceRemoveRequest) Header(key, value string) *UserServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UserServiceRemoveRequest) Query(key, value string) *UserServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UserServiceRemoveRequest) Async(async bool) *UserServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *UserServiceRemoveRequest) Send() (*UserServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.UserService.connection.URL(), p.UserService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.UserService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.UserService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.UserService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.UserService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.UserService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(UserServiceRemoveResponse), nil
}

func (p *UserServiceRemoveRequest) MustSend() *UserServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the system user.
// Usage:
// ....
// DELETE /ovirt-engine/api/users/1234
// ....
//
type UserServiceRemoveResponse struct {
}

//
// Removes the system user.
// Usage:
// ....
// DELETE /ovirt-engine/api/users/1234
// ....
//
func (p *UserService) Remove() *UserServiceRemoveRequest {
	return &UserServiceRemoveRequest{UserService: p}
}

//
// Updates information about the user.
// Only the `user_options` field can be updated.
// For example, to update user options:
// [source]
// ----
// PUT /ovirt-engine/api/users/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//    <user_options>
//       <property>
//          <name>test</name>
//          <value>test1</value>
//       </property>
//    </user_options>
// </user>
// ----
//
type UserServiceUpdateRequest struct {
	UserService *UserService
	header      map[string]string
	query       map[string]string
	user        *User
}

func (p *UserServiceUpdateRequest) Header(key, value string) *UserServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UserServiceUpdateRequest) Query(key, value string) *UserServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UserServiceUpdateRequest) User(user *User) *UserServiceUpdateRequest {
	p.user = user
	return p
}

func (p *UserServiceUpdateRequest) Send() (*UserServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.UserService.connection.URL(), p.UserService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLUserWriteOne(writer, p.user, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.UserService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.UserService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.UserService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.UserService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.UserService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &UserServiceUpdateResponse{user: result}, nil
}

func (p *UserServiceUpdateRequest) MustSend() *UserServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates information about the user.
// Only the `user_options` field can be updated.
// For example, to update user options:
// [source]
// ----
// PUT /ovirt-engine/api/users/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//    <user_options>
//       <property>
//          <name>test</name>
//          <value>test1</value>
//       </property>
//    </user_options>
// </user>
// ----
//
type UserServiceUpdateResponse struct {
	user *User
}

func (p *UserServiceUpdateResponse) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

func (p *UserServiceUpdateResponse) MustUser() *User {
	if p.user == nil {
		panic("user in response does not exist")
	}
	return p.user
}

//
// Updates information about the user.
// Only the `user_options` field can be updated.
// For example, to update user options:
// [source]
// ----
// PUT /ovirt-engine/api/users/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//    <user_options>
//       <property>
//          <name>test</name>
//          <value>test1</value>
//       </property>
//    </user_options>
// </user>
// ----
//
func (p *UserService) Update() *UserServiceUpdateRequest {
	return &UserServiceUpdateRequest{UserService: p}
}

//
// List of event-subscriptions for this user.
//
func (op *UserService) EventSubscriptionsService() *EventSubscriptionsService {
	return NewEventSubscriptionsService(op.connection, fmt.Sprintf("%s/eventsubscriptions", op.path))
}

//
//
func (op *UserService) GroupsService() *DomainUserGroupsService {
	return NewDomainUserGroupsService(op.connection, fmt.Sprintf("%s/groups", op.path))
}

//
//
func (op *UserService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *UserService) RolesService() *AssignedRolesService {
	return NewAssignedRolesService(op.connection, fmt.Sprintf("%s/roles", op.path))
}

//
//
func (op *UserService) SshPublicKeysService() *SshPublicKeysService {
	return NewSshPublicKeysService(op.connection, fmt.Sprintf("%s/sshpublickeys", op.path))
}

//
//
func (op *UserService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UserService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "eventsubscriptions" {
		return op.EventSubscriptionsService(), nil
	}
	if strings.HasPrefix(path, "eventsubscriptions/") {
		return op.EventSubscriptionsService().Service(path[19:])
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "sshpublickeys" {
		return op.SshPublicKeysService(), nil
	}
	if strings.HasPrefix(path, "sshpublickeys/") {
		return op.SshPublicKeysService().Service(path[14:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *UserService) String() string {
	return fmt.Sprintf("UserService:%s", op.path)
}

//
//
type DomainGroupService struct {
	BaseService
}

func NewDomainGroupService(connection *Connection, path string) *DomainGroupService {
	var result DomainGroupService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type DomainGroupServiceGetRequest struct {
	DomainGroupService *DomainGroupService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *DomainGroupServiceGetRequest) Header(key, value string) *DomainGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainGroupServiceGetRequest) Query(key, value string) *DomainGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainGroupServiceGetRequest) Follow(follow string) *DomainGroupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DomainGroupServiceGetRequest) Send() (*DomainGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DomainGroupService.connection.URL(), p.DomainGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DomainGroupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DomainGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DomainGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DomainGroupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DomainGroupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DomainGroupServiceGetResponse{get: result}, nil
}

func (p *DomainGroupServiceGetRequest) MustSend() *DomainGroupServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type DomainGroupServiceGetResponse struct {
	get *Group
}

func (p *DomainGroupServiceGetResponse) Get() (*Group, bool) {
	if p.get != nil {
		return p.get, true
	}
	return nil, false
}

func (p *DomainGroupServiceGetResponse) MustGet() *Group {
	if p.get == nil {
		panic("get in response does not exist")
	}
	return p.get
}

//
//
func (p *DomainGroupService) Get() *DomainGroupServiceGetRequest {
	return &DomainGroupServiceGetRequest{DomainGroupService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainGroupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainGroupService) String() string {
	return fmt.Sprintf("DomainGroupService:%s", op.path)
}

//
// A service to view details of an authentication domain in the system.
//
type DomainService struct {
	BaseService
}

func NewDomainService(connection *Connection, path string) *DomainService {
	var result DomainService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the authentication domain information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678
// ....
// Will return the domain information:
// [source,xml]
// ----
// <domain href="/ovirt-engine/api/domains/5678" id="5678">
//   <name>internal-authz</name>
//   <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//   <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//   <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//   <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
// </domain>
// ----
//
type DomainServiceGetRequest struct {
	DomainService *DomainService
	header        map[string]string
	query         map[string]string
	follow        *string
}

func (p *DomainServiceGetRequest) Header(key, value string) *DomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainServiceGetRequest) Query(key, value string) *DomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainServiceGetRequest) Follow(follow string) *DomainServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DomainServiceGetRequest) Send() (*DomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DomainService.connection.URL(), p.DomainService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DomainServiceGetResponse{domain: result}, nil
}

func (p *DomainServiceGetRequest) MustSend() *DomainServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the authentication domain information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678
// ....
// Will return the domain information:
// [source,xml]
// ----
// <domain href="/ovirt-engine/api/domains/5678" id="5678">
//   <name>internal-authz</name>
//   <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//   <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//   <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//   <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
// </domain>
// ----
//
type DomainServiceGetResponse struct {
	domain *Domain
}

func (p *DomainServiceGetResponse) Domain() (*Domain, bool) {
	if p.domain != nil {
		return p.domain, true
	}
	return nil, false
}

func (p *DomainServiceGetResponse) MustDomain() *Domain {
	if p.domain == nil {
		panic("domain in response does not exist")
	}
	return p.domain
}

//
// Gets the authentication domain information.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678
// ....
// Will return the domain information:
// [source,xml]
// ----
// <domain href="/ovirt-engine/api/domains/5678" id="5678">
//   <name>internal-authz</name>
//   <link href="/ovirt-engine/api/domains/5678/users" rel="users"/>
//   <link href="/ovirt-engine/api/domains/5678/groups" rel="groups"/>
//   <link href="/ovirt-engine/api/domains/5678/users?search={query}" rel="users/search"/>
//   <link href="/ovirt-engine/api/domains/5678/groups?search={query}" rel="groups/search"/>
// </domain>
// ----
//
func (p *DomainService) Get() *DomainServiceGetRequest {
	return &DomainServiceGetRequest{DomainService: p}
}

//
// Reference to a service to manage domain groups.
//
func (op *DomainService) GroupsService() *DomainGroupsService {
	return NewDomainGroupsService(op.connection, fmt.Sprintf("%s/groups", op.path))
}

//
// Reference to a service to manage domain users.
//
func (op *DomainService) UsersService() *DomainUsersService {
	return NewDomainUsersService(op.connection, fmt.Sprintf("%s/users", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "users" {
		return op.UsersService(), nil
	}
	if strings.HasPrefix(path, "users/") {
		return op.UsersService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainService) String() string {
	return fmt.Sprintf("DomainService:%s", op.path)
}

//
//
type SshPublicKeyService struct {
	BaseService
}

func NewSshPublicKeyService(connection *Connection, path string) *SshPublicKeyService {
	var result SshPublicKeyService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type SshPublicKeyServiceGetRequest struct {
	SshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *SshPublicKeyServiceGetRequest) Header(key, value string) *SshPublicKeyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceGetRequest) Query(key, value string) *SshPublicKeyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceGetRequest) Follow(follow string) *SshPublicKeyServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *SshPublicKeyServiceGetRequest) Send() (*SshPublicKeyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SshPublicKeyService.connection.URL(), p.SshPublicKeyService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SshPublicKeyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SshPublicKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SshPublicKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SshPublicKeyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SshPublicKeyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SshPublicKeyServiceGetResponse{key: result}, nil
}

func (p *SshPublicKeyServiceGetRequest) MustSend() *SshPublicKeyServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SshPublicKeyServiceGetResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeyServiceGetResponse) Key() (*SshPublicKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *SshPublicKeyServiceGetResponse) MustKey() *SshPublicKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
//
func (p *SshPublicKeyService) Get() *SshPublicKeyServiceGetRequest {
	return &SshPublicKeyServiceGetRequest{SshPublicKeyService: p}
}

//
//
type SshPublicKeyServiceRemoveRequest struct {
	SshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *SshPublicKeyServiceRemoveRequest) Header(key, value string) *SshPublicKeyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceRemoveRequest) Query(key, value string) *SshPublicKeyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceRemoveRequest) Async(async bool) *SshPublicKeyServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *SshPublicKeyServiceRemoveRequest) Send() (*SshPublicKeyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SshPublicKeyService.connection.URL(), p.SshPublicKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SshPublicKeyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SshPublicKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SshPublicKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SshPublicKeyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SshPublicKeyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(SshPublicKeyServiceRemoveResponse), nil
}

func (p *SshPublicKeyServiceRemoveRequest) MustSend() *SshPublicKeyServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SshPublicKeyServiceRemoveResponse struct {
}

//
//
func (p *SshPublicKeyService) Remove() *SshPublicKeyServiceRemoveRequest {
	return &SshPublicKeyServiceRemoveRequest{SshPublicKeyService: p}
}

//
//
type SshPublicKeyServiceUpdateRequest struct {
	SshPublicKeyService *SshPublicKeyService
	header              map[string]string
	query               map[string]string
	async               *bool
	key                 *SshPublicKey
}

func (p *SshPublicKeyServiceUpdateRequest) Header(key, value string) *SshPublicKeyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SshPublicKeyServiceUpdateRequest) Query(key, value string) *SshPublicKeyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SshPublicKeyServiceUpdateRequest) Async(async bool) *SshPublicKeyServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *SshPublicKeyServiceUpdateRequest) Key(key *SshPublicKey) *SshPublicKeyServiceUpdateRequest {
	p.key = key
	return p
}

func (p *SshPublicKeyServiceUpdateRequest) Send() (*SshPublicKeyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SshPublicKeyService.connection.URL(), p.SshPublicKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSshPublicKeyWriteOne(writer, p.key, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SshPublicKeyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SshPublicKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SshPublicKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SshPublicKeyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SshPublicKeyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSshPublicKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SshPublicKeyServiceUpdateResponse{key: result}, nil
}

func (p *SshPublicKeyServiceUpdateRequest) MustSend() *SshPublicKeyServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SshPublicKeyServiceUpdateResponse struct {
	key *SshPublicKey
}

func (p *SshPublicKeyServiceUpdateResponse) Key() (*SshPublicKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *SshPublicKeyServiceUpdateResponse) MustKey() *SshPublicKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
//
func (p *SshPublicKeyService) Update() *SshPublicKeyServiceUpdateRequest {
	return &SshPublicKeyServiceUpdateRequest{SshPublicKeyService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SshPublicKeyService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SshPublicKeyService) String() string {
	return fmt.Sprintf("SshPublicKeyService:%s", op.path)
}

//
// A service that shows a user's group membership in the AAA extension.
//
type DomainUserGroupsService struct {
	BaseService
}

func NewDomainUserGroupsService(connection *Connection, path string) *DomainUserGroupsService {
	var result DomainUserGroupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of groups that the user is a member of.
//
type DomainUserGroupsServiceListRequest struct {
	DomainUserGroupsService *DomainUserGroupsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *DomainUserGroupsServiceListRequest) Header(key, value string) *DomainUserGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainUserGroupsServiceListRequest) Query(key, value string) *DomainUserGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainUserGroupsServiceListRequest) Follow(follow string) *DomainUserGroupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DomainUserGroupsServiceListRequest) Send() (*DomainUserGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DomainUserGroupsService.connection.URL(), p.DomainUserGroupsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DomainUserGroupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DomainUserGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DomainUserGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DomainUserGroupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DomainUserGroupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DomainUserGroupsServiceListResponse{groups: result}, nil
}

func (p *DomainUserGroupsServiceListRequest) MustSend() *DomainUserGroupsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of groups that the user is a member of.
//
type DomainUserGroupsServiceListResponse struct {
	groups *GroupSlice
}

func (p *DomainUserGroupsServiceListResponse) Groups() (*GroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *DomainUserGroupsServiceListResponse) MustGroups() *GroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// Returns the list of groups that the user is a member of.
//
func (p *DomainUserGroupsService) List() *DomainUserGroupsServiceListRequest {
	return &DomainUserGroupsServiceListRequest{DomainUserGroupsService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainUserGroupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DomainUserGroupsService) String() string {
	return fmt.Sprintf("DomainUserGroupsService:%s", op.path)
}

//
// Manages the collection of groups of users.
//
type GroupsService struct {
	BaseService
}

func NewGroupsService(connection *Connection, path string) *GroupsService {
	var result GroupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add group from a directory service. Please note that domain name is name of the authorization provider.
// For example, to add the `Developers` group from the `internal-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/groups
// ----
// With a request body like this:
// [source,xml]
// ----
// <group>
//   <name>Developers</name>
//   <domain>
//     <name>internal-authz</name>
//   </domain>
// </group>
// ----
//
type GroupsServiceAddRequest struct {
	GroupsService *GroupsService
	header        map[string]string
	query         map[string]string
	group         *Group
}

func (p *GroupsServiceAddRequest) Header(key, value string) *GroupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupsServiceAddRequest) Query(key, value string) *GroupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupsServiceAddRequest) Group(group *Group) *GroupsServiceAddRequest {
	p.group = group
	return p
}

func (p *GroupsServiceAddRequest) Send() (*GroupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GroupsService.connection.URL(), p.GroupsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGroupWriteOne(writer, p.group, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GroupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GroupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GroupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &GroupsServiceAddResponse{group: result}, nil
}

func (p *GroupsServiceAddRequest) MustSend() *GroupsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add group from a directory service. Please note that domain name is name of the authorization provider.
// For example, to add the `Developers` group from the `internal-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/groups
// ----
// With a request body like this:
// [source,xml]
// ----
// <group>
//   <name>Developers</name>
//   <domain>
//     <name>internal-authz</name>
//   </domain>
// </group>
// ----
//
type GroupsServiceAddResponse struct {
	group *Group
}

func (p *GroupsServiceAddResponse) Group() (*Group, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *GroupsServiceAddResponse) MustGroup() *Group {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Add group from a directory service. Please note that domain name is name of the authorization provider.
// For example, to add the `Developers` group from the `internal-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/groups
// ----
// With a request body like this:
// [source,xml]
// ----
// <group>
//   <name>Developers</name>
//   <domain>
//     <name>internal-authz</name>
//   </domain>
// </group>
// ----
//
func (p *GroupsService) Add() *GroupsServiceAddRequest {
	return &GroupsServiceAddRequest{GroupsService: p}
}

//
// List all the groups in the system.
// Usage:
// ....
// GET /ovirt-engine/api/groups
// ....
// Will return the list of groups:
// [source,xml]
// ----
// <groups>
//   <group href="/ovirt-engine/api/groups/123" id="123">
//     <name>mygroup</name>
//     <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//     <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//     <namespace>DC=example,DC=com</namespace>
//     <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//       <name>myextension-authz</name>
//     </domain>
//   </group>
//   ...
// </groups>
// ----
// The order of the returned list of groups isn't guaranteed.
//
type GroupsServiceListRequest struct {
	GroupsService *GroupsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *GroupsServiceListRequest) Header(key, value string) *GroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GroupsServiceListRequest) Query(key, value string) *GroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GroupsServiceListRequest) CaseSensitive(caseSensitive bool) *GroupsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *GroupsServiceListRequest) Follow(follow string) *GroupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *GroupsServiceListRequest) Max(max int64) *GroupsServiceListRequest {
	p.max = &max
	return p
}

func (p *GroupsServiceListRequest) Search(search string) *GroupsServiceListRequest {
	p.search = &search
	return p
}

func (p *GroupsServiceListRequest) Send() (*GroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GroupsService.connection.URL(), p.GroupsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GroupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GroupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GroupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &GroupsServiceListResponse{groups: result}, nil
}

func (p *GroupsServiceListRequest) MustSend() *GroupsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all the groups in the system.
// Usage:
// ....
// GET /ovirt-engine/api/groups
// ....
// Will return the list of groups:
// [source,xml]
// ----
// <groups>
//   <group href="/ovirt-engine/api/groups/123" id="123">
//     <name>mygroup</name>
//     <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//     <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//     <namespace>DC=example,DC=com</namespace>
//     <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//       <name>myextension-authz</name>
//     </domain>
//   </group>
//   ...
// </groups>
// ----
// The order of the returned list of groups isn't guaranteed.
//
type GroupsServiceListResponse struct {
	groups *GroupSlice
}

func (p *GroupsServiceListResponse) Groups() (*GroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *GroupsServiceListResponse) MustGroups() *GroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// List all the groups in the system.
// Usage:
// ....
// GET /ovirt-engine/api/groups
// ....
// Will return the list of groups:
// [source,xml]
// ----
// <groups>
//   <group href="/ovirt-engine/api/groups/123" id="123">
//     <name>mygroup</name>
//     <link href="/ovirt-engine/api/groups/123/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/groups/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/groups/123/tags" rel="tags"/>
//     <domain_entry_id>476652557A382F67696B6D2B32762B37796E46476D513D3D</domain_entry_id>
//     <namespace>DC=example,DC=com</namespace>
//     <domain href="/ovirt-engine/api/domains/ABCDEF" id="ABCDEF">
//       <name>myextension-authz</name>
//     </domain>
//   </group>
//   ...
// </groups>
// ----
// The order of the returned list of groups isn't guaranteed.
//
func (p *GroupsService) List() *GroupsServiceListRequest {
	return &GroupsServiceListRequest{GroupsService: p}
}

//
// Reference to the service that manages a specific group.
//
func (op *GroupsService) GroupService(id string) *GroupService {
	return NewGroupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GroupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.GroupService(path), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *GroupsService) String() string {
	return fmt.Sprintf("GroupsService:%s", op.path)
}

//
// A service to manage the users in the system.
//
type UsersService struct {
	BaseService
}

func NewUsersService(connection *Connection, path string) *UsersService {
	var result UsersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add user from a directory service.
// For example, to add the `myuser` user from the `myextension-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/users
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//   <user_name>myuser@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
// In case you are working with Active Directory you have to pass user principal name (UPN) as `username`, followed
// by authorization provider name. Due to https://bugzilla.redhat.com/1147900[bug 1147900] you need to provide
// also `principal` parameter set to UPN of the user.
// For example, to add the user with UPN `myuser@mysubdomain.mydomain.com` from the `myextension-authz`
// authorization provider send a request body like this:
// [source,xml]
// ----
// <user>
//   <principal>myuser@mysubdomain.mydomain.com</principal>
//   <user_name>myuser@mysubdomain.mydomain.com@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
//
type UsersServiceAddRequest struct {
	UsersService *UsersService
	header       map[string]string
	query        map[string]string
	user         *User
}

func (p *UsersServiceAddRequest) Header(key, value string) *UsersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UsersServiceAddRequest) Query(key, value string) *UsersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UsersServiceAddRequest) User(user *User) *UsersServiceAddRequest {
	p.user = user
	return p
}

func (p *UsersServiceAddRequest) Send() (*UsersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.UsersService.connection.URL(), p.UsersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLUserWriteOne(writer, p.user, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.UsersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.UsersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.UsersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.UsersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.UsersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &UsersServiceAddResponse{user: result}, nil
}

func (p *UsersServiceAddRequest) MustSend() *UsersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add user from a directory service.
// For example, to add the `myuser` user from the `myextension-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/users
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//   <user_name>myuser@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
// In case you are working with Active Directory you have to pass user principal name (UPN) as `username`, followed
// by authorization provider name. Due to https://bugzilla.redhat.com/1147900[bug 1147900] you need to provide
// also `principal` parameter set to UPN of the user.
// For example, to add the user with UPN `myuser@mysubdomain.mydomain.com` from the `myextension-authz`
// authorization provider send a request body like this:
// [source,xml]
// ----
// <user>
//   <principal>myuser@mysubdomain.mydomain.com</principal>
//   <user_name>myuser@mysubdomain.mydomain.com@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
//
type UsersServiceAddResponse struct {
	user *User
}

func (p *UsersServiceAddResponse) User() (*User, bool) {
	if p.user != nil {
		return p.user, true
	}
	return nil, false
}

func (p *UsersServiceAddResponse) MustUser() *User {
	if p.user == nil {
		panic("user in response does not exist")
	}
	return p.user
}

//
// Add user from a directory service.
// For example, to add the `myuser` user from the `myextension-authz` authorization provider send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/users
// ----
// With a request body like this:
// [source,xml]
// ----
// <user>
//   <user_name>myuser@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
// In case you are working with Active Directory you have to pass user principal name (UPN) as `username`, followed
// by authorization provider name. Due to https://bugzilla.redhat.com/1147900[bug 1147900] you need to provide
// also `principal` parameter set to UPN of the user.
// For example, to add the user with UPN `myuser@mysubdomain.mydomain.com` from the `myextension-authz`
// authorization provider send a request body like this:
// [source,xml]
// ----
// <user>
//   <principal>myuser@mysubdomain.mydomain.com</principal>
//   <user_name>myuser@mysubdomain.mydomain.com@myextension-authz</user_name>
//   <domain>
//     <name>myextension-authz</name>
//   </domain>
// </user>
// ----
//
func (p *UsersService) Add() *UsersServiceAddRequest {
	return &UsersServiceAddRequest{UsersService: p}
}

//
// List all the users in the system.
// Usage:
// ....
// GET /ovirt-engine/api/users
// ....
// Will return the list of users:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/users/1234" id="1234">
//     <name>admin</name>
//     <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//     <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//     <domain_entry_id>23456</domain_entry_id>
//     <namespace>*</namespace>
//     <principal>user1</principal>
//     <user_name>user1@domain-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/45678" id="45678">
//       <name>domain-authz</name>
//     </domain>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
type UsersServiceListRequest struct {
	UsersService  *UsersService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *UsersServiceListRequest) Header(key, value string) *UsersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UsersServiceListRequest) Query(key, value string) *UsersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UsersServiceListRequest) CaseSensitive(caseSensitive bool) *UsersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *UsersServiceListRequest) Follow(follow string) *UsersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *UsersServiceListRequest) Max(max int64) *UsersServiceListRequest {
	p.max = &max
	return p
}

func (p *UsersServiceListRequest) Search(search string) *UsersServiceListRequest {
	p.search = &search
	return p
}

func (p *UsersServiceListRequest) Send() (*UsersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.UsersService.connection.URL(), p.UsersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.UsersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.UsersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.UsersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.UsersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.UsersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &UsersServiceListResponse{users: result}, nil
}

func (p *UsersServiceListRequest) MustSend() *UsersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all the users in the system.
// Usage:
// ....
// GET /ovirt-engine/api/users
// ....
// Will return the list of users:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/users/1234" id="1234">
//     <name>admin</name>
//     <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//     <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//     <domain_entry_id>23456</domain_entry_id>
//     <namespace>*</namespace>
//     <principal>user1</principal>
//     <user_name>user1@domain-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/45678" id="45678">
//       <name>domain-authz</name>
//     </domain>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
type UsersServiceListResponse struct {
	users *UserSlice
}

func (p *UsersServiceListResponse) Users() (*UserSlice, bool) {
	if p.users != nil {
		return p.users, true
	}
	return nil, false
}

func (p *UsersServiceListResponse) MustUsers() *UserSlice {
	if p.users == nil {
		panic("users in response does not exist")
	}
	return p.users
}

//
// List all the users in the system.
// Usage:
// ....
// GET /ovirt-engine/api/users
// ....
// Will return the list of users:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/users/1234" id="1234">
//     <name>admin</name>
//     <link href="/ovirt-engine/api/users/1234/sshpublickeys" rel="sshpublickeys"/>
//     <link href="/ovirt-engine/api/users/1234/roles" rel="roles"/>
//     <link href="/ovirt-engine/api/users/1234/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/users/1234/tags" rel="tags"/>
//     <domain_entry_id>23456</domain_entry_id>
//     <namespace>*</namespace>
//     <principal>user1</principal>
//     <user_name>user1@domain-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/45678" id="45678">
//       <name>domain-authz</name>
//     </domain>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
func (p *UsersService) List() *UsersServiceListRequest {
	return &UsersServiceListRequest{UsersService: p}
}

//
//
func (op *UsersService) UserService(id string) *UserService {
	return NewUserService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UsersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.UserService(path), nil
	}
	return op.UserService(path[:index]).Service(path[index+1:])
}

func (op *UsersService) String() string {
	return fmt.Sprintf("UsersService:%s", op.path)
}

//
// A service to list all domain users in the system.
//
type DomainUsersService struct {
	BaseService
}

func NewDomainUsersService(connection *Connection, path string) *DomainUsersService {
	var result DomainUsersService
	result.connection = connection
	result.path = path
	return &result
}

//
// List all the users in the domain.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users
// ....
// Will return the list of users in the domain:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/domains/5678/users/1234" id="1234">
//     <name>admin</name>
//     <namespace>*</namespace>
//     <principal>admin</principal>
//     <user_name>admin@internal-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/5678" id="5678">
//       <name>internal-authz</name>
//     </domain>
//     <groups/>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
type DomainUsersServiceListRequest struct {
	DomainUsersService *DomainUsersService
	header             map[string]string
	query              map[string]string
	caseSensitive      *bool
	follow             *string
	max                *int64
	search             *string
}

func (p *DomainUsersServiceListRequest) Header(key, value string) *DomainUsersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DomainUsersServiceListRequest) Query(key, value string) *DomainUsersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DomainUsersServiceListRequest) CaseSensitive(caseSensitive bool) *DomainUsersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *DomainUsersServiceListRequest) Follow(follow string) *DomainUsersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DomainUsersServiceListRequest) Max(max int64) *DomainUsersServiceListRequest {
	p.max = &max
	return p
}

func (p *DomainUsersServiceListRequest) Search(search string) *DomainUsersServiceListRequest {
	p.search = &search
	return p
}

func (p *DomainUsersServiceListRequest) Send() (*DomainUsersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DomainUsersService.connection.URL(), p.DomainUsersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DomainUsersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DomainUsersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DomainUsersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DomainUsersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DomainUsersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUserReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DomainUsersServiceListResponse{users: result}, nil
}

func (p *DomainUsersServiceListRequest) MustSend() *DomainUsersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all the users in the domain.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users
// ....
// Will return the list of users in the domain:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/domains/5678/users/1234" id="1234">
//     <name>admin</name>
//     <namespace>*</namespace>
//     <principal>admin</principal>
//     <user_name>admin@internal-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/5678" id="5678">
//       <name>internal-authz</name>
//     </domain>
//     <groups/>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
type DomainUsersServiceListResponse struct {
	users *UserSlice
}

func (p *DomainUsersServiceListResponse) Users() (*UserSlice, bool) {
	if p.users != nil {
		return p.users, true
	}
	return nil, false
}

func (p *DomainUsersServiceListResponse) MustUsers() *UserSlice {
	if p.users == nil {
		panic("users in response does not exist")
	}
	return p.users
}

//
// List all the users in the domain.
// Usage:
// ....
// GET /ovirt-engine/api/domains/5678/users
// ....
// Will return the list of users in the domain:
// [source,xml]
// ----
// <users>
//   <user href="/ovirt-engine/api/domains/5678/users/1234" id="1234">
//     <name>admin</name>
//     <namespace>*</namespace>
//     <principal>admin</principal>
//     <user_name>admin@internal-authz</user_name>
//     <domain href="/ovirt-engine/api/domains/5678" id="5678">
//       <name>internal-authz</name>
//     </domain>
//     <groups/>
//   </user>
// </users>
// ----
// The order of the returned list of users isn't guaranteed.
//
func (p *DomainUsersService) List() *DomainUsersServiceListRequest {
	return &DomainUsersServiceListRequest{DomainUsersService: p}
}

//
// Reference to a service to view details of a domain user.
//
func (op *DomainUsersService) UserService(id string) *DomainUserService {
	return NewDomainUserService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DomainUsersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.UserService(path), nil
	}
	return op.UserService(path[:index]).Service(path[index+1:])
}

func (op *DomainUsersService) String() string {
	return fmt.Sprintf("DomainUsersService:%s", op.path)
}

//
// A service to manage host storages.
//
type HostStorageService struct {
	BaseService
}

func NewHostStorageService(connection *Connection, path string) *HostStorageService {
	var result HostStorageService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get list of storages.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/storage
// ----
// The XML response you get will be like this one:
// [source,xml]
// ----
// <host_storages>
//   <host_storage id="123">
//     ...
//   </host_storage>
//   ...
// </host_storages>
// ----
// The order of the returned list of storages isn't guaranteed.
//
type HostStorageServiceListRequest struct {
	HostStorageService *HostStorageService
	header             map[string]string
	query              map[string]string
	follow             *string
	reportStatus       *bool
}

func (p *HostStorageServiceListRequest) Header(key, value string) *HostStorageServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostStorageServiceListRequest) Query(key, value string) *HostStorageServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostStorageServiceListRequest) Follow(follow string) *HostStorageServiceListRequest {
	p.follow = &follow
	return p
}

func (p *HostStorageServiceListRequest) ReportStatus(reportStatus bool) *HostStorageServiceListRequest {
	p.reportStatus = &reportStatus
	return p
}

func (p *HostStorageServiceListRequest) Send() (*HostStorageServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostStorageService.connection.URL(), p.HostStorageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.reportStatus != nil {
		values["report_status"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostStorageService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostStorageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostStorageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostStorageService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostStorageService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostStorageReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &HostStorageServiceListResponse{storages: result}, nil
}

func (p *HostStorageServiceListRequest) MustSend() *HostStorageServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get list of storages.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/storage
// ----
// The XML response you get will be like this one:
// [source,xml]
// ----
// <host_storages>
//   <host_storage id="123">
//     ...
//   </host_storage>
//   ...
// </host_storages>
// ----
// The order of the returned list of storages isn't guaranteed.
//
type HostStorageServiceListResponse struct {
	storages *HostStorageSlice
}

func (p *HostStorageServiceListResponse) Storages() (*HostStorageSlice, bool) {
	if p.storages != nil {
		return p.storages, true
	}
	return nil, false
}

func (p *HostStorageServiceListResponse) MustStorages() *HostStorageSlice {
	if p.storages == nil {
		panic("storages in response does not exist")
	}
	return p.storages
}

//
// Get list of storages.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/storage
// ----
// The XML response you get will be like this one:
// [source,xml]
// ----
// <host_storages>
//   <host_storage id="123">
//     ...
//   </host_storage>
//   ...
// </host_storages>
// ----
// The order of the returned list of storages isn't guaranteed.
//
func (p *HostStorageService) List() *HostStorageServiceListRequest {
	return &HostStorageServiceListRequest{HostStorageService: p}
}

//
// Reference to a service managing the storage.
//
func (op *HostStorageService) StorageService(id string) *StorageService {
	return NewStorageService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostStorageService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageService(path), nil
	}
	return op.StorageService(path[:index]).Service(path[index+1:])
}

func (op *HostStorageService) String() string {
	return fmt.Sprintf("HostStorageService:%s", op.path)
}

//
//
type DiskProfileService struct {
	BaseService
}

func NewDiskProfileService(connection *Connection, path string) *DiskProfileService {
	var result DiskProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type DiskProfileServiceGetRequest struct {
	DiskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *DiskProfileServiceGetRequest) Header(key, value string) *DiskProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceGetRequest) Query(key, value string) *DiskProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceGetRequest) Follow(follow string) *DiskProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DiskProfileServiceGetRequest) Send() (*DiskProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskProfileService.connection.URL(), p.DiskProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskProfileServiceGetResponse{profile: result}, nil
}

func (p *DiskProfileServiceGetRequest) MustSend() *DiskProfileServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type DiskProfileServiceGetResponse struct {
	profile *DiskProfile
}

func (p *DiskProfileServiceGetResponse) Profile() (*DiskProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *DiskProfileServiceGetResponse) MustProfile() *DiskProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
//
func (p *DiskProfileService) Get() *DiskProfileServiceGetRequest {
	return &DiskProfileServiceGetRequest{DiskProfileService: p}
}

//
//
type DiskProfileServiceRemoveRequest struct {
	DiskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *DiskProfileServiceRemoveRequest) Header(key, value string) *DiskProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceRemoveRequest) Query(key, value string) *DiskProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceRemoveRequest) Async(async bool) *DiskProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *DiskProfileServiceRemoveRequest) Send() (*DiskProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskProfileService.connection.URL(), p.DiskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DiskProfileServiceRemoveResponse), nil
}

func (p *DiskProfileServiceRemoveRequest) MustSend() *DiskProfileServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type DiskProfileServiceRemoveResponse struct {
}

//
//
func (p *DiskProfileService) Remove() *DiskProfileServiceRemoveRequest {
	return &DiskProfileServiceRemoveRequest{DiskProfileService: p}
}

//
// Update the specified disk profile in the system.
//
type DiskProfileServiceUpdateRequest struct {
	DiskProfileService *DiskProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
	profile            *DiskProfile
}

func (p *DiskProfileServiceUpdateRequest) Header(key, value string) *DiskProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfileServiceUpdateRequest) Query(key, value string) *DiskProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfileServiceUpdateRequest) Async(async bool) *DiskProfileServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *DiskProfileServiceUpdateRequest) Profile(profile *DiskProfile) *DiskProfileServiceUpdateRequest {
	p.profile = profile
	return p
}

func (p *DiskProfileServiceUpdateRequest) Send() (*DiskProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskProfileService.connection.URL(), p.DiskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskProfileServiceUpdateResponse{profile: result}, nil
}

func (p *DiskProfileServiceUpdateRequest) MustSend() *DiskProfileServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified disk profile in the system.
//
type DiskProfileServiceUpdateResponse struct {
	profile *DiskProfile
}

func (p *DiskProfileServiceUpdateResponse) Profile() (*DiskProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *DiskProfileServiceUpdateResponse) MustProfile() *DiskProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Update the specified disk profile in the system.
//
func (p *DiskProfileService) Update() *DiskProfileServiceUpdateRequest {
	return &DiskProfileServiceUpdateRequest{DiskProfileService: p}
}

//
//
func (op *DiskProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskProfileService) String() string {
	return fmt.Sprintf("DiskProfileService:%s", op.path)
}

//
//
type WeightsService struct {
	BaseService
}

func NewWeightsService(connection *Connection, path string) *WeightsService {
	var result WeightsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a weight to a specified user defined scheduling policy.
//
type WeightsServiceAddRequest struct {
	WeightsService *WeightsService
	header         map[string]string
	query          map[string]string
	weight         *Weight
}

func (p *WeightsServiceAddRequest) Header(key, value string) *WeightsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightsServiceAddRequest) Query(key, value string) *WeightsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightsServiceAddRequest) Weight(weight *Weight) *WeightsServiceAddRequest {
	p.weight = weight
	return p
}

func (p *WeightsServiceAddRequest) Send() (*WeightsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.WeightsService.connection.URL(), p.WeightsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWeightWriteOne(writer, p.weight, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.WeightsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.WeightsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.WeightsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.WeightsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.WeightsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &WeightsServiceAddResponse{weight: result}, nil
}

func (p *WeightsServiceAddRequest) MustSend() *WeightsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a weight to a specified user defined scheduling policy.
//
type WeightsServiceAddResponse struct {
	weight *Weight
}

func (p *WeightsServiceAddResponse) Weight() (*Weight, bool) {
	if p.weight != nil {
		return p.weight, true
	}
	return nil, false
}

func (p *WeightsServiceAddResponse) MustWeight() *Weight {
	if p.weight == nil {
		panic("weight in response does not exist")
	}
	return p.weight
}

//
// Add a weight to a specified user defined scheduling policy.
//
func (p *WeightsService) Add() *WeightsServiceAddRequest {
	return &WeightsServiceAddRequest{WeightsService: p}
}

//
// Returns the list of weights.
// The order of the returned list of weights isn't guaranteed.
//
type WeightsServiceListRequest struct {
	WeightsService *WeightsService
	header         map[string]string
	query          map[string]string
	filter         *bool
	follow         *string
	max            *int64
}

func (p *WeightsServiceListRequest) Header(key, value string) *WeightsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightsServiceListRequest) Query(key, value string) *WeightsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightsServiceListRequest) Filter(filter bool) *WeightsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *WeightsServiceListRequest) Follow(follow string) *WeightsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *WeightsServiceListRequest) Max(max int64) *WeightsServiceListRequest {
	p.max = &max
	return p
}

func (p *WeightsServiceListRequest) Send() (*WeightsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.WeightsService.connection.URL(), p.WeightsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.WeightsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.WeightsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.WeightsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.WeightsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.WeightsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &WeightsServiceListResponse{weights: result}, nil
}

func (p *WeightsServiceListRequest) MustSend() *WeightsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of weights.
// The order of the returned list of weights isn't guaranteed.
//
type WeightsServiceListResponse struct {
	weights *WeightSlice
}

func (p *WeightsServiceListResponse) Weights() (*WeightSlice, bool) {
	if p.weights != nil {
		return p.weights, true
	}
	return nil, false
}

func (p *WeightsServiceListResponse) MustWeights() *WeightSlice {
	if p.weights == nil {
		panic("weights in response does not exist")
	}
	return p.weights
}

//
// Returns the list of weights.
// The order of the returned list of weights isn't guaranteed.
//
func (p *WeightsService) List() *WeightsServiceListRequest {
	return &WeightsServiceListRequest{WeightsService: p}
}

//
//
func (op *WeightsService) WeightService(id string) *WeightService {
	return NewWeightService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *WeightsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.WeightService(path), nil
	}
	return op.WeightService(path[:index]).Service(path[index+1:])
}

func (op *WeightsService) String() string {
	return fmt.Sprintf("WeightsService:%s", op.path)
}

//
// Manages the set of quotas configured for a data center.
//
type QuotasService struct {
	BaseService
}

func NewQuotasService(connection *Connection, path string) *QuotasService {
	var result QuotasService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new quota.
// An example of creating a new quota:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas
// ----
// [source,xml]
// ----
// <quota>
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
// </quota>
// ----
//
type QuotasServiceAddRequest struct {
	QuotasService *QuotasService
	header        map[string]string
	query         map[string]string
	quota         *Quota
}

func (p *QuotasServiceAddRequest) Header(key, value string) *QuotasServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotasServiceAddRequest) Query(key, value string) *QuotasServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotasServiceAddRequest) Quota(quota *Quota) *QuotasServiceAddRequest {
	p.quota = quota
	return p
}

func (p *QuotasServiceAddRequest) Send() (*QuotasServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotasService.connection.URL(), p.QuotasService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaWriteOne(writer, p.quota, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotasService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotasService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotasService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotasService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotasService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QuotasServiceAddResponse{quota: result}, nil
}

func (p *QuotasServiceAddRequest) MustSend() *QuotasServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new quota.
// An example of creating a new quota:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas
// ----
// [source,xml]
// ----
// <quota>
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
// </quota>
// ----
//
type QuotasServiceAddResponse struct {
	quota *Quota
}

func (p *QuotasServiceAddResponse) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

func (p *QuotasServiceAddResponse) MustQuota() *Quota {
	if p.quota == nil {
		panic("quota in response does not exist")
	}
	return p.quota
}

//
// Creates a new quota.
// An example of creating a new quota:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas
// ----
// [source,xml]
// ----
// <quota>
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
// </quota>
// ----
//
func (p *QuotasService) Add() *QuotasServiceAddRequest {
	return &QuotasServiceAddRequest{QuotasService: p}
}

//
// Lists quotas of a data center.
// The order of the returned list of quotas isn't guaranteed.
//
type QuotasServiceListRequest struct {
	QuotasService *QuotasService
	header        map[string]string
	query         map[string]string
	follow        *string
	max           *int64
}

func (p *QuotasServiceListRequest) Header(key, value string) *QuotasServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotasServiceListRequest) Query(key, value string) *QuotasServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotasServiceListRequest) Follow(follow string) *QuotasServiceListRequest {
	p.follow = &follow
	return p
}

func (p *QuotasServiceListRequest) Max(max int64) *QuotasServiceListRequest {
	p.max = &max
	return p
}

func (p *QuotasServiceListRequest) Send() (*QuotasServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotasService.connection.URL(), p.QuotasService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotasService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotasService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotasService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotasService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotasService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &QuotasServiceListResponse{quotas: result}, nil
}

func (p *QuotasServiceListRequest) MustSend() *QuotasServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists quotas of a data center.
// The order of the returned list of quotas isn't guaranteed.
//
type QuotasServiceListResponse struct {
	quotas *QuotaSlice
}

func (p *QuotasServiceListResponse) Quotas() (*QuotaSlice, bool) {
	if p.quotas != nil {
		return p.quotas, true
	}
	return nil, false
}

func (p *QuotasServiceListResponse) MustQuotas() *QuotaSlice {
	if p.quotas == nil {
		panic("quotas in response does not exist")
	}
	return p.quotas
}

//
// Lists quotas of a data center.
// The order of the returned list of quotas isn't guaranteed.
//
func (p *QuotasService) List() *QuotasServiceListRequest {
	return &QuotasServiceListRequest{QuotasService: p}
}

//
//
func (op *QuotasService) QuotaService(id string) *QuotaService {
	return NewQuotaService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotasService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.QuotaService(path), nil
	}
	return op.QuotaService(path[:index]).Service(path[index+1:])
}

func (op *QuotasService) String() string {
	return fmt.Sprintf("QuotasService:%s", op.path)
}

//
// Manages the set of CD-ROM devices of a virtual machine snapshot.
//
type SnapshotCdromsService struct {
	BaseService
}

func NewSnapshotCdromsService(connection *Connection, path string) *SnapshotCdromsService {
	var result SnapshotCdromsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of CD-ROM devices of the snapshot.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type SnapshotCdromsServiceListRequest struct {
	SnapshotCdromsService *SnapshotCdromsService
	header                map[string]string
	query                 map[string]string
	follow                *string
	max                   *int64
}

func (p *SnapshotCdromsServiceListRequest) Header(key, value string) *SnapshotCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotCdromsServiceListRequest) Query(key, value string) *SnapshotCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotCdromsServiceListRequest) Follow(follow string) *SnapshotCdromsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *SnapshotCdromsServiceListRequest) Max(max int64) *SnapshotCdromsServiceListRequest {
	p.max = &max
	return p
}

func (p *SnapshotCdromsServiceListRequest) Send() (*SnapshotCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotCdromsService.connection.URL(), p.SnapshotCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotCdromsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotCdromsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotCdromsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotCdromsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotCdromsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotCdromsServiceListResponse{cdroms: result}, nil
}

func (p *SnapshotCdromsServiceListRequest) MustSend() *SnapshotCdromsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of CD-ROM devices of the snapshot.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type SnapshotCdromsServiceListResponse struct {
	cdroms *CdromSlice
}

func (p *SnapshotCdromsServiceListResponse) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *SnapshotCdromsServiceListResponse) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("cdroms in response does not exist")
	}
	return p.cdroms
}

//
// Returns the list of CD-ROM devices of the snapshot.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
func (p *SnapshotCdromsService) List() *SnapshotCdromsServiceListRequest {
	return &SnapshotCdromsServiceListRequest{SnapshotCdromsService: p}
}

//
//
func (op *SnapshotCdromsService) CdromService(id string) *SnapshotCdromService {
	return NewSnapshotCdromService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotCdromsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.CdromService(path), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotCdromsService) String() string {
	return fmt.Sprintf("SnapshotCdromsService:%s", op.path)
}

//
// A service to manage individual host device attached to a virtual machine.
//
type VmHostDeviceService struct {
	BaseService
}

func NewVmHostDeviceService(connection *Connection, path string) *VmHostDeviceService {
	var result VmHostDeviceService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieve information about particular host device attached to given virtual machine.
// Example:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/hostdevices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//   <name>pci_0000_04_00_0</name>
//   <capability>pci</capability>
//   <iommu_group>30</iommu_group>
//   <placeholder>true</placeholder>
//   <product id="0x13ba">
//     <name>GM107GL [Quadro K2200]</name>
//   </product>
//   <vendor id="0x10de">
//     <name>NVIDIA Corporation</name>
//   </vendor>
//   <host href="/ovirt-engine/api/hosts/543" id="543"/>
//   <parent_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//     <name>pci_0000_00_03_0</name>
//   </parent_device>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </host_device>
// ----
//
type VmHostDeviceServiceGetRequest struct {
	VmHostDeviceService *VmHostDeviceService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *VmHostDeviceServiceGetRequest) Header(key, value string) *VmHostDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDeviceServiceGetRequest) Query(key, value string) *VmHostDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDeviceServiceGetRequest) Follow(follow string) *VmHostDeviceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmHostDeviceServiceGetRequest) Send() (*VmHostDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmHostDeviceService.connection.URL(), p.VmHostDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmHostDeviceService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmHostDeviceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmHostDeviceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmHostDeviceService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmHostDeviceService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmHostDeviceServiceGetResponse{device: result}, nil
}

func (p *VmHostDeviceServiceGetRequest) MustSend() *VmHostDeviceServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieve information about particular host device attached to given virtual machine.
// Example:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/hostdevices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//   <name>pci_0000_04_00_0</name>
//   <capability>pci</capability>
//   <iommu_group>30</iommu_group>
//   <placeholder>true</placeholder>
//   <product id="0x13ba">
//     <name>GM107GL [Quadro K2200]</name>
//   </product>
//   <vendor id="0x10de">
//     <name>NVIDIA Corporation</name>
//   </vendor>
//   <host href="/ovirt-engine/api/hosts/543" id="543"/>
//   <parent_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//     <name>pci_0000_00_03_0</name>
//   </parent_device>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </host_device>
// ----
//
type VmHostDeviceServiceGetResponse struct {
	device *HostDevice
}

func (p *VmHostDeviceServiceGetResponse) Device() (*HostDevice, bool) {
	if p.device != nil {
		return p.device, true
	}
	return nil, false
}

func (p *VmHostDeviceServiceGetResponse) MustDevice() *HostDevice {
	if p.device == nil {
		panic("device in response does not exist")
	}
	return p.device
}

//
// Retrieve information about particular host device attached to given virtual machine.
// Example:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/hostdevices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//   <name>pci_0000_04_00_0</name>
//   <capability>pci</capability>
//   <iommu_group>30</iommu_group>
//   <placeholder>true</placeholder>
//   <product id="0x13ba">
//     <name>GM107GL [Quadro K2200]</name>
//   </product>
//   <vendor id="0x10de">
//     <name>NVIDIA Corporation</name>
//   </vendor>
//   <host href="/ovirt-engine/api/hosts/543" id="543"/>
//   <parent_device href="/ovirt-engine/api/hosts/543/devices/456" id="456">
//     <name>pci_0000_00_03_0</name>
//   </parent_device>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </host_device>
// ----
//
func (p *VmHostDeviceService) Get() *VmHostDeviceServiceGetRequest {
	return &VmHostDeviceServiceGetRequest{VmHostDeviceService: p}
}

//
// Remove the attachment of this host device from given virtual machine.
// NOTE: In case this device serves as an IOMMU placeholder, it cannot be removed (remove will result only
// in setting its `placeholder` flag to `true`). Note that all IOMMU placeholder devices will be removed
// automatically as soon as there will be no more non-placeholder devices (all devices from given IOMMU
// group are detached).
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/hostdevices/456
// ----
//
type VmHostDeviceServiceRemoveRequest struct {
	VmHostDeviceService *VmHostDeviceService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *VmHostDeviceServiceRemoveRequest) Header(key, value string) *VmHostDeviceServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDeviceServiceRemoveRequest) Query(key, value string) *VmHostDeviceServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDeviceServiceRemoveRequest) Async(async bool) *VmHostDeviceServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VmHostDeviceServiceRemoveRequest) Send() (*VmHostDeviceServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmHostDeviceService.connection.URL(), p.VmHostDeviceService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmHostDeviceService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmHostDeviceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmHostDeviceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmHostDeviceService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmHostDeviceService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmHostDeviceServiceRemoveResponse), nil
}

func (p *VmHostDeviceServiceRemoveRequest) MustSend() *VmHostDeviceServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove the attachment of this host device from given virtual machine.
// NOTE: In case this device serves as an IOMMU placeholder, it cannot be removed (remove will result only
// in setting its `placeholder` flag to `true`). Note that all IOMMU placeholder devices will be removed
// automatically as soon as there will be no more non-placeholder devices (all devices from given IOMMU
// group are detached).
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/hostdevices/456
// ----
//
type VmHostDeviceServiceRemoveResponse struct {
}

//
// Remove the attachment of this host device from given virtual machine.
// NOTE: In case this device serves as an IOMMU placeholder, it cannot be removed (remove will result only
// in setting its `placeholder` flag to `true`). Note that all IOMMU placeholder devices will be removed
// automatically as soon as there will be no more non-placeholder devices (all devices from given IOMMU
// group are detached).
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/hostdevices/456
// ----
//
func (p *VmHostDeviceService) Remove() *VmHostDeviceServiceRemoveRequest {
	return &VmHostDeviceServiceRemoveRequest{VmHostDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmHostDeviceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmHostDeviceService) String() string {
	return fmt.Sprintf("VmHostDeviceService:%s", op.path)
}

//
//
type HostNumaNodesService struct {
	BaseService
}

func NewHostNumaNodesService(connection *Connection, path string) *HostNumaNodesService {
	var result HostNumaNodesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of NUMA nodes of the host.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
type HostNumaNodesServiceListRequest struct {
	HostNumaNodesService *HostNumaNodesService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *HostNumaNodesServiceListRequest) Header(key, value string) *HostNumaNodesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNumaNodesServiceListRequest) Query(key, value string) *HostNumaNodesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNumaNodesServiceListRequest) Follow(follow string) *HostNumaNodesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *HostNumaNodesServiceListRequest) Max(max int64) *HostNumaNodesServiceListRequest {
	p.max = &max
	return p
}

func (p *HostNumaNodesServiceListRequest) Send() (*HostNumaNodesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostNumaNodesService.connection.URL(), p.HostNumaNodesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostNumaNodesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostNumaNodesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostNumaNodesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostNumaNodesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostNumaNodesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNumaNodeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &HostNumaNodesServiceListResponse{nodes: result}, nil
}

func (p *HostNumaNodesServiceListRequest) MustSend() *HostNumaNodesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of NUMA nodes of the host.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
type HostNumaNodesServiceListResponse struct {
	nodes *NumaNodeSlice
}

func (p *HostNumaNodesServiceListResponse) Nodes() (*NumaNodeSlice, bool) {
	if p.nodes != nil {
		return p.nodes, true
	}
	return nil, false
}

func (p *HostNumaNodesServiceListResponse) MustNodes() *NumaNodeSlice {
	if p.nodes == nil {
		panic("nodes in response does not exist")
	}
	return p.nodes
}

//
// Returns the list of NUMA nodes of the host.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
func (p *HostNumaNodesService) List() *HostNumaNodesServiceListRequest {
	return &HostNumaNodesServiceListRequest{HostNumaNodesService: p}
}

//
//
func (op *HostNumaNodesService) NodeService(id string) *HostNumaNodeService {
	return NewHostNumaNodeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNumaNodesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NodeService(path), nil
	}
	return op.NodeService(path[:index]).Service(path[index+1:])
}

func (op *HostNumaNodesService) String() string {
	return fmt.Sprintf("HostNumaNodesService:%s", op.path)
}

//
//
type InstanceTypeWatchdogsService struct {
	BaseService
}

func NewInstanceTypeWatchdogsService(connection *Connection, path string) *InstanceTypeWatchdogsService {
	var result InstanceTypeWatchdogsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new watchdog to the instance type.
//
type InstanceTypeWatchdogsServiceAddRequest struct {
	InstanceTypeWatchdogsService *InstanceTypeWatchdogsService
	header                       map[string]string
	query                        map[string]string
	watchdog                     *Watchdog
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Header(key, value string) *InstanceTypeWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Query(key, value string) *InstanceTypeWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *InstanceTypeWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}

func (p *InstanceTypeWatchdogsServiceAddRequest) Send() (*InstanceTypeWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeWatchdogsService.connection.URL(), p.InstanceTypeWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeWatchdogsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeWatchdogsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeWatchdogsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeWatchdogsServiceAddResponse{watchdog: result}, nil
}

func (p *InstanceTypeWatchdogsServiceAddRequest) MustSend() *InstanceTypeWatchdogsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add new watchdog to the instance type.
//
type InstanceTypeWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogsServiceAddResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *InstanceTypeWatchdogsServiceAddResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Add new watchdog to the instance type.
//
func (p *InstanceTypeWatchdogsService) Add() *InstanceTypeWatchdogsServiceAddRequest {
	return &InstanceTypeWatchdogsServiceAddRequest{InstanceTypeWatchdogsService: p}
}

//
// Lists all the configured watchdogs of the instance type.
// The order of the returned list of watchdogs isn't guaranteed.
//
type InstanceTypeWatchdogsServiceListRequest struct {
	InstanceTypeWatchdogsService *InstanceTypeWatchdogsService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
	max                          *int64
	search                       *string
}

func (p *InstanceTypeWatchdogsServiceListRequest) Header(key, value string) *InstanceTypeWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Query(key, value string) *InstanceTypeWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Follow(follow string) *InstanceTypeWatchdogsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Max(max int64) *InstanceTypeWatchdogsServiceListRequest {
	p.max = &max
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Search(search string) *InstanceTypeWatchdogsServiceListRequest {
	p.search = &search
	return p
}

func (p *InstanceTypeWatchdogsServiceListRequest) Send() (*InstanceTypeWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeWatchdogsService.connection.URL(), p.InstanceTypeWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeWatchdogsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeWatchdogsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeWatchdogsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &InstanceTypeWatchdogsServiceListResponse{watchdogs: result}, nil
}

func (p *InstanceTypeWatchdogsServiceListRequest) MustSend() *InstanceTypeWatchdogsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all the configured watchdogs of the instance type.
// The order of the returned list of watchdogs isn't guaranteed.
//
type InstanceTypeWatchdogsServiceListResponse struct {
	watchdogs *WatchdogSlice
}

func (p *InstanceTypeWatchdogsServiceListResponse) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *InstanceTypeWatchdogsServiceListResponse) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("watchdogs in response does not exist")
	}
	return p.watchdogs
}

//
// Lists all the configured watchdogs of the instance type.
// The order of the returned list of watchdogs isn't guaranteed.
//
func (p *InstanceTypeWatchdogsService) List() *InstanceTypeWatchdogsServiceListRequest {
	return &InstanceTypeWatchdogsServiceListRequest{InstanceTypeWatchdogsService: p}
}

//
//
func (op *InstanceTypeWatchdogsService) WatchdogService(id string) *InstanceTypeWatchdogService {
	return NewInstanceTypeWatchdogService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeWatchdogsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.WatchdogService(path), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeWatchdogsService) String() string {
	return fmt.Sprintf("InstanceTypeWatchdogsService:%s", op.path)
}

//
//
type VirtualFunctionAllowedNetworksService struct {
	BaseService
}

func NewVirtualFunctionAllowedNetworksService(connection *Connection, path string) *VirtualFunctionAllowedNetworksService {
	var result VirtualFunctionAllowedNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type VirtualFunctionAllowedNetworksServiceAddRequest struct {
	VirtualFunctionAllowedNetworksService *VirtualFunctionAllowedNetworksService
	header                                map[string]string
	query                                 map[string]string
	network                               *Network
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Header(key, value string) *VirtualFunctionAllowedNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Query(key, value string) *VirtualFunctionAllowedNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Network(network *Network) *VirtualFunctionAllowedNetworksServiceAddRequest {
	p.network = network
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) Send() (*VirtualFunctionAllowedNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VirtualFunctionAllowedNetworksService.connection.URL(), p.VirtualFunctionAllowedNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VirtualFunctionAllowedNetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VirtualFunctionAllowedNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VirtualFunctionAllowedNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VirtualFunctionAllowedNetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VirtualFunctionAllowedNetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VirtualFunctionAllowedNetworksServiceAddResponse{network: result}, nil
}

func (p *VirtualFunctionAllowedNetworksServiceAddRequest) MustSend() *VirtualFunctionAllowedNetworksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VirtualFunctionAllowedNetworksServiceAddResponse struct {
	network *Network
}

func (p *VirtualFunctionAllowedNetworksServiceAddResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *VirtualFunctionAllowedNetworksServiceAddResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
//
func (p *VirtualFunctionAllowedNetworksService) Add() *VirtualFunctionAllowedNetworksServiceAddRequest {
	return &VirtualFunctionAllowedNetworksServiceAddRequest{VirtualFunctionAllowedNetworksService: p}
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
type VirtualFunctionAllowedNetworksServiceListRequest struct {
	VirtualFunctionAllowedNetworksService *VirtualFunctionAllowedNetworksService
	header                                map[string]string
	query                                 map[string]string
	follow                                *string
	max                                   *int64
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Header(key, value string) *VirtualFunctionAllowedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Query(key, value string) *VirtualFunctionAllowedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Follow(follow string) *VirtualFunctionAllowedNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Max(max int64) *VirtualFunctionAllowedNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) Send() (*VirtualFunctionAllowedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VirtualFunctionAllowedNetworksService.connection.URL(), p.VirtualFunctionAllowedNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VirtualFunctionAllowedNetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VirtualFunctionAllowedNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VirtualFunctionAllowedNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VirtualFunctionAllowedNetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VirtualFunctionAllowedNetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VirtualFunctionAllowedNetworksServiceListResponse{networks: result}, nil
}

func (p *VirtualFunctionAllowedNetworksServiceListRequest) MustSend() *VirtualFunctionAllowedNetworksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
type VirtualFunctionAllowedNetworksServiceListResponse struct {
	networks *NetworkSlice
}

func (p *VirtualFunctionAllowedNetworksServiceListResponse) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *VirtualFunctionAllowedNetworksServiceListResponse) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
func (p *VirtualFunctionAllowedNetworksService) List() *VirtualFunctionAllowedNetworksServiceListRequest {
	return &VirtualFunctionAllowedNetworksServiceListRequest{VirtualFunctionAllowedNetworksService: p}
}

//
//
func (op *VirtualFunctionAllowedNetworksService) NetworkService(id string) *VirtualFunctionAllowedNetworkService {
	return NewVirtualFunctionAllowedNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VirtualFunctionAllowedNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *VirtualFunctionAllowedNetworksService) String() string {
	return fmt.Sprintf("VirtualFunctionAllowedNetworksService:%s", op.path)
}

//
// This service manages the set of disks attached to a virtual machine. Each attached disk is represented by a
// <<types/disk_attachment,DiskAttachment>>, containing the bootable flag, the disk interface and the reference to
// the disk.
//
type DiskAttachmentsService struct {
	BaseService
}

func NewDiskAttachmentsService(connection *Connection, path string) *DiskAttachmentsService {
	var result DiskAttachmentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new disk attachment to the virtual machine. The `attachment` parameter can contain just a reference, if
// the disk already exists:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk id="123"/>
// </disk_attachment>
// ----
// Or it can contain the complete representation of the disk, if the disk doesn't exist yet:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
// In this case the disk will be created and then attached to the virtual machine.
// In both cases, use the following URL for a virtual machine with an id `345`:
// [source]
// ----
// POST /ovirt-engine/api/vms/345/diskattachments
// ----
// IMPORTANT: The server accepts requests that don't contain the `active` attribute, but the effect is
// undefined. In some cases the disk will be automatically activated and in other cases it won't. To
// avoid issues it is strongly recommended to always include the `active` attribute with the desired
// value.
//
type DiskAttachmentsServiceAddRequest struct {
	DiskAttachmentsService *DiskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	attachment             *DiskAttachment
}

func (p *DiskAttachmentsServiceAddRequest) Header(key, value string) *DiskAttachmentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddRequest) Query(key, value string) *DiskAttachmentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddRequest) Attachment(attachment *DiskAttachment) *DiskAttachmentsServiceAddRequest {
	p.attachment = attachment
	return p
}

func (p *DiskAttachmentsServiceAddRequest) Send() (*DiskAttachmentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskAttachmentsService.connection.URL(), p.DiskAttachmentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskAttachmentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskAttachmentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskAttachmentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskAttachmentsServiceAddResponse{attachment: result}, nil
}

func (p *DiskAttachmentsServiceAddRequest) MustSend() *DiskAttachmentsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a new disk attachment to the virtual machine. The `attachment` parameter can contain just a reference, if
// the disk already exists:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk id="123"/>
// </disk_attachment>
// ----
// Or it can contain the complete representation of the disk, if the disk doesn't exist yet:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
// In this case the disk will be created and then attached to the virtual machine.
// In both cases, use the following URL for a virtual machine with an id `345`:
// [source]
// ----
// POST /ovirt-engine/api/vms/345/diskattachments
// ----
// IMPORTANT: The server accepts requests that don't contain the `active` attribute, but the effect is
// undefined. In some cases the disk will be automatically activated and in other cases it won't. To
// avoid issues it is strongly recommended to always include the `active` attribute with the desired
// value.
//
type DiskAttachmentsServiceAddResponse struct {
	attachment *DiskAttachment
}

func (p *DiskAttachmentsServiceAddResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *DiskAttachmentsServiceAddResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Adds a new disk attachment to the virtual machine. The `attachment` parameter can contain just a reference, if
// the disk already exists:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk id="123"/>
// </disk_attachment>
// ----
// Or it can contain the complete representation of the disk, if the disk doesn't exist yet:
// [source,xml]
// ----
// <disk_attachment>
//   <bootable>true</bootable>
//   <pass_discard>true</pass_discard>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
// In this case the disk will be created and then attached to the virtual machine.
// In both cases, use the following URL for a virtual machine with an id `345`:
// [source]
// ----
// POST /ovirt-engine/api/vms/345/diskattachments
// ----
// IMPORTANT: The server accepts requests that don't contain the `active` attribute, but the effect is
// undefined. In some cases the disk will be automatically activated and in other cases it won't. To
// avoid issues it is strongly recommended to always include the `active` attribute with the desired
// value.
//
func (p *DiskAttachmentsService) Add() *DiskAttachmentsServiceAddRequest {
	return &DiskAttachmentsServiceAddRequest{DiskAttachmentsService: p}
}

//
// List the disk that are attached to the virtual machine.
// The order of the returned list of disks attachments isn't guaranteed.
//
type DiskAttachmentsServiceListRequest struct {
	DiskAttachmentsService *DiskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *DiskAttachmentsServiceListRequest) Header(key, value string) *DiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentsServiceListRequest) Query(key, value string) *DiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentsServiceListRequest) Follow(follow string) *DiskAttachmentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DiskAttachmentsServiceListRequest) Send() (*DiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskAttachmentsService.connection.URL(), p.DiskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskAttachmentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskAttachmentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskAttachmentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DiskAttachmentsServiceListResponse{attachments: result}, nil
}

func (p *DiskAttachmentsServiceListRequest) MustSend() *DiskAttachmentsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the disk that are attached to the virtual machine.
// The order of the returned list of disks attachments isn't guaranteed.
//
type DiskAttachmentsServiceListResponse struct {
	attachments *DiskAttachmentSlice
}

func (p *DiskAttachmentsServiceListResponse) Attachments() (*DiskAttachmentSlice, bool) {
	if p.attachments != nil {
		return p.attachments, true
	}
	return nil, false
}

func (p *DiskAttachmentsServiceListResponse) MustAttachments() *DiskAttachmentSlice {
	if p.attachments == nil {
		panic("attachments in response does not exist")
	}
	return p.attachments
}

//
// List the disk that are attached to the virtual machine.
// The order of the returned list of disks attachments isn't guaranteed.
//
func (p *DiskAttachmentsService) List() *DiskAttachmentsServiceListRequest {
	return &DiskAttachmentsServiceListRequest{DiskAttachmentsService: p}
}

//
//
type DiskAttachmentsServiceAddProvidingDiskIdRequest struct {
	DiskAttachmentsService *DiskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	attachment             *DiskAttachment
}

func (p *DiskAttachmentsServiceAddProvidingDiskIdRequest) Header(key, value string) *DiskAttachmentsServiceAddProvidingDiskIdRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddProvidingDiskIdRequest) Query(key, value string) *DiskAttachmentsServiceAddProvidingDiskIdRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddProvidingDiskIdRequest) Attachment(attachment *DiskAttachment) *DiskAttachmentsServiceAddProvidingDiskIdRequest {
	p.attachment = attachment
	return p
}

func (p *DiskAttachmentsServiceAddProvidingDiskIdRequest) Send() (*DiskAttachmentsServiceAddProvidingDiskIdResponse, error) {
	rawURL := fmt.Sprintf("%s%s/providingdiskid", p.DiskAttachmentsService.connection.URL(), p.DiskAttachmentsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Attachment(p.attachment)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskAttachmentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskAttachmentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskAttachmentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustAttachment()
	return &DiskAttachmentsServiceAddProvidingDiskIdResponse{attachment: result}, nil
}

func (p *DiskAttachmentsServiceAddProvidingDiskIdRequest) MustSend() *DiskAttachmentsServiceAddProvidingDiskIdResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type DiskAttachmentsServiceAddProvidingDiskIdResponse struct {
	attachment *DiskAttachment
}

func (p *DiskAttachmentsServiceAddProvidingDiskIdResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *DiskAttachmentsServiceAddProvidingDiskIdResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
//
func (p *DiskAttachmentsService) AddProvidingDiskId() *DiskAttachmentsServiceAddProvidingDiskIdRequest {
	return &DiskAttachmentsServiceAddProvidingDiskIdRequest{DiskAttachmentsService: p}
}

//
//
type DiskAttachmentsServiceAddSignature1Request struct {
	DiskAttachmentsService *DiskAttachmentsService
	header                 map[string]string
	query                  map[string]string
	attachment             *DiskAttachment
}

func (p *DiskAttachmentsServiceAddSignature1Request) Header(key, value string) *DiskAttachmentsServiceAddSignature1Request {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddSignature1Request) Query(key, value string) *DiskAttachmentsServiceAddSignature1Request {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentsServiceAddSignature1Request) Attachment(attachment *DiskAttachment) *DiskAttachmentsServiceAddSignature1Request {
	p.attachment = attachment
	return p
}

func (p *DiskAttachmentsServiceAddSignature1Request) Send() (*DiskAttachmentsServiceAddSignature1Response, error) {
	rawURL := fmt.Sprintf("%s%s/signature1", p.DiskAttachmentsService.connection.URL(), p.DiskAttachmentsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Attachment(p.attachment)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskAttachmentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskAttachmentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskAttachmentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustAttachment()
	return &DiskAttachmentsServiceAddSignature1Response{attachment: result}, nil
}

func (p *DiskAttachmentsServiceAddSignature1Request) MustSend() *DiskAttachmentsServiceAddSignature1Response {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type DiskAttachmentsServiceAddSignature1Response struct {
	attachment *DiskAttachment
}

func (p *DiskAttachmentsServiceAddSignature1Response) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *DiskAttachmentsServiceAddSignature1Response) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
//
func (p *DiskAttachmentsService) AddSignature1() *DiskAttachmentsServiceAddSignature1Request {
	return &DiskAttachmentsServiceAddSignature1Request{DiskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *DiskAttachmentsService) AttachmentService(id string) *DiskAttachmentService {
	return NewDiskAttachmentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskAttachmentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AttachmentService(path), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *DiskAttachmentsService) String() string {
	return fmt.Sprintf("DiskAttachmentsService:%s", op.path)
}

//
//
type StorageServerConnectionExtensionService struct {
	BaseService
}

func NewStorageServerConnectionExtensionService(connection *Connection, path string) *StorageServerConnectionExtensionService {
	var result StorageServerConnectionExtensionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StorageServerConnectionExtensionServiceGetRequest struct {
	StorageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	follow                                  *string
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Header(key, value string) *StorageServerConnectionExtensionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Query(key, value string) *StorageServerConnectionExtensionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Follow(follow string) *StorageServerConnectionExtensionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageServerConnectionExtensionServiceGetRequest) Send() (*StorageServerConnectionExtensionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionExtensionService.connection.URL(), p.StorageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionExtensionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionExtensionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionExtensionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageServerConnectionExtensionServiceGetResponse{extension: result}, nil
}

func (p *StorageServerConnectionExtensionServiceGetRequest) MustSend() *StorageServerConnectionExtensionServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageServerConnectionExtensionServiceGetResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceGetResponse) Extension() (*StorageConnectionExtension, bool) {
	if p.extension != nil {
		return p.extension, true
	}
	return nil, false
}

func (p *StorageServerConnectionExtensionServiceGetResponse) MustExtension() *StorageConnectionExtension {
	if p.extension == nil {
		panic("extension in response does not exist")
	}
	return p.extension
}

//
//
func (p *StorageServerConnectionExtensionService) Get() *StorageServerConnectionExtensionServiceGetRequest {
	return &StorageServerConnectionExtensionServiceGetRequest{StorageServerConnectionExtensionService: p}
}

//
//
type StorageServerConnectionExtensionServiceRemoveRequest struct {
	StorageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Header(key, value string) *StorageServerConnectionExtensionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Query(key, value string) *StorageServerConnectionExtensionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Async(async bool) *StorageServerConnectionExtensionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) Send() (*StorageServerConnectionExtensionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionExtensionService.connection.URL(), p.StorageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionExtensionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionExtensionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionExtensionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageServerConnectionExtensionServiceRemoveResponse), nil
}

func (p *StorageServerConnectionExtensionServiceRemoveRequest) MustSend() *StorageServerConnectionExtensionServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageServerConnectionExtensionServiceRemoveResponse struct {
}

//
//
func (p *StorageServerConnectionExtensionService) Remove() *StorageServerConnectionExtensionServiceRemoveRequest {
	return &StorageServerConnectionExtensionServiceRemoveRequest{StorageServerConnectionExtensionService: p}
}

//
// Update a storage server connection extension for the given host.
// To update the storage connection `456` of host `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123/storageconnectionextensions/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
type StorageServerConnectionExtensionServiceUpdateRequest struct {
	StorageServerConnectionExtensionService *StorageServerConnectionExtensionService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
	extension                               *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Header(key, value string) *StorageServerConnectionExtensionServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Query(key, value string) *StorageServerConnectionExtensionServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Async(async bool) *StorageServerConnectionExtensionServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Extension(extension *StorageConnectionExtension) *StorageServerConnectionExtensionServiceUpdateRequest {
	p.extension = extension
	return p
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) Send() (*StorageServerConnectionExtensionServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionExtensionService.connection.URL(), p.StorageServerConnectionExtensionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionExtensionWriteOne(writer, p.extension, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionExtensionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionExtensionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionExtensionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionExtensionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionExtensionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageServerConnectionExtensionServiceUpdateResponse{extension: result}, nil
}

func (p *StorageServerConnectionExtensionServiceUpdateRequest) MustSend() *StorageServerConnectionExtensionServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update a storage server connection extension for the given host.
// To update the storage connection `456` of host `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123/storageconnectionextensions/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
type StorageServerConnectionExtensionServiceUpdateResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionServiceUpdateResponse) Extension() (*StorageConnectionExtension, bool) {
	if p.extension != nil {
		return p.extension, true
	}
	return nil, false
}

func (p *StorageServerConnectionExtensionServiceUpdateResponse) MustExtension() *StorageConnectionExtension {
	if p.extension == nil {
		panic("extension in response does not exist")
	}
	return p.extension
}

//
// Update a storage server connection extension for the given host.
// To update the storage connection `456` of host `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123/storageconnectionextensions/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
func (p *StorageServerConnectionExtensionService) Update() *StorageServerConnectionExtensionServiceUpdateRequest {
	return &StorageServerConnectionExtensionServiceUpdateRequest{StorageServerConnectionExtensionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionExtensionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageServerConnectionExtensionService) String() string {
	return fmt.Sprintf("StorageServerConnectionExtensionService:%s", op.path)
}

//
// This service manages image transfers, for performing Image I/O API in {product-name}.
// Please refer to <<services/image_transfer, image transfer>> for further
// documentation.
//
type ImageTransfersService struct {
	BaseService
}

func NewImageTransfersService(connection *Connection, path string) *ImageTransfersService {
	var result ImageTransfersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new image transfer. An image, disk or disk snapshot needs to be specified
// in order to make a new transfer.
// IMPORTANT: The `image` attribute is deprecated since version 4.2 of the engine.
// Use the `disk` or `snapshot` attributes instead.
// *Creating a new image transfer for downloading or uploading a `disk`:*
// To create an image transfer to download or upload a disk with id `123`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <disk id="123"/>
//   <direction>upload|download</direction>
// </image_transfer>
// ----
// *Creating a new image transfer for downloading or uploading a `disk_snapshot`:*
// To create an image transfer to download or upload a `disk_snapshot` with id `456`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <snapshot id="456"/>
//   <direction>download|upload</direction>
// </image_transfer>
// ----
//
type ImageTransfersServiceAddRequest struct {
	ImageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *ImageTransfersServiceAddRequest) Header(key, value string) *ImageTransfersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceAddRequest) Query(key, value string) *ImageTransfersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceAddRequest) ImageTransfer(imageTransfer *ImageTransfer) *ImageTransfersServiceAddRequest {
	p.imageTransfer = imageTransfer
	return p
}

func (p *ImageTransfersServiceAddRequest) Send() (*ImageTransfersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ImageTransfersService.connection.URL(), p.ImageTransfersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLImageTransferWriteOne(writer, p.imageTransfer, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransfersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransfersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransfersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ImageTransfersServiceAddResponse{imageTransfer: result}, nil
}

func (p *ImageTransfersServiceAddRequest) MustSend() *ImageTransfersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new image transfer. An image, disk or disk snapshot needs to be specified
// in order to make a new transfer.
// IMPORTANT: The `image` attribute is deprecated since version 4.2 of the engine.
// Use the `disk` or `snapshot` attributes instead.
// *Creating a new image transfer for downloading or uploading a `disk`:*
// To create an image transfer to download or upload a disk with id `123`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <disk id="123"/>
//   <direction>upload|download</direction>
// </image_transfer>
// ----
// *Creating a new image transfer for downloading or uploading a `disk_snapshot`:*
// To create an image transfer to download or upload a `disk_snapshot` with id `456`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <snapshot id="456"/>
//   <direction>download|upload</direction>
// </image_transfer>
// ----
//
type ImageTransfersServiceAddResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransfersServiceAddResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *ImageTransfersServiceAddResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
// Add a new image transfer. An image, disk or disk snapshot needs to be specified
// in order to make a new transfer.
// IMPORTANT: The `image` attribute is deprecated since version 4.2 of the engine.
// Use the `disk` or `snapshot` attributes instead.
// *Creating a new image transfer for downloading or uploading a `disk`:*
// To create an image transfer to download or upload a disk with id `123`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <disk id="123"/>
//   <direction>upload|download</direction>
// </image_transfer>
// ----
// *Creating a new image transfer for downloading or uploading a `disk_snapshot`:*
// To create an image transfer to download or upload a `disk_snapshot` with id `456`,
// send the following request:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body like this:
// [source,xml]
// ----
// <image_transfer>
//   <snapshot id="456"/>
//   <direction>download|upload</direction>
// </image_transfer>
// ----
//
func (p *ImageTransfersService) Add() *ImageTransfersServiceAddRequest {
	return &ImageTransfersServiceAddRequest{ImageTransfersService: p}
}

//
//
type ImageTransfersServiceAddForDiskRequest struct {
	ImageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *ImageTransfersServiceAddForDiskRequest) Header(key, value string) *ImageTransfersServiceAddForDiskRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceAddForDiskRequest) Query(key, value string) *ImageTransfersServiceAddForDiskRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceAddForDiskRequest) ImageTransfer(imageTransfer *ImageTransfer) *ImageTransfersServiceAddForDiskRequest {
	p.imageTransfer = imageTransfer
	return p
}

func (p *ImageTransfersServiceAddForDiskRequest) Send() (*ImageTransfersServiceAddForDiskResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fordisk", p.ImageTransfersService.connection.URL(), p.ImageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransfersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransfersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransfersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustImageTransfer()
	return &ImageTransfersServiceAddForDiskResponse{imageTransfer: result}, nil
}

func (p *ImageTransfersServiceAddForDiskRequest) MustSend() *ImageTransfersServiceAddForDiskResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type ImageTransfersServiceAddForDiskResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransfersServiceAddForDiskResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *ImageTransfersServiceAddForDiskResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
//
func (p *ImageTransfersService) AddForDisk() *ImageTransfersServiceAddForDiskRequest {
	return &ImageTransfersServiceAddForDiskRequest{ImageTransfersService: p}
}

//
//
type ImageTransfersServiceAddForImageRequest struct {
	ImageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *ImageTransfersServiceAddForImageRequest) Header(key, value string) *ImageTransfersServiceAddForImageRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceAddForImageRequest) Query(key, value string) *ImageTransfersServiceAddForImageRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceAddForImageRequest) ImageTransfer(imageTransfer *ImageTransfer) *ImageTransfersServiceAddForImageRequest {
	p.imageTransfer = imageTransfer
	return p
}

func (p *ImageTransfersServiceAddForImageRequest) Send() (*ImageTransfersServiceAddForImageResponse, error) {
	rawURL := fmt.Sprintf("%s%s/forimage", p.ImageTransfersService.connection.URL(), p.ImageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransfersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransfersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransfersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustImageTransfer()
	return &ImageTransfersServiceAddForImageResponse{imageTransfer: result}, nil
}

func (p *ImageTransfersServiceAddForImageRequest) MustSend() *ImageTransfersServiceAddForImageResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type ImageTransfersServiceAddForImageResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransfersServiceAddForImageResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *ImageTransfersServiceAddForImageResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
//
func (p *ImageTransfersService) AddForImage() *ImageTransfersServiceAddForImageRequest {
	return &ImageTransfersServiceAddForImageRequest{ImageTransfersService: p}
}

//
//
type ImageTransfersServiceAddForSnapshotRequest struct {
	ImageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
	imageTransfer         *ImageTransfer
}

func (p *ImageTransfersServiceAddForSnapshotRequest) Header(key, value string) *ImageTransfersServiceAddForSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceAddForSnapshotRequest) Query(key, value string) *ImageTransfersServiceAddForSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceAddForSnapshotRequest) ImageTransfer(imageTransfer *ImageTransfer) *ImageTransfersServiceAddForSnapshotRequest {
	p.imageTransfer = imageTransfer
	return p
}

func (p *ImageTransfersServiceAddForSnapshotRequest) Send() (*ImageTransfersServiceAddForSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/forsnapshot", p.ImageTransfersService.connection.URL(), p.ImageTransfersService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.ImageTransfer(p.imageTransfer)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransfersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransfersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransfersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustImageTransfer()
	return &ImageTransfersServiceAddForSnapshotResponse{imageTransfer: result}, nil
}

func (p *ImageTransfersServiceAddForSnapshotRequest) MustSend() *ImageTransfersServiceAddForSnapshotResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type ImageTransfersServiceAddForSnapshotResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransfersServiceAddForSnapshotResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *ImageTransfersServiceAddForSnapshotResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
//
func (p *ImageTransfersService) AddForSnapshot() *ImageTransfersServiceAddForSnapshotRequest {
	return &ImageTransfersServiceAddForSnapshotRequest{ImageTransfersService: p}
}

//
// Retrieves the list of image transfers that are currently
// being performed.
// The order of the returned list of image transfers is not guaranteed.
//
type ImageTransfersServiceListRequest struct {
	ImageTransfersService *ImageTransfersService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *ImageTransfersServiceListRequest) Header(key, value string) *ImageTransfersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransfersServiceListRequest) Query(key, value string) *ImageTransfersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransfersServiceListRequest) Follow(follow string) *ImageTransfersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ImageTransfersServiceListRequest) Send() (*ImageTransfersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ImageTransfersService.connection.URL(), p.ImageTransfersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransfersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransfersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransfersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransfersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransfersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ImageTransfersServiceListResponse{imageTransfer: result}, nil
}

func (p *ImageTransfersServiceListRequest) MustSend() *ImageTransfersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the list of image transfers that are currently
// being performed.
// The order of the returned list of image transfers is not guaranteed.
//
type ImageTransfersServiceListResponse struct {
	imageTransfer *ImageTransferSlice
}

func (p *ImageTransfersServiceListResponse) ImageTransfer() (*ImageTransferSlice, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *ImageTransfersServiceListResponse) MustImageTransfer() *ImageTransferSlice {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
// Retrieves the list of image transfers that are currently
// being performed.
// The order of the returned list of image transfers is not guaranteed.
//
func (p *ImageTransfersService) List() *ImageTransfersServiceListRequest {
	return &ImageTransfersServiceListRequest{ImageTransfersService: p}
}

//
// Returns a reference to the service that manages an
// specific image transfer.
//
func (op *ImageTransfersService) ImageTransferService(id string) *ImageTransferService {
	return NewImageTransferService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageTransfersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ImageTransferService(path), nil
	}
	return op.ImageTransferService(path[:index]).Service(path[index+1:])
}

func (op *ImageTransfersService) String() string {
	return fmt.Sprintf("ImageTransfersService:%s", op.path)
}

//
// A service to manage a specific permit of the role.
//
type PermitService struct {
	BaseService
}

func NewPermitService(connection *Connection, path string) *PermitService {
	var result PermitService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the information about the permit of the role.
// For example to retrieve the information about the permit with the id `456` of the role with the id `123`
// send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits/456
// ....
// [source,xml]
// ----
// <permit href="/ovirt-engine/api/roles/123/permits/456" id="456">
//   <name>change_vm_cd</name>
//   <administrative>false</administrative>
//   <role href="/ovirt-engine/api/roles/123" id="123"/>
// </permit>
// ----
//
type PermitServiceGetRequest struct {
	PermitService *PermitService
	header        map[string]string
	query         map[string]string
	follow        *string
}

func (p *PermitServiceGetRequest) Header(key, value string) *PermitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitServiceGetRequest) Query(key, value string) *PermitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitServiceGetRequest) Follow(follow string) *PermitServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *PermitServiceGetRequest) Send() (*PermitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.PermitService.connection.URL(), p.PermitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.PermitService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.PermitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.PermitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.PermitService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.PermitService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &PermitServiceGetResponse{permit: result}, nil
}

func (p *PermitServiceGetRequest) MustSend() *PermitServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the information about the permit of the role.
// For example to retrieve the information about the permit with the id `456` of the role with the id `123`
// send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits/456
// ....
// [source,xml]
// ----
// <permit href="/ovirt-engine/api/roles/123/permits/456" id="456">
//   <name>change_vm_cd</name>
//   <administrative>false</administrative>
//   <role href="/ovirt-engine/api/roles/123" id="123"/>
// </permit>
// ----
//
type PermitServiceGetResponse struct {
	permit *Permit
}

func (p *PermitServiceGetResponse) Permit() (*Permit, bool) {
	if p.permit != nil {
		return p.permit, true
	}
	return nil, false
}

func (p *PermitServiceGetResponse) MustPermit() *Permit {
	if p.permit == nil {
		panic("permit in response does not exist")
	}
	return p.permit
}

//
// Gets the information about the permit of the role.
// For example to retrieve the information about the permit with the id `456` of the role with the id `123`
// send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits/456
// ....
// [source,xml]
// ----
// <permit href="/ovirt-engine/api/roles/123/permits/456" id="456">
//   <name>change_vm_cd</name>
//   <administrative>false</administrative>
//   <role href="/ovirt-engine/api/roles/123" id="123"/>
// </permit>
// ----
//
func (p *PermitService) Get() *PermitServiceGetRequest {
	return &PermitServiceGetRequest{PermitService: p}
}

//
// Removes the permit from the role.
// For example to remove the permit with id `456` from the role with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/roles/123/permits/456
// ....
//
type PermitServiceRemoveRequest struct {
	PermitService *PermitService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *PermitServiceRemoveRequest) Header(key, value string) *PermitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitServiceRemoveRequest) Query(key, value string) *PermitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitServiceRemoveRequest) Async(async bool) *PermitServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *PermitServiceRemoveRequest) Send() (*PermitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.PermitService.connection.URL(), p.PermitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.PermitService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.PermitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.PermitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.PermitService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.PermitService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(PermitServiceRemoveResponse), nil
}

func (p *PermitServiceRemoveRequest) MustSend() *PermitServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the permit from the role.
// For example to remove the permit with id `456` from the role with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/roles/123/permits/456
// ....
//
type PermitServiceRemoveResponse struct {
}

//
// Removes the permit from the role.
// For example to remove the permit with id `456` from the role with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/roles/123/permits/456
// ....
//
func (p *PermitService) Remove() *PermitServiceRemoveRequest {
	return &PermitServiceRemoveRequest{PermitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermitService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *PermitService) String() string {
	return fmt.Sprintf("PermitService:%s", op.path)
}

//
//
type AssignedDiskProfilesService struct {
	BaseService
}

func NewAssignedDiskProfilesService(connection *Connection, path string) *AssignedDiskProfilesService {
	var result AssignedDiskProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new disk profile for the storage domain.
//
type AssignedDiskProfilesServiceAddRequest struct {
	AssignedDiskProfilesService *AssignedDiskProfilesService
	header                      map[string]string
	query                       map[string]string
	profile                     *DiskProfile
}

func (p *AssignedDiskProfilesServiceAddRequest) Header(key, value string) *AssignedDiskProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceAddRequest) Query(key, value string) *AssignedDiskProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceAddRequest) Profile(profile *DiskProfile) *AssignedDiskProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *AssignedDiskProfilesServiceAddRequest) Send() (*AssignedDiskProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedDiskProfilesService.connection.URL(), p.AssignedDiskProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedDiskProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedDiskProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedDiskProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedDiskProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedDiskProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedDiskProfilesServiceAddResponse{profile: result}, nil
}

func (p *AssignedDiskProfilesServiceAddRequest) MustSend() *AssignedDiskProfilesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new disk profile for the storage domain.
//
type AssignedDiskProfilesServiceAddResponse struct {
	profile *DiskProfile
}

func (p *AssignedDiskProfilesServiceAddResponse) Profile() (*DiskProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *AssignedDiskProfilesServiceAddResponse) MustProfile() *DiskProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new disk profile for the storage domain.
//
func (p *AssignedDiskProfilesService) Add() *AssignedDiskProfilesServiceAddRequest {
	return &AssignedDiskProfilesServiceAddRequest{AssignedDiskProfilesService: p}
}

//
// Returns the list of disk profiles assigned to the storage domain.
// The order of the returned disk profiles isn't guaranteed.
//
type AssignedDiskProfilesServiceListRequest struct {
	AssignedDiskProfilesService *AssignedDiskProfilesService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
	max                         *int64
}

func (p *AssignedDiskProfilesServiceListRequest) Header(key, value string) *AssignedDiskProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceListRequest) Query(key, value string) *AssignedDiskProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfilesServiceListRequest) Follow(follow string) *AssignedDiskProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AssignedDiskProfilesServiceListRequest) Max(max int64) *AssignedDiskProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *AssignedDiskProfilesServiceListRequest) Send() (*AssignedDiskProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedDiskProfilesService.connection.URL(), p.AssignedDiskProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedDiskProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedDiskProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedDiskProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedDiskProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedDiskProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AssignedDiskProfilesServiceListResponse{profiles: result}, nil
}

func (p *AssignedDiskProfilesServiceListRequest) MustSend() *AssignedDiskProfilesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of disk profiles assigned to the storage domain.
// The order of the returned disk profiles isn't guaranteed.
//
type AssignedDiskProfilesServiceListResponse struct {
	profiles *DiskProfileSlice
}

func (p *AssignedDiskProfilesServiceListResponse) Profiles() (*DiskProfileSlice, bool) {
	if p.profiles != nil {
		return p.profiles, true
	}
	return nil, false
}

func (p *AssignedDiskProfilesServiceListResponse) MustProfiles() *DiskProfileSlice {
	if p.profiles == nil {
		panic("profiles in response does not exist")
	}
	return p.profiles
}

//
// Returns the list of disk profiles assigned to the storage domain.
// The order of the returned disk profiles isn't guaranteed.
//
func (p *AssignedDiskProfilesService) List() *AssignedDiskProfilesServiceListRequest {
	return &AssignedDiskProfilesServiceListRequest{AssignedDiskProfilesService: p}
}

//
//
func (op *AssignedDiskProfilesService) ProfileService(id string) *AssignedDiskProfileService {
	return NewAssignedDiskProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedDiskProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedDiskProfilesService) String() string {
	return fmt.Sprintf("AssignedDiskProfilesService:%s", op.path)
}

//
//
type GlusterHookService struct {
	BaseService
}

func NewGlusterHookService(connection *Connection, path string) *GlusterHookService {
	var result GlusterHookService
	result.connection = connection
	result.path = path
	return &result
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
type GlusterHookServiceDisableRequest struct {
	GlusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceDisableRequest) Header(key, value string) *GlusterHookServiceDisableRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceDisableRequest) Query(key, value string) *GlusterHookServiceDisableRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceDisableRequest) Async(async bool) *GlusterHookServiceDisableRequest {
	p.async = &async
	return p
}

func (p *GlusterHookServiceDisableRequest) Send() (*GlusterHookServiceDisableResponse, error) {
	rawURL := fmt.Sprintf("%s%s/disable", p.GlusterHookService.connection.URL(), p.GlusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterHookService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterHookService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterHookService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterHookServiceDisableResponse), nil
}

func (p *GlusterHookServiceDisableRequest) MustSend() *GlusterHookServiceDisableResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
type GlusterHookServiceDisableResponse struct {
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
func (p *GlusterHookService) Disable() *GlusterHookServiceDisableRequest {
	return &GlusterHookServiceDisableRequest{GlusterHookService: p}
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
type GlusterHookServiceEnableRequest struct {
	GlusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceEnableRequest) Header(key, value string) *GlusterHookServiceEnableRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceEnableRequest) Query(key, value string) *GlusterHookServiceEnableRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceEnableRequest) Async(async bool) *GlusterHookServiceEnableRequest {
	p.async = &async
	return p
}

func (p *GlusterHookServiceEnableRequest) Send() (*GlusterHookServiceEnableResponse, error) {
	rawURL := fmt.Sprintf("%s%s/enable", p.GlusterHookService.connection.URL(), p.GlusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterHookService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterHookService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterHookService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterHookServiceEnableResponse), nil
}

func (p *GlusterHookServiceEnableRequest) MustSend() *GlusterHookServiceEnableResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
type GlusterHookServiceEnableResponse struct {
}

//
// Resolves status conflict of hook among servers in cluster by disabling Gluster hook in all servers of the
// cluster. This updates the hook status to `DISABLED` in database.
//
func (p *GlusterHookService) Enable() *GlusterHookServiceEnableRequest {
	return &GlusterHookServiceEnableRequest{GlusterHookService: p}
}

//
//
type GlusterHookServiceGetRequest struct {
	GlusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *GlusterHookServiceGetRequest) Header(key, value string) *GlusterHookServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceGetRequest) Query(key, value string) *GlusterHookServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceGetRequest) Follow(follow string) *GlusterHookServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *GlusterHookServiceGetRequest) Send() (*GlusterHookServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterHookService.connection.URL(), p.GlusterHookService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterHookService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterHookService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterHookService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterHookReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &GlusterHookServiceGetResponse{hook: result}, nil
}

func (p *GlusterHookServiceGetRequest) MustSend() *GlusterHookServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type GlusterHookServiceGetResponse struct {
	hook *GlusterHook
}

func (p *GlusterHookServiceGetResponse) Hook() (*GlusterHook, bool) {
	if p.hook != nil {
		return p.hook, true
	}
	return nil, false
}

func (p *GlusterHookServiceGetResponse) MustHook() *GlusterHook {
	if p.hook == nil {
		panic("hook in response does not exist")
	}
	return p.hook
}

//
//
func (p *GlusterHookService) Get() *GlusterHookServiceGetRequest {
	return &GlusterHookServiceGetRequest{GlusterHookService: p}
}

//
// Removes the this Gluster hook from all servers in cluster and deletes it from the database.
//
type GlusterHookServiceRemoveRequest struct {
	GlusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *GlusterHookServiceRemoveRequest) Header(key, value string) *GlusterHookServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceRemoveRequest) Query(key, value string) *GlusterHookServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceRemoveRequest) Async(async bool) *GlusterHookServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *GlusterHookServiceRemoveRequest) Send() (*GlusterHookServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterHookService.connection.URL(), p.GlusterHookService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterHookService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterHookService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterHookService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GlusterHookServiceRemoveResponse), nil
}

func (p *GlusterHookServiceRemoveRequest) MustSend() *GlusterHookServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the this Gluster hook from all servers in cluster and deletes it from the database.
//
type GlusterHookServiceRemoveResponse struct {
}

//
// Removes the this Gluster hook from all servers in cluster and deletes it from the database.
//
func (p *GlusterHookService) Remove() *GlusterHookServiceRemoveRequest {
	return &GlusterHookServiceRemoveRequest{GlusterHookService: p}
}

//
// Resolves missing hook conflict depending on the resolution type.
// For `ADD` resolves by copying hook stored in engine database to all servers where the hook is missing. The
// engine maintains a list of all servers where hook is missing.
// For `COPY` resolves conflict in hook content by copying hook stored in engine database to all servers where
// the hook is missing. The engine maintains a list of all servers where the content is conflicting. If a host
// id is passed as parameter, the hook content from the server is used as the master to copy to other servers
// in cluster.
//
type GlusterHookServiceResolveRequest struct {
	GlusterHookService *GlusterHookService
	header             map[string]string
	query              map[string]string
	async              *bool
	host               *Host
	resolutionType     *string
}

func (p *GlusterHookServiceResolveRequest) Header(key, value string) *GlusterHookServiceResolveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHookServiceResolveRequest) Query(key, value string) *GlusterHookServiceResolveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHookServiceResolveRequest) Async(async bool) *GlusterHookServiceResolveRequest {
	p.async = &async
	return p
}

func (p *GlusterHookServiceResolveRequest) Host(host *Host) *GlusterHookServiceResolveRequest {
	p.host = host
	return p
}

func (p *GlusterHookServiceResolveRequest) ResolutionType(resolutionType string) *GlusterHookServiceResolveRequest {
	p.resolutionType = &resolutionType
	return p
}

func (p *GlusterHookServiceResolveRequest) Send() (*GlusterHookServiceResolveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resolve", p.GlusterHookService.connection.URL(), p.GlusterHookService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	if p.resolutionType != nil {
		actionBuilder.ResolutionType(*p.resolutionType)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterHookService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterHookService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterHookService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterHookServiceResolveResponse), nil
}

func (p *GlusterHookServiceResolveRequest) MustSend() *GlusterHookServiceResolveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Resolves missing hook conflict depending on the resolution type.
// For `ADD` resolves by copying hook stored in engine database to all servers where the hook is missing. The
// engine maintains a list of all servers where hook is missing.
// For `COPY` resolves conflict in hook content by copying hook stored in engine database to all servers where
// the hook is missing. The engine maintains a list of all servers where the content is conflicting. If a host
// id is passed as parameter, the hook content from the server is used as the master to copy to other servers
// in cluster.
//
type GlusterHookServiceResolveResponse struct {
}

//
// Resolves missing hook conflict depending on the resolution type.
// For `ADD` resolves by copying hook stored in engine database to all servers where the hook is missing. The
// engine maintains a list of all servers where hook is missing.
// For `COPY` resolves conflict in hook content by copying hook stored in engine database to all servers where
// the hook is missing. The engine maintains a list of all servers where the content is conflicting. If a host
// id is passed as parameter, the hook content from the server is used as the master to copy to other servers
// in cluster.
//
func (p *GlusterHookService) Resolve() *GlusterHookServiceResolveRequest {
	return &GlusterHookServiceResolveRequest{GlusterHookService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterHookService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterHookService) String() string {
	return fmt.Sprintf("GlusterHookService:%s", op.path)
}

//
//
type GlusterHooksService struct {
	BaseService
}

func NewGlusterHooksService(connection *Connection, path string) *GlusterHooksService {
	var result GlusterHooksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of hooks.
// The order of the returned list of hooks isn't guaranteed.
//
type GlusterHooksServiceListRequest struct {
	GlusterHooksService *GlusterHooksService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *GlusterHooksServiceListRequest) Header(key, value string) *GlusterHooksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterHooksServiceListRequest) Query(key, value string) *GlusterHooksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterHooksServiceListRequest) Follow(follow string) *GlusterHooksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *GlusterHooksServiceListRequest) Max(max int64) *GlusterHooksServiceListRequest {
	p.max = &max
	return p
}

func (p *GlusterHooksServiceListRequest) Send() (*GlusterHooksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterHooksService.connection.URL(), p.GlusterHooksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterHooksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterHooksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterHooksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterHooksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterHooksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterHookReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &GlusterHooksServiceListResponse{hooks: result}, nil
}

func (p *GlusterHooksServiceListRequest) MustSend() *GlusterHooksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of hooks.
// The order of the returned list of hooks isn't guaranteed.
//
type GlusterHooksServiceListResponse struct {
	hooks *GlusterHookSlice
}

func (p *GlusterHooksServiceListResponse) Hooks() (*GlusterHookSlice, bool) {
	if p.hooks != nil {
		return p.hooks, true
	}
	return nil, false
}

func (p *GlusterHooksServiceListResponse) MustHooks() *GlusterHookSlice {
	if p.hooks == nil {
		panic("hooks in response does not exist")
	}
	return p.hooks
}

//
// Returns the list of hooks.
// The order of the returned list of hooks isn't guaranteed.
//
func (p *GlusterHooksService) List() *GlusterHooksServiceListRequest {
	return &GlusterHooksServiceListRequest{GlusterHooksService: p}
}

//
//
func (op *GlusterHooksService) HookService(id string) *GlusterHookService {
	return NewGlusterHookService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterHooksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HookService(path), nil
	}
	return op.HookService(path[:index]).Service(path[index+1:])
}

func (op *GlusterHooksService) String() string {
	return fmt.Sprintf("GlusterHooksService:%s", op.path)
}

//
// This service manages a single gluster brick.
//
type GlusterBrickService struct {
	BaseService
}

func NewGlusterBrickService(connection *Connection, path string) *GlusterBrickService {
	var result GlusterBrickService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get details of a brick.
// Retrieves status details of brick from underlying gluster volume with header `All-Content` set to `true`. This is
// the equivalent of running `gluster volume status <volumename> <brickname> detail`.
// For example, to get the details of brick `234` of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
// Which will return a response body like this:
// [source,xml]
// ----
// <brick id="234">
//   <name>host1:/rhgs/data/brick1</name>
//   <brick_dir>/rhgs/data/brick1</brick_dir>
//   <server_id>111</server_id>
//   <status>up</status>
//   <device>/dev/mapper/RHGS_vg1-lv_vmaddldisks</device>
//   <fs_name>xfs</fs_name>
//   <gluster_clients>
//     <gluster_client>
//       <bytes_read>2818417648</bytes_read>
//       <bytes_written>1384694844</bytes_written>
//       <client_port>1011</client_port>
//       <host_name>client2</host_name>
//     </gluster_client>
//   </gluster_clients>
//   <memory_pools>
//     <memory_pool>
//       <name>data-server:fd_t</name>
//       <alloc_count>1626348</alloc_count>
//       <cold_count>1020</cold_count>
//       <hot_count>4</hot_count>
//       <max_alloc>23</max_alloc>
//       <max_stdalloc>0</max_stdalloc>
//       <padded_size>140</padded_size>
//       <pool_misses>0</pool_misses>
//     </memory_pool>
//   </memory_pools>
//   <mnt_options>rw,seclabel,noatime,nodiratime,attr2,inode64,sunit=512,swidth=2048,noquota</mnt_options>
//   <pid>25589</pid>
//   <port>49155</port>
// </brick>
// ----
//
type GlusterBrickServiceGetRequest struct {
	GlusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *GlusterBrickServiceGetRequest) Header(key, value string) *GlusterBrickServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceGetRequest) Query(key, value string) *GlusterBrickServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceGetRequest) Follow(follow string) *GlusterBrickServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *GlusterBrickServiceGetRequest) Send() (*GlusterBrickServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterBrickService.connection.URL(), p.GlusterBrickService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBrickService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBrickService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBrickService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBrickService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBrickService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &GlusterBrickServiceGetResponse{brick: result}, nil
}

func (p *GlusterBrickServiceGetRequest) MustSend() *GlusterBrickServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get details of a brick.
// Retrieves status details of brick from underlying gluster volume with header `All-Content` set to `true`. This is
// the equivalent of running `gluster volume status <volumename> <brickname> detail`.
// For example, to get the details of brick `234` of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
// Which will return a response body like this:
// [source,xml]
// ----
// <brick id="234">
//   <name>host1:/rhgs/data/brick1</name>
//   <brick_dir>/rhgs/data/brick1</brick_dir>
//   <server_id>111</server_id>
//   <status>up</status>
//   <device>/dev/mapper/RHGS_vg1-lv_vmaddldisks</device>
//   <fs_name>xfs</fs_name>
//   <gluster_clients>
//     <gluster_client>
//       <bytes_read>2818417648</bytes_read>
//       <bytes_written>1384694844</bytes_written>
//       <client_port>1011</client_port>
//       <host_name>client2</host_name>
//     </gluster_client>
//   </gluster_clients>
//   <memory_pools>
//     <memory_pool>
//       <name>data-server:fd_t</name>
//       <alloc_count>1626348</alloc_count>
//       <cold_count>1020</cold_count>
//       <hot_count>4</hot_count>
//       <max_alloc>23</max_alloc>
//       <max_stdalloc>0</max_stdalloc>
//       <padded_size>140</padded_size>
//       <pool_misses>0</pool_misses>
//     </memory_pool>
//   </memory_pools>
//   <mnt_options>rw,seclabel,noatime,nodiratime,attr2,inode64,sunit=512,swidth=2048,noquota</mnt_options>
//   <pid>25589</pid>
//   <port>49155</port>
// </brick>
// ----
//
type GlusterBrickServiceGetResponse struct {
	brick *GlusterBrick
}

func (p *GlusterBrickServiceGetResponse) Brick() (*GlusterBrick, bool) {
	if p.brick != nil {
		return p.brick, true
	}
	return nil, false
}

func (p *GlusterBrickServiceGetResponse) MustBrick() *GlusterBrick {
	if p.brick == nil {
		panic("brick in response does not exist")
	}
	return p.brick
}

//
// Get details of a brick.
// Retrieves status details of brick from underlying gluster volume with header `All-Content` set to `true`. This is
// the equivalent of running `gluster volume status <volumename> <brickname> detail`.
// For example, to get the details of brick `234` of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
// Which will return a response body like this:
// [source,xml]
// ----
// <brick id="234">
//   <name>host1:/rhgs/data/brick1</name>
//   <brick_dir>/rhgs/data/brick1</brick_dir>
//   <server_id>111</server_id>
//   <status>up</status>
//   <device>/dev/mapper/RHGS_vg1-lv_vmaddldisks</device>
//   <fs_name>xfs</fs_name>
//   <gluster_clients>
//     <gluster_client>
//       <bytes_read>2818417648</bytes_read>
//       <bytes_written>1384694844</bytes_written>
//       <client_port>1011</client_port>
//       <host_name>client2</host_name>
//     </gluster_client>
//   </gluster_clients>
//   <memory_pools>
//     <memory_pool>
//       <name>data-server:fd_t</name>
//       <alloc_count>1626348</alloc_count>
//       <cold_count>1020</cold_count>
//       <hot_count>4</hot_count>
//       <max_alloc>23</max_alloc>
//       <max_stdalloc>0</max_stdalloc>
//       <padded_size>140</padded_size>
//       <pool_misses>0</pool_misses>
//     </memory_pool>
//   </memory_pools>
//   <mnt_options>rw,seclabel,noatime,nodiratime,attr2,inode64,sunit=512,swidth=2048,noquota</mnt_options>
//   <pid>25589</pid>
//   <port>49155</port>
// </brick>
// ----
//
func (p *GlusterBrickService) Get() *GlusterBrickServiceGetRequest {
	return &GlusterBrickServiceGetRequest{GlusterBrickService: p}
}

//
// Removes a brick.
// Removes a brick from the underlying gluster volume and deletes entries from database. This can be used only when
// removing a single brick without data migration. To remove multiple bricks and with data migration, use
// <<services/gluster_bricks/methods/migrate, migrate>> instead.
// For example, to delete brick `234` from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
//
type GlusterBrickServiceRemoveRequest struct {
	GlusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *GlusterBrickServiceRemoveRequest) Header(key, value string) *GlusterBrickServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceRemoveRequest) Query(key, value string) *GlusterBrickServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceRemoveRequest) Async(async bool) *GlusterBrickServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *GlusterBrickServiceRemoveRequest) Send() (*GlusterBrickServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterBrickService.connection.URL(), p.GlusterBrickService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBrickService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBrickService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBrickService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBrickService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBrickService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GlusterBrickServiceRemoveResponse), nil
}

func (p *GlusterBrickServiceRemoveRequest) MustSend() *GlusterBrickServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a brick.
// Removes a brick from the underlying gluster volume and deletes entries from database. This can be used only when
// removing a single brick without data migration. To remove multiple bricks and with data migration, use
// <<services/gluster_bricks/methods/migrate, migrate>> instead.
// For example, to delete brick `234` from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
//
type GlusterBrickServiceRemoveResponse struct {
}

//
// Removes a brick.
// Removes a brick from the underlying gluster volume and deletes entries from database. This can be used only when
// removing a single brick without data migration. To remove multiple bricks and with data migration, use
// <<services/gluster_bricks/methods/migrate, migrate>> instead.
// For example, to delete brick `234` from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/234
// ----
//
func (p *GlusterBrickService) Remove() *GlusterBrickServiceRemoveRequest {
	return &GlusterBrickServiceRemoveRequest{GlusterBrickService: p}
}

//
// Replaces this brick with a new one.
// IMPORTANT: This operation has been deprecated since version 3.5 of the engine and will be removed in the future.
// Use <<services/gluster_bricks/methods/add, add brick(s)>> and
// <<services/gluster_bricks/methods/migrate, migrate brick(s)>> instead.
//
type GlusterBrickServiceReplaceRequest struct {
	GlusterBrickService *GlusterBrickService
	header              map[string]string
	query               map[string]string
	async               *bool
	force               *bool
}

func (p *GlusterBrickServiceReplaceRequest) Header(key, value string) *GlusterBrickServiceReplaceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBrickServiceReplaceRequest) Query(key, value string) *GlusterBrickServiceReplaceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBrickServiceReplaceRequest) Async(async bool) *GlusterBrickServiceReplaceRequest {
	p.async = &async
	return p
}

func (p *GlusterBrickServiceReplaceRequest) Force(force bool) *GlusterBrickServiceReplaceRequest {
	p.force = &force
	return p
}

func (p *GlusterBrickServiceReplaceRequest) Send() (*GlusterBrickServiceReplaceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/replace", p.GlusterBrickService.connection.URL(), p.GlusterBrickService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBrickService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBrickService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBrickService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBrickService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBrickService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterBrickServiceReplaceResponse), nil
}

func (p *GlusterBrickServiceReplaceRequest) MustSend() *GlusterBrickServiceReplaceResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Replaces this brick with a new one.
// IMPORTANT: This operation has been deprecated since version 3.5 of the engine and will be removed in the future.
// Use <<services/gluster_bricks/methods/add, add brick(s)>> and
// <<services/gluster_bricks/methods/migrate, migrate brick(s)>> instead.
//
type GlusterBrickServiceReplaceResponse struct {
}

//
// Replaces this brick with a new one.
// IMPORTANT: This operation has been deprecated since version 3.5 of the engine and will be removed in the future.
// Use <<services/gluster_bricks/methods/add, add brick(s)>> and
// <<services/gluster_bricks/methods/migrate, migrate brick(s)>> instead.
//
func (p *GlusterBrickService) Replace() *GlusterBrickServiceReplaceRequest {
	return &GlusterBrickServiceReplaceRequest{GlusterBrickService: p}
}

//
//
func (op *GlusterBrickService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterBrickService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterBrickService) String() string {
	return fmt.Sprintf("GlusterBrickService:%s", op.path)
}

//
// This service manages a collection of gluster volumes available in a cluster.
//
type GlusterVolumesService struct {
	BaseService
}

func NewGlusterVolumesService(connection *Connection, path string) *GlusterVolumesService {
	var result GlusterVolumesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new gluster volume.
// The volume is created based on properties of the `volume` parameter. The properties `name`, `volume_type` and
// `bricks` are required.
// For example, to add a volume with name `myvolume` to the cluster `123`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/glustervolumes
// ----
// With the following request body:
// [source,xml]
// ----
// <gluster_volume>
//   <name>myvolume</name>
//   <volume_type>replicate</volume_type>
//   <replica_count>3</replica_count>
//   <bricks>
//     <brick>
//       <server_id>server1</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server2</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server3</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//   <bricks>
// </gluster_volume>
// ----
//
type GlusterVolumesServiceAddRequest struct {
	GlusterVolumesService *GlusterVolumesService
	header                map[string]string
	query                 map[string]string
	volume                *GlusterVolume
}

func (p *GlusterVolumesServiceAddRequest) Header(key, value string) *GlusterVolumesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumesServiceAddRequest) Query(key, value string) *GlusterVolumesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumesServiceAddRequest) Volume(volume *GlusterVolume) *GlusterVolumesServiceAddRequest {
	p.volume = volume
	return p
}

func (p *GlusterVolumesServiceAddRequest) Send() (*GlusterVolumesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterVolumesService.connection.URL(), p.GlusterVolumesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGlusterVolumeWriteOne(writer, p.volume, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &GlusterVolumesServiceAddResponse{volume: result}, nil
}

func (p *GlusterVolumesServiceAddRequest) MustSend() *GlusterVolumesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new gluster volume.
// The volume is created based on properties of the `volume` parameter. The properties `name`, `volume_type` and
// `bricks` are required.
// For example, to add a volume with name `myvolume` to the cluster `123`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/glustervolumes
// ----
// With the following request body:
// [source,xml]
// ----
// <gluster_volume>
//   <name>myvolume</name>
//   <volume_type>replicate</volume_type>
//   <replica_count>3</replica_count>
//   <bricks>
//     <brick>
//       <server_id>server1</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server2</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server3</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//   <bricks>
// </gluster_volume>
// ----
//
type GlusterVolumesServiceAddResponse struct {
	volume *GlusterVolume
}

func (p *GlusterVolumesServiceAddResponse) Volume() (*GlusterVolume, bool) {
	if p.volume != nil {
		return p.volume, true
	}
	return nil, false
}

func (p *GlusterVolumesServiceAddResponse) MustVolume() *GlusterVolume {
	if p.volume == nil {
		panic("volume in response does not exist")
	}
	return p.volume
}

//
// Creates a new gluster volume.
// The volume is created based on properties of the `volume` parameter. The properties `name`, `volume_type` and
// `bricks` are required.
// For example, to add a volume with name `myvolume` to the cluster `123`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/glustervolumes
// ----
// With the following request body:
// [source,xml]
// ----
// <gluster_volume>
//   <name>myvolume</name>
//   <volume_type>replicate</volume_type>
//   <replica_count>3</replica_count>
//   <bricks>
//     <brick>
//       <server_id>server1</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server2</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//     <brick>
//       <server_id>server3</server_id>
//       <brick_dir>/exp1</brick_dir>
//     </brick>
//   <bricks>
// </gluster_volume>
// ----
//
func (p *GlusterVolumesService) Add() *GlusterVolumesServiceAddRequest {
	return &GlusterVolumesServiceAddRequest{GlusterVolumesService: p}
}

//
// Lists all gluster volumes in the cluster.
// For example, to list all Gluster Volumes in cluster `456`, send a request like
// this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes
// ----
// The order of the returned list of volumes isn't guaranteed.
//
type GlusterVolumesServiceListRequest struct {
	GlusterVolumesService *GlusterVolumesService
	header                map[string]string
	query                 map[string]string
	caseSensitive         *bool
	follow                *string
	max                   *int64
	search                *string
}

func (p *GlusterVolumesServiceListRequest) Header(key, value string) *GlusterVolumesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumesServiceListRequest) Query(key, value string) *GlusterVolumesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumesServiceListRequest) CaseSensitive(caseSensitive bool) *GlusterVolumesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *GlusterVolumesServiceListRequest) Follow(follow string) *GlusterVolumesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *GlusterVolumesServiceListRequest) Max(max int64) *GlusterVolumesServiceListRequest {
	p.max = &max
	return p
}

func (p *GlusterVolumesServiceListRequest) Search(search string) *GlusterVolumesServiceListRequest {
	p.search = &search
	return p
}

func (p *GlusterVolumesServiceListRequest) Send() (*GlusterVolumesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterVolumesService.connection.URL(), p.GlusterVolumesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &GlusterVolumesServiceListResponse{volumes: result}, nil
}

func (p *GlusterVolumesServiceListRequest) MustSend() *GlusterVolumesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all gluster volumes in the cluster.
// For example, to list all Gluster Volumes in cluster `456`, send a request like
// this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes
// ----
// The order of the returned list of volumes isn't guaranteed.
//
type GlusterVolumesServiceListResponse struct {
	volumes *GlusterVolumeSlice
}

func (p *GlusterVolumesServiceListResponse) Volumes() (*GlusterVolumeSlice, bool) {
	if p.volumes != nil {
		return p.volumes, true
	}
	return nil, false
}

func (p *GlusterVolumesServiceListResponse) MustVolumes() *GlusterVolumeSlice {
	if p.volumes == nil {
		panic("volumes in response does not exist")
	}
	return p.volumes
}

//
// Lists all gluster volumes in the cluster.
// For example, to list all Gluster Volumes in cluster `456`, send a request like
// this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes
// ----
// The order of the returned list of volumes isn't guaranteed.
//
func (p *GlusterVolumesService) List() *GlusterVolumesServiceListRequest {
	return &GlusterVolumesServiceListRequest{GlusterVolumesService: p}
}

//
// Reference to a service managing gluster volume.
//
func (op *GlusterVolumesService) VolumeService(id string) *GlusterVolumeService {
	return NewGlusterVolumeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterVolumesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VolumeService(path), nil
	}
	return op.VolumeService(path[:index]).Service(path[index+1:])
}

func (op *GlusterVolumesService) String() string {
	return fmt.Sprintf("GlusterVolumesService:%s", op.path)
}

//
// This service manages a single gluster volume.
//
type GlusterVolumeService struct {
	BaseService
}

func NewGlusterVolumeService(connection *Connection, path string) *GlusterVolumeService {
	var result GlusterVolumeService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get the gluster volume details.
// For example, to get details of a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
// This GET request will return the following output:
// [source,xml]
// ----
// <gluster_volume id="123">
//  <name>data</name>
//  <link href="/ovirt-engine/api/clusters/456/glustervolumes/123/glusterbricks" rel="glusterbricks"/>
//  <disperse_count>0</disperse_count>
//  <options>
//    <option>
//      <name>storage.owner-gid</name>
//      <value>36</value>
//    </option>
//    <option>
//      <name>performance.io-cache</name>
//      <value>off</value>
//    </option>
//    <option>
//      <name>cluster.data-self-heal-algorithm</name>
//      <value>full</value>
//    </option>
//  </options>
//  <redundancy_count>0</redundancy_count>
//  <replica_count>3</replica_count>
//  <status>up</status>
//  <stripe_count>0</stripe_count>
//  <transport_types>
//    <transport_type>tcp</transport_type>
//  </transport_types>
//  <volume_type>replicate</volume_type>
//  </gluster_volume>
// ----
//
type GlusterVolumeServiceGetRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *GlusterVolumeServiceGetRequest) Header(key, value string) *GlusterVolumeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceGetRequest) Query(key, value string) *GlusterVolumeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceGetRequest) Follow(follow string) *GlusterVolumeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *GlusterVolumeServiceGetRequest) Send() (*GlusterVolumeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterVolumeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &GlusterVolumeServiceGetResponse{volume: result}, nil
}

func (p *GlusterVolumeServiceGetRequest) MustSend() *GlusterVolumeServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get the gluster volume details.
// For example, to get details of a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
// This GET request will return the following output:
// [source,xml]
// ----
// <gluster_volume id="123">
//  <name>data</name>
//  <link href="/ovirt-engine/api/clusters/456/glustervolumes/123/glusterbricks" rel="glusterbricks"/>
//  <disperse_count>0</disperse_count>
//  <options>
//    <option>
//      <name>storage.owner-gid</name>
//      <value>36</value>
//    </option>
//    <option>
//      <name>performance.io-cache</name>
//      <value>off</value>
//    </option>
//    <option>
//      <name>cluster.data-self-heal-algorithm</name>
//      <value>full</value>
//    </option>
//  </options>
//  <redundancy_count>0</redundancy_count>
//  <replica_count>3</replica_count>
//  <status>up</status>
//  <stripe_count>0</stripe_count>
//  <transport_types>
//    <transport_type>tcp</transport_type>
//  </transport_types>
//  <volume_type>replicate</volume_type>
//  </gluster_volume>
// ----
//
type GlusterVolumeServiceGetResponse struct {
	volume *GlusterVolume
}

func (p *GlusterVolumeServiceGetResponse) Volume() (*GlusterVolume, bool) {
	if p.volume != nil {
		return p.volume, true
	}
	return nil, false
}

func (p *GlusterVolumeServiceGetResponse) MustVolume() *GlusterVolume {
	if p.volume == nil {
		panic("volume in response does not exist")
	}
	return p.volume
}

//
// Get the gluster volume details.
// For example, to get details of a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
// This GET request will return the following output:
// [source,xml]
// ----
// <gluster_volume id="123">
//  <name>data</name>
//  <link href="/ovirt-engine/api/clusters/456/glustervolumes/123/glusterbricks" rel="glusterbricks"/>
//  <disperse_count>0</disperse_count>
//  <options>
//    <option>
//      <name>storage.owner-gid</name>
//      <value>36</value>
//    </option>
//    <option>
//      <name>performance.io-cache</name>
//      <value>off</value>
//    </option>
//    <option>
//      <name>cluster.data-self-heal-algorithm</name>
//      <value>full</value>
//    </option>
//  </options>
//  <redundancy_count>0</redundancy_count>
//  <replica_count>3</replica_count>
//  <status>up</status>
//  <stripe_count>0</stripe_count>
//  <transport_types>
//    <transport_type>tcp</transport_type>
//  </transport_types>
//  <volume_type>replicate</volume_type>
//  </gluster_volume>
// ----
//
func (p *GlusterVolumeService) Get() *GlusterVolumeServiceGetRequest {
	return &GlusterVolumeServiceGetRequest{GlusterVolumeService: p}
}

//
// Get gluster volume profile statistics.
// For example, to get profile statistics for a gluster volume with identifier `123` in cluster `456`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/getprofilestatistics
// ----
//
type GlusterVolumeServiceGetProfileStatisticsRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Header(key, value string) *GlusterVolumeServiceGetProfileStatisticsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Query(key, value string) *GlusterVolumeServiceGetProfileStatisticsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) Send() (*GlusterVolumeServiceGetProfileStatisticsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/getprofilestatistics", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustDetails()
	return &GlusterVolumeServiceGetProfileStatisticsResponse{details: result}, nil
}

func (p *GlusterVolumeServiceGetProfileStatisticsRequest) MustSend() *GlusterVolumeServiceGetProfileStatisticsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get gluster volume profile statistics.
// For example, to get profile statistics for a gluster volume with identifier `123` in cluster `456`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/getprofilestatistics
// ----
//
type GlusterVolumeServiceGetProfileStatisticsResponse struct {
	details *GlusterVolumeProfileDetails
}

func (p *GlusterVolumeServiceGetProfileStatisticsResponse) Details() (*GlusterVolumeProfileDetails, bool) {
	if p.details != nil {
		return p.details, true
	}
	return nil, false
}

func (p *GlusterVolumeServiceGetProfileStatisticsResponse) MustDetails() *GlusterVolumeProfileDetails {
	if p.details == nil {
		panic("details in response does not exist")
	}
	return p.details
}

//
// Get gluster volume profile statistics.
// For example, to get profile statistics for a gluster volume with identifier `123` in cluster `456`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/getprofilestatistics
// ----
//
func (p *GlusterVolumeService) GetProfileStatistics() *GlusterVolumeServiceGetProfileStatisticsRequest {
	return &GlusterVolumeServiceGetProfileStatisticsRequest{GlusterVolumeService: p}
}

//
// Rebalance the gluster volume.
// Rebalancing a gluster volume helps to distribute the data evenly across all the bricks. After expanding or
// shrinking a gluster volume (without migrating data), we need to rebalance the data among the bricks. In a
// non-replicated volume, all bricks should be online to perform the rebalance operation. In a replicated volume, at
// least one of the bricks in the replica should be online.
// For example, to rebalance a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/rebalance
// ----
//
type GlusterVolumeServiceRebalanceRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	fixLayout            *bool
	force                *bool
}

func (p *GlusterVolumeServiceRebalanceRequest) Header(key, value string) *GlusterVolumeServiceRebalanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) Query(key, value string) *GlusterVolumeServiceRebalanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) Async(async bool) *GlusterVolumeServiceRebalanceRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) FixLayout(fixLayout bool) *GlusterVolumeServiceRebalanceRequest {
	p.fixLayout = &fixLayout
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) Force(force bool) *GlusterVolumeServiceRebalanceRequest {
	p.force = &force
	return p
}

func (p *GlusterVolumeServiceRebalanceRequest) Send() (*GlusterVolumeServiceRebalanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/rebalance", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.fixLayout != nil {
		actionBuilder.FixLayout(*p.fixLayout)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceRebalanceResponse), nil
}

func (p *GlusterVolumeServiceRebalanceRequest) MustSend() *GlusterVolumeServiceRebalanceResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Rebalance the gluster volume.
// Rebalancing a gluster volume helps to distribute the data evenly across all the bricks. After expanding or
// shrinking a gluster volume (without migrating data), we need to rebalance the data among the bricks. In a
// non-replicated volume, all bricks should be online to perform the rebalance operation. In a replicated volume, at
// least one of the bricks in the replica should be online.
// For example, to rebalance a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/rebalance
// ----
//
type GlusterVolumeServiceRebalanceResponse struct {
}

//
// Rebalance the gluster volume.
// Rebalancing a gluster volume helps to distribute the data evenly across all the bricks. After expanding or
// shrinking a gluster volume (without migrating data), we need to rebalance the data among the bricks. In a
// non-replicated volume, all bricks should be online to perform the rebalance operation. In a replicated volume, at
// least one of the bricks in the replica should be online.
// For example, to rebalance a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/rebalance
// ----
//
func (p *GlusterVolumeService) Rebalance() *GlusterVolumeServiceRebalanceRequest {
	return &GlusterVolumeServiceRebalanceRequest{GlusterVolumeService: p}
}

//
// Removes the gluster volume.
// For example, to remove a volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
//
type GlusterVolumeServiceRemoveRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceRemoveRequest) Header(key, value string) *GlusterVolumeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceRemoveRequest) Query(key, value string) *GlusterVolumeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceRemoveRequest) Async(async bool) *GlusterVolumeServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceRemoveRequest) Send() (*GlusterVolumeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GlusterVolumeServiceRemoveResponse), nil
}

func (p *GlusterVolumeServiceRemoveRequest) MustSend() *GlusterVolumeServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the gluster volume.
// For example, to remove a volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
//
type GlusterVolumeServiceRemoveResponse struct {
}

//
// Removes the gluster volume.
// For example, to remove a volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/456/glustervolumes/123
// ----
//
func (p *GlusterVolumeService) Remove() *GlusterVolumeServiceRemoveRequest {
	return &GlusterVolumeServiceRemoveRequest{GlusterVolumeService: p}
}

//
// Resets all the options set in the gluster volume.
// For example, to reset all options in a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetalloptions
// ----
//
type GlusterVolumeServiceResetAllOptionsRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Header(key, value string) *GlusterVolumeServiceResetAllOptionsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Query(key, value string) *GlusterVolumeServiceResetAllOptionsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Async(async bool) *GlusterVolumeServiceResetAllOptionsRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) Send() (*GlusterVolumeServiceResetAllOptionsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetalloptions", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceResetAllOptionsResponse), nil
}

func (p *GlusterVolumeServiceResetAllOptionsRequest) MustSend() *GlusterVolumeServiceResetAllOptionsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Resets all the options set in the gluster volume.
// For example, to reset all options in a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetalloptions
// ----
//
type GlusterVolumeServiceResetAllOptionsResponse struct {
}

//
// Resets all the options set in the gluster volume.
// For example, to reset all options in a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetalloptions
// ----
//
func (p *GlusterVolumeService) ResetAllOptions() *GlusterVolumeServiceResetAllOptionsRequest {
	return &GlusterVolumeServiceResetAllOptionsRequest{GlusterVolumeService: p}
}

//
// Resets a particular option in the gluster volume.
// For example, to reset a particular option `option1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1"/>
// </action>
// ----
//
type GlusterVolumeServiceResetOptionRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
	option               *Option
}

func (p *GlusterVolumeServiceResetOptionRequest) Header(key, value string) *GlusterVolumeServiceResetOptionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Query(key, value string) *GlusterVolumeServiceResetOptionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Async(async bool) *GlusterVolumeServiceResetOptionRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Force(force bool) *GlusterVolumeServiceResetOptionRequest {
	p.force = &force
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Option(option *Option) *GlusterVolumeServiceResetOptionRequest {
	p.option = option
	return p
}

func (p *GlusterVolumeServiceResetOptionRequest) Send() (*GlusterVolumeServiceResetOptionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetoption", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	actionBuilder.Option(p.option)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceResetOptionResponse), nil
}

func (p *GlusterVolumeServiceResetOptionRequest) MustSend() *GlusterVolumeServiceResetOptionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Resets a particular option in the gluster volume.
// For example, to reset a particular option `option1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1"/>
// </action>
// ----
//
type GlusterVolumeServiceResetOptionResponse struct {
}

//
// Resets a particular option in the gluster volume.
// For example, to reset a particular option `option1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/resetoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1"/>
// </action>
// ----
//
func (p *GlusterVolumeService) ResetOption() *GlusterVolumeServiceResetOptionRequest {
	return &GlusterVolumeServiceResetOptionRequest{GlusterVolumeService: p}
}

//
// Sets a particular option in the gluster volume.
// For example, to set `option1` with value `value1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/setoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1" value="value1"/>
// </action>
// ----
//
type GlusterVolumeServiceSetOptionRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	option               *Option
}

func (p *GlusterVolumeServiceSetOptionRequest) Header(key, value string) *GlusterVolumeServiceSetOptionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceSetOptionRequest) Query(key, value string) *GlusterVolumeServiceSetOptionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceSetOptionRequest) Async(async bool) *GlusterVolumeServiceSetOptionRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceSetOptionRequest) Option(option *Option) *GlusterVolumeServiceSetOptionRequest {
	p.option = option
	return p
}

func (p *GlusterVolumeServiceSetOptionRequest) Send() (*GlusterVolumeServiceSetOptionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/setoption", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Option(p.option)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceSetOptionResponse), nil
}

func (p *GlusterVolumeServiceSetOptionRequest) MustSend() *GlusterVolumeServiceSetOptionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Sets a particular option in the gluster volume.
// For example, to set `option1` with value `value1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/setoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1" value="value1"/>
// </action>
// ----
//
type GlusterVolumeServiceSetOptionResponse struct {
}

//
// Sets a particular option in the gluster volume.
// For example, to set `option1` with value `value1` in a gluster volume with identifier `123` in cluster `456`,
// send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/setoption
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//  <option name="option1" value="value1"/>
// </action>
// ----
//
func (p *GlusterVolumeService) SetOption() *GlusterVolumeServiceSetOptionRequest {
	return &GlusterVolumeServiceSetOptionRequest{GlusterVolumeService: p}
}

//
// Starts the gluster volume.
// A Gluster Volume should be started to read/write data. For example, to start a gluster volume with identifier
// `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/start
// ----
//
type GlusterVolumeServiceStartRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
}

func (p *GlusterVolumeServiceStartRequest) Header(key, value string) *GlusterVolumeServiceStartRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStartRequest) Query(key, value string) *GlusterVolumeServiceStartRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStartRequest) Async(async bool) *GlusterVolumeServiceStartRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceStartRequest) Force(force bool) *GlusterVolumeServiceStartRequest {
	p.force = &force
	return p
}

func (p *GlusterVolumeServiceStartRequest) Send() (*GlusterVolumeServiceStartResponse, error) {
	rawURL := fmt.Sprintf("%s%s/start", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStartResponse), nil
}

func (p *GlusterVolumeServiceStartRequest) MustSend() *GlusterVolumeServiceStartResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Starts the gluster volume.
// A Gluster Volume should be started to read/write data. For example, to start a gluster volume with identifier
// `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/start
// ----
//
type GlusterVolumeServiceStartResponse struct {
}

//
// Starts the gluster volume.
// A Gluster Volume should be started to read/write data. For example, to start a gluster volume with identifier
// `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/start
// ----
//
func (p *GlusterVolumeService) Start() *GlusterVolumeServiceStartRequest {
	return &GlusterVolumeServiceStartRequest{GlusterVolumeService: p}
}

//
// Start profiling the gluster volume.
// For example, to start profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/startprofile
// ----
//
type GlusterVolumeServiceStartProfileRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStartProfileRequest) Header(key, value string) *GlusterVolumeServiceStartProfileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStartProfileRequest) Query(key, value string) *GlusterVolumeServiceStartProfileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStartProfileRequest) Async(async bool) *GlusterVolumeServiceStartProfileRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceStartProfileRequest) Send() (*GlusterVolumeServiceStartProfileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/startprofile", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStartProfileResponse), nil
}

func (p *GlusterVolumeServiceStartProfileRequest) MustSend() *GlusterVolumeServiceStartProfileResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Start profiling the gluster volume.
// For example, to start profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/startprofile
// ----
//
type GlusterVolumeServiceStartProfileResponse struct {
}

//
// Start profiling the gluster volume.
// For example, to start profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/startprofile
// ----
//
func (p *GlusterVolumeService) StartProfile() *GlusterVolumeServiceStartProfileRequest {
	return &GlusterVolumeServiceStartProfileRequest{GlusterVolumeService: p}
}

//
// Stops the gluster volume.
// Stopping a volume will make its data inaccessible.
// For example, to stop a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stop
// ----
//
type GlusterVolumeServiceStopRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
	force                *bool
}

func (p *GlusterVolumeServiceStopRequest) Header(key, value string) *GlusterVolumeServiceStopRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRequest) Query(key, value string) *GlusterVolumeServiceStopRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRequest) Async(async bool) *GlusterVolumeServiceStopRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceStopRequest) Force(force bool) *GlusterVolumeServiceStopRequest {
	p.force = &force
	return p
}

func (p *GlusterVolumeServiceStopRequest) Send() (*GlusterVolumeServiceStopResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stop", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStopResponse), nil
}

func (p *GlusterVolumeServiceStopRequest) MustSend() *GlusterVolumeServiceStopResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Stops the gluster volume.
// Stopping a volume will make its data inaccessible.
// For example, to stop a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stop
// ----
//
type GlusterVolumeServiceStopResponse struct {
}

//
// Stops the gluster volume.
// Stopping a volume will make its data inaccessible.
// For example, to stop a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stop
// ----
//
func (p *GlusterVolumeService) Stop() *GlusterVolumeServiceStopRequest {
	return &GlusterVolumeServiceStopRequest{GlusterVolumeService: p}
}

//
// Stop profiling the gluster volume.
// For example, to stop profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stopprofile
// ----
//
type GlusterVolumeServiceStopProfileRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStopProfileRequest) Header(key, value string) *GlusterVolumeServiceStopProfileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopProfileRequest) Query(key, value string) *GlusterVolumeServiceStopProfileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopProfileRequest) Async(async bool) *GlusterVolumeServiceStopProfileRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceStopProfileRequest) Send() (*GlusterVolumeServiceStopProfileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stopprofile", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStopProfileResponse), nil
}

func (p *GlusterVolumeServiceStopProfileRequest) MustSend() *GlusterVolumeServiceStopProfileResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Stop profiling the gluster volume.
// For example, to stop profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stopprofile
// ----
//
type GlusterVolumeServiceStopProfileResponse struct {
}

//
// Stop profiling the gluster volume.
// For example, to stop profiling a gluster volume with identifier `123` in cluster `456`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stopprofile
// ----
//
func (p *GlusterVolumeService) StopProfile() *GlusterVolumeServiceStopProfileRequest {
	return &GlusterVolumeServiceStopProfileRequest{GlusterVolumeService: p}
}

//
// Stop rebalancing the gluster volume.
// For example, to stop rebalancing a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stoprebalance
// ----
//
type GlusterVolumeServiceStopRebalanceRequest struct {
	GlusterVolumeService *GlusterVolumeService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Header(key, value string) *GlusterVolumeServiceStopRebalanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Query(key, value string) *GlusterVolumeServiceStopRebalanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Async(async bool) *GlusterVolumeServiceStopRebalanceRequest {
	p.async = &async
	return p
}

func (p *GlusterVolumeServiceStopRebalanceRequest) Send() (*GlusterVolumeServiceStopRebalanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stoprebalance", p.GlusterVolumeService.connection.URL(), p.GlusterVolumeService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterVolumeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterVolumeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterVolumeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterVolumeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterVolumeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterVolumeServiceStopRebalanceResponse), nil
}

func (p *GlusterVolumeServiceStopRebalanceRequest) MustSend() *GlusterVolumeServiceStopRebalanceResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Stop rebalancing the gluster volume.
// For example, to stop rebalancing a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stoprebalance
// ----
//
type GlusterVolumeServiceStopRebalanceResponse struct {
}

//
// Stop rebalancing the gluster volume.
// For example, to stop rebalancing a gluster volume with identifier `123` in cluster `456`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/456/glustervolumes/123/stoprebalance
// ----
//
func (p *GlusterVolumeService) StopRebalance() *GlusterVolumeServiceStopRebalanceRequest {
	return &GlusterVolumeServiceStopRebalanceRequest{GlusterVolumeService: p}
}

//
// Reference to a service managing gluster bricks.
//
func (op *GlusterVolumeService) GlusterBricksService() *GlusterBricksService {
	return NewGlusterBricksService(op.connection, fmt.Sprintf("%s/glusterbricks", op.path))
}

//
//
func (op *GlusterVolumeService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterVolumeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "glusterbricks" {
		return op.GlusterBricksService(), nil
	}
	if strings.HasPrefix(path, "glusterbricks/") {
		return op.GlusterBricksService().Service(path[14:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *GlusterVolumeService) String() string {
	return fmt.Sprintf("GlusterVolumeService:%s", op.path)
}

//
// This service manages the gluster bricks in a gluster volume
//
type GlusterBricksService struct {
	BaseService
}

func NewGlusterBricksService(connection *Connection, path string) *GlusterBricksService {
	var result GlusterBricksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Activate the bricks post data migration of remove brick operation.
// Used to activate brick(s) once the data migration from bricks is complete but user no longer wishes to remove
// bricks. The bricks that were previously marked for removal will now be used as normal bricks.
// For example, to retain the bricks that on glustervolume `123` from which data was migrated, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/activate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
//
type GlusterBricksServiceActivateRequest struct {
	GlusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               *GlusterBrickSlice
}

func (p *GlusterBricksServiceActivateRequest) Header(key, value string) *GlusterBricksServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceActivateRequest) Query(key, value string) *GlusterBricksServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceActivateRequest) Async(async bool) *GlusterBricksServiceActivateRequest {
	p.async = &async
	return p
}

func (p *GlusterBricksServiceActivateRequest) Bricks(bricks *GlusterBrickSlice) *GlusterBricksServiceActivateRequest {
	p.bricks = bricks
	return p
}

func (p *GlusterBricksServiceActivateRequest) BricksOfAny(anys ...*GlusterBrick) *GlusterBricksServiceActivateRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *GlusterBricksServiceActivateRequest) Send() (*GlusterBricksServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.GlusterBricksService.connection.URL(), p.GlusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBricksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBricksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBricksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterBricksServiceActivateResponse), nil
}

func (p *GlusterBricksServiceActivateRequest) MustSend() *GlusterBricksServiceActivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Activate the bricks post data migration of remove brick operation.
// Used to activate brick(s) once the data migration from bricks is complete but user no longer wishes to remove
// bricks. The bricks that were previously marked for removal will now be used as normal bricks.
// For example, to retain the bricks that on glustervolume `123` from which data was migrated, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/activate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
//
type GlusterBricksServiceActivateResponse struct {
}

//
// Activate the bricks post data migration of remove brick operation.
// Used to activate brick(s) once the data migration from bricks is complete but user no longer wishes to remove
// bricks. The bricks that were previously marked for removal will now be used as normal bricks.
// For example, to retain the bricks that on glustervolume `123` from which data was migrated, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/activate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
//
func (p *GlusterBricksService) Activate() *GlusterBricksServiceActivateRequest {
	return &GlusterBricksServiceActivateRequest{GlusterBricksService: p}
}

//
// Adds a list of bricks to gluster volume.
// Used to expand a gluster volume by adding bricks. For replicated volume types, the parameter `replica_count`
// needs to be passed. In case the replica count is being increased, then the number of bricks needs to be
// equivalent to the number of replica sets.
// For example, to add bricks to gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <server_id>111</server_id>
//     <brick_dir>/export/data/brick3</brick_dir>
//   </brick>
// </bricks>
// ----
//
type GlusterBricksServiceAddRequest struct {
	GlusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	bricks               *GlusterBrickSlice
	replicaCount         *int64
	stripeCount          *int64
}

func (p *GlusterBricksServiceAddRequest) Header(key, value string) *GlusterBricksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceAddRequest) Query(key, value string) *GlusterBricksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceAddRequest) Bricks(bricks *GlusterBrickSlice) *GlusterBricksServiceAddRequest {
	p.bricks = bricks
	return p
}

func (p *GlusterBricksServiceAddRequest) BricksOfAny(anys ...*GlusterBrick) *GlusterBricksServiceAddRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *GlusterBricksServiceAddRequest) ReplicaCount(replicaCount int64) *GlusterBricksServiceAddRequest {
	p.replicaCount = &replicaCount
	return p
}

func (p *GlusterBricksServiceAddRequest) StripeCount(stripeCount int64) *GlusterBricksServiceAddRequest {
	p.stripeCount = &stripeCount
	return p
}

func (p *GlusterBricksServiceAddRequest) Send() (*GlusterBricksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterBricksService.connection.URL(), p.GlusterBricksService.path)
	values := make(url.Values)
	if p.replicaCount != nil {
		values["replica_count"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}

	if p.stripeCount != nil {
		values["stripe_count"] = []string{fmt.Sprintf("%v", *p.stripeCount)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGlusterBrickWriteMany(writer, p.bricks, "", "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBricksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBricksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBricksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &GlusterBricksServiceAddResponse{bricks: result}, nil
}

func (p *GlusterBricksServiceAddRequest) MustSend() *GlusterBricksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a list of bricks to gluster volume.
// Used to expand a gluster volume by adding bricks. For replicated volume types, the parameter `replica_count`
// needs to be passed. In case the replica count is being increased, then the number of bricks needs to be
// equivalent to the number of replica sets.
// For example, to add bricks to gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <server_id>111</server_id>
//     <brick_dir>/export/data/brick3</brick_dir>
//   </brick>
// </bricks>
// ----
//
type GlusterBricksServiceAddResponse struct {
	bricks *GlusterBrickSlice
}

func (p *GlusterBricksServiceAddResponse) Bricks() (*GlusterBrickSlice, bool) {
	if p.bricks != nil {
		return p.bricks, true
	}
	return nil, false
}

func (p *GlusterBricksServiceAddResponse) MustBricks() *GlusterBrickSlice {
	if p.bricks == nil {
		panic("bricks in response does not exist")
	}
	return p.bricks
}

//
// Adds a list of bricks to gluster volume.
// Used to expand a gluster volume by adding bricks. For replicated volume types, the parameter `replica_count`
// needs to be passed. In case the replica count is being increased, then the number of bricks needs to be
// equivalent to the number of replica sets.
// For example, to add bricks to gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <server_id>111</server_id>
//     <brick_dir>/export/data/brick3</brick_dir>
//   </brick>
// </bricks>
// ----
//
func (p *GlusterBricksService) Add() *GlusterBricksServiceAddRequest {
	return &GlusterBricksServiceAddRequest{GlusterBricksService: p}
}

//
// Lists the bricks of a gluster volume.
// For example, to list bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// Provides an output as below:
// [source,xml]
// ----
// <bricks>
//   <brick id="234">
//     <name>host1:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>111</server_id>
//     <status>up</status>
//   </brick>
//   <brick id="233">
//     <name>host2:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>222</server_id>
//     <status>up</status>
//   </brick>
// </bricks>
// ----
// The order of the returned list is based on the brick order provided at gluster volume creation.
//
type GlusterBricksServiceListRequest struct {
	GlusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *GlusterBricksServiceListRequest) Header(key, value string) *GlusterBricksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceListRequest) Query(key, value string) *GlusterBricksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceListRequest) Follow(follow string) *GlusterBricksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *GlusterBricksServiceListRequest) Max(max int64) *GlusterBricksServiceListRequest {
	p.max = &max
	return p
}

func (p *GlusterBricksServiceListRequest) Send() (*GlusterBricksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterBricksService.connection.URL(), p.GlusterBricksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBricksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBricksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBricksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGlusterBrickReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &GlusterBricksServiceListResponse{bricks: result}, nil
}

func (p *GlusterBricksServiceListRequest) MustSend() *GlusterBricksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists the bricks of a gluster volume.
// For example, to list bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// Provides an output as below:
// [source,xml]
// ----
// <bricks>
//   <brick id="234">
//     <name>host1:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>111</server_id>
//     <status>up</status>
//   </brick>
//   <brick id="233">
//     <name>host2:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>222</server_id>
//     <status>up</status>
//   </brick>
// </bricks>
// ----
// The order of the returned list is based on the brick order provided at gluster volume creation.
//
type GlusterBricksServiceListResponse struct {
	bricks *GlusterBrickSlice
}

func (p *GlusterBricksServiceListResponse) Bricks() (*GlusterBrickSlice, bool) {
	if p.bricks != nil {
		return p.bricks, true
	}
	return nil, false
}

func (p *GlusterBricksServiceListResponse) MustBricks() *GlusterBrickSlice {
	if p.bricks == nil {
		panic("bricks in response does not exist")
	}
	return p.bricks
}

//
// Lists the bricks of a gluster volume.
// For example, to list bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// Provides an output as below:
// [source,xml]
// ----
// <bricks>
//   <brick id="234">
//     <name>host1:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>111</server_id>
//     <status>up</status>
//   </brick>
//   <brick id="233">
//     <name>host2:/rhgs/data/brick1</name>
//     <brick_dir>/rhgs/data/brick1</brick_dir>
//     <server_id>222</server_id>
//     <status>up</status>
//   </brick>
// </bricks>
// ----
// The order of the returned list is based on the brick order provided at gluster volume creation.
//
func (p *GlusterBricksService) List() *GlusterBricksServiceListRequest {
	return &GlusterBricksServiceListRequest{GlusterBricksService: p}
}

//
// Start migration of data prior to removing bricks.
// Removing bricks is a two-step process, where the data on bricks to be removed, is first migrated to remaining
// bricks. Once migration is completed the removal of bricks is confirmed via the API
// <<services/gluster_bricks/methods/remove, remove>>. If at any point, the action needs to be cancelled
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> has to be called.
// For instance, to delete a brick from a gluster volume with id `123`, send a request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/migrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
// The migration process can be tracked from the job id returned from the API using
// <<services/job/methods/get, job>> and steps in job using <<services/step/methods/get, step>>
//
type GlusterBricksServiceMigrateRequest struct {
	GlusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               *GlusterBrickSlice
}

func (p *GlusterBricksServiceMigrateRequest) Header(key, value string) *GlusterBricksServiceMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceMigrateRequest) Query(key, value string) *GlusterBricksServiceMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceMigrateRequest) Async(async bool) *GlusterBricksServiceMigrateRequest {
	p.async = &async
	return p
}

func (p *GlusterBricksServiceMigrateRequest) Bricks(bricks *GlusterBrickSlice) *GlusterBricksServiceMigrateRequest {
	p.bricks = bricks
	return p
}

func (p *GlusterBricksServiceMigrateRequest) BricksOfAny(anys ...*GlusterBrick) *GlusterBricksServiceMigrateRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *GlusterBricksServiceMigrateRequest) Send() (*GlusterBricksServiceMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/migrate", p.GlusterBricksService.connection.URL(), p.GlusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBricksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBricksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBricksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterBricksServiceMigrateResponse), nil
}

func (p *GlusterBricksServiceMigrateRequest) MustSend() *GlusterBricksServiceMigrateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Start migration of data prior to removing bricks.
// Removing bricks is a two-step process, where the data on bricks to be removed, is first migrated to remaining
// bricks. Once migration is completed the removal of bricks is confirmed via the API
// <<services/gluster_bricks/methods/remove, remove>>. If at any point, the action needs to be cancelled
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> has to be called.
// For instance, to delete a brick from a gluster volume with id `123`, send a request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/migrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
// The migration process can be tracked from the job id returned from the API using
// <<services/job/methods/get, job>> and steps in job using <<services/step/methods/get, step>>
//
type GlusterBricksServiceMigrateResponse struct {
}

//
// Start migration of data prior to removing bricks.
// Removing bricks is a two-step process, where the data on bricks to be removed, is first migrated to remaining
// bricks. Once migration is completed the removal of bricks is confirmed via the API
// <<services/gluster_bricks/methods/remove, remove>>. If at any point, the action needs to be cancelled
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> has to be called.
// For instance, to delete a brick from a gluster volume with id `123`, send a request:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/migrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <bricks>
//     <brick>
//       <name>host1:/rhgs/brick1</name>
//     </brick>
//   </bricks>
// </action>
// ----
// The migration process can be tracked from the job id returned from the API using
// <<services/job/methods/get, job>> and steps in job using <<services/step/methods/get, step>>
//
func (p *GlusterBricksService) Migrate() *GlusterBricksServiceMigrateRequest {
	return &GlusterBricksServiceMigrateRequest{GlusterBricksService: p}
}

//
// Removes bricks from gluster volume.
// The recommended way to remove bricks without data loss is to first migrate the data using
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> and then removing them. If migrate was not called on
// bricks prior to remove, the bricks are removed without data migration which may lead to data loss.
// For example, to delete the bricks from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
type GlusterBricksServiceRemoveRequest struct {
	GlusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               *GlusterBrickSlice
	replicaCount         *int64
}

func (p *GlusterBricksServiceRemoveRequest) Header(key, value string) *GlusterBricksServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceRemoveRequest) Query(key, value string) *GlusterBricksServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceRemoveRequest) Async(async bool) *GlusterBricksServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *GlusterBricksServiceRemoveRequest) Bricks(bricks *GlusterBrickSlice) *GlusterBricksServiceRemoveRequest {
	p.bricks = bricks
	return p
}

func (p *GlusterBricksServiceRemoveRequest) BricksOfAny(anys ...*GlusterBrick) *GlusterBricksServiceRemoveRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *GlusterBricksServiceRemoveRequest) ReplicaCount(replicaCount int64) *GlusterBricksServiceRemoveRequest {
	p.replicaCount = &replicaCount
	return p
}

func (p *GlusterBricksServiceRemoveRequest) Send() (*GlusterBricksServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.GlusterBricksService.connection.URL(), p.GlusterBricksService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.replicaCount != nil {
		values["replica_count"] = []string{fmt.Sprintf("%v", *p.replicaCount)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBricksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBricksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBricksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(GlusterBricksServiceRemoveResponse), nil
}

func (p *GlusterBricksServiceRemoveRequest) MustSend() *GlusterBricksServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes bricks from gluster volume.
// The recommended way to remove bricks without data loss is to first migrate the data using
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> and then removing them. If migrate was not called on
// bricks prior to remove, the bricks are removed without data migration which may lead to data loss.
// For example, to delete the bricks from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
type GlusterBricksServiceRemoveResponse struct {
}

//
// Removes bricks from gluster volume.
// The recommended way to remove bricks without data loss is to first migrate the data using
// <<services/gluster_bricks/methods/stop_migrate, stopmigrate>> and then removing them. If migrate was not called on
// bricks prior to remove, the bricks are removed without data migration which may lead to data loss.
// For example, to delete the bricks from gluster volume `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
func (p *GlusterBricksService) Remove() *GlusterBricksServiceRemoveRequest {
	return &GlusterBricksServiceRemoveRequest{GlusterBricksService: p}
}

//
// Stops migration of data from bricks for a remove brick operation.
// To cancel data migration that was started as part of the 2-step remove brick process in case the user wishes to
// continue using the bricks. The bricks that were marked for removal will function as normal bricks post this
// operation.
// For example, to stop migration of data from the bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/stopmigrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
type GlusterBricksServiceStopMigrateRequest struct {
	GlusterBricksService *GlusterBricksService
	header               map[string]string
	query                map[string]string
	async                *bool
	bricks               *GlusterBrickSlice
}

func (p *GlusterBricksServiceStopMigrateRequest) Header(key, value string) *GlusterBricksServiceStopMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) Query(key, value string) *GlusterBricksServiceStopMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) Async(async bool) *GlusterBricksServiceStopMigrateRequest {
	p.async = &async
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) Bricks(bricks *GlusterBrickSlice) *GlusterBricksServiceStopMigrateRequest {
	p.bricks = bricks
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) BricksOfAny(anys ...*GlusterBrick) *GlusterBricksServiceStopMigrateRequest {
	if p.bricks == nil {
		p.bricks = new(GlusterBrickSlice)
	}
	p.bricks.slice = append(p.bricks.slice, anys...)
	return p
}

func (p *GlusterBricksServiceStopMigrateRequest) Send() (*GlusterBricksServiceStopMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stopmigrate", p.GlusterBricksService.connection.URL(), p.GlusterBricksService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Bricks(p.bricks)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.GlusterBricksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.GlusterBricksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.GlusterBricksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.GlusterBricksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.GlusterBricksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(GlusterBricksServiceStopMigrateResponse), nil
}

func (p *GlusterBricksServiceStopMigrateRequest) MustSend() *GlusterBricksServiceStopMigrateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Stops migration of data from bricks for a remove brick operation.
// To cancel data migration that was started as part of the 2-step remove brick process in case the user wishes to
// continue using the bricks. The bricks that were marked for removal will function as normal bricks post this
// operation.
// For example, to stop migration of data from the bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/stopmigrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
type GlusterBricksServiceStopMigrateResponse struct {
}

//
// Stops migration of data from bricks for a remove brick operation.
// To cancel data migration that was started as part of the 2-step remove brick process in case the user wishes to
// continue using the bricks. The bricks that were marked for removal will function as normal bricks post this
// operation.
// For example, to stop migration of data from the bricks of gluster volume `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/567/glustervolumes/123/glusterbricks/stopmigrate
// ----
// With a request body like this:
// [source,xml]
// ----
// <bricks>
//   <brick>
//     <name>host:brick_directory</name>
//   </brick>
// </bricks>
// ----
//
func (p *GlusterBricksService) StopMigrate() *GlusterBricksServiceStopMigrateRequest {
	return &GlusterBricksServiceStopMigrateRequest{GlusterBricksService: p}
}

//
// Returns a reference to the service managing a single gluster brick.
//
func (op *GlusterBricksService) BrickService(id string) *GlusterBrickService {
	return NewGlusterBrickService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *GlusterBricksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.BrickService(path), nil
	}
	return op.BrickService(path[:index]).Service(path[index+1:])
}

func (op *GlusterBricksService) String() string {
	return fmt.Sprintf("GlusterBricksService:%s", op.path)
}

//
// Manages the set of snapshots of a storage domain or virtual machine.
//
type SnapshotsService struct {
	BaseService
}

func NewSnapshotsService(connection *Connection, path string) *SnapshotsService {
	var result SnapshotsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a virtual machine snapshot.
// For example, to create a new snapshot for virtual machine `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots
// ----
// With a request body like this:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
// </snapshot>
// ----
// For including only a sub-set of disks in the snapshots, add `disk_attachments` element to the
// request body. Note that disks which are not specified in `disk_attachments` element will not be a
// part of the snapshot. If an empty `disk_attachments` element is passed, the snapshot will include
// only the virtual machine configuration. If no `disk_attachments` element is passed, then all
// the disks will be included in the snapshot.
// For each disk, `image_id` element can be specified for setting the new active image id.
// This is used in order to restore a chain of images from backup. I.e. when restoring
// a disk with snapshots, the relevant `image_id` should be specified for each snapshot
// (so the identifiers of the disk snapshots are identical to the backup).
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="123">
//         <image_id>456</image_id>
//       </disk>
//     </disk_attachment>
//   </disk_attachments>
// </snapshot>
// ----
// [IMPORTANT]
// ====
// When a snapshot is created the default value for the <<types/snapshot/attributes/persist_memorystate,
// persist_memorystate>> attribute is `true`. That means that the content of the memory of the virtual
// machine will be included in the snapshot, and it also means that the virtual machine will be paused
// for a longer time. That can negatively affect applications that are very sensitive to timing (NTP
// servers, for example). In those cases make sure that you set the attribute to `false`:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
// ====
//
type SnapshotsServiceAddRequest struct {
	SnapshotsService *SnapshotsService
	header           map[string]string
	query            map[string]string
	snapshot         *Snapshot
}

func (p *SnapshotsServiceAddRequest) Header(key, value string) *SnapshotsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotsServiceAddRequest) Query(key, value string) *SnapshotsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotsServiceAddRequest) Snapshot(snapshot *Snapshot) *SnapshotsServiceAddRequest {
	p.snapshot = snapshot
	return p
}

func (p *SnapshotsServiceAddRequest) Send() (*SnapshotsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotsService.connection.URL(), p.SnapshotsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSnapshotWriteOne(writer, p.snapshot, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SnapshotsServiceAddResponse{snapshot: result}, nil
}

func (p *SnapshotsServiceAddRequest) MustSend() *SnapshotsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a virtual machine snapshot.
// For example, to create a new snapshot for virtual machine `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots
// ----
// With a request body like this:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
// </snapshot>
// ----
// For including only a sub-set of disks in the snapshots, add `disk_attachments` element to the
// request body. Note that disks which are not specified in `disk_attachments` element will not be a
// part of the snapshot. If an empty `disk_attachments` element is passed, the snapshot will include
// only the virtual machine configuration. If no `disk_attachments` element is passed, then all
// the disks will be included in the snapshot.
// For each disk, `image_id` element can be specified for setting the new active image id.
// This is used in order to restore a chain of images from backup. I.e. when restoring
// a disk with snapshots, the relevant `image_id` should be specified for each snapshot
// (so the identifiers of the disk snapshots are identical to the backup).
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="123">
//         <image_id>456</image_id>
//       </disk>
//     </disk_attachment>
//   </disk_attachments>
// </snapshot>
// ----
// [IMPORTANT]
// ====
// When a snapshot is created the default value for the <<types/snapshot/attributes/persist_memorystate,
// persist_memorystate>> attribute is `true`. That means that the content of the memory of the virtual
// machine will be included in the snapshot, and it also means that the virtual machine will be paused
// for a longer time. That can negatively affect applications that are very sensitive to timing (NTP
// servers, for example). In those cases make sure that you set the attribute to `false`:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
// ====
//
type SnapshotsServiceAddResponse struct {
	snapshot *Snapshot
}

func (p *SnapshotsServiceAddResponse) Snapshot() (*Snapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

func (p *SnapshotsServiceAddResponse) MustSnapshot() *Snapshot {
	if p.snapshot == nil {
		panic("snapshot in response does not exist")
	}
	return p.snapshot
}

//
// Creates a virtual machine snapshot.
// For example, to create a new snapshot for virtual machine `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots
// ----
// With a request body like this:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
// </snapshot>
// ----
// For including only a sub-set of disks in the snapshots, add `disk_attachments` element to the
// request body. Note that disks which are not specified in `disk_attachments` element will not be a
// part of the snapshot. If an empty `disk_attachments` element is passed, the snapshot will include
// only the virtual machine configuration. If no `disk_attachments` element is passed, then all
// the disks will be included in the snapshot.
// For each disk, `image_id` element can be specified for setting the new active image id.
// This is used in order to restore a chain of images from backup. I.e. when restoring
// a disk with snapshots, the relevant `image_id` should be specified for each snapshot
// (so the identifiers of the disk snapshots are identical to the backup).
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="123">
//         <image_id>456</image_id>
//       </disk>
//     </disk_attachment>
//   </disk_attachments>
// </snapshot>
// ----
// [IMPORTANT]
// ====
// When a snapshot is created the default value for the <<types/snapshot/attributes/persist_memorystate,
// persist_memorystate>> attribute is `true`. That means that the content of the memory of the virtual
// machine will be included in the snapshot, and it also means that the virtual machine will be paused
// for a longer time. That can negatively affect applications that are very sensitive to timing (NTP
// servers, for example). In those cases make sure that you set the attribute to `false`:
// [source,xml]
// ----
// <snapshot>
//   <description>My snapshot</description>
//   <persist_memorystate>false</persist_memorystate>
// </snapshot>
// ----
// ====
//
func (p *SnapshotsService) Add() *SnapshotsServiceAddRequest {
	return &SnapshotsServiceAddRequest{SnapshotsService: p}
}

//
// Returns the list of snapshots of the storage domain or virtual machine.
// The order of the returned list of snapshots isn't guaranteed.
//
type SnapshotsServiceListRequest struct {
	SnapshotsService *SnapshotsService
	header           map[string]string
	query            map[string]string
	allContent       *bool
	follow           *string
	max              *int64
}

func (p *SnapshotsServiceListRequest) Header(key, value string) *SnapshotsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotsServiceListRequest) Query(key, value string) *SnapshotsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotsServiceListRequest) AllContent(allContent bool) *SnapshotsServiceListRequest {
	p.allContent = &allContent
	return p
}

func (p *SnapshotsServiceListRequest) Follow(follow string) *SnapshotsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *SnapshotsServiceListRequest) Max(max int64) *SnapshotsServiceListRequest {
	p.max = &max
	return p
}

func (p *SnapshotsServiceListRequest) Send() (*SnapshotsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotsService.connection.URL(), p.SnapshotsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotsServiceListResponse{snapshots: result}, nil
}

func (p *SnapshotsServiceListRequest) MustSend() *SnapshotsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of snapshots of the storage domain or virtual machine.
// The order of the returned list of snapshots isn't guaranteed.
//
type SnapshotsServiceListResponse struct {
	snapshots *SnapshotSlice
}

func (p *SnapshotsServiceListResponse) Snapshots() (*SnapshotSlice, bool) {
	if p.snapshots != nil {
		return p.snapshots, true
	}
	return nil, false
}

func (p *SnapshotsServiceListResponse) MustSnapshots() *SnapshotSlice {
	if p.snapshots == nil {
		panic("snapshots in response does not exist")
	}
	return p.snapshots
}

//
// Returns the list of snapshots of the storage domain or virtual machine.
// The order of the returned list of snapshots isn't guaranteed.
//
func (p *SnapshotsService) List() *SnapshotsServiceListRequest {
	return &SnapshotsServiceListRequest{SnapshotsService: p}
}

//
//
func (op *SnapshotsService) SnapshotService(id string) *SnapshotService {
	return NewSnapshotService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.SnapshotService(path), nil
	}
	return op.SnapshotService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotsService) String() string {
	return fmt.Sprintf("SnapshotsService:%s", op.path)
}

//
// This service manages hostgroups.
//
type ExternalHostGroupsService struct {
	BaseService
}

func NewExternalHostGroupsService(connection *Connection, path string) *ExternalHostGroupsService {
	var result ExternalHostGroupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get host groups list from external host provider.
// Host group is a term of host providers - the host group includes provision details. This API returns all possible
// hostgroups exposed by the external provider.
// For example, to get the details of all host groups of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_groups>
//   <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//     <name>rhel7</name>
//     <architecture_name>x86_64</architecture_name>
//     <domain_name>example.com</domain_name>
//     <operating_system_name>RedHat 7.3</operating_system_name>
//     <subnet_name>sat0</subnet_name>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//   </external_host_group>
//   ...
// </external_host_groups>
// ----
// The order of the returned list of host groups isn't guaranteed.
//
type ExternalHostGroupsServiceListRequest struct {
	ExternalHostGroupsService *ExternalHostGroupsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *ExternalHostGroupsServiceListRequest) Header(key, value string) *ExternalHostGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostGroupsServiceListRequest) Query(key, value string) *ExternalHostGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostGroupsServiceListRequest) Follow(follow string) *ExternalHostGroupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ExternalHostGroupsServiceListRequest) Max(max int64) *ExternalHostGroupsServiceListRequest {
	p.max = &max
	return p
}

func (p *ExternalHostGroupsServiceListRequest) Send() (*ExternalHostGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostGroupsService.connection.URL(), p.ExternalHostGroupsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostGroupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostGroupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostGroupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ExternalHostGroupsServiceListResponse{groups: result}, nil
}

func (p *ExternalHostGroupsServiceListRequest) MustSend() *ExternalHostGroupsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get host groups list from external host provider.
// Host group is a term of host providers - the host group includes provision details. This API returns all possible
// hostgroups exposed by the external provider.
// For example, to get the details of all host groups of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_groups>
//   <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//     <name>rhel7</name>
//     <architecture_name>x86_64</architecture_name>
//     <domain_name>example.com</domain_name>
//     <operating_system_name>RedHat 7.3</operating_system_name>
//     <subnet_name>sat0</subnet_name>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//   </external_host_group>
//   ...
// </external_host_groups>
// ----
// The order of the returned list of host groups isn't guaranteed.
//
type ExternalHostGroupsServiceListResponse struct {
	groups *ExternalHostGroupSlice
}

func (p *ExternalHostGroupsServiceListResponse) Groups() (*ExternalHostGroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *ExternalHostGroupsServiceListResponse) MustGroups() *ExternalHostGroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// Get host groups list from external host provider.
// Host group is a term of host providers - the host group includes provision details. This API returns all possible
// hostgroups exposed by the external provider.
// For example, to get the details of all host groups of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_groups>
//   <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//     <name>rhel7</name>
//     <architecture_name>x86_64</architecture_name>
//     <domain_name>example.com</domain_name>
//     <operating_system_name>RedHat 7.3</operating_system_name>
//     <subnet_name>sat0</subnet_name>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//   </external_host_group>
//   ...
// </external_host_groups>
// ----
// The order of the returned list of host groups isn't guaranteed.
//
func (p *ExternalHostGroupsService) List() *ExternalHostGroupsServiceListRequest {
	return &ExternalHostGroupsServiceListRequest{ExternalHostGroupsService: p}
}

//
// This service manages hostgroup instance.
//
func (op *ExternalHostGroupsService) GroupService(id string) *ExternalHostGroupService {
	return NewExternalHostGroupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostGroupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.GroupService(path), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostGroupsService) String() string {
	return fmt.Sprintf("ExternalHostGroupsService:%s", op.path)
}

//
// Manages a single external compute resource.
// Compute resource is a term of host external provider. The external provider also needs to know to where the
// provisioned host needs to register. The login details of the engine are saved as a compute resource  in the external
// provider side.
//
type ExternalComputeResourceService struct {
	BaseService
}

func NewExternalComputeResourceService(connection *Connection, path string) *ExternalComputeResourceService {
	var result ExternalComputeResourceService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves external compute resource details.
// For example, to get the details of compute resource `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//   <name>hostname</name>
//   <provider>oVirt</provider>
//   <url>https://hostname/api</url>
//   <user>admin@internal</user>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_compute_resource>
// ----
//
type ExternalComputeResourceServiceGetRequest struct {
	ExternalComputeResourceService *ExternalComputeResourceService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *ExternalComputeResourceServiceGetRequest) Header(key, value string) *ExternalComputeResourceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalComputeResourceServiceGetRequest) Query(key, value string) *ExternalComputeResourceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalComputeResourceServiceGetRequest) Follow(follow string) *ExternalComputeResourceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ExternalComputeResourceServiceGetRequest) Send() (*ExternalComputeResourceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalComputeResourceService.connection.URL(), p.ExternalComputeResourceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalComputeResourceService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalComputeResourceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalComputeResourceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalComputeResourceService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalComputeResourceService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalComputeResourceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalComputeResourceServiceGetResponse{resource: result}, nil
}

func (p *ExternalComputeResourceServiceGetRequest) MustSend() *ExternalComputeResourceServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves external compute resource details.
// For example, to get the details of compute resource `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//   <name>hostname</name>
//   <provider>oVirt</provider>
//   <url>https://hostname/api</url>
//   <user>admin@internal</user>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_compute_resource>
// ----
//
type ExternalComputeResourceServiceGetResponse struct {
	resource *ExternalComputeResource
}

func (p *ExternalComputeResourceServiceGetResponse) Resource() (*ExternalComputeResource, bool) {
	if p.resource != nil {
		return p.resource, true
	}
	return nil, false
}

func (p *ExternalComputeResourceServiceGetResponse) MustResource() *ExternalComputeResource {
	if p.resource == nil {
		panic("resource in response does not exist")
	}
	return p.resource
}

//
// Retrieves external compute resource details.
// For example, to get the details of compute resource `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//   <name>hostname</name>
//   <provider>oVirt</provider>
//   <url>https://hostname/api</url>
//   <user>admin@internal</user>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_compute_resource>
// ----
//
func (p *ExternalComputeResourceService) Get() *ExternalComputeResourceServiceGetRequest {
	return &ExternalComputeResourceServiceGetRequest{ExternalComputeResourceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalComputeResourceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalComputeResourceService) String() string {
	return fmt.Sprintf("ExternalComputeResourceService:%s", op.path)
}

//
//
type ExternalHostsService struct {
	BaseService
}

func NewExternalHostsService(connection *Connection, path string) *ExternalHostsService {
	var result ExternalHostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Return the list of external hosts.
// The order of the returned list of hosts isn't guaranteed.
//
type ExternalHostsServiceListRequest struct {
	ExternalHostsService *ExternalHostsService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *ExternalHostsServiceListRequest) Header(key, value string) *ExternalHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostsServiceListRequest) Query(key, value string) *ExternalHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostsServiceListRequest) Follow(follow string) *ExternalHostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ExternalHostsServiceListRequest) Max(max int64) *ExternalHostsServiceListRequest {
	p.max = &max
	return p
}

func (p *ExternalHostsServiceListRequest) Send() (*ExternalHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostsService.connection.URL(), p.ExternalHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ExternalHostsServiceListResponse{hosts: result}, nil
}

func (p *ExternalHostsServiceListRequest) MustSend() *ExternalHostsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Return the list of external hosts.
// The order of the returned list of hosts isn't guaranteed.
//
type ExternalHostsServiceListResponse struct {
	hosts *ExternalHostSlice
}

func (p *ExternalHostsServiceListResponse) Hosts() (*ExternalHostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *ExternalHostsServiceListResponse) MustHosts() *ExternalHostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// Return the list of external hosts.
// The order of the returned list of hosts isn't guaranteed.
//
func (p *ExternalHostsService) List() *ExternalHostsServiceListRequest {
	return &ExternalHostsServiceListRequest{ExternalHostsService: p}
}

//
//
func (op *ExternalHostsService) HostService(id string) *ExternalHostService {
	return NewExternalHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostsService) String() string {
	return fmt.Sprintf("ExternalHostsService:%s", op.path)
}

//
//
type ExternalHostService struct {
	BaseService
}

func NewExternalHostService(connection *Connection, path string) *ExternalHostService {
	var result ExternalHostService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type ExternalHostServiceGetRequest struct {
	ExternalHostService *ExternalHostService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *ExternalHostServiceGetRequest) Header(key, value string) *ExternalHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostServiceGetRequest) Query(key, value string) *ExternalHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostServiceGetRequest) Follow(follow string) *ExternalHostServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ExternalHostServiceGetRequest) Send() (*ExternalHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostService.connection.URL(), p.ExternalHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalHostServiceGetResponse{host: result}, nil
}

func (p *ExternalHostServiceGetRequest) MustSend() *ExternalHostServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type ExternalHostServiceGetResponse struct {
	host *ExternalHost
}

func (p *ExternalHostServiceGetResponse) Host() (*ExternalHost, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *ExternalHostServiceGetResponse) MustHost() *ExternalHost {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
//
func (p *ExternalHostService) Get() *ExternalHostServiceGetRequest {
	return &ExternalHostServiceGetRequest{ExternalHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostService) String() string {
	return fmt.Sprintf("ExternalHostService:%s", op.path)
}

//
// Manages a collection of external compute resources.
// Compute resource is a term of host external provider. The external provider also needs to know to where the
// provisioned host needs to register. The login details of the engine is saved as a compute resource in the external
// provider side.
//
type ExternalComputeResourcesService struct {
	BaseService
}

func NewExternalComputeResourcesService(connection *Connection, path string) *ExternalComputeResourcesService {
	var result ExternalComputeResourcesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a list of external compute resources.
// For example, to retrieve the compute resources of external host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resources>
//   <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//     <name>hostname</name>
//     <provider>oVirt</provider>
//     <url>https://address/api</url>
//     <user>admin@internal</user>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//    </external_compute_resource>
//    ...
// </external_compute_resources>
// ----
// The order of the returned list of compute resources isn't guaranteed.
//
type ExternalComputeResourcesServiceListRequest struct {
	ExternalComputeResourcesService *ExternalComputeResourcesService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
	max                             *int64
}

func (p *ExternalComputeResourcesServiceListRequest) Header(key, value string) *ExternalComputeResourcesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalComputeResourcesServiceListRequest) Query(key, value string) *ExternalComputeResourcesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalComputeResourcesServiceListRequest) Follow(follow string) *ExternalComputeResourcesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ExternalComputeResourcesServiceListRequest) Max(max int64) *ExternalComputeResourcesServiceListRequest {
	p.max = &max
	return p
}

func (p *ExternalComputeResourcesServiceListRequest) Send() (*ExternalComputeResourcesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalComputeResourcesService.connection.URL(), p.ExternalComputeResourcesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalComputeResourcesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalComputeResourcesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalComputeResourcesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalComputeResourcesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalComputeResourcesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalComputeResourceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ExternalComputeResourcesServiceListResponse{resources: result}, nil
}

func (p *ExternalComputeResourcesServiceListRequest) MustSend() *ExternalComputeResourcesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves a list of external compute resources.
// For example, to retrieve the compute resources of external host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resources>
//   <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//     <name>hostname</name>
//     <provider>oVirt</provider>
//     <url>https://address/api</url>
//     <user>admin@internal</user>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//    </external_compute_resource>
//    ...
// </external_compute_resources>
// ----
// The order of the returned list of compute resources isn't guaranteed.
//
type ExternalComputeResourcesServiceListResponse struct {
	resources *ExternalComputeResourceSlice
}

func (p *ExternalComputeResourcesServiceListResponse) Resources() (*ExternalComputeResourceSlice, bool) {
	if p.resources != nil {
		return p.resources, true
	}
	return nil, false
}

func (p *ExternalComputeResourcesServiceListResponse) MustResources() *ExternalComputeResourceSlice {
	if p.resources == nil {
		panic("resources in response does not exist")
	}
	return p.resources
}

//
// Retrieves a list of external compute resources.
// For example, to retrieve the compute resources of external host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/computeresources
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_compute_resources>
//   <external_compute_resource href="/ovirt-engine/api/externalhostproviders/123/computeresources/234" id="234">
//     <name>hostname</name>
//     <provider>oVirt</provider>
//     <url>https://address/api</url>
//     <user>admin@internal</user>
//     <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//    </external_compute_resource>
//    ...
// </external_compute_resources>
// ----
// The order of the returned list of compute resources isn't guaranteed.
//
func (p *ExternalComputeResourcesService) List() *ExternalComputeResourcesServiceListRequest {
	return &ExternalComputeResourcesServiceListRequest{ExternalComputeResourcesService: p}
}

//
// This service manages compute resource instance
//
func (op *ExternalComputeResourcesService) ResourceService(id string) *ExternalComputeResourceService {
	return NewExternalComputeResourceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalComputeResourcesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ResourceService(path), nil
	}
	return op.ResourceService(path[:index]).Service(path[index+1:])
}

func (op *ExternalComputeResourcesService) String() string {
	return fmt.Sprintf("ExternalComputeResourcesService:%s", op.path)
}

//
// A service to manage Katello errata.
// The information is retrieved from Katello.
//
type KatelloErrataService struct {
	BaseService
}

func NewKatelloErrataService(connection *Connection, path string) *KatelloErrataService {
	var result KatelloErrataService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
type KatelloErrataServiceListRequest struct {
	KatelloErrataService *KatelloErrataService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *KatelloErrataServiceListRequest) Header(key, value string) *KatelloErrataServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *KatelloErrataServiceListRequest) Query(key, value string) *KatelloErrataServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *KatelloErrataServiceListRequest) Follow(follow string) *KatelloErrataServiceListRequest {
	p.follow = &follow
	return p
}

func (p *KatelloErrataServiceListRequest) Max(max int64) *KatelloErrataServiceListRequest {
	p.max = &max
	return p
}

func (p *KatelloErrataServiceListRequest) Send() (*KatelloErrataServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.KatelloErrataService.connection.URL(), p.KatelloErrataService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.KatelloErrataService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.KatelloErrataService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.KatelloErrataService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.KatelloErrataService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.KatelloErrataService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &KatelloErrataServiceListResponse{errata: result}, nil
}

func (p *KatelloErrataServiceListRequest) MustSend() *KatelloErrataServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
type KatelloErrataServiceListResponse struct {
	errata *KatelloErratumSlice
}

func (p *KatelloErrataServiceListResponse) Errata() (*KatelloErratumSlice, bool) {
	if p.errata != nil {
		return p.errata, true
	}
	return nil, false
}

func (p *KatelloErrataServiceListResponse) MustErrata() *KatelloErratumSlice {
	if p.errata == nil {
		panic("errata in response does not exist")
	}
	return p.errata
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
func (p *KatelloErrataService) List() *KatelloErrataServiceListRequest {
	return &KatelloErrataServiceListRequest{KatelloErrataService: p}
}

//
// Reference to the Katello erratum service.
// Use this service to view the erratum by its id.
//
func (op *KatelloErrataService) KatelloErratumService(id string) *KatelloErratumService {
	return NewKatelloErratumService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *KatelloErrataService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.KatelloErratumService(path), nil
	}
	return op.KatelloErratumService(path[:index]).Service(path[index+1:])
}

func (op *KatelloErrataService) String() string {
	return fmt.Sprintf("KatelloErrataService:%s", op.path)
}

//
// This service manages a single discovered host.
//
type ExternalDiscoveredHostService struct {
	BaseService
}

func NewExternalDiscoveredHostService(connection *Connection, path string) *ExternalDiscoveredHostService {
	var result ExternalDiscoveredHostService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get discovered host info.
// Retrieves information about an host that is managed in external provider management system, such as Foreman. The
// information includes hostname, address, subnet, base image and more.
// For example, to get the details of host `234` from provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhosts/234
// ....
// The result will be like this:
// [source,xml]
// ----
// <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/234" id="234">
//  <name>mac001a4ad04040</name>
//  <ip>10.34.67.43</ip>
//  <last_report>2017-04-24 11:05:41 UTC</last_report>
//  <mac>00:1a:4a:d0:40:40</mac>
//  <subnet_name>sat0</subnet_name>
//  <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_discovered_host>
// ----
//
type ExternalDiscoveredHostServiceGetRequest struct {
	ExternalDiscoveredHostService *ExternalDiscoveredHostService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *ExternalDiscoveredHostServiceGetRequest) Header(key, value string) *ExternalDiscoveredHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalDiscoveredHostServiceGetRequest) Query(key, value string) *ExternalDiscoveredHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalDiscoveredHostServiceGetRequest) Follow(follow string) *ExternalDiscoveredHostServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ExternalDiscoveredHostServiceGetRequest) Send() (*ExternalDiscoveredHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalDiscoveredHostService.connection.URL(), p.ExternalDiscoveredHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalDiscoveredHostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalDiscoveredHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalDiscoveredHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalDiscoveredHostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalDiscoveredHostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalDiscoveredHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalDiscoveredHostServiceGetResponse{host: result}, nil
}

func (p *ExternalDiscoveredHostServiceGetRequest) MustSend() *ExternalDiscoveredHostServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get discovered host info.
// Retrieves information about an host that is managed in external provider management system, such as Foreman. The
// information includes hostname, address, subnet, base image and more.
// For example, to get the details of host `234` from provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhosts/234
// ....
// The result will be like this:
// [source,xml]
// ----
// <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/234" id="234">
//  <name>mac001a4ad04040</name>
//  <ip>10.34.67.43</ip>
//  <last_report>2017-04-24 11:05:41 UTC</last_report>
//  <mac>00:1a:4a:d0:40:40</mac>
//  <subnet_name>sat0</subnet_name>
//  <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_discovered_host>
// ----
//
type ExternalDiscoveredHostServiceGetResponse struct {
	host *ExternalDiscoveredHost
}

func (p *ExternalDiscoveredHostServiceGetResponse) Host() (*ExternalDiscoveredHost, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *ExternalDiscoveredHostServiceGetResponse) MustHost() *ExternalDiscoveredHost {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Get discovered host info.
// Retrieves information about an host that is managed in external provider management system, such as Foreman. The
// information includes hostname, address, subnet, base image and more.
// For example, to get the details of host `234` from provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhosts/234
// ....
// The result will be like this:
// [source,xml]
// ----
// <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/234" id="234">
//  <name>mac001a4ad04040</name>
//  <ip>10.34.67.43</ip>
//  <last_report>2017-04-24 11:05:41 UTC</last_report>
//  <mac>00:1a:4a:d0:40:40</mac>
//  <subnet_name>sat0</subnet_name>
//  <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_discovered_host>
// ----
//
func (p *ExternalDiscoveredHostService) Get() *ExternalDiscoveredHostServiceGetRequest {
	return &ExternalDiscoveredHostServiceGetRequest{ExternalDiscoveredHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalDiscoveredHostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalDiscoveredHostService) String() string {
	return fmt.Sprintf("ExternalDiscoveredHostService:%s", op.path)
}

//
// Represents an external host provider, such as Foreman or Satellite.
// See https://www.theforeman.org/ for more details on Foreman.
// See https://access.redhat.com/products/red-hat-satellite for more details on Red Hat Satellite.
//
type ExternalHostProviderService struct {
	BaseService
}

func NewExternalHostProviderService(connection *Connection, path string) *ExternalHostProviderService {
	var result ExternalHostProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get external host provider information
// Host provider, Foreman or Satellite, can be set as an external provider in ovirt. To see details about specific
// host providers attached to ovirt use this API.
// For example, to get the details of host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123">
//   <name>mysatellite</name>
//   <requires_authentication>true</requires_authentication>
//   <url>https://mysatellite.example.com</url>
//   <username>admin</username>
// </external_host_provider>
// ----
//
type ExternalHostProviderServiceGetRequest struct {
	ExternalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
}

func (p *ExternalHostProviderServiceGetRequest) Header(key, value string) *ExternalHostProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceGetRequest) Query(key, value string) *ExternalHostProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceGetRequest) Follow(follow string) *ExternalHostProviderServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ExternalHostProviderServiceGetRequest) Send() (*ExternalHostProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostProviderService.connection.URL(), p.ExternalHostProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalHostProviderServiceGetResponse{provider: result}, nil
}

func (p *ExternalHostProviderServiceGetRequest) MustSend() *ExternalHostProviderServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get external host provider information
// Host provider, Foreman or Satellite, can be set as an external provider in ovirt. To see details about specific
// host providers attached to ovirt use this API.
// For example, to get the details of host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123">
//   <name>mysatellite</name>
//   <requires_authentication>true</requires_authentication>
//   <url>https://mysatellite.example.com</url>
//   <username>admin</username>
// </external_host_provider>
// ----
//
type ExternalHostProviderServiceGetResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProviderServiceGetResponse) Provider() (*ExternalHostProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *ExternalHostProviderServiceGetResponse) MustProvider() *ExternalHostProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Get external host provider information
// Host provider, Foreman or Satellite, can be set as an external provider in ovirt. To see details about specific
// host providers attached to ovirt use this API.
// For example, to get the details of host provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123
// ....
// The response will be like this:
// [source,xml]
// ----
// <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123">
//   <name>mysatellite</name>
//   <requires_authentication>true</requires_authentication>
//   <url>https://mysatellite.example.com</url>
//   <username>admin</username>
// </external_host_provider>
// ----
//
func (p *ExternalHostProviderService) Get() *ExternalHostProviderServiceGetRequest {
	return &ExternalHostProviderServiceGetRequest{ExternalHostProviderService: p}
}

//
// Import the SSL certificates of the external host provider.
//
type ExternalHostProviderServiceImportCertificatesRequest struct {
	ExternalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	certificates                *CertificateSlice
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Header(key, value string) *ExternalHostProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Query(key, value string) *ExternalHostProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *ExternalHostProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *ExternalHostProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) Send() (*ExternalHostProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.ExternalHostProviderService.connection.URL(), p.ExternalHostProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ExternalHostProviderServiceImportCertificatesResponse), nil
}

func (p *ExternalHostProviderServiceImportCertificatesRequest) MustSend() *ExternalHostProviderServiceImportCertificatesResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Import the SSL certificates of the external host provider.
//
type ExternalHostProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *ExternalHostProviderService) ImportCertificates() *ExternalHostProviderServiceImportCertificatesRequest {
	return &ExternalHostProviderServiceImportCertificatesRequest{ExternalHostProviderService: p}
}

//
//
type ExternalHostProviderServiceRemoveRequest struct {
	ExternalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *ExternalHostProviderServiceRemoveRequest) Header(key, value string) *ExternalHostProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceRemoveRequest) Query(key, value string) *ExternalHostProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceRemoveRequest) Async(async bool) *ExternalHostProviderServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *ExternalHostProviderServiceRemoveRequest) Send() (*ExternalHostProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostProviderService.connection.URL(), p.ExternalHostProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(ExternalHostProviderServiceRemoveResponse), nil
}

func (p *ExternalHostProviderServiceRemoveRequest) MustSend() *ExternalHostProviderServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type ExternalHostProviderServiceRemoveResponse struct {
}

//
//
func (p *ExternalHostProviderService) Remove() *ExternalHostProviderServiceRemoveRequest {
	return &ExternalHostProviderServiceRemoveRequest{ExternalHostProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type ExternalHostProviderServiceTestConnectivityRequest struct {
	ExternalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Header(key, value string) *ExternalHostProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Query(key, value string) *ExternalHostProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Async(async bool) *ExternalHostProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) Send() (*ExternalHostProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.ExternalHostProviderService.connection.URL(), p.ExternalHostProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ExternalHostProviderServiceTestConnectivityResponse), nil
}

func (p *ExternalHostProviderServiceTestConnectivityRequest) MustSend() *ExternalHostProviderServiceTestConnectivityResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type ExternalHostProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *ExternalHostProviderService) TestConnectivity() *ExternalHostProviderServiceTestConnectivityRequest {
	return &ExternalHostProviderServiceTestConnectivityRequest{ExternalHostProviderService: p}
}

//
// Update the specified external host provider in the system.
//
type ExternalHostProviderServiceUpdateRequest struct {
	ExternalHostProviderService *ExternalHostProviderService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	provider                    *ExternalHostProvider
}

func (p *ExternalHostProviderServiceUpdateRequest) Header(key, value string) *ExternalHostProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProviderServiceUpdateRequest) Query(key, value string) *ExternalHostProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProviderServiceUpdateRequest) Async(async bool) *ExternalHostProviderServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *ExternalHostProviderServiceUpdateRequest) Provider(provider *ExternalHostProvider) *ExternalHostProviderServiceUpdateRequest {
	p.provider = provider
	return p
}

func (p *ExternalHostProviderServiceUpdateRequest) Send() (*ExternalHostProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostProviderService.connection.URL(), p.ExternalHostProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalHostProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalHostProviderServiceUpdateResponse{provider: result}, nil
}

func (p *ExternalHostProviderServiceUpdateRequest) MustSend() *ExternalHostProviderServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified external host provider in the system.
//
type ExternalHostProviderServiceUpdateResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProviderServiceUpdateResponse) Provider() (*ExternalHostProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *ExternalHostProviderServiceUpdateResponse) MustProvider() *ExternalHostProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Update the specified external host provider in the system.
//
func (p *ExternalHostProviderService) Update() *ExternalHostProviderServiceUpdateRequest {
	return &ExternalHostProviderServiceUpdateRequest{ExternalHostProviderService: p}
}

//
// A service to view certificates for this external provider.
//
func (op *ExternalHostProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
//
func (op *ExternalHostProviderService) ComputeResourcesService() *ExternalComputeResourcesService {
	return NewExternalComputeResourcesService(op.connection, fmt.Sprintf("%s/computeresources", op.path))
}

//
//
func (op *ExternalHostProviderService) DiscoveredHostsService() *ExternalDiscoveredHostsService {
	return NewExternalDiscoveredHostsService(op.connection, fmt.Sprintf("%s/discoveredhosts", op.path))
}

//
//
func (op *ExternalHostProviderService) HostGroupsService() *ExternalHostGroupsService {
	return NewExternalHostGroupsService(op.connection, fmt.Sprintf("%s/hostgroups", op.path))
}

//
//
func (op *ExternalHostProviderService) HostsService() *ExternalHostsService {
	return NewExternalHostsService(op.connection, fmt.Sprintf("%s/hosts", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "computeresources" {
		return op.ComputeResourcesService(), nil
	}
	if strings.HasPrefix(path, "computeresources/") {
		return op.ComputeResourcesService().Service(path[17:])
	}
	if path == "discoveredhosts" {
		return op.DiscoveredHostsService(), nil
	}
	if strings.HasPrefix(path, "discoveredhosts/") {
		return op.DiscoveredHostsService().Service(path[16:])
	}
	if path == "hostgroups" {
		return op.HostGroupsService(), nil
	}
	if strings.HasPrefix(path, "hostgroups/") {
		return op.HostGroupsService().Service(path[11:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostProviderService) String() string {
	return fmt.Sprintf("ExternalHostProviderService:%s", op.path)
}

//
// A service to manage a Katello erratum.
//
type KatelloErratumService struct {
	BaseService
}

func NewKatelloErratumService(connection *Connection, path string) *KatelloErratumService {
	var result KatelloErratumService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a Katello erratum.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//   <name>RHBA-2013:XYZ</name>
//   <description>The description of the erratum</description>
//   <title>some bug fix update</title>
//   <type>bugfix</type>
//   <issued>2013-11-20T02:00:00.000+02:00</issued>
//   <solution>Few guidelines regarding the solution</solution>
//   <summary>Updated packages that fix one bug are now available for XYZ</summary>
//   <packages>
//     <package>
//       <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//     </package>
//     ...
//   </packages>
// </katello_erratum>
// ----
//
type KatelloErratumServiceGetRequest struct {
	KatelloErratumService *KatelloErratumService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *KatelloErratumServiceGetRequest) Header(key, value string) *KatelloErratumServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *KatelloErratumServiceGetRequest) Query(key, value string) *KatelloErratumServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *KatelloErratumServiceGetRequest) Follow(follow string) *KatelloErratumServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *KatelloErratumServiceGetRequest) Send() (*KatelloErratumServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.KatelloErratumService.connection.URL(), p.KatelloErratumService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.KatelloErratumService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.KatelloErratumService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.KatelloErratumService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.KatelloErratumService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.KatelloErratumService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &KatelloErratumServiceGetResponse{erratum: result}, nil
}

func (p *KatelloErratumServiceGetRequest) MustSend() *KatelloErratumServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves a Katello erratum.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//   <name>RHBA-2013:XYZ</name>
//   <description>The description of the erratum</description>
//   <title>some bug fix update</title>
//   <type>bugfix</type>
//   <issued>2013-11-20T02:00:00.000+02:00</issued>
//   <solution>Few guidelines regarding the solution</solution>
//   <summary>Updated packages that fix one bug are now available for XYZ</summary>
//   <packages>
//     <package>
//       <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//     </package>
//     ...
//   </packages>
// </katello_erratum>
// ----
//
type KatelloErratumServiceGetResponse struct {
	erratum *KatelloErratum
}

func (p *KatelloErratumServiceGetResponse) Erratum() (*KatelloErratum, bool) {
	if p.erratum != nil {
		return p.erratum, true
	}
	return nil, false
}

func (p *KatelloErratumServiceGetResponse) MustErratum() *KatelloErratum {
	if p.erratum == nil {
		panic("erratum in response does not exist")
	}
	return p.erratum
}

//
// Retrieves a Katello erratum.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//   <name>RHBA-2013:XYZ</name>
//   <description>The description of the erratum</description>
//   <title>some bug fix update</title>
//   <type>bugfix</type>
//   <issued>2013-11-20T02:00:00.000+02:00</issued>
//   <solution>Few guidelines regarding the solution</solution>
//   <summary>Updated packages that fix one bug are now available for XYZ</summary>
//   <packages>
//     <package>
//       <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//     </package>
//     ...
//   </packages>
// </katello_erratum>
// ----
//
func (p *KatelloErratumService) Get() *KatelloErratumServiceGetRequest {
	return &KatelloErratumServiceGetRequest{KatelloErratumService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *KatelloErratumService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *KatelloErratumService) String() string {
	return fmt.Sprintf("KatelloErratumService:%s", op.path)
}

//
//
type ExternalHostProvidersService struct {
	BaseService
}

func NewExternalHostProvidersService(connection *Connection, path string) *ExternalHostProvidersService {
	var result ExternalHostProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new external host provider to the system.
//
type ExternalHostProvidersServiceAddRequest struct {
	ExternalHostProvidersService *ExternalHostProvidersService
	header                       map[string]string
	query                        map[string]string
	provider                     *ExternalHostProvider
}

func (p *ExternalHostProvidersServiceAddRequest) Header(key, value string) *ExternalHostProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProvidersServiceAddRequest) Query(key, value string) *ExternalHostProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProvidersServiceAddRequest) Provider(provider *ExternalHostProvider) *ExternalHostProvidersServiceAddRequest {
	p.provider = provider
	return p
}

func (p *ExternalHostProvidersServiceAddRequest) Send() (*ExternalHostProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostProvidersService.connection.URL(), p.ExternalHostProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalHostProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalHostProvidersServiceAddResponse{provider: result}, nil
}

func (p *ExternalHostProvidersServiceAddRequest) MustSend() *ExternalHostProvidersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new external host provider to the system.
//
type ExternalHostProvidersServiceAddResponse struct {
	provider *ExternalHostProvider
}

func (p *ExternalHostProvidersServiceAddResponse) Provider() (*ExternalHostProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *ExternalHostProvidersServiceAddResponse) MustProvider() *ExternalHostProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Add a new external host provider to the system.
//
func (p *ExternalHostProvidersService) Add() *ExternalHostProvidersServiceAddRequest {
	return &ExternalHostProvidersServiceAddRequest{ExternalHostProvidersService: p}
}

//
// Returns the list of external host providers.
// The order of the returned list of host providers isn't guaranteed.
//
type ExternalHostProvidersServiceListRequest struct {
	ExternalHostProvidersService *ExternalHostProvidersService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
	max                          *int64
	search                       *string
}

func (p *ExternalHostProvidersServiceListRequest) Header(key, value string) *ExternalHostProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Query(key, value string) *ExternalHostProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Follow(follow string) *ExternalHostProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Max(max int64) *ExternalHostProvidersServiceListRequest {
	p.max = &max
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Search(search string) *ExternalHostProvidersServiceListRequest {
	p.search = &search
	return p
}

func (p *ExternalHostProvidersServiceListRequest) Send() (*ExternalHostProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostProvidersService.connection.URL(), p.ExternalHostProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ExternalHostProvidersServiceListResponse{providers: result}, nil
}

func (p *ExternalHostProvidersServiceListRequest) MustSend() *ExternalHostProvidersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of external host providers.
// The order of the returned list of host providers isn't guaranteed.
//
type ExternalHostProvidersServiceListResponse struct {
	providers *ExternalHostProviderSlice
}

func (p *ExternalHostProvidersServiceListResponse) Providers() (*ExternalHostProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *ExternalHostProvidersServiceListResponse) MustProviders() *ExternalHostProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Returns the list of external host providers.
// The order of the returned list of host providers isn't guaranteed.
//
func (p *ExternalHostProvidersService) List() *ExternalHostProvidersServiceListRequest {
	return &ExternalHostProvidersServiceListRequest{ExternalHostProvidersService: p}
}

//
//
func (op *ExternalHostProvidersService) ProviderService(id string) *ExternalHostProviderService {
	return NewExternalHostProviderService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProviderService(path), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *ExternalHostProvidersService) String() string {
	return fmt.Sprintf("ExternalHostProvidersService:%s", op.path)
}

//
// This service manages external discovered hosts.
//
type ExternalDiscoveredHostsService struct {
	BaseService
}

func NewExternalDiscoveredHostsService(connection *Connection, path string) *ExternalDiscoveredHostsService {
	var result ExternalDiscoveredHostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get list of discovered hosts' information.
// Discovered hosts are fetched from third-party providers such as Foreman.
// To list all discovered hosts for provider `123` send the following:
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhost
// ----
// [source,xml]
// ----
// <external_discovered_hosts>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/456" id="456">
//   <name>mac001a4ad04031</name>
//   <ip>10.34.67.42</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:31</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/789" id="789">
//   <name>mac001a4ad04040</name>
//   <ip>10.34.67.43</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:40</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  ...
// </external_discovered_hosts>
// ----
// The order of the returned list of hosts isn't guaranteed.
//
type ExternalDiscoveredHostsServiceListRequest struct {
	ExternalDiscoveredHostsService *ExternalDiscoveredHostsService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
	max                            *int64
}

func (p *ExternalDiscoveredHostsServiceListRequest) Header(key, value string) *ExternalDiscoveredHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalDiscoveredHostsServiceListRequest) Query(key, value string) *ExternalDiscoveredHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalDiscoveredHostsServiceListRequest) Follow(follow string) *ExternalDiscoveredHostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ExternalDiscoveredHostsServiceListRequest) Max(max int64) *ExternalDiscoveredHostsServiceListRequest {
	p.max = &max
	return p
}

func (p *ExternalDiscoveredHostsServiceListRequest) Send() (*ExternalDiscoveredHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalDiscoveredHostsService.connection.URL(), p.ExternalDiscoveredHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalDiscoveredHostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalDiscoveredHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalDiscoveredHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalDiscoveredHostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalDiscoveredHostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalDiscoveredHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ExternalDiscoveredHostsServiceListResponse{hosts: result}, nil
}

func (p *ExternalDiscoveredHostsServiceListRequest) MustSend() *ExternalDiscoveredHostsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get list of discovered hosts' information.
// Discovered hosts are fetched from third-party providers such as Foreman.
// To list all discovered hosts for provider `123` send the following:
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhost
// ----
// [source,xml]
// ----
// <external_discovered_hosts>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/456" id="456">
//   <name>mac001a4ad04031</name>
//   <ip>10.34.67.42</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:31</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/789" id="789">
//   <name>mac001a4ad04040</name>
//   <ip>10.34.67.43</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:40</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  ...
// </external_discovered_hosts>
// ----
// The order of the returned list of hosts isn't guaranteed.
//
type ExternalDiscoveredHostsServiceListResponse struct {
	hosts *ExternalDiscoveredHostSlice
}

func (p *ExternalDiscoveredHostsServiceListResponse) Hosts() (*ExternalDiscoveredHostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *ExternalDiscoveredHostsServiceListResponse) MustHosts() *ExternalDiscoveredHostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// Get list of discovered hosts' information.
// Discovered hosts are fetched from third-party providers such as Foreman.
// To list all discovered hosts for provider `123` send the following:
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/discoveredhost
// ----
// [source,xml]
// ----
// <external_discovered_hosts>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/456" id="456">
//   <name>mac001a4ad04031</name>
//   <ip>10.34.67.42</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:31</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  <external_discovered_host href="/ovirt-engine/api/externalhostproviders/123/discoveredhosts/789" id="789">
//   <name>mac001a4ad04040</name>
//   <ip>10.34.67.43</ip>
//   <last_report>2017-04-24 11:05:41 UTC</last_report>
//   <mac>00:1a:4a:d0:40:40</mac>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
//  </external_discovered_host>
//  ...
// </external_discovered_hosts>
// ----
// The order of the returned list of hosts isn't guaranteed.
//
func (p *ExternalDiscoveredHostsService) List() *ExternalDiscoveredHostsServiceListRequest {
	return &ExternalDiscoveredHostsServiceListRequest{ExternalDiscoveredHostsService: p}
}

//
//
func (op *ExternalDiscoveredHostsService) HostService(id string) *ExternalDiscoveredHostService {
	return NewExternalDiscoveredHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalDiscoveredHostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *ExternalDiscoveredHostsService) String() string {
	return fmt.Sprintf("ExternalDiscoveredHostsService:%s", op.path)
}

//
// A service to manage Katello errata assigned to the engine.
// The information is retrieved from Katello.
//
type EngineKatelloErrataService struct {
	BaseService
}

func NewEngineKatelloErrataService(connection *Connection, path string) *EngineKatelloErrataService {
	var result EngineKatelloErrataService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
type EngineKatelloErrataServiceListRequest struct {
	EngineKatelloErrataService *EngineKatelloErrataService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
	max                        *int64
}

func (p *EngineKatelloErrataServiceListRequest) Header(key, value string) *EngineKatelloErrataServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EngineKatelloErrataServiceListRequest) Query(key, value string) *EngineKatelloErrataServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EngineKatelloErrataServiceListRequest) Follow(follow string) *EngineKatelloErrataServiceListRequest {
	p.follow = &follow
	return p
}

func (p *EngineKatelloErrataServiceListRequest) Max(max int64) *EngineKatelloErrataServiceListRequest {
	p.max = &max
	return p
}

func (p *EngineKatelloErrataServiceListRequest) Send() (*EngineKatelloErrataServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EngineKatelloErrataService.connection.URL(), p.EngineKatelloErrataService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EngineKatelloErrataService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EngineKatelloErrataService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EngineKatelloErrataService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EngineKatelloErrataService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EngineKatelloErrataService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLKatelloErratumReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &EngineKatelloErrataServiceListResponse{errata: result}, nil
}

func (p *EngineKatelloErrataServiceListRequest) MustSend() *EngineKatelloErrataServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
type EngineKatelloErrataServiceListResponse struct {
	errata *KatelloErratumSlice
}

func (p *EngineKatelloErrataServiceListResponse) Errata() (*KatelloErratumSlice, bool) {
	if p.errata != nil {
		return p.errata, true
	}
	return nil, false
}

func (p *EngineKatelloErrataServiceListResponse) MustErrata() *KatelloErratumSlice {
	if p.errata == nil {
		panic("errata in response does not exist")
	}
	return p.errata
}

//
// Retrieves the representation of the Katello errata.
// [source]
// ----
// GET /ovirt-engine/api/katelloerrata
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <katello_errata>
//   <katello_erratum href="/ovirt-engine/api/katelloerrata/123" id="123">
//     <name>RHBA-2013:XYZ</name>
//     <description>The description of the erratum</description>
//     <title>some bug fix update</title>
//     <type>bugfix</type>
//     <issued>2013-11-20T02:00:00.000+02:00</issued>
//     <solution>Few guidelines regarding the solution</solution>
//     <summary>Updated packages that fix one bug are now available for XYZ</summary>
//     <packages>
//       <package>
//         <name>libipa_hbac-1.9.2-82.11.el6_4.i686</name>
//       </package>
//       ...
//     </packages>
//   </katello_erratum>
//   ...
// </katello_errata>
// ----
// The order of the returned list of erratum isn't guaranteed.
//
func (p *EngineKatelloErrataService) List() *EngineKatelloErrataServiceListRequest {
	return &EngineKatelloErrataServiceListRequest{EngineKatelloErrataService: p}
}

//
// Reference to the Katello erratum service.
// Use this service to view the erratum by its id.
//
func (op *EngineKatelloErrataService) KatelloErratumService(id string) *KatelloErratumService {
	return NewKatelloErratumService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EngineKatelloErrataService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.KatelloErratumService(path), nil
	}
	return op.KatelloErratumService(path[:index]).Service(path[index+1:])
}

func (op *EngineKatelloErrataService) String() string {
	return fmt.Sprintf("EngineKatelloErrataService:%s", op.path)
}

//
// This service manages a single host group information.
// Host group is a term of host provider - the host group includes provision details that are applied to new discovered
// host. Information such as subnet, operating system, domain, etc.
//
type ExternalHostGroupService struct {
	BaseService
}

func NewExternalHostGroupService(connection *Connection, path string) *ExternalHostGroupService {
	var result ExternalHostGroupService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get host group information.
// For example, to get the details of hostgroup `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//   <name>rhel7</name>
//   <architecture_name>x86_64</architecture_name>
//   <domain_name>s.com</domain_name>
//   <operating_system_name>RedHat 7.3</operating_system_name>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_host_group>
// ----
//
type ExternalHostGroupServiceGetRequest struct {
	ExternalHostGroupService *ExternalHostGroupService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *ExternalHostGroupServiceGetRequest) Header(key, value string) *ExternalHostGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalHostGroupServiceGetRequest) Query(key, value string) *ExternalHostGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalHostGroupServiceGetRequest) Follow(follow string) *ExternalHostGroupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ExternalHostGroupServiceGetRequest) Send() (*ExternalHostGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalHostGroupService.connection.URL(), p.ExternalHostGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalHostGroupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalHostGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalHostGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalHostGroupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalHostGroupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalHostGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalHostGroupServiceGetResponse{group: result}, nil
}

func (p *ExternalHostGroupServiceGetRequest) MustSend() *ExternalHostGroupServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get host group information.
// For example, to get the details of hostgroup `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//   <name>rhel7</name>
//   <architecture_name>x86_64</architecture_name>
//   <domain_name>s.com</domain_name>
//   <operating_system_name>RedHat 7.3</operating_system_name>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_host_group>
// ----
//
type ExternalHostGroupServiceGetResponse struct {
	group *ExternalHostGroup
}

func (p *ExternalHostGroupServiceGetResponse) Group() (*ExternalHostGroup, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *ExternalHostGroupServiceGetResponse) MustGroup() *ExternalHostGroup {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Get host group information.
// For example, to get the details of hostgroup `234` of provider `123`, send a request like this:
// ....
// GET /ovirt-engine/api/externalhostproviders/123/hostgroups/234
// ....
// It will return a response like this:
// [source,xml]
// ----
// <external_host_group href="/ovirt-engine/api/externalhostproviders/123/hostgroups/234" id="234">
//   <name>rhel7</name>
//   <architecture_name>x86_64</architecture_name>
//   <domain_name>s.com</domain_name>
//   <operating_system_name>RedHat 7.3</operating_system_name>
//   <subnet_name>sat0</subnet_name>
//   <external_host_provider href="/ovirt-engine/api/externalhostproviders/123" id="123"/>
// </external_host_group>
// ----
//
func (p *ExternalHostGroupService) Get() *ExternalHostGroupServiceGetRequest {
	return &ExternalHostGroupServiceGetRequest{ExternalHostGroupService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalHostGroupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalHostGroupService) String() string {
	return fmt.Sprintf("ExternalHostGroupService:%s", op.path)
}

//
// Manages the set of quota limits configured for a cluster.
//
type QuotaClusterLimitsService struct {
	BaseService
}

func NewQuotaClusterLimitsService(connection *Connection, path string) *QuotaClusterLimitsService {
	var result QuotaClusterLimitsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a cluster limit to a specified Quota.
//
type QuotaClusterLimitsServiceAddRequest struct {
	QuotaClusterLimitsService *QuotaClusterLimitsService
	header                    map[string]string
	query                     map[string]string
	limit                     *QuotaClusterLimit
}

func (p *QuotaClusterLimitsServiceAddRequest) Header(key, value string) *QuotaClusterLimitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceAddRequest) Query(key, value string) *QuotaClusterLimitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceAddRequest) Limit(limit *QuotaClusterLimit) *QuotaClusterLimitsServiceAddRequest {
	p.limit = limit
	return p
}

func (p *QuotaClusterLimitsServiceAddRequest) Send() (*QuotaClusterLimitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaClusterLimitsService.connection.URL(), p.QuotaClusterLimitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaClusterLimitWriteOne(writer, p.limit, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaClusterLimitsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaClusterLimitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaClusterLimitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaClusterLimitsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaClusterLimitsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QuotaClusterLimitsServiceAddResponse{limit: result}, nil
}

func (p *QuotaClusterLimitsServiceAddRequest) MustSend() *QuotaClusterLimitsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a cluster limit to a specified Quota.
//
type QuotaClusterLimitsServiceAddResponse struct {
	limit *QuotaClusterLimit
}

func (p *QuotaClusterLimitsServiceAddResponse) Limit() (*QuotaClusterLimit, bool) {
	if p.limit != nil {
		return p.limit, true
	}
	return nil, false
}

func (p *QuotaClusterLimitsServiceAddResponse) MustLimit() *QuotaClusterLimit {
	if p.limit == nil {
		panic("limit in response does not exist")
	}
	return p.limit
}

//
// Add a cluster limit to a specified Quota.
//
func (p *QuotaClusterLimitsService) Add() *QuotaClusterLimitsServiceAddRequest {
	return &QuotaClusterLimitsServiceAddRequest{QuotaClusterLimitsService: p}
}

//
// Returns the set of quota limits configured for the cluster.
// The returned list of quota limits isn't guaranteed.
//
type QuotaClusterLimitsServiceListRequest struct {
	QuotaClusterLimitsService *QuotaClusterLimitsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *QuotaClusterLimitsServiceListRequest) Header(key, value string) *QuotaClusterLimitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceListRequest) Query(key, value string) *QuotaClusterLimitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitsServiceListRequest) Follow(follow string) *QuotaClusterLimitsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *QuotaClusterLimitsServiceListRequest) Max(max int64) *QuotaClusterLimitsServiceListRequest {
	p.max = &max
	return p
}

func (p *QuotaClusterLimitsServiceListRequest) Send() (*QuotaClusterLimitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaClusterLimitsService.connection.URL(), p.QuotaClusterLimitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaClusterLimitsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaClusterLimitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaClusterLimitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaClusterLimitsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaClusterLimitsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &QuotaClusterLimitsServiceListResponse{limits: result}, nil
}

func (p *QuotaClusterLimitsServiceListRequest) MustSend() *QuotaClusterLimitsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the set of quota limits configured for the cluster.
// The returned list of quota limits isn't guaranteed.
//
type QuotaClusterLimitsServiceListResponse struct {
	limits *QuotaClusterLimitSlice
}

func (p *QuotaClusterLimitsServiceListResponse) Limits() (*QuotaClusterLimitSlice, bool) {
	if p.limits != nil {
		return p.limits, true
	}
	return nil, false
}

func (p *QuotaClusterLimitsServiceListResponse) MustLimits() *QuotaClusterLimitSlice {
	if p.limits == nil {
		panic("limits in response does not exist")
	}
	return p.limits
}

//
// Returns the set of quota limits configured for the cluster.
// The returned list of quota limits isn't guaranteed.
//
func (p *QuotaClusterLimitsService) List() *QuotaClusterLimitsServiceListRequest {
	return &QuotaClusterLimitsServiceListRequest{QuotaClusterLimitsService: p}
}

//
//
func (op *QuotaClusterLimitsService) LimitService(id string) *QuotaClusterLimitService {
	return NewQuotaClusterLimitService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaClusterLimitsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LimitService(path), nil
	}
	return op.LimitService(path[:index]).Service(path[index+1:])
}

func (op *QuotaClusterLimitsService) String() string {
	return fmt.Sprintf("QuotaClusterLimitsService:%s", op.path)
}

//
// This service doesn't add any new methods, it is just a placeholder for the annotation that specifies the path of the
// resource that manages the permissions assigned to the system object.
//
type SystemPermissionsService struct {
	BaseService
}

func NewSystemPermissionsService(connection *Connection, path string) *SystemPermissionsService {
	var result SystemPermissionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
type SystemPermissionsServiceAddRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddRequest) Header(key, value string) *SystemPermissionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddRequest) Query(key, value string) *SystemPermissionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddRequest) Permission(permission *Permission) *SystemPermissionsServiceAddRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddRequest) Send() (*SystemPermissionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermissionWriteOne(writer, p.permission, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SystemPermissionsServiceAddResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddRequest) MustSend() *SystemPermissionsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
type SystemPermissionsServiceAddResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
func (p *SystemPermissionsService) Add() *SystemPermissionsServiceAddRequest {
	return &SystemPermissionsServiceAddRequest{SystemPermissionsService: p}
}

//
// Add a new permission on the cluster to the group in the system.
//
type SystemPermissionsServiceAddClusterPermissionRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddClusterPermissionRequest) Header(key, value string) *SystemPermissionsServiceAddClusterPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddClusterPermissionRequest) Query(key, value string) *SystemPermissionsServiceAddClusterPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddClusterPermissionRequest) Permission(permission *Permission) *SystemPermissionsServiceAddClusterPermissionRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddClusterPermissionRequest) Send() (*SystemPermissionsServiceAddClusterPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clusterpermission", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddClusterPermissionResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddClusterPermissionRequest) MustSend() *SystemPermissionsServiceAddClusterPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the cluster to the group in the system.
//
type SystemPermissionsServiceAddClusterPermissionResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddClusterPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddClusterPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the cluster to the group in the system.
//
func (p *SystemPermissionsService) AddClusterPermission() *SystemPermissionsServiceAddClusterPermissionRequest {
	return &SystemPermissionsServiceAddClusterPermissionRequest{SystemPermissionsService: p}
}

//
// Add a new permission on the data center to the group in the system.
//
type SystemPermissionsServiceAddDataCenterPermissionRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddDataCenterPermissionRequest) Header(key, value string) *SystemPermissionsServiceAddDataCenterPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddDataCenterPermissionRequest) Query(key, value string) *SystemPermissionsServiceAddDataCenterPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddDataCenterPermissionRequest) Permission(permission *Permission) *SystemPermissionsServiceAddDataCenterPermissionRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddDataCenterPermissionRequest) Send() (*SystemPermissionsServiceAddDataCenterPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/datacenterpermission", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddDataCenterPermissionResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddDataCenterPermissionRequest) MustSend() *SystemPermissionsServiceAddDataCenterPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the data center to the group in the system.
//
type SystemPermissionsServiceAddDataCenterPermissionResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddDataCenterPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddDataCenterPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the data center to the group in the system.
//
func (p *SystemPermissionsService) AddDataCenterPermission() *SystemPermissionsServiceAddDataCenterPermissionRequest {
	return &SystemPermissionsServiceAddDataCenterPermissionRequest{SystemPermissionsService: p}
}

//
// Add a new group level permission for a given virtual machine.
//
type SystemPermissionsServiceAddGroupLevelRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddGroupLevelRequest) Header(key, value string) *SystemPermissionsServiceAddGroupLevelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddGroupLevelRequest) Query(key, value string) *SystemPermissionsServiceAddGroupLevelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddGroupLevelRequest) Permission(permission *Permission) *SystemPermissionsServiceAddGroupLevelRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddGroupLevelRequest) Send() (*SystemPermissionsServiceAddGroupLevelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/grouplevel", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddGroupLevelResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddGroupLevelRequest) MustSend() *SystemPermissionsServiceAddGroupLevelResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new group level permission for a given virtual machine.
//
type SystemPermissionsServiceAddGroupLevelResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddGroupLevelResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddGroupLevelResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new group level permission for a given virtual machine.
//
func (p *SystemPermissionsService) AddGroupLevel() *SystemPermissionsServiceAddGroupLevelRequest {
	return &SystemPermissionsServiceAddGroupLevelRequest{SystemPermissionsService: p}
}

//
// Add a new permission on the host to the group in the system.
//
type SystemPermissionsServiceAddHostPermissionRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddHostPermissionRequest) Header(key, value string) *SystemPermissionsServiceAddHostPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddHostPermissionRequest) Query(key, value string) *SystemPermissionsServiceAddHostPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddHostPermissionRequest) Permission(permission *Permission) *SystemPermissionsServiceAddHostPermissionRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddHostPermissionRequest) Send() (*SystemPermissionsServiceAddHostPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/hostpermission", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddHostPermissionResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddHostPermissionRequest) MustSend() *SystemPermissionsServiceAddHostPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the host to the group in the system.
//
type SystemPermissionsServiceAddHostPermissionResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddHostPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddHostPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the host to the group in the system.
//
func (p *SystemPermissionsService) AddHostPermission() *SystemPermissionsServiceAddHostPermissionRequest {
	return &SystemPermissionsServiceAddHostPermissionRequest{SystemPermissionsService: p}
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
type SystemPermissionsServiceListRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *SystemPermissionsServiceListRequest) Header(key, value string) *SystemPermissionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceListRequest) Query(key, value string) *SystemPermissionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceListRequest) Follow(follow string) *SystemPermissionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *SystemPermissionsServiceListRequest) Send() (*SystemPermissionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &SystemPermissionsServiceListResponse{permissions: result}, nil
}

func (p *SystemPermissionsServiceListRequest) MustSend() *SystemPermissionsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
type SystemPermissionsServiceListResponse struct {
	permissions *PermissionSlice
}

func (p *SystemPermissionsServiceListResponse) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceListResponse) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("permissions in response does not exist")
	}
	return p.permissions
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
func (p *SystemPermissionsService) List() *SystemPermissionsServiceListRequest {
	return &SystemPermissionsServiceListRequest{SystemPermissionsService: p}
}

//
// Add a new permission on the storage domain to the group in the system.
//
type SystemPermissionsServiceAddStorageDomainPermissionRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddStorageDomainPermissionRequest) Header(key, value string) *SystemPermissionsServiceAddStorageDomainPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddStorageDomainPermissionRequest) Query(key, value string) *SystemPermissionsServiceAddStorageDomainPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddStorageDomainPermissionRequest) Permission(permission *Permission) *SystemPermissionsServiceAddStorageDomainPermissionRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddStorageDomainPermissionRequest) Send() (*SystemPermissionsServiceAddStorageDomainPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/storagedomainpermission", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddStorageDomainPermissionResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddStorageDomainPermissionRequest) MustSend() *SystemPermissionsServiceAddStorageDomainPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the storage domain to the group in the system.
//
type SystemPermissionsServiceAddStorageDomainPermissionResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddStorageDomainPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddStorageDomainPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the storage domain to the group in the system.
//
func (p *SystemPermissionsService) AddStorageDomainPermission() *SystemPermissionsServiceAddStorageDomainPermissionRequest {
	return &SystemPermissionsServiceAddStorageDomainPermissionRequest{SystemPermissionsService: p}
}

//
// Add a new permission on the template to the group in the system.
//
type SystemPermissionsServiceAddTemplatePermissionRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddTemplatePermissionRequest) Header(key, value string) *SystemPermissionsServiceAddTemplatePermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddTemplatePermissionRequest) Query(key, value string) *SystemPermissionsServiceAddTemplatePermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddTemplatePermissionRequest) Permission(permission *Permission) *SystemPermissionsServiceAddTemplatePermissionRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddTemplatePermissionRequest) Send() (*SystemPermissionsServiceAddTemplatePermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/templatepermission", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddTemplatePermissionResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddTemplatePermissionRequest) MustSend() *SystemPermissionsServiceAddTemplatePermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the template to the group in the system.
//
type SystemPermissionsServiceAddTemplatePermissionResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddTemplatePermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddTemplatePermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the template to the group in the system.
//
func (p *SystemPermissionsService) AddTemplatePermission() *SystemPermissionsServiceAddTemplatePermissionRequest {
	return &SystemPermissionsServiceAddTemplatePermissionRequest{SystemPermissionsService: p}
}

//
// Add a new user level permission for a given virtual machine.
//
type SystemPermissionsServiceAddUserLevelRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddUserLevelRequest) Header(key, value string) *SystemPermissionsServiceAddUserLevelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddUserLevelRequest) Query(key, value string) *SystemPermissionsServiceAddUserLevelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddUserLevelRequest) Permission(permission *Permission) *SystemPermissionsServiceAddUserLevelRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddUserLevelRequest) Send() (*SystemPermissionsServiceAddUserLevelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/userlevel", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddUserLevelResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddUserLevelRequest) MustSend() *SystemPermissionsServiceAddUserLevelResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new user level permission for a given virtual machine.
//
type SystemPermissionsServiceAddUserLevelResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddUserLevelResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddUserLevelResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new user level permission for a given virtual machine.
//
func (p *SystemPermissionsService) AddUserLevel() *SystemPermissionsServiceAddUserLevelRequest {
	return &SystemPermissionsServiceAddUserLevelRequest{SystemPermissionsService: p}
}

//
// Add a new permission on the vm to the group in the system.
//
type SystemPermissionsServiceAddVmPermissionRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddVmPermissionRequest) Header(key, value string) *SystemPermissionsServiceAddVmPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddVmPermissionRequest) Query(key, value string) *SystemPermissionsServiceAddVmPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddVmPermissionRequest) Permission(permission *Permission) *SystemPermissionsServiceAddVmPermissionRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddVmPermissionRequest) Send() (*SystemPermissionsServiceAddVmPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vmpermission", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddVmPermissionResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddVmPermissionRequest) MustSend() *SystemPermissionsServiceAddVmPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the vm to the group in the system.
//
type SystemPermissionsServiceAddVmPermissionResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddVmPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddVmPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the vm to the group in the system.
//
func (p *SystemPermissionsService) AddVmPermission() *SystemPermissionsServiceAddVmPermissionRequest {
	return &SystemPermissionsServiceAddVmPermissionRequest{SystemPermissionsService: p}
}

//
// Add a new permission on the vm pool to the group in the system.
//
type SystemPermissionsServiceAddVmPoolPermissionRequest struct {
	SystemPermissionsService *SystemPermissionsService
	header                   map[string]string
	query                    map[string]string
	permission               *Permission
}

func (p *SystemPermissionsServiceAddVmPoolPermissionRequest) Header(key, value string) *SystemPermissionsServiceAddVmPoolPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemPermissionsServiceAddVmPoolPermissionRequest) Query(key, value string) *SystemPermissionsServiceAddVmPoolPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemPermissionsServiceAddVmPoolPermissionRequest) Permission(permission *Permission) *SystemPermissionsServiceAddVmPoolPermissionRequest {
	p.permission = permission
	return p
}

func (p *SystemPermissionsServiceAddVmPoolPermissionRequest) Send() (*SystemPermissionsServiceAddVmPoolPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vmpoolpermission", p.SystemPermissionsService.connection.URL(), p.SystemPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &SystemPermissionsServiceAddVmPoolPermissionResponse{permission: result}, nil
}

func (p *SystemPermissionsServiceAddVmPoolPermissionRequest) MustSend() *SystemPermissionsServiceAddVmPoolPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the vm pool to the group in the system.
//
type SystemPermissionsServiceAddVmPoolPermissionResponse struct {
	permission *Permission
}

func (p *SystemPermissionsServiceAddVmPoolPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *SystemPermissionsServiceAddVmPoolPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the vm pool to the group in the system.
//
func (p *SystemPermissionsService) AddVmPoolPermission() *SystemPermissionsServiceAddVmPoolPermissionRequest {
	return &SystemPermissionsServiceAddVmPoolPermissionRequest{SystemPermissionsService: p}
}

//
// Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
// dispatched.
//
func (op *SystemPermissionsService) PermissionService(id string) *PermissionService {
	return NewPermissionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SystemPermissionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PermissionService(path), nil
	}
	return op.PermissionService(path[:index]).Service(path[index+1:])
}

func (op *SystemPermissionsService) String() string {
	return fmt.Sprintf("SystemPermissionsService:%s", op.path)
}

//
// Manages the set of disks available in a storage domain.
//
type StorageDomainContentDisksService struct {
	BaseService
}

func NewStorageDomainContentDisksService(connection *Connection, path string) *StorageDomainContentDisksService {
	var result StorageDomainContentDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disks available in the storage domain.
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
type StorageDomainContentDisksServiceListRequest struct {
	StorageDomainContentDisksService *StorageDomainContentDisksService
	header                           map[string]string
	query                            map[string]string
	caseSensitive                    *bool
	follow                           *string
	max                              *int64
	search                           *string
}

func (p *StorageDomainContentDisksServiceListRequest) Header(key, value string) *StorageDomainContentDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) Query(key, value string) *StorageDomainContentDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) CaseSensitive(caseSensitive bool) *StorageDomainContentDisksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) Follow(follow string) *StorageDomainContentDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) Max(max int64) *StorageDomainContentDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) Search(search string) *StorageDomainContentDisksServiceListRequest {
	p.search = &search
	return p
}

func (p *StorageDomainContentDisksServiceListRequest) Send() (*StorageDomainContentDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainContentDisksService.connection.URL(), p.StorageDomainContentDisksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainContentDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainContentDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainContentDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainContentDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainContentDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageDomainContentDisksServiceListResponse{disks: result}, nil
}

func (p *StorageDomainContentDisksServiceListRequest) MustSend() *StorageDomainContentDisksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of disks available in the storage domain.
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
type StorageDomainContentDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *StorageDomainContentDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *StorageDomainContentDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks available in the storage domain.
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
func (p *StorageDomainContentDisksService) List() *StorageDomainContentDisksServiceListRequest {
	return &StorageDomainContentDisksServiceListRequest{StorageDomainContentDisksService: p}
}

//
//
func (op *StorageDomainContentDisksService) DiskService(id string) *StorageDomainContentDiskService {
	return NewStorageDomainContentDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainContentDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainContentDisksService) String() string {
	return fmt.Sprintf("StorageDomainContentDisksService:%s", op.path)
}

//
// Provides information about the cluster features that are supported by a cluster level.
//
type ClusterFeaturesService struct {
	BaseService
}

func NewClusterFeaturesService(connection *Connection, path string) *ClusterFeaturesService {
	var result ClusterFeaturesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Lists the cluster features supported by the cluster level.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures
// ----
// This will return a list of cluster features supported by the cluster level:
// [source,xml]
// ----
// <cluster_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </cluster_features>
// ----
//
type ClusterFeaturesServiceListRequest struct {
	ClusterFeaturesService *ClusterFeaturesService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *ClusterFeaturesServiceListRequest) Header(key, value string) *ClusterFeaturesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterFeaturesServiceListRequest) Query(key, value string) *ClusterFeaturesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterFeaturesServiceListRequest) Follow(follow string) *ClusterFeaturesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ClusterFeaturesServiceListRequest) Send() (*ClusterFeaturesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterFeaturesService.connection.URL(), p.ClusterFeaturesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterFeaturesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterFeaturesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterFeaturesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterFeaturesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterFeaturesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ClusterFeaturesServiceListResponse{features: result}, nil
}

func (p *ClusterFeaturesServiceListRequest) MustSend() *ClusterFeaturesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists the cluster features supported by the cluster level.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures
// ----
// This will return a list of cluster features supported by the cluster level:
// [source,xml]
// ----
// <cluster_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </cluster_features>
// ----
//
type ClusterFeaturesServiceListResponse struct {
	features *ClusterFeatureSlice
}

func (p *ClusterFeaturesServiceListResponse) Features() (*ClusterFeatureSlice, bool) {
	if p.features != nil {
		return p.features, true
	}
	return nil, false
}

func (p *ClusterFeaturesServiceListResponse) MustFeatures() *ClusterFeatureSlice {
	if p.features == nil {
		panic("features in response does not exist")
	}
	return p.features
}

//
// Lists the cluster features supported by the cluster level.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures
// ----
// This will return a list of cluster features supported by the cluster level:
// [source,xml]
// ----
// <cluster_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </cluster_features>
// ----
//
func (p *ClusterFeaturesService) List() *ClusterFeaturesServiceListRequest {
	return &ClusterFeaturesServiceListRequest{ClusterFeaturesService: p}
}

//
// Reference to the service that provides information about a specific feature.
//
func (op *ClusterFeaturesService) FeatureService(id string) *ClusterFeatureService {
	return NewClusterFeatureService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterFeaturesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.FeatureService(path), nil
	}
	return op.FeatureService(path[:index]).Service(path[index+1:])
}

func (op *ClusterFeaturesService) String() string {
	return fmt.Sprintf("ClusterFeaturesService:%s", op.path)
}

//
//
type SchedulingPolicyUnitService struct {
	BaseService
}

func NewSchedulingPolicyUnitService(connection *Connection, path string) *SchedulingPolicyUnitService {
	var result SchedulingPolicyUnitService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type SchedulingPolicyUnitServiceGetRequest struct {
	SchedulingPolicyUnitService *SchedulingPolicyUnitService
	header                      map[string]string
	query                       map[string]string
	filter                      *bool
	follow                      *string
}

func (p *SchedulingPolicyUnitServiceGetRequest) Header(key, value string) *SchedulingPolicyUnitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceGetRequest) Query(key, value string) *SchedulingPolicyUnitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceGetRequest) Filter(filter bool) *SchedulingPolicyUnitServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *SchedulingPolicyUnitServiceGetRequest) Follow(follow string) *SchedulingPolicyUnitServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *SchedulingPolicyUnitServiceGetRequest) Send() (*SchedulingPolicyUnitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SchedulingPolicyUnitService.connection.URL(), p.SchedulingPolicyUnitService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SchedulingPolicyUnitService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SchedulingPolicyUnitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SchedulingPolicyUnitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SchedulingPolicyUnitService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SchedulingPolicyUnitService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyUnitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SchedulingPolicyUnitServiceGetResponse{unit: result}, nil
}

func (p *SchedulingPolicyUnitServiceGetRequest) MustSend() *SchedulingPolicyUnitServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SchedulingPolicyUnitServiceGetResponse struct {
	unit *SchedulingPolicyUnit
}

func (p *SchedulingPolicyUnitServiceGetResponse) Unit() (*SchedulingPolicyUnit, bool) {
	if p.unit != nil {
		return p.unit, true
	}
	return nil, false
}

func (p *SchedulingPolicyUnitServiceGetResponse) MustUnit() *SchedulingPolicyUnit {
	if p.unit == nil {
		panic("unit in response does not exist")
	}
	return p.unit
}

//
//
func (p *SchedulingPolicyUnitService) Get() *SchedulingPolicyUnitServiceGetRequest {
	return &SchedulingPolicyUnitServiceGetRequest{SchedulingPolicyUnitService: p}
}

//
//
type SchedulingPolicyUnitServiceRemoveRequest struct {
	SchedulingPolicyUnitService *SchedulingPolicyUnitService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Header(key, value string) *SchedulingPolicyUnitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Query(key, value string) *SchedulingPolicyUnitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Async(async bool) *SchedulingPolicyUnitServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) Send() (*SchedulingPolicyUnitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SchedulingPolicyUnitService.connection.URL(), p.SchedulingPolicyUnitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SchedulingPolicyUnitService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SchedulingPolicyUnitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SchedulingPolicyUnitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SchedulingPolicyUnitService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SchedulingPolicyUnitService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(SchedulingPolicyUnitServiceRemoveResponse), nil
}

func (p *SchedulingPolicyUnitServiceRemoveRequest) MustSend() *SchedulingPolicyUnitServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SchedulingPolicyUnitServiceRemoveResponse struct {
}

//
//
func (p *SchedulingPolicyUnitService) Remove() *SchedulingPolicyUnitServiceRemoveRequest {
	return &SchedulingPolicyUnitServiceRemoveRequest{SchedulingPolicyUnitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyUnitService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SchedulingPolicyUnitService) String() string {
	return fmt.Sprintf("SchedulingPolicyUnitService:%s", op.path)
}

//
//
type StorageServerConnectionsService struct {
	BaseService
}

func NewStorageServerConnectionsService(connection *Connection, path string) *StorageServerConnectionsService {
	var result StorageServerConnectionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new storage connection.
// For example, to create a new storage connection for the NFS server `mynfs.example.com` and NFS share
// `/export/mydata` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageconnections
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <type>nfs</type>
//   <address>mynfs.example.com</address>
//   <path>/export/mydata</path>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
type StorageServerConnectionsServiceAddRequest struct {
	StorageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *StorageServerConnectionsServiceAddRequest) Header(key, value string) *StorageServerConnectionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddRequest) Query(key, value string) *StorageServerConnectionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddRequest) Connection(connection *StorageConnection) *StorageServerConnectionsServiceAddRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionsServiceAddRequest) Send() (*StorageServerConnectionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionsService.connection.URL(), p.StorageServerConnectionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageServerConnectionsServiceAddResponse{connection: result}, nil
}

func (p *StorageServerConnectionsServiceAddRequest) MustSend() *StorageServerConnectionsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new storage connection.
// For example, to create a new storage connection for the NFS server `mynfs.example.com` and NFS share
// `/export/mydata` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageconnections
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <type>nfs</type>
//   <address>mynfs.example.com</address>
//   <path>/export/mydata</path>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
type StorageServerConnectionsServiceAddResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionsServiceAddResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionsServiceAddResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Creates a new storage connection.
// For example, to create a new storage connection for the NFS server `mynfs.example.com` and NFS share
// `/export/mydata` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageconnections
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <type>nfs</type>
//   <address>mynfs.example.com</address>
//   <path>/export/mydata</path>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_connection>
// ----
//
func (p *StorageServerConnectionsService) Add() *StorageServerConnectionsServiceAddRequest {
	return &StorageServerConnectionsServiceAddRequest{StorageServerConnectionsService: p}
}

//
// Add a Glusterfs storage connection to the system.
//
type StorageServerConnectionsServiceAddGlusterfsRequest struct {
	StorageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *StorageServerConnectionsServiceAddGlusterfsRequest) Header(key, value string) *StorageServerConnectionsServiceAddGlusterfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddGlusterfsRequest) Query(key, value string) *StorageServerConnectionsServiceAddGlusterfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddGlusterfsRequest) Connection(connection *StorageConnection) *StorageServerConnectionsServiceAddGlusterfsRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionsServiceAddGlusterfsRequest) Send() (*StorageServerConnectionsServiceAddGlusterfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/glusterfs", p.StorageServerConnectionsService.connection.URL(), p.StorageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionsServiceAddGlusterfsResponse{connection: result}, nil
}

func (p *StorageServerConnectionsServiceAddGlusterfsRequest) MustSend() *StorageServerConnectionsServiceAddGlusterfsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a Glusterfs storage connection to the system.
//
type StorageServerConnectionsServiceAddGlusterfsResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionsServiceAddGlusterfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionsServiceAddGlusterfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a Glusterfs storage connection to the system.
//
func (p *StorageServerConnectionsService) AddGlusterfs() *StorageServerConnectionsServiceAddGlusterfsRequest {
	return &StorageServerConnectionsServiceAddGlusterfsRequest{StorageServerConnectionsService: p}
}

//
// Add a iSCSI storage connection to the system.
//
type StorageServerConnectionsServiceAddIscsiRequest struct {
	StorageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *StorageServerConnectionsServiceAddIscsiRequest) Header(key, value string) *StorageServerConnectionsServiceAddIscsiRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddIscsiRequest) Query(key, value string) *StorageServerConnectionsServiceAddIscsiRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddIscsiRequest) Connection(connection *StorageConnection) *StorageServerConnectionsServiceAddIscsiRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionsServiceAddIscsiRequest) Send() (*StorageServerConnectionsServiceAddIscsiResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsi", p.StorageServerConnectionsService.connection.URL(), p.StorageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionsServiceAddIscsiResponse{connection: result}, nil
}

func (p *StorageServerConnectionsServiceAddIscsiRequest) MustSend() *StorageServerConnectionsServiceAddIscsiResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a iSCSI storage connection to the system.
//
type StorageServerConnectionsServiceAddIscsiResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionsServiceAddIscsiResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionsServiceAddIscsiResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a iSCSI storage connection to the system.
//
func (p *StorageServerConnectionsService) AddIscsi() *StorageServerConnectionsServiceAddIscsiRequest {
	return &StorageServerConnectionsServiceAddIscsiRequest{StorageServerConnectionsService: p}
}

//
// Returns the list of storage connections.
// The order of the returned list of connections isn't guaranteed.
//
type StorageServerConnectionsServiceListRequest struct {
	StorageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
	max                             *int64
}

func (p *StorageServerConnectionsServiceListRequest) Header(key, value string) *StorageServerConnectionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceListRequest) Query(key, value string) *StorageServerConnectionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceListRequest) Follow(follow string) *StorageServerConnectionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageServerConnectionsServiceListRequest) Max(max int64) *StorageServerConnectionsServiceListRequest {
	p.max = &max
	return p
}

func (p *StorageServerConnectionsServiceListRequest) Send() (*StorageServerConnectionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionsService.connection.URL(), p.StorageServerConnectionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageServerConnectionsServiceListResponse{connections: result}, nil
}

func (p *StorageServerConnectionsServiceListRequest) MustSend() *StorageServerConnectionsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of storage connections.
// The order of the returned list of connections isn't guaranteed.
//
type StorageServerConnectionsServiceListResponse struct {
	connections *StorageConnectionSlice
}

func (p *StorageServerConnectionsServiceListResponse) Connections() (*StorageConnectionSlice, bool) {
	if p.connections != nil {
		return p.connections, true
	}
	return nil, false
}

func (p *StorageServerConnectionsServiceListResponse) MustConnections() *StorageConnectionSlice {
	if p.connections == nil {
		panic("connections in response does not exist")
	}
	return p.connections
}

//
// Returns the list of storage connections.
// The order of the returned list of connections isn't guaranteed.
//
func (p *StorageServerConnectionsService) List() *StorageServerConnectionsServiceListRequest {
	return &StorageServerConnectionsServiceListRequest{StorageServerConnectionsService: p}
}

//
// Add a local storage connection to the system.
//
type StorageServerConnectionsServiceAddLocalRequest struct {
	StorageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *StorageServerConnectionsServiceAddLocalRequest) Header(key, value string) *StorageServerConnectionsServiceAddLocalRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddLocalRequest) Query(key, value string) *StorageServerConnectionsServiceAddLocalRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddLocalRequest) Connection(connection *StorageConnection) *StorageServerConnectionsServiceAddLocalRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionsServiceAddLocalRequest) Send() (*StorageServerConnectionsServiceAddLocalResponse, error) {
	rawURL := fmt.Sprintf("%s%s/local", p.StorageServerConnectionsService.connection.URL(), p.StorageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionsServiceAddLocalResponse{connection: result}, nil
}

func (p *StorageServerConnectionsServiceAddLocalRequest) MustSend() *StorageServerConnectionsServiceAddLocalResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a local storage connection to the system.
//
type StorageServerConnectionsServiceAddLocalResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionsServiceAddLocalResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionsServiceAddLocalResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a local storage connection to the system.
//
func (p *StorageServerConnectionsService) AddLocal() *StorageServerConnectionsServiceAddLocalRequest {
	return &StorageServerConnectionsServiceAddLocalRequest{StorageServerConnectionsService: p}
}

//
// Add a nfs storage connection to the system.
//
type StorageServerConnectionsServiceAddNfsRequest struct {
	StorageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *StorageServerConnectionsServiceAddNfsRequest) Header(key, value string) *StorageServerConnectionsServiceAddNfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddNfsRequest) Query(key, value string) *StorageServerConnectionsServiceAddNfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddNfsRequest) Connection(connection *StorageConnection) *StorageServerConnectionsServiceAddNfsRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionsServiceAddNfsRequest) Send() (*StorageServerConnectionsServiceAddNfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/nfs", p.StorageServerConnectionsService.connection.URL(), p.StorageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionsServiceAddNfsResponse{connection: result}, nil
}

func (p *StorageServerConnectionsServiceAddNfsRequest) MustSend() *StorageServerConnectionsServiceAddNfsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a nfs storage connection to the system.
//
type StorageServerConnectionsServiceAddNfsResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionsServiceAddNfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionsServiceAddNfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a nfs storage connection to the system.
//
func (p *StorageServerConnectionsService) AddNfs() *StorageServerConnectionsServiceAddNfsRequest {
	return &StorageServerConnectionsServiceAddNfsRequest{StorageServerConnectionsService: p}
}

//
// Add a vfs storage connection to the system.
//
type StorageServerConnectionsServiceAddVfsRequest struct {
	StorageServerConnectionsService *StorageServerConnectionsService
	header                          map[string]string
	query                           map[string]string
	connection                      *StorageConnection
}

func (p *StorageServerConnectionsServiceAddVfsRequest) Header(key, value string) *StorageServerConnectionsServiceAddVfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddVfsRequest) Query(key, value string) *StorageServerConnectionsServiceAddVfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionsServiceAddVfsRequest) Connection(connection *StorageConnection) *StorageServerConnectionsServiceAddVfsRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionsServiceAddVfsRequest) Send() (*StorageServerConnectionsServiceAddVfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vfs", p.StorageServerConnectionsService.connection.URL(), p.StorageServerConnectionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Connection(p.connection)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionsServiceAddVfsResponse{connection: result}, nil
}

func (p *StorageServerConnectionsServiceAddVfsRequest) MustSend() *StorageServerConnectionsServiceAddVfsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a vfs storage connection to the system.
//
type StorageServerConnectionsServiceAddVfsResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionsServiceAddVfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionsServiceAddVfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Add a vfs storage connection to the system.
//
func (p *StorageServerConnectionsService) AddVfs() *StorageServerConnectionsServiceAddVfsRequest {
	return &StorageServerConnectionsServiceAddVfsRequest{StorageServerConnectionsService: p}
}

//
//
func (op *StorageServerConnectionsService) StorageConnectionService(id string) *StorageServerConnectionService {
	return NewStorageServerConnectionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageConnectionService(path), nil
	}
	return op.StorageConnectionService(path[:index]).Service(path[index+1:])
}

func (op *StorageServerConnectionsService) String() string {
	return fmt.Sprintf("StorageServerConnectionsService:%s", op.path)
}

//
// Manages the collection of disks available in the system.
//
type DisksService struct {
	BaseService
}

func NewDisksService(connection *Connection, path string) *DisksService {
	var result DisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new floating disk.
// There are three types of disks that can be added - disk image, direct LUN and
//  https://wiki.openstack.org/wiki/Cinder[Cinder] disk.
// *Adding a new image disk:*
// When creating a new floating image <<types/disk,Disk>>, the API requires the `storage_domain`, `provisioned_size`
// and `format` attributes.
// Note that block storage domains (i.e., storage domains with the <<types/storage_type, storage type>> of iSCSI or
// FCP) don't support the combination of the raw `format` with `sparse=true`, so `sparse=false` must be stated
// explicitly.
// To create a new floating image disk with specified `provisioned_size`, `format` and `name` on a storage domain
// with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
// *Adding a new direct LUN disk:*
// When adding a new floating direct LUN via the API, there are two flavors that can be used:
// . With a `host` element - in this case, the host is used for sanity checks (e.g., that the LUN is visible) and
// to retrieve basic information about the LUN (e.g., size and serial).
// . Without a `host` element - in this case, the operation is a database-only operation, and the storage is never
// accessed.
// To create a new floating direct LUN disk with a `host` element with an id `123`, specified `alias`, `type` and
// `logical_unit` with an id `456` (that has the attributes `address`, `port` and `target`),
// send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <alias>mylun</alias>
//   <lun_storage>
//     <host id="123"/>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="456">
//         <address>10.35.10.20</address>
//         <port>3260</port>
//         <target>iqn.2017-01.com.myhost:444</target>
//       </logical_unit>
//     </logical_units>
//   </lun_storage>
// </disk>
// ----
// To create a new floating direct LUN disk without using a host, remove the `host` element.
// *Adding a new Cinder disk:*
// To create a new floating Cinder disk, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <openstack_volume_type>
//     <name>myceph</name>
//   </openstack_volume_type>
//   <storage_domains>
//     <storage_domain>
//       <name>cinderDomain</name>
//     </storage_domain>
//   </storage_domains>
//   <provisioned_size>1073741824</provisioned_size>
//   <interface>virtio</interface>
//   <format>raw</format>
// </disk>
// ----
// *Adding a floating disks in order to upload disk snapshots:*
// Since version 4.2 of the engine it is possible to upload disks with
// snapshots. This request should be used to create the base image of the
// images chain (The consecutive disk snapshots (images), should be created
// using `disk-attachments` element when creating a snapshot).
// The disk has to be created with the same disk identifier and image identifier
// of the uploaded image. I.e. the identifiers should be saved as part of the
// backup process. The image identifier can be also fetched using the
// `qemu-img info` command. For example, if the disk image is stored into
// a file named `b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img`:
// [source,shell]
// ----
// $ qemu-img info b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img
// image: b548366b-fb51-4b41-97be-733c887fe305
// file format: qcow2
// virtual size: 1.0G (1073741824 bytes)
// disk size: 196K
// cluster_size: 65536
// backing file: ad58716a-1fe9-481f-815e-664de1df04eb
// backing file format: raw
// ----
// To create a disk with with the disk identifier and image identifier obtained
// with the `qemu-img info` command shown above, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk id="b7a4c6c5-443b-47c5-967f-6abc79675e8b">
//   <image_id>b548366b-fb51-4b41-97be-733c887fe305</image_id>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
//
type DisksServiceAddRequest struct {
	DisksService *DisksService
	header       map[string]string
	query        map[string]string
	disk         *Disk
}

func (p *DisksServiceAddRequest) Header(key, value string) *DisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DisksServiceAddRequest) Query(key, value string) *DisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DisksServiceAddRequest) Disk(disk *Disk) *DisksServiceAddRequest {
	p.disk = disk
	return p
}

func (p *DisksServiceAddRequest) Send() (*DisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DisksService.connection.URL(), p.DisksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DisksServiceAddResponse{disk: result}, nil
}

func (p *DisksServiceAddRequest) MustSend() *DisksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a new floating disk.
// There are three types of disks that can be added - disk image, direct LUN and
//  https://wiki.openstack.org/wiki/Cinder[Cinder] disk.
// *Adding a new image disk:*
// When creating a new floating image <<types/disk,Disk>>, the API requires the `storage_domain`, `provisioned_size`
// and `format` attributes.
// Note that block storage domains (i.e., storage domains with the <<types/storage_type, storage type>> of iSCSI or
// FCP) don't support the combination of the raw `format` with `sparse=true`, so `sparse=false` must be stated
// explicitly.
// To create a new floating image disk with specified `provisioned_size`, `format` and `name` on a storage domain
// with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
// *Adding a new direct LUN disk:*
// When adding a new floating direct LUN via the API, there are two flavors that can be used:
// . With a `host` element - in this case, the host is used for sanity checks (e.g., that the LUN is visible) and
// to retrieve basic information about the LUN (e.g., size and serial).
// . Without a `host` element - in this case, the operation is a database-only operation, and the storage is never
// accessed.
// To create a new floating direct LUN disk with a `host` element with an id `123`, specified `alias`, `type` and
// `logical_unit` with an id `456` (that has the attributes `address`, `port` and `target`),
// send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <alias>mylun</alias>
//   <lun_storage>
//     <host id="123"/>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="456">
//         <address>10.35.10.20</address>
//         <port>3260</port>
//         <target>iqn.2017-01.com.myhost:444</target>
//       </logical_unit>
//     </logical_units>
//   </lun_storage>
// </disk>
// ----
// To create a new floating direct LUN disk without using a host, remove the `host` element.
// *Adding a new Cinder disk:*
// To create a new floating Cinder disk, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <openstack_volume_type>
//     <name>myceph</name>
//   </openstack_volume_type>
//   <storage_domains>
//     <storage_domain>
//       <name>cinderDomain</name>
//     </storage_domain>
//   </storage_domains>
//   <provisioned_size>1073741824</provisioned_size>
//   <interface>virtio</interface>
//   <format>raw</format>
// </disk>
// ----
// *Adding a floating disks in order to upload disk snapshots:*
// Since version 4.2 of the engine it is possible to upload disks with
// snapshots. This request should be used to create the base image of the
// images chain (The consecutive disk snapshots (images), should be created
// using `disk-attachments` element when creating a snapshot).
// The disk has to be created with the same disk identifier and image identifier
// of the uploaded image. I.e. the identifiers should be saved as part of the
// backup process. The image identifier can be also fetched using the
// `qemu-img info` command. For example, if the disk image is stored into
// a file named `b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img`:
// [source,shell]
// ----
// $ qemu-img info b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img
// image: b548366b-fb51-4b41-97be-733c887fe305
// file format: qcow2
// virtual size: 1.0G (1073741824 bytes)
// disk size: 196K
// cluster_size: 65536
// backing file: ad58716a-1fe9-481f-815e-664de1df04eb
// backing file format: raw
// ----
// To create a disk with with the disk identifier and image identifier obtained
// with the `qemu-img info` command shown above, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk id="b7a4c6c5-443b-47c5-967f-6abc79675e8b">
//   <image_id>b548366b-fb51-4b41-97be-733c887fe305</image_id>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
//
type DisksServiceAddResponse struct {
	disk *Disk
}

func (p *DisksServiceAddResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *DisksServiceAddResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Adds a new floating disk.
// There are three types of disks that can be added - disk image, direct LUN and
//  https://wiki.openstack.org/wiki/Cinder[Cinder] disk.
// *Adding a new image disk:*
// When creating a new floating image <<types/disk,Disk>>, the API requires the `storage_domain`, `provisioned_size`
// and `format` attributes.
// Note that block storage domains (i.e., storage domains with the <<types/storage_type, storage type>> of iSCSI or
// FCP) don't support the combination of the raw `format` with `sparse=true`, so `sparse=false` must be stated
// explicitly.
// To create a new floating image disk with specified `provisioned_size`, `format` and `name` on a storage domain
// with an id `123`, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
// *Adding a new direct LUN disk:*
// When adding a new floating direct LUN via the API, there are two flavors that can be used:
// . With a `host` element - in this case, the host is used for sanity checks (e.g., that the LUN is visible) and
// to retrieve basic information about the LUN (e.g., size and serial).
// . Without a `host` element - in this case, the operation is a database-only operation, and the storage is never
// accessed.
// To create a new floating direct LUN disk with a `host` element with an id `123`, specified `alias`, `type` and
// `logical_unit` with an id `456` (that has the attributes `address`, `port` and `target`),
// send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <alias>mylun</alias>
//   <lun_storage>
//     <host id="123"/>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="456">
//         <address>10.35.10.20</address>
//         <port>3260</port>
//         <target>iqn.2017-01.com.myhost:444</target>
//       </logical_unit>
//     </logical_units>
//   </lun_storage>
// </disk>
// ----
// To create a new floating direct LUN disk without using a host, remove the `host` element.
// *Adding a new Cinder disk:*
// To create a new floating Cinder disk, send a request as follows:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <openstack_volume_type>
//     <name>myceph</name>
//   </openstack_volume_type>
//   <storage_domains>
//     <storage_domain>
//       <name>cinderDomain</name>
//     </storage_domain>
//   </storage_domains>
//   <provisioned_size>1073741824</provisioned_size>
//   <interface>virtio</interface>
//   <format>raw</format>
// </disk>
// ----
// *Adding a floating disks in order to upload disk snapshots:*
// Since version 4.2 of the engine it is possible to upload disks with
// snapshots. This request should be used to create the base image of the
// images chain (The consecutive disk snapshots (images), should be created
// using `disk-attachments` element when creating a snapshot).
// The disk has to be created with the same disk identifier and image identifier
// of the uploaded image. I.e. the identifiers should be saved as part of the
// backup process. The image identifier can be also fetched using the
// `qemu-img info` command. For example, if the disk image is stored into
// a file named `b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img`:
// [source,shell]
// ----
// $ qemu-img info b7a4c6c5-443b-47c5-967f-6abc79675e8b/myimage.img
// image: b548366b-fb51-4b41-97be-733c887fe305
// file format: qcow2
// virtual size: 1.0G (1073741824 bytes)
// disk size: 196K
// cluster_size: 65536
// backing file: ad58716a-1fe9-481f-815e-664de1df04eb
// backing file format: raw
// ----
// To create a disk with with the disk identifier and image identifier obtained
// with the `qemu-img info` command shown above, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk id="b7a4c6c5-443b-47c5-967f-6abc79675e8b">
//   <image_id>b548366b-fb51-4b41-97be-733c887fe305</image_id>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <name>mydisk</name>
//   <provisioned_size>1048576</provisioned_size>
//   <format>cow</format>
// </disk>
// ----
//
func (p *DisksService) Add() *DisksServiceAddRequest {
	return &DisksServiceAddRequest{DisksService: p}
}

//
// Get list of disks.
// [source]
// ----
// GET /ovirt-engine/api/disks
// ----
// You will get a XML response which will look like this one:
// [source,xml]
// ----
// <disks>
//   <disk id="123">
//     <actions>...</actions>
//     <name>MyDisk</name>
//     <description>MyDisk description</description>
//     <link href="/ovirt-engine/api/disks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/disks/123/statistics" rel="statistics"/>
//     <actual_size>5345845248</actual_size>
//     <alias>MyDisk alias</alias>
//     ...
//     <status>ok</status>
//     <storage_type>image</storage_type>
//     <wipe_after_delete>false</wipe_after_delete>
//     <disk_profile id="123"/>
//     <quota id="123"/>
//     <storage_domains>...</storage_domains>
//   </disk>
//   ...
// </disks>
// ----
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type DisksServiceListRequest struct {
	DisksService  *DisksService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *DisksServiceListRequest) Header(key, value string) *DisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DisksServiceListRequest) Query(key, value string) *DisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DisksServiceListRequest) CaseSensitive(caseSensitive bool) *DisksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *DisksServiceListRequest) Follow(follow string) *DisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DisksServiceListRequest) Max(max int64) *DisksServiceListRequest {
	p.max = &max
	return p
}

func (p *DisksServiceListRequest) Search(search string) *DisksServiceListRequest {
	p.search = &search
	return p
}

func (p *DisksServiceListRequest) Send() (*DisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DisksService.connection.URL(), p.DisksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DisksServiceListResponse{disks: result}, nil
}

func (p *DisksServiceListRequest) MustSend() *DisksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get list of disks.
// [source]
// ----
// GET /ovirt-engine/api/disks
// ----
// You will get a XML response which will look like this one:
// [source,xml]
// ----
// <disks>
//   <disk id="123">
//     <actions>...</actions>
//     <name>MyDisk</name>
//     <description>MyDisk description</description>
//     <link href="/ovirt-engine/api/disks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/disks/123/statistics" rel="statistics"/>
//     <actual_size>5345845248</actual_size>
//     <alias>MyDisk alias</alias>
//     ...
//     <status>ok</status>
//     <storage_type>image</storage_type>
//     <wipe_after_delete>false</wipe_after_delete>
//     <disk_profile id="123"/>
//     <quota id="123"/>
//     <storage_domains>...</storage_domains>
//   </disk>
//   ...
// </disks>
// ----
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type DisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *DisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *DisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Get list of disks.
// [source]
// ----
// GET /ovirt-engine/api/disks
// ----
// You will get a XML response which will look like this one:
// [source,xml]
// ----
// <disks>
//   <disk id="123">
//     <actions>...</actions>
//     <name>MyDisk</name>
//     <description>MyDisk description</description>
//     <link href="/ovirt-engine/api/disks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/disks/123/statistics" rel="statistics"/>
//     <actual_size>5345845248</actual_size>
//     <alias>MyDisk alias</alias>
//     ...
//     <status>ok</status>
//     <storage_type>image</storage_type>
//     <wipe_after_delete>false</wipe_after_delete>
//     <disk_profile id="123"/>
//     <quota id="123"/>
//     <storage_domains>...</storage_domains>
//   </disk>
//   ...
// </disks>
// ----
// The order of the returned list of disks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *DisksService) List() *DisksServiceListRequest {
	return &DisksServiceListRequest{DisksService: p}
}

//
// Add a new lun disk to the storage domain.
//
type DisksServiceAddLunRequest struct {
	DisksService *DisksService
	header       map[string]string
	query        map[string]string
	disk         *Disk
}

func (p *DisksServiceAddLunRequest) Header(key, value string) *DisksServiceAddLunRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DisksServiceAddLunRequest) Query(key, value string) *DisksServiceAddLunRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DisksServiceAddLunRequest) Disk(disk *Disk) *DisksServiceAddLunRequest {
	p.disk = disk
	return p
}

func (p *DisksServiceAddLunRequest) Send() (*DisksServiceAddLunResponse, error) {
	rawURL := fmt.Sprintf("%s%s/lun", p.DisksService.connection.URL(), p.DisksService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustDisk()
	return &DisksServiceAddLunResponse{disk: result}, nil
}

func (p *DisksServiceAddLunRequest) MustSend() *DisksServiceAddLunResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new lun disk to the storage domain.
//
type DisksServiceAddLunResponse struct {
	disk *Disk
}

func (p *DisksServiceAddLunResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *DisksServiceAddLunResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Add a new lun disk to the storage domain.
//
func (p *DisksService) AddLun() *DisksServiceAddLunRequest {
	return &DisksServiceAddLunRequest{DisksService: p}
}

//
// Add a new disk to the storage domain with the specified size allocating space from the storage domain.
//
type DisksServiceAddOnStorageDomainRequest struct {
	DisksService *DisksService
	header       map[string]string
	query        map[string]string
	disk         *Disk
}

func (p *DisksServiceAddOnStorageDomainRequest) Header(key, value string) *DisksServiceAddOnStorageDomainRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DisksServiceAddOnStorageDomainRequest) Query(key, value string) *DisksServiceAddOnStorageDomainRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DisksServiceAddOnStorageDomainRequest) Disk(disk *Disk) *DisksServiceAddOnStorageDomainRequest {
	p.disk = disk
	return p
}

func (p *DisksServiceAddOnStorageDomainRequest) Send() (*DisksServiceAddOnStorageDomainResponse, error) {
	rawURL := fmt.Sprintf("%s%s/onstoragedomain", p.DisksService.connection.URL(), p.DisksService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustDisk()
	return &DisksServiceAddOnStorageDomainResponse{disk: result}, nil
}

func (p *DisksServiceAddOnStorageDomainRequest) MustSend() *DisksServiceAddOnStorageDomainResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new disk to the storage domain with the specified size allocating space from the storage domain.
//
type DisksServiceAddOnStorageDomainResponse struct {
	disk *Disk
}

func (p *DisksServiceAddOnStorageDomainResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *DisksServiceAddOnStorageDomainResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Add a new disk to the storage domain with the specified size allocating space from the storage domain.
//
func (p *DisksService) AddOnStorageDomain() *DisksServiceAddOnStorageDomainRequest {
	return &DisksServiceAddOnStorageDomainRequest{DisksService: p}
}

//
// Reference to a service managing a specific disk.
//
func (op *DisksService) DiskService(id string) *DiskService {
	return NewDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *DisksService) String() string {
	return fmt.Sprintf("DisksService:%s", op.path)
}

//
//
type VirtualFunctionAllowedNetworkService struct {
	BaseService
}

func NewVirtualFunctionAllowedNetworkService(connection *Connection, path string) *VirtualFunctionAllowedNetworkService {
	var result VirtualFunctionAllowedNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type VirtualFunctionAllowedNetworkServiceGetRequest struct {
	VirtualFunctionAllowedNetworkService *VirtualFunctionAllowedNetworkService
	header                               map[string]string
	query                                map[string]string
	follow                               *string
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Header(key, value string) *VirtualFunctionAllowedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Query(key, value string) *VirtualFunctionAllowedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Follow(follow string) *VirtualFunctionAllowedNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) Send() (*VirtualFunctionAllowedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VirtualFunctionAllowedNetworkService.connection.URL(), p.VirtualFunctionAllowedNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VirtualFunctionAllowedNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VirtualFunctionAllowedNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VirtualFunctionAllowedNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VirtualFunctionAllowedNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VirtualFunctionAllowedNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VirtualFunctionAllowedNetworkServiceGetResponse{network: result}, nil
}

func (p *VirtualFunctionAllowedNetworkServiceGetRequest) MustSend() *VirtualFunctionAllowedNetworkServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VirtualFunctionAllowedNetworkServiceGetResponse struct {
	network *Network
}

func (p *VirtualFunctionAllowedNetworkServiceGetResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *VirtualFunctionAllowedNetworkServiceGetResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
//
func (p *VirtualFunctionAllowedNetworkService) Get() *VirtualFunctionAllowedNetworkServiceGetRequest {
	return &VirtualFunctionAllowedNetworkServiceGetRequest{VirtualFunctionAllowedNetworkService: p}
}

//
//
type VirtualFunctionAllowedNetworkServiceRemoveRequest struct {
	VirtualFunctionAllowedNetworkService *VirtualFunctionAllowedNetworkService
	header                               map[string]string
	query                                map[string]string
	async                                *bool
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Header(key, value string) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Query(key, value string) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Async(async bool) *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) Send() (*VirtualFunctionAllowedNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VirtualFunctionAllowedNetworkService.connection.URL(), p.VirtualFunctionAllowedNetworkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VirtualFunctionAllowedNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VirtualFunctionAllowedNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VirtualFunctionAllowedNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VirtualFunctionAllowedNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VirtualFunctionAllowedNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VirtualFunctionAllowedNetworkServiceRemoveResponse), nil
}

func (p *VirtualFunctionAllowedNetworkServiceRemoveRequest) MustSend() *VirtualFunctionAllowedNetworkServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VirtualFunctionAllowedNetworkServiceRemoveResponse struct {
}

//
//
func (p *VirtualFunctionAllowedNetworkService) Remove() *VirtualFunctionAllowedNetworkServiceRemoveRequest {
	return &VirtualFunctionAllowedNetworkServiceRemoveRequest{VirtualFunctionAllowedNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VirtualFunctionAllowedNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VirtualFunctionAllowedNetworkService) String() string {
	return fmt.Sprintf("VirtualFunctionAllowedNetworkService:%s", op.path)
}

//
// Manages the set of scheduling policy units available in the system.
//
type SchedulingPolicyUnitsService struct {
	BaseService
}

func NewSchedulingPolicyUnitsService(connection *Connection, path string) *SchedulingPolicyUnitsService {
	var result SchedulingPolicyUnitsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of scheduling policy units available in the system.
// The order of the returned list of scheduling policy units isn't guaranteed.
//
type SchedulingPolicyUnitsServiceListRequest struct {
	SchedulingPolicyUnitsService *SchedulingPolicyUnitsService
	header                       map[string]string
	query                        map[string]string
	filter                       *bool
	follow                       *string
	max                          *int64
}

func (p *SchedulingPolicyUnitsServiceListRequest) Header(key, value string) *SchedulingPolicyUnitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Query(key, value string) *SchedulingPolicyUnitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Filter(filter bool) *SchedulingPolicyUnitsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Follow(follow string) *SchedulingPolicyUnitsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Max(max int64) *SchedulingPolicyUnitsServiceListRequest {
	p.max = &max
	return p
}

func (p *SchedulingPolicyUnitsServiceListRequest) Send() (*SchedulingPolicyUnitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SchedulingPolicyUnitsService.connection.URL(), p.SchedulingPolicyUnitsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SchedulingPolicyUnitsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SchedulingPolicyUnitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SchedulingPolicyUnitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SchedulingPolicyUnitsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SchedulingPolicyUnitsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyUnitReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &SchedulingPolicyUnitsServiceListResponse{units: result}, nil
}

func (p *SchedulingPolicyUnitsServiceListRequest) MustSend() *SchedulingPolicyUnitsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of scheduling policy units available in the system.
// The order of the returned list of scheduling policy units isn't guaranteed.
//
type SchedulingPolicyUnitsServiceListResponse struct {
	units *SchedulingPolicyUnitSlice
}

func (p *SchedulingPolicyUnitsServiceListResponse) Units() (*SchedulingPolicyUnitSlice, bool) {
	if p.units != nil {
		return p.units, true
	}
	return nil, false
}

func (p *SchedulingPolicyUnitsServiceListResponse) MustUnits() *SchedulingPolicyUnitSlice {
	if p.units == nil {
		panic("units in response does not exist")
	}
	return p.units
}

//
// Returns the list of scheduling policy units available in the system.
// The order of the returned list of scheduling policy units isn't guaranteed.
//
func (p *SchedulingPolicyUnitsService) List() *SchedulingPolicyUnitsServiceListRequest {
	return &SchedulingPolicyUnitsServiceListRequest{SchedulingPolicyUnitsService: p}
}

//
//
func (op *SchedulingPolicyUnitsService) UnitService(id string) *SchedulingPolicyUnitService {
	return NewSchedulingPolicyUnitService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyUnitsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.UnitService(path), nil
	}
	return op.UnitService(path[:index]).Service(path[index+1:])
}

func (op *SchedulingPolicyUnitsService) String() string {
	return fmt.Sprintf("SchedulingPolicyUnitsService:%s", op.path)
}

//
// Manages a single disk available in a storage domain attached to a data center.
// IMPORTANT: Since version 4.2 of the engine this service is intended only to list disks available in the storage
// domain, and to register unregistered disks. All the other operations, like copying a disk, moving a disk, etc, have
// been deprecated and will be removed in the future. To perform those operations use the <<services/disks, service
// that manages all the disks of the system>>, or the <<services/disk, service that manages an specific disk>>.
//
type AttachedStorageDomainDiskService struct {
	BaseService
}

func NewAttachedStorageDomainDiskService(connection *Connection, path string) *AttachedStorageDomainDiskService {
	var result AttachedStorageDomainDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceCopyRequest struct {
	AttachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	disk                             *Disk
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Header(key, value string) *AttachedStorageDomainDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Query(key, value string) *AttachedStorageDomainDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Disk(disk *Disk) *AttachedStorageDomainDiskServiceCopyRequest {
	p.disk = disk
	return p
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) Send() (*AttachedStorageDomainDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.AttachedStorageDomainDiskService.connection.URL(), p.AttachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceCopyResponse), nil
}

func (p *AttachedStorageDomainDiskServiceCopyRequest) MustSend() *AttachedStorageDomainDiskServiceCopyResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceCopyResponse struct {
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
func (p *AttachedStorageDomainDiskService) Copy() *AttachedStorageDomainDiskServiceCopyRequest {
	return &AttachedStorageDomainDiskServiceCopyRequest{AttachedStorageDomainDiskService: p}
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceExportRequest struct {
	AttachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceExportRequest) Header(key, value string) *AttachedStorageDomainDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceExportRequest) Query(key, value string) *AttachedStorageDomainDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *AttachedStorageDomainDiskServiceExportRequest) Send() (*AttachedStorageDomainDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.AttachedStorageDomainDiskService.connection.URL(), p.AttachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceExportResponse), nil
}

func (p *AttachedStorageDomainDiskServiceExportRequest) MustSend() *AttachedStorageDomainDiskServiceExportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
func (p *AttachedStorageDomainDiskService) Export() *AttachedStorageDomainDiskServiceExportRequest {
	return &AttachedStorageDomainDiskServiceExportRequest{AttachedStorageDomainDiskService: p}
}

//
// Retrieves the description of the disk.
//
type AttachedStorageDomainDiskServiceGetRequest struct {
	AttachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	follow                           *string
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Header(key, value string) *AttachedStorageDomainDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Query(key, value string) *AttachedStorageDomainDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Follow(follow string) *AttachedStorageDomainDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AttachedStorageDomainDiskServiceGetRequest) Send() (*AttachedStorageDomainDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainDiskService.connection.URL(), p.AttachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AttachedStorageDomainDiskServiceGetResponse{disk: result}, nil
}

func (p *AttachedStorageDomainDiskServiceGetRequest) MustSend() *AttachedStorageDomainDiskServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the description of the disk.
//
type AttachedStorageDomainDiskServiceGetResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *AttachedStorageDomainDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (p *AttachedStorageDomainDiskService) Get() *AttachedStorageDomainDiskServiceGetRequest {
	return &AttachedStorageDomainDiskServiceGetRequest{AttachedStorageDomainDiskService: p}
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceMoveRequest struct {
	AttachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	async                            *bool
	filter                           *bool
	storageDomain                    *StorageDomain
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Header(key, value string) *AttachedStorageDomainDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Query(key, value string) *AttachedStorageDomainDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Async(async bool) *AttachedStorageDomainDiskServiceMoveRequest {
	p.async = &async
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Filter(filter bool) *AttachedStorageDomainDiskServiceMoveRequest {
	p.filter = &filter
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainDiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) Send() (*AttachedStorageDomainDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.AttachedStorageDomainDiskService.connection.URL(), p.AttachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceMoveResponse), nil
}

func (p *AttachedStorageDomainDiskServiceMoveRequest) MustSend() *AttachedStorageDomainDiskServiceMoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
func (p *AttachedStorageDomainDiskService) Move() *AttachedStorageDomainDiskServiceMoveRequest {
	return &AttachedStorageDomainDiskServiceMoveRequest{AttachedStorageDomainDiskService: p}
}

//
// Registers an unregistered disk.
//
type AttachedStorageDomainDiskServiceRegisterRequest struct {
	AttachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Header(key, value string) *AttachedStorageDomainDiskServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Query(key, value string) *AttachedStorageDomainDiskServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) Send() (*AttachedStorageDomainDiskServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.AttachedStorageDomainDiskService.connection.URL(), p.AttachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceRegisterResponse), nil
}

func (p *AttachedStorageDomainDiskServiceRegisterRequest) MustSend() *AttachedStorageDomainDiskServiceRegisterResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Registers an unregistered disk.
//
type AttachedStorageDomainDiskServiceRegisterResponse struct {
}

//
// Registers an unregistered disk.
//
func (p *AttachedStorageDomainDiskService) Register() *AttachedStorageDomainDiskServiceRegisterRequest {
	return &AttachedStorageDomainDiskServiceRegisterRequest{AttachedStorageDomainDiskService: p}
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceRemoveRequest struct {
	AttachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Header(key, value string) *AttachedStorageDomainDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Query(key, value string) *AttachedStorageDomainDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) Send() (*AttachedStorageDomainDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainDiskService.connection.URL(), p.AttachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AttachedStorageDomainDiskServiceRemoveResponse), nil
}

func (p *AttachedStorageDomainDiskServiceRemoveRequest) MustSend() *AttachedStorageDomainDiskServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceRemoveResponse struct {
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (p *AttachedStorageDomainDiskService) Remove() *AttachedStorageDomainDiskServiceRemoveRequest {
	return &AttachedStorageDomainDiskServiceRemoveRequest{AttachedStorageDomainDiskService: p}
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceSparsifyRequest struct {
	AttachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Header(key, value string) *AttachedStorageDomainDiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Query(key, value string) *AttachedStorageDomainDiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) Send() (*AttachedStorageDomainDiskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.AttachedStorageDomainDiskService.connection.URL(), p.AttachedStorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainDiskServiceSparsifyResponse), nil
}

func (p *AttachedStorageDomainDiskServiceSparsifyRequest) MustSend() *AttachedStorageDomainDiskServiceSparsifyResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (p *AttachedStorageDomainDiskService) Sparsify() *AttachedStorageDomainDiskServiceSparsifyRequest {
	return &AttachedStorageDomainDiskServiceSparsifyRequest{AttachedStorageDomainDiskService: p}
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceUpdateRequest struct {
	AttachedStorageDomainDiskService *AttachedStorageDomainDiskService
	header                           map[string]string
	query                            map[string]string
	disk                             *Disk
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Header(key, value string) *AttachedStorageDomainDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Query(key, value string) *AttachedStorageDomainDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Disk(disk *Disk) *AttachedStorageDomainDiskServiceUpdateRequest {
	p.disk = disk
	return p
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) Send() (*AttachedStorageDomainDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainDiskService.connection.URL(), p.AttachedStorageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AttachedStorageDomainDiskServiceUpdateResponse{disk: result}, nil
}

func (p *AttachedStorageDomainDiskServiceUpdateRequest) MustSend() *AttachedStorageDomainDiskServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
type AttachedStorageDomainDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDiskServiceUpdateResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *AttachedStorageDomainDiskServiceUpdateResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
func (p *AttachedStorageDomainDiskService) Update() *AttachedStorageDomainDiskServiceUpdateRequest {
	return &AttachedStorageDomainDiskServiceUpdateRequest{AttachedStorageDomainDiskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *AttachedStorageDomainDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *AttachedStorageDomainDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AttachedStorageDomainDiskService) String() string {
	return fmt.Sprintf("AttachedStorageDomainDiskService:%s", op.path)
}

//
// Describes how an external network provider is provisioned by the system on the host.
//
type ExternalNetworkProviderConfigurationService struct {
	BaseService
}

func NewExternalNetworkProviderConfigurationService(connection *Connection, path string) *ExternalNetworkProviderConfigurationService {
	var result ExternalNetworkProviderConfigurationService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about an external network provider on the host.
//
type ExternalNetworkProviderConfigurationServiceGetRequest struct {
	ExternalNetworkProviderConfigurationService *ExternalNetworkProviderConfigurationService
	header                                      map[string]string
	query                                       map[string]string
	follow                                      *string
}

func (p *ExternalNetworkProviderConfigurationServiceGetRequest) Header(key, value string) *ExternalNetworkProviderConfigurationServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalNetworkProviderConfigurationServiceGetRequest) Query(key, value string) *ExternalNetworkProviderConfigurationServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalNetworkProviderConfigurationServiceGetRequest) Follow(follow string) *ExternalNetworkProviderConfigurationServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ExternalNetworkProviderConfigurationServiceGetRequest) Send() (*ExternalNetworkProviderConfigurationServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalNetworkProviderConfigurationService.connection.URL(), p.ExternalNetworkProviderConfigurationService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalNetworkProviderConfigurationService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalNetworkProviderConfigurationService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalNetworkProviderConfigurationService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalNetworkProviderConfigurationService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalNetworkProviderConfigurationService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalNetworkProviderConfigurationReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalNetworkProviderConfigurationServiceGetResponse{configuration: result}, nil
}

func (p *ExternalNetworkProviderConfigurationServiceGetRequest) MustSend() *ExternalNetworkProviderConfigurationServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the information about an external network provider on the host.
//
type ExternalNetworkProviderConfigurationServiceGetResponse struct {
	configuration *ExternalNetworkProviderConfiguration
}

func (p *ExternalNetworkProviderConfigurationServiceGetResponse) Configuration() (*ExternalNetworkProviderConfiguration, bool) {
	if p.configuration != nil {
		return p.configuration, true
	}
	return nil, false
}

func (p *ExternalNetworkProviderConfigurationServiceGetResponse) MustConfiguration() *ExternalNetworkProviderConfiguration {
	if p.configuration == nil {
		panic("configuration in response does not exist")
	}
	return p.configuration
}

//
// Returns the information about an external network provider on the host.
//
func (p *ExternalNetworkProviderConfigurationService) Get() *ExternalNetworkProviderConfigurationServiceGetRequest {
	return &ExternalNetworkProviderConfigurationServiceGetRequest{ExternalNetworkProviderConfigurationService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalNetworkProviderConfigurationService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalNetworkProviderConfigurationService) String() string {
	return fmt.Sprintf("ExternalNetworkProviderConfigurationService:%s", op.path)
}

//
// Manages the set of scheduling policies available in the system.
//
type SchedulingPoliciesService struct {
	BaseService
}

func NewSchedulingPoliciesService(connection *Connection, path string) *SchedulingPoliciesService {
	var result SchedulingPoliciesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new scheduling policy to the system.
//
type SchedulingPoliciesServiceAddRequest struct {
	SchedulingPoliciesService *SchedulingPoliciesService
	header                    map[string]string
	query                     map[string]string
	policy                    *SchedulingPolicy
}

func (p *SchedulingPoliciesServiceAddRequest) Header(key, value string) *SchedulingPoliciesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPoliciesServiceAddRequest) Query(key, value string) *SchedulingPoliciesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPoliciesServiceAddRequest) Policy(policy *SchedulingPolicy) *SchedulingPoliciesServiceAddRequest {
	p.policy = policy
	return p
}

func (p *SchedulingPoliciesServiceAddRequest) Send() (*SchedulingPoliciesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SchedulingPoliciesService.connection.URL(), p.SchedulingPoliciesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSchedulingPolicyWriteOne(writer, p.policy, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SchedulingPoliciesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SchedulingPoliciesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SchedulingPoliciesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SchedulingPoliciesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SchedulingPoliciesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SchedulingPoliciesServiceAddResponse{policy: result}, nil
}

func (p *SchedulingPoliciesServiceAddRequest) MustSend() *SchedulingPoliciesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new scheduling policy to the system.
//
type SchedulingPoliciesServiceAddResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPoliciesServiceAddResponse) Policy() (*SchedulingPolicy, bool) {
	if p.policy != nil {
		return p.policy, true
	}
	return nil, false
}

func (p *SchedulingPoliciesServiceAddResponse) MustPolicy() *SchedulingPolicy {
	if p.policy == nil {
		panic("policy in response does not exist")
	}
	return p.policy
}

//
// Add a new scheduling policy to the system.
//
func (p *SchedulingPoliciesService) Add() *SchedulingPoliciesServiceAddRequest {
	return &SchedulingPoliciesServiceAddRequest{SchedulingPoliciesService: p}
}

//
// Returns the list of scheduling policies available in the system.
// The order of the returned list of scheduling policies isn't guaranteed.
//
type SchedulingPoliciesServiceListRequest struct {
	SchedulingPoliciesService *SchedulingPoliciesService
	header                    map[string]string
	query                     map[string]string
	filter                    *bool
	follow                    *string
	max                       *int64
}

func (p *SchedulingPoliciesServiceListRequest) Header(key, value string) *SchedulingPoliciesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Query(key, value string) *SchedulingPoliciesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Filter(filter bool) *SchedulingPoliciesServiceListRequest {
	p.filter = &filter
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Follow(follow string) *SchedulingPoliciesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Max(max int64) *SchedulingPoliciesServiceListRequest {
	p.max = &max
	return p
}

func (p *SchedulingPoliciesServiceListRequest) Send() (*SchedulingPoliciesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SchedulingPoliciesService.connection.URL(), p.SchedulingPoliciesService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SchedulingPoliciesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SchedulingPoliciesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SchedulingPoliciesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SchedulingPoliciesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SchedulingPoliciesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &SchedulingPoliciesServiceListResponse{policies: result}, nil
}

func (p *SchedulingPoliciesServiceListRequest) MustSend() *SchedulingPoliciesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of scheduling policies available in the system.
// The order of the returned list of scheduling policies isn't guaranteed.
//
type SchedulingPoliciesServiceListResponse struct {
	policies *SchedulingPolicySlice
}

func (p *SchedulingPoliciesServiceListResponse) Policies() (*SchedulingPolicySlice, bool) {
	if p.policies != nil {
		return p.policies, true
	}
	return nil, false
}

func (p *SchedulingPoliciesServiceListResponse) MustPolicies() *SchedulingPolicySlice {
	if p.policies == nil {
		panic("policies in response does not exist")
	}
	return p.policies
}

//
// Returns the list of scheduling policies available in the system.
// The order of the returned list of scheduling policies isn't guaranteed.
//
func (p *SchedulingPoliciesService) List() *SchedulingPoliciesServiceListRequest {
	return &SchedulingPoliciesServiceListRequest{SchedulingPoliciesService: p}
}

//
//
func (op *SchedulingPoliciesService) PolicyService(id string) *SchedulingPolicyService {
	return NewSchedulingPolicyService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPoliciesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PolicyService(path), nil
	}
	return op.PolicyService(path[:index]).Service(path[index+1:])
}

func (op *SchedulingPoliciesService) String() string {
	return fmt.Sprintf("SchedulingPoliciesService:%s", op.path)
}

//
//
type ImageService struct {
	BaseService
}

func NewImageService(connection *Connection, path string) *ImageService {
	var result ImageService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type ImageServiceGetRequest struct {
	ImageService *ImageService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *ImageServiceGetRequest) Header(key, value string) *ImageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageServiceGetRequest) Query(key, value string) *ImageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageServiceGetRequest) Follow(follow string) *ImageServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ImageServiceGetRequest) Send() (*ImageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ImageService.connection.URL(), p.ImageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ImageServiceGetResponse{image: result}, nil
}

func (p *ImageServiceGetRequest) MustSend() *ImageServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type ImageServiceGetResponse struct {
	image *Image
}

func (p *ImageServiceGetResponse) Image() (*Image, bool) {
	if p.image != nil {
		return p.image, true
	}
	return nil, false
}

func (p *ImageServiceGetResponse) MustImage() *Image {
	if p.image == nil {
		panic("image in response does not exist")
	}
	return p.image
}

//
//
func (p *ImageService) Get() *ImageServiceGetRequest {
	return &ImageServiceGetRequest{ImageService: p}
}

//
// Imports an image.
// If the `import_as_template` parameter is `true` then the image will be imported as a template, otherwise it will
// be imported as a disk.
// When imported as a template, the name of the template can be specified by the optional `template.name`
// parameter. If that parameter is not specified, then the name of the template will be automatically assigned by the
// engine as `GlanceTemplate-x` (where `x` will be seven random hexadecimal characters).
// When imported as a disk, the name of the disk can be specified by the optional `disk.name` parameter. If
// that parameter is not specified, then the name of the disk will be automatically assigned by the engine as
// `GlanceDisk-x` (where `x` will be the seven hexadecimal characters of the image identifier).
// It is recommended to always explicitly specify the template or disk name, to avoid these automatic names
// generated by the engine.
//
type ImageServiceImportRequest struct {
	ImageService     *ImageService
	header           map[string]string
	query            map[string]string
	async            *bool
	cluster          *Cluster
	disk             *Disk
	importAsTemplate *bool
	storageDomain    *StorageDomain
	template         *Template
}

func (p *ImageServiceImportRequest) Header(key, value string) *ImageServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageServiceImportRequest) Query(key, value string) *ImageServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageServiceImportRequest) Async(async bool) *ImageServiceImportRequest {
	p.async = &async
	return p
}

func (p *ImageServiceImportRequest) Cluster(cluster *Cluster) *ImageServiceImportRequest {
	p.cluster = cluster
	return p
}

func (p *ImageServiceImportRequest) Disk(disk *Disk) *ImageServiceImportRequest {
	p.disk = disk
	return p
}

func (p *ImageServiceImportRequest) ImportAsTemplate(importAsTemplate bool) *ImageServiceImportRequest {
	p.importAsTemplate = &importAsTemplate
	return p
}

func (p *ImageServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *ImageServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *ImageServiceImportRequest) Template(template *Template) *ImageServiceImportRequest {
	p.template = template
	return p
}

func (p *ImageServiceImportRequest) Send() (*ImageServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.ImageService.connection.URL(), p.ImageService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Disk(p.disk)
	if p.importAsTemplate != nil {
		actionBuilder.ImportAsTemplate(*p.importAsTemplate)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageServiceImportResponse), nil
}

func (p *ImageServiceImportRequest) MustSend() *ImageServiceImportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Imports an image.
// If the `import_as_template` parameter is `true` then the image will be imported as a template, otherwise it will
// be imported as a disk.
// When imported as a template, the name of the template can be specified by the optional `template.name`
// parameter. If that parameter is not specified, then the name of the template will be automatically assigned by the
// engine as `GlanceTemplate-x` (where `x` will be seven random hexadecimal characters).
// When imported as a disk, the name of the disk can be specified by the optional `disk.name` parameter. If
// that parameter is not specified, then the name of the disk will be automatically assigned by the engine as
// `GlanceDisk-x` (where `x` will be the seven hexadecimal characters of the image identifier).
// It is recommended to always explicitly specify the template or disk name, to avoid these automatic names
// generated by the engine.
//
type ImageServiceImportResponse struct {
}

//
// Imports an image.
// If the `import_as_template` parameter is `true` then the image will be imported as a template, otherwise it will
// be imported as a disk.
// When imported as a template, the name of the template can be specified by the optional `template.name`
// parameter. If that parameter is not specified, then the name of the template will be automatically assigned by the
// engine as `GlanceTemplate-x` (where `x` will be seven random hexadecimal characters).
// When imported as a disk, the name of the disk can be specified by the optional `disk.name` parameter. If
// that parameter is not specified, then the name of the disk will be automatically assigned by the engine as
// `GlanceDisk-x` (where `x` will be the seven hexadecimal characters of the image identifier).
// It is recommended to always explicitly specify the template or disk name, to avoid these automatic names
// generated by the engine.
//
func (p *ImageService) Import() *ImageServiceImportRequest {
	return &ImageServiceImportRequest{ImageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ImageService) String() string {
	return fmt.Sprintf("ImageService:%s", op.path)
}

//
// A service to manage a network interface of a host.
//
type HostNicService struct {
	BaseService
}

func NewHostNicService(connection *Connection, path string) *HostNicService {
	var result HostNicService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type HostNicServiceGetRequest struct {
	HostNicService *HostNicService
	header         map[string]string
	query          map[string]string
	allContent     *bool
	follow         *string
}

func (p *HostNicServiceGetRequest) Header(key, value string) *HostNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicServiceGetRequest) Query(key, value string) *HostNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicServiceGetRequest) AllContent(allContent bool) *HostNicServiceGetRequest {
	p.allContent = &allContent
	return p
}

func (p *HostNicServiceGetRequest) Follow(follow string) *HostNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *HostNicServiceGetRequest) Send() (*HostNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostNicService.connection.URL(), p.HostNicService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &HostNicServiceGetResponse{nic: result}, nil
}

func (p *HostNicServiceGetRequest) MustSend() *HostNicServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type HostNicServiceGetResponse struct {
	nic *HostNic
}

func (p *HostNicServiceGetResponse) Nic() (*HostNic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *HostNicServiceGetResponse) MustNic() *HostNic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
//
func (p *HostNicService) Get() *HostNicServiceGetRequest {
	return &HostNicServiceGetRequest{HostNicService: p}
}

//
// The action updates virtual function configuration in case the current resource represents an SR-IOV enabled NIC.
// The input should be consisted of at least one of the following properties:
// - `allNetworksAllowed`
// - `numberOfVirtualFunctions`
// Please see the `HostNicVirtualFunctionsConfiguration` type for the meaning of the properties.
//
type HostNicServiceUpdateVirtualFunctionsConfigurationRequest struct {
	HostNicService                *HostNicService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
	virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Header(key, value string) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Query(key, value string) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Async(async bool) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	p.async = &async
	return p
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) VirtualFunctionsConfiguration(virtualFunctionsConfiguration *HostNicVirtualFunctionsConfiguration) *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	p.virtualFunctionsConfiguration = virtualFunctionsConfiguration
	return p
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) Send() (*HostNicServiceUpdateVirtualFunctionsConfigurationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/updatevirtualfunctionsconfiguration", p.HostNicService.connection.URL(), p.HostNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.VirtualFunctionsConfiguration(p.virtualFunctionsConfiguration)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostNicServiceUpdateVirtualFunctionsConfigurationResponse), nil
}

func (p *HostNicServiceUpdateVirtualFunctionsConfigurationRequest) MustSend() *HostNicServiceUpdateVirtualFunctionsConfigurationResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// The action updates virtual function configuration in case the current resource represents an SR-IOV enabled NIC.
// The input should be consisted of at least one of the following properties:
// - `allNetworksAllowed`
// - `numberOfVirtualFunctions`
// Please see the `HostNicVirtualFunctionsConfiguration` type for the meaning of the properties.
//
type HostNicServiceUpdateVirtualFunctionsConfigurationResponse struct {
}

//
// The action updates virtual function configuration in case the current resource represents an SR-IOV enabled NIC.
// The input should be consisted of at least one of the following properties:
// - `allNetworksAllowed`
// - `numberOfVirtualFunctions`
// Please see the `HostNicVirtualFunctionsConfiguration` type for the meaning of the properties.
//
func (p *HostNicService) UpdateVirtualFunctionsConfiguration() *HostNicServiceUpdateVirtualFunctionsConfigurationRequest {
	return &HostNicServiceUpdateVirtualFunctionsConfigurationRequest{HostNicService: p}
}

//
// A reference to information elements received by LLDP on the NIC.
//
func (op *HostNicService) LinkLayerDiscoveryProtocolElementsService() *LinkLayerDiscoveryProtocolService {
	return NewLinkLayerDiscoveryProtocolService(op.connection, fmt.Sprintf("%s/linklayerdiscoveryprotocolelements", op.path))
}

//
// Reference to the service that manages the network attachments assigned to this network interface.
//
func (op *HostNicService) NetworkAttachmentsService() *NetworkAttachmentsService {
	return NewNetworkAttachmentsService(op.connection, fmt.Sprintf("%s/networkattachments", op.path))
}

//
// Reference to the service that manages the network labels assigned to this network interface.
//
func (op *HostNicService) NetworkLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.connection, fmt.Sprintf("%s/networklabels", op.path))
}

//
//
func (op *HostNicService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Retrieves sub-collection resource of network labels that are allowed on an the virtual functions
// in case that the current resource represents an SR-IOV physical function NIC.
//
func (op *HostNicService) VirtualFunctionAllowedLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.connection, fmt.Sprintf("%s/virtualfunctionallowedlabels", op.path))
}

//
// Retrieves sub-collection resource of networks that are allowed on an the virtual functions
// in case that the current resource represents an SR-IOV physical function NIC.
//
func (op *HostNicService) VirtualFunctionAllowedNetworksService() *VirtualFunctionAllowedNetworksService {
	return NewVirtualFunctionAllowedNetworksService(op.connection, fmt.Sprintf("%s/virtualfunctionallowednetworks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "linklayerdiscoveryprotocolelements" {
		return op.LinkLayerDiscoveryProtocolElementsService(), nil
	}
	if strings.HasPrefix(path, "linklayerdiscoveryprotocolelements/") {
		return op.LinkLayerDiscoveryProtocolElementsService().Service(path[35:])
	}
	if path == "networkattachments" {
		return op.NetworkAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "networkattachments/") {
		return op.NetworkAttachmentsService().Service(path[19:])
	}
	if path == "networklabels" {
		return op.NetworkLabelsService(), nil
	}
	if strings.HasPrefix(path, "networklabels/") {
		return op.NetworkLabelsService().Service(path[14:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "virtualfunctionallowedlabels" {
		return op.VirtualFunctionAllowedLabelsService(), nil
	}
	if strings.HasPrefix(path, "virtualfunctionallowedlabels/") {
		return op.VirtualFunctionAllowedLabelsService().Service(path[29:])
	}
	if path == "virtualfunctionallowednetworks" {
		return op.VirtualFunctionAllowedNetworksService(), nil
	}
	if strings.HasPrefix(path, "virtualfunctionallowednetworks/") {
		return op.VirtualFunctionAllowedNetworksService().Service(path[31:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostNicService) String() string {
	return fmt.Sprintf("HostNicService:%s", op.path)
}

//
//
type VmNicsService struct {
	BaseService
}

func NewVmNicsService(connection *Connection, path string) *VmNicsService {
	var result VmNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a NIC to the virtual machine.
// The following example adds to the virtual machine `123` a network interface named `mynic` using `virtio` and the
// NIC profile `456`.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/nics
// ----
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ----
// The following example sends that request using `curl`:
// [source,bash]
// ----
// curl \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --data '
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ' \
// https://myengine.example.com/ovirt-engine/api/vms/123/nics
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type VmNicsServiceAddRequest struct {
	VmNicsService *VmNicsService
	header        map[string]string
	query         map[string]string
	nic           *Nic
}

func (p *VmNicsServiceAddRequest) Header(key, value string) *VmNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicsServiceAddRequest) Query(key, value string) *VmNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicsServiceAddRequest) Nic(nic *Nic) *VmNicsServiceAddRequest {
	p.nic = nic
	return p
}

func (p *VmNicsServiceAddRequest) Send() (*VmNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNicsService.connection.URL(), p.VmNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNicsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNicsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNicsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmNicsServiceAddResponse{nic: result}, nil
}

func (p *VmNicsServiceAddRequest) MustSend() *VmNicsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a NIC to the virtual machine.
// The following example adds to the virtual machine `123` a network interface named `mynic` using `virtio` and the
// NIC profile `456`.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/nics
// ----
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ----
// The following example sends that request using `curl`:
// [source,bash]
// ----
// curl \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --data '
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ' \
// https://myengine.example.com/ovirt-engine/api/vms/123/nics
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type VmNicsServiceAddResponse struct {
	nic *Nic
}

func (p *VmNicsServiceAddResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *VmNicsServiceAddResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Adds a NIC to the virtual machine.
// The following example adds to the virtual machine `123` a network interface named `mynic` using `virtio` and the
// NIC profile `456`.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/nics
// ----
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ----
// The following example sends that request using `curl`:
// [source,bash]
// ----
// curl \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --data '
// <nic>
//   <name>mynic</name>
//   <interface>virtio</interface>
//   <vnic_profile id="456"/>
// </nic>
// ' \
// https://myengine.example.com/ovirt-engine/api/vms/123/nics
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
func (p *VmNicsService) Add() *VmNicsServiceAddRequest {
	return &VmNicsServiceAddRequest{VmNicsService: p}
}

//
// Returns the list of NICs of the virtual machine.
// The order of the returned list of NICs isn't guaranteed.
//
type VmNicsServiceListRequest struct {
	VmNicsService *VmNicsService
	header        map[string]string
	query         map[string]string
	follow        *string
	max           *int64
}

func (p *VmNicsServiceListRequest) Header(key, value string) *VmNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicsServiceListRequest) Query(key, value string) *VmNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicsServiceListRequest) Follow(follow string) *VmNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmNicsServiceListRequest) Max(max int64) *VmNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *VmNicsServiceListRequest) Send() (*VmNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNicsService.connection.URL(), p.VmNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNicsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNicsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNicsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmNicsServiceListResponse{nics: result}, nil
}

func (p *VmNicsServiceListRequest) MustSend() *VmNicsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of NICs of the virtual machine.
// The order of the returned list of NICs isn't guaranteed.
//
type VmNicsServiceListResponse struct {
	nics *NicSlice
}

func (p *VmNicsServiceListResponse) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *VmNicsServiceListResponse) MustNics() *NicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Returns the list of NICs of the virtual machine.
// The order of the returned list of NICs isn't guaranteed.
//
func (p *VmNicsService) List() *VmNicsServiceListRequest {
	return &VmNicsServiceListRequest{VmNicsService: p}
}

//
//
func (op *VmNicsService) NicService(id string) *VmNicService {
	return NewVmNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *VmNicsService) String() string {
	return fmt.Sprintf("VmNicsService:%s", op.path)
}

//
// This service manages a vNIC profile.
//
type VnicProfileService struct {
	BaseService
}

func NewVnicProfileService(connection *Connection, path string) *VnicProfileService {
	var result VnicProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves details about a vNIC profile.
//
type VnicProfileServiceGetRequest struct {
	VnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *VnicProfileServiceGetRequest) Header(key, value string) *VnicProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceGetRequest) Query(key, value string) *VnicProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceGetRequest) Follow(follow string) *VnicProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VnicProfileServiceGetRequest) Send() (*VnicProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VnicProfileService.connection.URL(), p.VnicProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VnicProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VnicProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VnicProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VnicProfileServiceGetResponse{profile: result}, nil
}

func (p *VnicProfileServiceGetRequest) MustSend() *VnicProfileServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves details about a vNIC profile.
//
type VnicProfileServiceGetResponse struct {
	profile *VnicProfile
}

func (p *VnicProfileServiceGetResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *VnicProfileServiceGetResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Retrieves details about a vNIC profile.
//
func (p *VnicProfileService) Get() *VnicProfileServiceGetRequest {
	return &VnicProfileServiceGetRequest{VnicProfileService: p}
}

//
// Removes the vNIC profile.
//
type VnicProfileServiceRemoveRequest struct {
	VnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *VnicProfileServiceRemoveRequest) Header(key, value string) *VnicProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceRemoveRequest) Query(key, value string) *VnicProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceRemoveRequest) Async(async bool) *VnicProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VnicProfileServiceRemoveRequest) Send() (*VnicProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VnicProfileService.connection.URL(), p.VnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VnicProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VnicProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VnicProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VnicProfileServiceRemoveResponse), nil
}

func (p *VnicProfileServiceRemoveRequest) MustSend() *VnicProfileServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the vNIC profile.
//
type VnicProfileServiceRemoveResponse struct {
}

//
// Removes the vNIC profile.
//
func (p *VnicProfileService) Remove() *VnicProfileServiceRemoveRequest {
	return &VnicProfileServiceRemoveRequest{VnicProfileService: p}
}

//
// Updates details of a vNIC profile.
//
type VnicProfileServiceUpdateRequest struct {
	VnicProfileService *VnicProfileService
	header             map[string]string
	query              map[string]string
	async              *bool
	profile            *VnicProfile
}

func (p *VnicProfileServiceUpdateRequest) Header(key, value string) *VnicProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfileServiceUpdateRequest) Query(key, value string) *VnicProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfileServiceUpdateRequest) Async(async bool) *VnicProfileServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *VnicProfileServiceUpdateRequest) Profile(profile *VnicProfile) *VnicProfileServiceUpdateRequest {
	p.profile = profile
	return p
}

func (p *VnicProfileServiceUpdateRequest) Send() (*VnicProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VnicProfileService.connection.URL(), p.VnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VnicProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VnicProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VnicProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VnicProfileServiceUpdateResponse{profile: result}, nil
}

func (p *VnicProfileServiceUpdateRequest) MustSend() *VnicProfileServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates details of a vNIC profile.
//
type VnicProfileServiceUpdateResponse struct {
	profile *VnicProfile
}

func (p *VnicProfileServiceUpdateResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *VnicProfileServiceUpdateResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Updates details of a vNIC profile.
//
func (p *VnicProfileService) Update() *VnicProfileServiceUpdateRequest {
	return &VnicProfileServiceUpdateRequest{VnicProfileService: p}
}

//
//
func (op *VnicProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VnicProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VnicProfileService) String() string {
	return fmt.Sprintf("VnicProfileService:%s", op.path)
}

//
// Represents a readonly network filters sub-collection.
// The network filter enables to filter packets send to/from the VM's nic according to defined rules.
// For more information please refer to <<services/network_filter,NetworkFilter>> service documentation
// Network filters are supported in different versions, starting from version 3.0.
// A network filter is defined for each vnic profile.
// A vnic profile is defined for a specific network.
// A network can be assigned to several different clusters. In the future, each network will be defined in
// cluster level.
// Currently, each network is being defined at data center level. Potential network filters for each network
// are determined by the network's data center compatibility version V.
// V must be >= the network filter version in order to configure this network filter for a specific network.
// Please note, that if a network is assigned to cluster with a version supporting a network filter, the filter
// may not be available due to the data center version being smaller then the network filter's version.
// Example of listing all of the supported network filters for a specific cluster:
// [source]
// ----
// GET http://localhost:8080/ovirt-engine/api/clusters/{cluster:id}/networkfilters
// ----
// Output:
// [source,xml]
// ----
// <network_filters>
//   <network_filter id="00000019-0019-0019-0019-00000000026c">
//     <name>example-network-filter-a</name>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
//   <network_filter id="00000019-0019-0019-0019-00000000026b">
//     <name>example-network-filter-b</name>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
//   <network_filter id="00000019-0019-0019-0019-00000000026a">
//     <name>example-network-filter-a</name>
//     <version>
//       <major>3</major>
//       <minor>0</minor>
//       <build>-1</build>
//       <revision>-1</revision>
//     </version>
//   </network_filter>
// </network_filters>
// ----
//
type NetworkFiltersService struct {
	BaseService
}

func NewNetworkFiltersService(connection *Connection, path string) *NetworkFiltersService {
	var result NetworkFiltersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the representations of the network filters.
// The order of the returned list of network filters isn't guaranteed.
//
type NetworkFiltersServiceListRequest struct {
	NetworkFiltersService *NetworkFiltersService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *NetworkFiltersServiceListRequest) Header(key, value string) *NetworkFiltersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFiltersServiceListRequest) Query(key, value string) *NetworkFiltersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFiltersServiceListRequest) Follow(follow string) *NetworkFiltersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *NetworkFiltersServiceListRequest) Send() (*NetworkFiltersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkFiltersService.connection.URL(), p.NetworkFiltersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkFiltersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkFiltersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkFiltersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkFiltersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkFiltersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &NetworkFiltersServiceListResponse{filters: result}, nil
}

func (p *NetworkFiltersServiceListRequest) MustSend() *NetworkFiltersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the representations of the network filters.
// The order of the returned list of network filters isn't guaranteed.
//
type NetworkFiltersServiceListResponse struct {
	filters *NetworkFilterSlice
}

func (p *NetworkFiltersServiceListResponse) Filters() (*NetworkFilterSlice, bool) {
	if p.filters != nil {
		return p.filters, true
	}
	return nil, false
}

func (p *NetworkFiltersServiceListResponse) MustFilters() *NetworkFilterSlice {
	if p.filters == nil {
		panic("filters in response does not exist")
	}
	return p.filters
}

//
// Retrieves the representations of the network filters.
// The order of the returned list of network filters isn't guaranteed.
//
func (p *NetworkFiltersService) List() *NetworkFiltersServiceListRequest {
	return &NetworkFiltersServiceListRequest{NetworkFiltersService: p}
}

//
//
func (op *NetworkFiltersService) NetworkFilterService(id string) *NetworkFilterService {
	return NewNetworkFilterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFiltersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkFilterService(path), nil
	}
	return op.NetworkFilterService(path[:index]).Service(path[index+1:])
}

func (op *NetworkFiltersService) String() string {
	return fmt.Sprintf("NetworkFiltersService:%s", op.path)
}

//
// A service that provides information about an application installed in a virtual machine.
//
type VmApplicationService struct {
	BaseService
}

func NewVmApplicationService(connection *Connection, path string) *VmApplicationService {
	var result VmApplicationService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about the application.
//
type VmApplicationServiceGetRequest struct {
	VmApplicationService *VmApplicationService
	header               map[string]string
	query                map[string]string
	filter               *bool
	follow               *string
}

func (p *VmApplicationServiceGetRequest) Header(key, value string) *VmApplicationServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmApplicationServiceGetRequest) Query(key, value string) *VmApplicationServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmApplicationServiceGetRequest) Filter(filter bool) *VmApplicationServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *VmApplicationServiceGetRequest) Follow(follow string) *VmApplicationServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmApplicationServiceGetRequest) Send() (*VmApplicationServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmApplicationService.connection.URL(), p.VmApplicationService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmApplicationService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmApplicationService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmApplicationService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmApplicationService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmApplicationService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApplicationReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmApplicationServiceGetResponse{application: result}, nil
}

func (p *VmApplicationServiceGetRequest) MustSend() *VmApplicationServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the information about the application.
//
type VmApplicationServiceGetResponse struct {
	application *Application
}

func (p *VmApplicationServiceGetResponse) Application() (*Application, bool) {
	if p.application != nil {
		return p.application, true
	}
	return nil, false
}

func (p *VmApplicationServiceGetResponse) MustApplication() *Application {
	if p.application == nil {
		panic("application in response does not exist")
	}
	return p.application
}

//
// Returns the information about the application.
//
func (p *VmApplicationService) Get() *VmApplicationServiceGetRequest {
	return &VmApplicationServiceGetRequest{VmApplicationService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmApplicationService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmApplicationService) String() string {
	return fmt.Sprintf("VmApplicationService:%s", op.path)
}

//
//
type VmNumaNodesService struct {
	BaseService
}

func NewVmNumaNodesService(connection *Connection, path string) *VmNumaNodesService {
	var result VmNumaNodesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new virtual NUMA node for the virtual machine.
// An example of creating a NUMA node:
// [source]
// ----
// POST /ovirt-engine/api/vms/c7ecd2dc/numanodes
// Accept: application/xml
// Content-type: application/xml
// ----
// The request body can contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>1024</memory>
// </vm_numa_node>
// ----
//
type VmNumaNodesServiceAddRequest struct {
	VmNumaNodesService *VmNumaNodesService
	header             map[string]string
	query              map[string]string
	node               *VirtualNumaNode
}

func (p *VmNumaNodesServiceAddRequest) Header(key, value string) *VmNumaNodesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodesServiceAddRequest) Query(key, value string) *VmNumaNodesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodesServiceAddRequest) Node(node *VirtualNumaNode) *VmNumaNodesServiceAddRequest {
	p.node = node
	return p
}

func (p *VmNumaNodesServiceAddRequest) Send() (*VmNumaNodesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNumaNodesService.connection.URL(), p.VmNumaNodesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVirtualNumaNodeWriteOne(writer, p.node, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNumaNodesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNumaNodesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNumaNodesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNumaNodesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNumaNodesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmNumaNodesServiceAddResponse{node: result}, nil
}

func (p *VmNumaNodesServiceAddRequest) MustSend() *VmNumaNodesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new virtual NUMA node for the virtual machine.
// An example of creating a NUMA node:
// [source]
// ----
// POST /ovirt-engine/api/vms/c7ecd2dc/numanodes
// Accept: application/xml
// Content-type: application/xml
// ----
// The request body can contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>1024</memory>
// </vm_numa_node>
// ----
//
type VmNumaNodesServiceAddResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodesServiceAddResponse) Node() (*VirtualNumaNode, bool) {
	if p.node != nil {
		return p.node, true
	}
	return nil, false
}

func (p *VmNumaNodesServiceAddResponse) MustNode() *VirtualNumaNode {
	if p.node == nil {
		panic("node in response does not exist")
	}
	return p.node
}

//
// Creates a new virtual NUMA node for the virtual machine.
// An example of creating a NUMA node:
// [source]
// ----
// POST /ovirt-engine/api/vms/c7ecd2dc/numanodes
// Accept: application/xml
// Content-type: application/xml
// ----
// The request body can contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <cpu>
//     <cores>
//       <core>
//         <index>0</index>
//       </core>
//     </cores>
//   </cpu>
//   <index>0</index>
//   <memory>1024</memory>
// </vm_numa_node>
// ----
//
func (p *VmNumaNodesService) Add() *VmNumaNodesServiceAddRequest {
	return &VmNumaNodesServiceAddRequest{VmNumaNodesService: p}
}

//
// Lists virtual NUMA nodes of a virtual machine.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
type VmNumaNodesServiceListRequest struct {
	VmNumaNodesService *VmNumaNodesService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *VmNumaNodesServiceListRequest) Header(key, value string) *VmNumaNodesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodesServiceListRequest) Query(key, value string) *VmNumaNodesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodesServiceListRequest) Follow(follow string) *VmNumaNodesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmNumaNodesServiceListRequest) Max(max int64) *VmNumaNodesServiceListRequest {
	p.max = &max
	return p
}

func (p *VmNumaNodesServiceListRequest) Send() (*VmNumaNodesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNumaNodesService.connection.URL(), p.VmNumaNodesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNumaNodesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNumaNodesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNumaNodesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNumaNodesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNumaNodesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmNumaNodesServiceListResponse{nodes: result}, nil
}

func (p *VmNumaNodesServiceListRequest) MustSend() *VmNumaNodesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists virtual NUMA nodes of a virtual machine.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
type VmNumaNodesServiceListResponse struct {
	nodes *VirtualNumaNodeSlice
}

func (p *VmNumaNodesServiceListResponse) Nodes() (*VirtualNumaNodeSlice, bool) {
	if p.nodes != nil {
		return p.nodes, true
	}
	return nil, false
}

func (p *VmNumaNodesServiceListResponse) MustNodes() *VirtualNumaNodeSlice {
	if p.nodes == nil {
		panic("nodes in response does not exist")
	}
	return p.nodes
}

//
// Lists virtual NUMA nodes of a virtual machine.
// The order of the returned list of NUMA nodes isn't guaranteed.
//
func (p *VmNumaNodesService) List() *VmNumaNodesServiceListRequest {
	return &VmNumaNodesServiceListRequest{VmNumaNodesService: p}
}

//
//
func (op *VmNumaNodesService) NodeService(id string) *VmNumaNodeService {
	return NewVmNumaNodeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNumaNodesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NodeService(path), nil
	}
	return op.NodeService(path[:index]).Service(path[index+1:])
}

func (op *VmNumaNodesService) String() string {
	return fmt.Sprintf("VmNumaNodesService:%s", op.path)
}

//
//
type StorageService struct {
	BaseService
}

func NewStorageService(connection *Connection, path string) *StorageService {
	var result StorageService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StorageServiceGetRequest struct {
	StorageService *StorageService
	header         map[string]string
	query          map[string]string
	follow         *string
	reportStatus   *bool
}

func (p *StorageServiceGetRequest) Header(key, value string) *StorageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServiceGetRequest) Query(key, value string) *StorageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServiceGetRequest) Follow(follow string) *StorageServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageServiceGetRequest) ReportStatus(reportStatus bool) *StorageServiceGetRequest {
	p.reportStatus = &reportStatus
	return p
}

func (p *StorageServiceGetRequest) Send() (*StorageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageService.connection.URL(), p.StorageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.reportStatus != nil {
		values["report_status"] = []string{fmt.Sprintf("%v", *p.reportStatus)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostStorageReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageServiceGetResponse{storage: result}, nil
}

func (p *StorageServiceGetRequest) MustSend() *StorageServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageServiceGetResponse struct {
	storage *HostStorage
}

func (p *StorageServiceGetResponse) Storage() (*HostStorage, bool) {
	if p.storage != nil {
		return p.storage, true
	}
	return nil, false
}

func (p *StorageServiceGetResponse) MustStorage() *HostStorage {
	if p.storage == nil {
		panic("storage in response does not exist")
	}
	return p.storage
}

//
//
func (p *StorageService) Get() *StorageServiceGetRequest {
	return &StorageServiceGetRequest{StorageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageService) String() string {
	return fmt.Sprintf("StorageService:%s", op.path)
}

//
//
type UnmanagedNetworkService struct {
	BaseService
}

func NewUnmanagedNetworkService(connection *Connection, path string) *UnmanagedNetworkService {
	var result UnmanagedNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type UnmanagedNetworkServiceGetRequest struct {
	UnmanagedNetworkService *UnmanagedNetworkService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *UnmanagedNetworkServiceGetRequest) Header(key, value string) *UnmanagedNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworkServiceGetRequest) Query(key, value string) *UnmanagedNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworkServiceGetRequest) Follow(follow string) *UnmanagedNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *UnmanagedNetworkServiceGetRequest) Send() (*UnmanagedNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.UnmanagedNetworkService.connection.URL(), p.UnmanagedNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.UnmanagedNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.UnmanagedNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.UnmanagedNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.UnmanagedNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.UnmanagedNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUnmanagedNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &UnmanagedNetworkServiceGetResponse{network: result}, nil
}

func (p *UnmanagedNetworkServiceGetRequest) MustSend() *UnmanagedNetworkServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type UnmanagedNetworkServiceGetResponse struct {
	network *UnmanagedNetwork
}

func (p *UnmanagedNetworkServiceGetResponse) Network() (*UnmanagedNetwork, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *UnmanagedNetworkServiceGetResponse) MustNetwork() *UnmanagedNetwork {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
//
func (p *UnmanagedNetworkService) Get() *UnmanagedNetworkServiceGetRequest {
	return &UnmanagedNetworkServiceGetRequest{UnmanagedNetworkService: p}
}

//
//
type UnmanagedNetworkServiceRemoveRequest struct {
	UnmanagedNetworkService *UnmanagedNetworkService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *UnmanagedNetworkServiceRemoveRequest) Header(key, value string) *UnmanagedNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworkServiceRemoveRequest) Query(key, value string) *UnmanagedNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworkServiceRemoveRequest) Async(async bool) *UnmanagedNetworkServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *UnmanagedNetworkServiceRemoveRequest) Send() (*UnmanagedNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.UnmanagedNetworkService.connection.URL(), p.UnmanagedNetworkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.UnmanagedNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.UnmanagedNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.UnmanagedNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.UnmanagedNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.UnmanagedNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(UnmanagedNetworkServiceRemoveResponse), nil
}

func (p *UnmanagedNetworkServiceRemoveRequest) MustSend() *UnmanagedNetworkServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type UnmanagedNetworkServiceRemoveResponse struct {
}

//
//
func (p *UnmanagedNetworkService) Remove() *UnmanagedNetworkServiceRemoveRequest {
	return &UnmanagedNetworkServiceRemoveRequest{UnmanagedNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UnmanagedNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *UnmanagedNetworkService) String() string {
	return fmt.Sprintf("UnmanagedNetworkService:%s", op.path)
}

//
//
type AttachedStorageDomainService struct {
	BaseService
}

func NewAttachedStorageDomainService(connection *Connection, path string) *AttachedStorageDomainService {
	var result AttachedStorageDomainService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation activates an attached storage domain.
// Once the storage domain is activated it is ready for use with the data center.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/activate
// ----
// The activate action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type AttachedStorageDomainServiceActivateRequest struct {
	AttachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *AttachedStorageDomainServiceActivateRequest) Header(key, value string) *AttachedStorageDomainServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceActivateRequest) Query(key, value string) *AttachedStorageDomainServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceActivateRequest) Async(async bool) *AttachedStorageDomainServiceActivateRequest {
	p.async = &async
	return p
}

func (p *AttachedStorageDomainServiceActivateRequest) Send() (*AttachedStorageDomainServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.AttachedStorageDomainService.connection.URL(), p.AttachedStorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainServiceActivateResponse), nil
}

func (p *AttachedStorageDomainServiceActivateRequest) MustSend() *AttachedStorageDomainServiceActivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation activates an attached storage domain.
// Once the storage domain is activated it is ready for use with the data center.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/activate
// ----
// The activate action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type AttachedStorageDomainServiceActivateResponse struct {
}

//
// This operation activates an attached storage domain.
// Once the storage domain is activated it is ready for use with the data center.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/activate
// ----
// The activate action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *AttachedStorageDomainService) Activate() *AttachedStorageDomainServiceActivateRequest {
	return &AttachedStorageDomainServiceActivateRequest{AttachedStorageDomainService: p}
}

//
// This operation deactivates an attached storage domain.
// Once the storage domain is deactivated it will not be used with the data center.
// For example, to deactivate storage domain `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// If the `force` parameter is `true` then the operation will succeed, even if the OVF update which takes place
// before the deactivation of the storage domain failed. If the `force` parameter is `false` and the OVF update failed,
// the deactivation of the storage domain will also fail.
//
type AttachedStorageDomainServiceDeactivateRequest struct {
	AttachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
	force                        *bool
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Header(key, value string) *AttachedStorageDomainServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Query(key, value string) *AttachedStorageDomainServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Async(async bool) *AttachedStorageDomainServiceDeactivateRequest {
	p.async = &async
	return p
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Force(force bool) *AttachedStorageDomainServiceDeactivateRequest {
	p.force = &force
	return p
}

func (p *AttachedStorageDomainServiceDeactivateRequest) Send() (*AttachedStorageDomainServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.AttachedStorageDomainService.connection.URL(), p.AttachedStorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(AttachedStorageDomainServiceDeactivateResponse), nil
}

func (p *AttachedStorageDomainServiceDeactivateRequest) MustSend() *AttachedStorageDomainServiceDeactivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation deactivates an attached storage domain.
// Once the storage domain is deactivated it will not be used with the data center.
// For example, to deactivate storage domain `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// If the `force` parameter is `true` then the operation will succeed, even if the OVF update which takes place
// before the deactivation of the storage domain failed. If the `force` parameter is `false` and the OVF update failed,
// the deactivation of the storage domain will also fail.
//
type AttachedStorageDomainServiceDeactivateResponse struct {
}

//
// This operation deactivates an attached storage domain.
// Once the storage domain is deactivated it will not be used with the data center.
// For example, to deactivate storage domain `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains/456/deactivate
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// If the `force` parameter is `true` then the operation will succeed, even if the OVF update which takes place
// before the deactivation of the storage domain failed. If the `force` parameter is `false` and the OVF update failed,
// the deactivation of the storage domain will also fail.
//
func (p *AttachedStorageDomainService) Deactivate() *AttachedStorageDomainServiceDeactivateRequest {
	return &AttachedStorageDomainServiceDeactivateRequest{AttachedStorageDomainService: p}
}

//
//
type AttachedStorageDomainServiceGetRequest struct {
	AttachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
}

func (p *AttachedStorageDomainServiceGetRequest) Header(key, value string) *AttachedStorageDomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceGetRequest) Query(key, value string) *AttachedStorageDomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceGetRequest) Follow(follow string) *AttachedStorageDomainServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AttachedStorageDomainServiceGetRequest) Send() (*AttachedStorageDomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainService.connection.URL(), p.AttachedStorageDomainService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AttachedStorageDomainServiceGetResponse{storageDomain: result}, nil
}

func (p *AttachedStorageDomainServiceGetRequest) MustSend() *AttachedStorageDomainServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type AttachedStorageDomainServiceGetResponse struct {
	storageDomain *StorageDomain
}

func (p *AttachedStorageDomainServiceGetResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *AttachedStorageDomainServiceGetResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
//
func (p *AttachedStorageDomainService) Get() *AttachedStorageDomainServiceGetRequest {
	return &AttachedStorageDomainServiceGetRequest{AttachedStorageDomainService: p}
}

//
//
type AttachedStorageDomainServiceRemoveRequest struct {
	AttachedStorageDomainService *AttachedStorageDomainService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *AttachedStorageDomainServiceRemoveRequest) Header(key, value string) *AttachedStorageDomainServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainServiceRemoveRequest) Query(key, value string) *AttachedStorageDomainServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainServiceRemoveRequest) Async(async bool) *AttachedStorageDomainServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AttachedStorageDomainServiceRemoveRequest) Send() (*AttachedStorageDomainServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainService.connection.URL(), p.AttachedStorageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AttachedStorageDomainServiceRemoveResponse), nil
}

func (p *AttachedStorageDomainServiceRemoveRequest) MustSend() *AttachedStorageDomainServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type AttachedStorageDomainServiceRemoveResponse struct {
}

//
//
func (p *AttachedStorageDomainService) Remove() *AttachedStorageDomainServiceRemoveRequest {
	return &AttachedStorageDomainServiceRemoveRequest{AttachedStorageDomainService: p}
}

//
//
func (op *AttachedStorageDomainService) DisksService() *AttachedStorageDomainDisksService {
	return NewAttachedStorageDomainDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AttachedStorageDomainService) String() string {
	return fmt.Sprintf("AttachedStorageDomainService:%s", op.path)
}

//
// Represents a permits sub-collection of the specific role.
//
type PermitsService struct {
	BaseService
}

func NewPermitsService(connection *Connection, path string) *PermitsService {
	var result PermitsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a permit to the role. The permit name can be retrieved from the <<services/cluster_levels>> service.
// For example to assign a permit `create_vm` to the role with id `123` send a request like this:
// ....
// POST /ovirt-engine/api/roles/123/permits
// ....
// With a request body like this:
// [source,xml]
// ----
// <permit>
//   <name>create_vm</name>
// </permit>
// ----
//
type PermitsServiceAddRequest struct {
	PermitsService *PermitsService
	header         map[string]string
	query          map[string]string
	permit         *Permit
}

func (p *PermitsServiceAddRequest) Header(key, value string) *PermitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitsServiceAddRequest) Query(key, value string) *PermitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitsServiceAddRequest) Permit(permit *Permit) *PermitsServiceAddRequest {
	p.permit = permit
	return p
}

func (p *PermitsServiceAddRequest) Send() (*PermitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.PermitsService.connection.URL(), p.PermitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermitWriteOne(writer, p.permit, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.PermitsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.PermitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.PermitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.PermitsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.PermitsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &PermitsServiceAddResponse{permit: result}, nil
}

func (p *PermitsServiceAddRequest) MustSend() *PermitsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a permit to the role. The permit name can be retrieved from the <<services/cluster_levels>> service.
// For example to assign a permit `create_vm` to the role with id `123` send a request like this:
// ....
// POST /ovirt-engine/api/roles/123/permits
// ....
// With a request body like this:
// [source,xml]
// ----
// <permit>
//   <name>create_vm</name>
// </permit>
// ----
//
type PermitsServiceAddResponse struct {
	permit *Permit
}

func (p *PermitsServiceAddResponse) Permit() (*Permit, bool) {
	if p.permit != nil {
		return p.permit, true
	}
	return nil, false
}

func (p *PermitsServiceAddResponse) MustPermit() *Permit {
	if p.permit == nil {
		panic("permit in response does not exist")
	}
	return p.permit
}

//
// Adds a permit to the role. The permit name can be retrieved from the <<services/cluster_levels>> service.
// For example to assign a permit `create_vm` to the role with id `123` send a request like this:
// ....
// POST /ovirt-engine/api/roles/123/permits
// ....
// With a request body like this:
// [source,xml]
// ----
// <permit>
//   <name>create_vm</name>
// </permit>
// ----
//
func (p *PermitsService) Add() *PermitsServiceAddRequest {
	return &PermitsServiceAddRequest{PermitsService: p}
}

//
// List the permits of the role.
// For example to list the permits of the role with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits
// ....
// [source,xml]
// ----
// <permits>
//   <permit href="/ovirt-engine/api/roles/123/permits/5" id="5">
//     <name>change_vm_cd</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
//   <permit href="/ovirt-engine/api/roles/123/permits/7" id="7">
//     <name>connect_to_vm</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
// </permits>
// ----
// The order of the returned list of permits isn't guaranteed.
//
type PermitsServiceListRequest struct {
	PermitsService *PermitsService
	header         map[string]string
	query          map[string]string
	follow         *string
	max            *int64
}

func (p *PermitsServiceListRequest) Header(key, value string) *PermitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermitsServiceListRequest) Query(key, value string) *PermitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermitsServiceListRequest) Follow(follow string) *PermitsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *PermitsServiceListRequest) Max(max int64) *PermitsServiceListRequest {
	p.max = &max
	return p
}

func (p *PermitsServiceListRequest) Send() (*PermitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.PermitsService.connection.URL(), p.PermitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.PermitsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.PermitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.PermitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.PermitsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.PermitsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermitReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &PermitsServiceListResponse{permits: result}, nil
}

func (p *PermitsServiceListRequest) MustSend() *PermitsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the permits of the role.
// For example to list the permits of the role with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits
// ....
// [source,xml]
// ----
// <permits>
//   <permit href="/ovirt-engine/api/roles/123/permits/5" id="5">
//     <name>change_vm_cd</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
//   <permit href="/ovirt-engine/api/roles/123/permits/7" id="7">
//     <name>connect_to_vm</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
// </permits>
// ----
// The order of the returned list of permits isn't guaranteed.
//
type PermitsServiceListResponse struct {
	permits *PermitSlice
}

func (p *PermitsServiceListResponse) Permits() (*PermitSlice, bool) {
	if p.permits != nil {
		return p.permits, true
	}
	return nil, false
}

func (p *PermitsServiceListResponse) MustPermits() *PermitSlice {
	if p.permits == nil {
		panic("permits in response does not exist")
	}
	return p.permits
}

//
// List the permits of the role.
// For example to list the permits of the role with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/roles/123/permits
// ....
// [source,xml]
// ----
// <permits>
//   <permit href="/ovirt-engine/api/roles/123/permits/5" id="5">
//     <name>change_vm_cd</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
//   <permit href="/ovirt-engine/api/roles/123/permits/7" id="7">
//     <name>connect_to_vm</name>
//     <administrative>false</administrative>
//     <role href="/ovirt-engine/api/roles/123" id="123"/>
//   </permit>
// </permits>
// ----
// The order of the returned list of permits isn't guaranteed.
//
func (p *PermitsService) List() *PermitsServiceListRequest {
	return &PermitsServiceListRequest{PermitsService: p}
}

//
// Sub-resource locator method, returns individual permit resource on which the remainder of the URI is dispatched.
//
func (op *PermitsService) PermitService(id string) *PermitService {
	return NewPermitService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermitsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PermitService(path), nil
	}
	return op.PermitService(path[:index]).Service(path[index+1:])
}

func (op *PermitsService) String() string {
	return fmt.Sprintf("PermitsService:%s", op.path)
}

//
// Manages the set of connections to storage servers that exist in a storage domain.
//
type StorageDomainServerConnectionsService struct {
	BaseService
}

func NewStorageDomainServerConnectionsService(connection *Connection, path string) *StorageDomainServerConnectionsService {
	var result StorageDomainServerConnectionsService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StorageDomainServerConnectionsServiceAddRequest struct {
	StorageDomainServerConnectionsService *StorageDomainServerConnectionsService
	header                                map[string]string
	query                                 map[string]string
	connection                            *StorageConnection
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Header(key, value string) *StorageDomainServerConnectionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Query(key, value string) *StorageDomainServerConnectionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Connection(connection *StorageConnection) *StorageDomainServerConnectionsServiceAddRequest {
	p.connection = connection
	return p
}

func (p *StorageDomainServerConnectionsServiceAddRequest) Send() (*StorageDomainServerConnectionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainServerConnectionsService.connection.URL(), p.StorageDomainServerConnectionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainServerConnectionsServiceAddResponse{connection: result}, nil
}

func (p *StorageDomainServerConnectionsServiceAddRequest) MustSend() *StorageDomainServerConnectionsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageDomainServerConnectionsServiceAddResponse struct {
	connection *StorageConnection
}

func (p *StorageDomainServerConnectionsServiceAddResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageDomainServerConnectionsServiceAddResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
//
func (p *StorageDomainServerConnectionsService) Add() *StorageDomainServerConnectionsServiceAddRequest {
	return &StorageDomainServerConnectionsServiceAddRequest{StorageDomainServerConnectionsService: p}
}

//
// Returns the list of connections to storage servers that existin the storage domain.
// The order of the returned list of connections isn't guaranteed.
//
type StorageDomainServerConnectionsServiceListRequest struct {
	StorageDomainServerConnectionsService *StorageDomainServerConnectionsService
	header                                map[string]string
	query                                 map[string]string
	follow                                *string
	max                                   *int64
}

func (p *StorageDomainServerConnectionsServiceListRequest) Header(key, value string) *StorageDomainServerConnectionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceListRequest) Query(key, value string) *StorageDomainServerConnectionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionsServiceListRequest) Follow(follow string) *StorageDomainServerConnectionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainServerConnectionsServiceListRequest) Max(max int64) *StorageDomainServerConnectionsServiceListRequest {
	p.max = &max
	return p
}

func (p *StorageDomainServerConnectionsServiceListRequest) Send() (*StorageDomainServerConnectionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainServerConnectionsService.connection.URL(), p.StorageDomainServerConnectionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainServerConnectionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainServerConnectionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainServerConnectionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainServerConnectionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainServerConnectionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageDomainServerConnectionsServiceListResponse{connections: result}, nil
}

func (p *StorageDomainServerConnectionsServiceListRequest) MustSend() *StorageDomainServerConnectionsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of connections to storage servers that existin the storage domain.
// The order of the returned list of connections isn't guaranteed.
//
type StorageDomainServerConnectionsServiceListResponse struct {
	connections *StorageConnectionSlice
}

func (p *StorageDomainServerConnectionsServiceListResponse) Connections() (*StorageConnectionSlice, bool) {
	if p.connections != nil {
		return p.connections, true
	}
	return nil, false
}

func (p *StorageDomainServerConnectionsServiceListResponse) MustConnections() *StorageConnectionSlice {
	if p.connections == nil {
		panic("connections in response does not exist")
	}
	return p.connections
}

//
// Returns the list of connections to storage servers that existin the storage domain.
// The order of the returned list of connections isn't guaranteed.
//
func (p *StorageDomainServerConnectionsService) List() *StorageDomainServerConnectionsServiceListRequest {
	return &StorageDomainServerConnectionsServiceListRequest{StorageDomainServerConnectionsService: p}
}

//
//
func (op *StorageDomainServerConnectionsService) ConnectionService(id string) *StorageDomainServerConnectionService {
	return NewStorageDomainServerConnectionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainServerConnectionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConnectionService(path), nil
	}
	return op.ConnectionService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainServerConnectionsService) String() string {
	return fmt.Sprintf("StorageDomainServerConnectionsService:%s", op.path)
}

//
// Manages the set of storage domains in the system.
//
type StorageDomainsService struct {
	BaseService
}

func NewStorageDomainsService(connection *Connection, path string) *StorageDomainsService {
	var result StorageDomainsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new storage domain.
// Creation of a new <<types/storage_domain,StorageDomain>> requires the `name`, `type`, `host`, and `storage`
// attributes. Identify the `host` attribute with the `id` or `name` attributes. In {product-name} 3.6 and
// later you can enable the wipe after delete option by default on the storage domain. To configure this, specify
// `wipe_after_delete` in the POST request. This option can be edited after the domain is created, but doing so will
// not change the wipe after delete property of disks that already exist.
// To add a new storage domain with specified `name`, `type`, `storage.type`, `storage.address`, and `storage.path`,
// and using a host with an id `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>mydata</name>
//   <type>data</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/exports/mydata</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new NFS ISO storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myisos</name>
//   <type>iso</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/export/myisos</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new iSCSI storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myiscsi</name>
//   <type>data</type>
//   <storage>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="3600144f09dbd050000004eedbd340001"/>
//       <logical_unit id="3600144f09dbd050000004eedbd340002"/>
//     </logical_units>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
//
type StorageDomainsServiceAddRequest struct {
	StorageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *StorageDomainsServiceAddRequest) Header(key, value string) *StorageDomainsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceAddRequest) Query(key, value string) *StorageDomainsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceAddRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainsServiceAddRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainsServiceAddRequest) Send() (*StorageDomainsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainsService.connection.URL(), p.StorageDomainsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainsServiceAddResponse{storageDomain: result}, nil
}

func (p *StorageDomainsServiceAddRequest) MustSend() *StorageDomainsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a new storage domain.
// Creation of a new <<types/storage_domain,StorageDomain>> requires the `name`, `type`, `host`, and `storage`
// attributes. Identify the `host` attribute with the `id` or `name` attributes. In {product-name} 3.6 and
// later you can enable the wipe after delete option by default on the storage domain. To configure this, specify
// `wipe_after_delete` in the POST request. This option can be edited after the domain is created, but doing so will
// not change the wipe after delete property of disks that already exist.
// To add a new storage domain with specified `name`, `type`, `storage.type`, `storage.address`, and `storage.path`,
// and using a host with an id `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>mydata</name>
//   <type>data</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/exports/mydata</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new NFS ISO storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myisos</name>
//   <type>iso</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/export/myisos</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new iSCSI storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myiscsi</name>
//   <type>data</type>
//   <storage>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="3600144f09dbd050000004eedbd340001"/>
//       <logical_unit id="3600144f09dbd050000004eedbd340002"/>
//     </logical_units>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
//
type StorageDomainsServiceAddResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainsServiceAddResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *StorageDomainsServiceAddResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Adds a new storage domain.
// Creation of a new <<types/storage_domain,StorageDomain>> requires the `name`, `type`, `host`, and `storage`
// attributes. Identify the `host` attribute with the `id` or `name` attributes. In {product-name} 3.6 and
// later you can enable the wipe after delete option by default on the storage domain. To configure this, specify
// `wipe_after_delete` in the POST request. This option can be edited after the domain is created, but doing so will
// not change the wipe after delete property of disks that already exist.
// To add a new storage domain with specified `name`, `type`, `storage.type`, `storage.address`, and `storage.path`,
// and using a host with an id `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>mydata</name>
//   <type>data</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/exports/mydata</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new NFS ISO storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myisos</name>
//   <type>iso</type>
//   <storage>
//     <type>nfs</type>
//     <address>mynfs.example.com</address>
//     <path>/export/myisos</path>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
// To create a new iSCSI storage domain send a request like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>myiscsi</name>
//   <type>data</type>
//   <storage>
//     <type>iscsi</type>
//     <logical_units>
//       <logical_unit id="3600144f09dbd050000004eedbd340001"/>
//       <logical_unit id="3600144f09dbd050000004eedbd340002"/>
//     </logical_units>
//   </storage>
//   <host>
//     <name>myhost</name>
//   </host>
// </storage_domain>
// ----
//
func (p *StorageDomainsService) Add() *StorageDomainsServiceAddRequest {
	return &StorageDomainsServiceAddRequest{StorageDomainsService: p}
}

//
// Import an existing block storage domain to the system using the targets already connected to the host.
//
type StorageDomainsServiceAddBlockDomainRequest struct {
	StorageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *StorageDomainsServiceAddBlockDomainRequest) Header(key, value string) *StorageDomainsServiceAddBlockDomainRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceAddBlockDomainRequest) Query(key, value string) *StorageDomainsServiceAddBlockDomainRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceAddBlockDomainRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainsServiceAddBlockDomainRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainsServiceAddBlockDomainRequest) Send() (*StorageDomainsServiceAddBlockDomainResponse, error) {
	rawURL := fmt.Sprintf("%s%s/blockdomain", p.StorageDomainsService.connection.URL(), p.StorageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &StorageDomainsServiceAddBlockDomainResponse{storageDomain: result}, nil
}

func (p *StorageDomainsServiceAddBlockDomainRequest) MustSend() *StorageDomainsServiceAddBlockDomainResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Import an existing block storage domain to the system using the targets already connected to the host.
//
type StorageDomainsServiceAddBlockDomainResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainsServiceAddBlockDomainResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *StorageDomainsServiceAddBlockDomainResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Import an existing block storage domain to the system using the targets already connected to the host.
//
func (p *StorageDomainsService) AddBlockDomain() *StorageDomainsServiceAddBlockDomainRequest {
	return &StorageDomainsServiceAddBlockDomainRequest{StorageDomainsService: p}
}

//
// Add a new storage domain to the system using the storage on the given host and path.
//
type StorageDomainsServiceAddByPathRequest struct {
	StorageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *StorageDomainsServiceAddByPathRequest) Header(key, value string) *StorageDomainsServiceAddByPathRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceAddByPathRequest) Query(key, value string) *StorageDomainsServiceAddByPathRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceAddByPathRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainsServiceAddByPathRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainsServiceAddByPathRequest) Send() (*StorageDomainsServiceAddByPathResponse, error) {
	rawURL := fmt.Sprintf("%s%s/bypath", p.StorageDomainsService.connection.URL(), p.StorageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &StorageDomainsServiceAddByPathResponse{storageDomain: result}, nil
}

func (p *StorageDomainsServiceAddByPathRequest) MustSend() *StorageDomainsServiceAddByPathResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new storage domain to the system using the storage on the given host and path.
//
type StorageDomainsServiceAddByPathResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainsServiceAddByPathResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *StorageDomainsServiceAddByPathResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Add a new storage domain to the system using the storage on the given host and path.
//
func (p *StorageDomainsService) AddByPath() *StorageDomainsServiceAddByPathRequest {
	return &StorageDomainsServiceAddByPathRequest{StorageDomainsService: p}
}

//
// Add a new storage domain to the system using a direct LUN.
//
type StorageDomainsServiceAddDirectLunRequest struct {
	StorageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *StorageDomainsServiceAddDirectLunRequest) Header(key, value string) *StorageDomainsServiceAddDirectLunRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceAddDirectLunRequest) Query(key, value string) *StorageDomainsServiceAddDirectLunRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceAddDirectLunRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainsServiceAddDirectLunRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainsServiceAddDirectLunRequest) Send() (*StorageDomainsServiceAddDirectLunResponse, error) {
	rawURL := fmt.Sprintf("%s%s/directlun", p.StorageDomainsService.connection.URL(), p.StorageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &StorageDomainsServiceAddDirectLunResponse{storageDomain: result}, nil
}

func (p *StorageDomainsServiceAddDirectLunRequest) MustSend() *StorageDomainsServiceAddDirectLunResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new storage domain to the system using a direct LUN.
//
type StorageDomainsServiceAddDirectLunResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainsServiceAddDirectLunResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *StorageDomainsServiceAddDirectLunResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Add a new storage domain to the system using a direct LUN.
//
func (p *StorageDomainsService) AddDirectLun() *StorageDomainsServiceAddDirectLunRequest {
	return &StorageDomainsServiceAddDirectLunRequest{StorageDomainsService: p}
}

//
// Add a new storage domain to the system using Gluster or POSIX FS storage.
//
type StorageDomainsServiceAddGlusterOrPostfsRequest struct {
	StorageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *StorageDomainsServiceAddGlusterOrPostfsRequest) Header(key, value string) *StorageDomainsServiceAddGlusterOrPostfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceAddGlusterOrPostfsRequest) Query(key, value string) *StorageDomainsServiceAddGlusterOrPostfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceAddGlusterOrPostfsRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainsServiceAddGlusterOrPostfsRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainsServiceAddGlusterOrPostfsRequest) Send() (*StorageDomainsServiceAddGlusterOrPostfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/glusterorpostfs", p.StorageDomainsService.connection.URL(), p.StorageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &StorageDomainsServiceAddGlusterOrPostfsResponse{storageDomain: result}, nil
}

func (p *StorageDomainsServiceAddGlusterOrPostfsRequest) MustSend() *StorageDomainsServiceAddGlusterOrPostfsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new storage domain to the system using Gluster or POSIX FS storage.
//
type StorageDomainsServiceAddGlusterOrPostfsResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainsServiceAddGlusterOrPostfsResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *StorageDomainsServiceAddGlusterOrPostfsResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Add a new storage domain to the system using Gluster or POSIX FS storage.
//
func (p *StorageDomainsService) AddGlusterOrPostfs() *StorageDomainsServiceAddGlusterOrPostfsRequest {
	return &StorageDomainsServiceAddGlusterOrPostfsRequest{StorageDomainsService: p}
}

//
// Returns the list of storage domains in the system.
// The order of the returned list of storage domains is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
type StorageDomainsServiceListRequest struct {
	StorageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	caseSensitive         *bool
	filter                *bool
	follow                *string
	max                   *int64
	search                *string
}

func (p *StorageDomainsServiceListRequest) Header(key, value string) *StorageDomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceListRequest) Query(key, value string) *StorageDomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceListRequest) CaseSensitive(caseSensitive bool) *StorageDomainsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *StorageDomainsServiceListRequest) Filter(filter bool) *StorageDomainsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *StorageDomainsServiceListRequest) Follow(follow string) *StorageDomainsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainsServiceListRequest) Max(max int64) *StorageDomainsServiceListRequest {
	p.max = &max
	return p
}

func (p *StorageDomainsServiceListRequest) Search(search string) *StorageDomainsServiceListRequest {
	p.search = &search
	return p
}

func (p *StorageDomainsServiceListRequest) Send() (*StorageDomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainsService.connection.URL(), p.StorageDomainsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageDomainsServiceListResponse{storageDomains: result}, nil
}

func (p *StorageDomainsServiceListRequest) MustSend() *StorageDomainsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of storage domains in the system.
// The order of the returned list of storage domains is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
type StorageDomainsServiceListResponse struct {
	storageDomains *StorageDomainSlice
}

func (p *StorageDomainsServiceListResponse) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *StorageDomainsServiceListResponse) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("storageDomains in response does not exist")
	}
	return p.storageDomains
}

//
// Returns the list of storage domains in the system.
// The order of the returned list of storage domains is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
func (p *StorageDomainsService) List() *StorageDomainsServiceListRequest {
	return &StorageDomainsServiceListRequest{StorageDomainsService: p}
}

//
// Add a new storage domain to the system using the storage on the local host at the given path.
//
type StorageDomainsServiceAddLocalRequest struct {
	StorageDomainsService *StorageDomainsService
	header                map[string]string
	query                 map[string]string
	storageDomain         *StorageDomain
}

func (p *StorageDomainsServiceAddLocalRequest) Header(key, value string) *StorageDomainsServiceAddLocalRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainsServiceAddLocalRequest) Query(key, value string) *StorageDomainsServiceAddLocalRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainsServiceAddLocalRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainsServiceAddLocalRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainsServiceAddLocalRequest) Send() (*StorageDomainsServiceAddLocalResponse, error) {
	rawURL := fmt.Sprintf("%s%s/local", p.StorageDomainsService.connection.URL(), p.StorageDomainsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomain()
	return &StorageDomainsServiceAddLocalResponse{storageDomain: result}, nil
}

func (p *StorageDomainsServiceAddLocalRequest) MustSend() *StorageDomainsServiceAddLocalResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new storage domain to the system using the storage on the local host at the given path.
//
type StorageDomainsServiceAddLocalResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainsServiceAddLocalResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *StorageDomainsServiceAddLocalResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Add a new storage domain to the system using the storage on the local host at the given path.
//
func (p *StorageDomainsService) AddLocal() *StorageDomainsServiceAddLocalRequest {
	return &StorageDomainsServiceAddLocalRequest{StorageDomainsService: p}
}

//
//
func (op *StorageDomainsService) StorageDomainService(id string) *StorageDomainService {
	return NewStorageDomainService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageDomainService(path), nil
	}
	return op.StorageDomainService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainsService) String() string {
	return fmt.Sprintf("StorageDomainsService:%s", op.path)
}

//
// A service to manage data center networks.
//
type DataCenterNetworksService struct {
	BaseService
}

func NewDataCenterNetworksService(connection *Connection, path string) *DataCenterNetworksService {
	var result DataCenterNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Create a new network in a data center.
// Post a request like in the example below to create a new network in a data center with an ID of `123`.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
// </network>
// ----
//
type DataCenterNetworksServiceAddRequest struct {
	DataCenterNetworksService *DataCenterNetworksService
	header                    map[string]string
	query                     map[string]string
	network                   *Network
}

func (p *DataCenterNetworksServiceAddRequest) Header(key, value string) *DataCenterNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterNetworksServiceAddRequest) Query(key, value string) *DataCenterNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterNetworksServiceAddRequest) Network(network *Network) *DataCenterNetworksServiceAddRequest {
	p.network = network
	return p
}

func (p *DataCenterNetworksServiceAddRequest) Send() (*DataCenterNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCenterNetworksService.connection.URL(), p.DataCenterNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCenterNetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCenterNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCenterNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCenterNetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCenterNetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DataCenterNetworksServiceAddResponse{network: result}, nil
}

func (p *DataCenterNetworksServiceAddRequest) MustSend() *DataCenterNetworksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Create a new network in a data center.
// Post a request like in the example below to create a new network in a data center with an ID of `123`.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
// </network>
// ----
//
type DataCenterNetworksServiceAddResponse struct {
	network *Network
}

func (p *DataCenterNetworksServiceAddResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *DataCenterNetworksServiceAddResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Create a new network in a data center.
// Post a request like in the example below to create a new network in a data center with an ID of `123`.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
// </network>
// ----
//
func (p *DataCenterNetworksService) Add() *DataCenterNetworksServiceAddRequest {
	return &DataCenterNetworksServiceAddRequest{DataCenterNetworksService: p}
}

//
// Lists networks in the data center.
// The order of the returned list of networks isn't guaranteed.
//
type DataCenterNetworksServiceListRequest struct {
	DataCenterNetworksService *DataCenterNetworksService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *DataCenterNetworksServiceListRequest) Header(key, value string) *DataCenterNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterNetworksServiceListRequest) Query(key, value string) *DataCenterNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterNetworksServiceListRequest) Follow(follow string) *DataCenterNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DataCenterNetworksServiceListRequest) Max(max int64) *DataCenterNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *DataCenterNetworksServiceListRequest) Send() (*DataCenterNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCenterNetworksService.connection.URL(), p.DataCenterNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCenterNetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCenterNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCenterNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCenterNetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCenterNetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DataCenterNetworksServiceListResponse{networks: result}, nil
}

func (p *DataCenterNetworksServiceListRequest) MustSend() *DataCenterNetworksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists networks in the data center.
// The order of the returned list of networks isn't guaranteed.
//
type DataCenterNetworksServiceListResponse struct {
	networks *NetworkSlice
}

func (p *DataCenterNetworksServiceListResponse) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *DataCenterNetworksServiceListResponse) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Lists networks in the data center.
// The order of the returned list of networks isn't guaranteed.
//
func (p *DataCenterNetworksService) List() *DataCenterNetworksServiceListRequest {
	return &DataCenterNetworksServiceListRequest{DataCenterNetworksService: p}
}

//
// Access the data center network service that manages the data center network specified by an ID.
//
func (op *DataCenterNetworksService) NetworkService(id string) *DataCenterNetworkService {
	return NewDataCenterNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DataCenterNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *DataCenterNetworksService) String() string {
	return fmt.Sprintf("DataCenterNetworksService:%s", op.path)
}

//
//
type QuotaStorageLimitService struct {
	BaseService
}

func NewQuotaStorageLimitService(connection *Connection, path string) *QuotaStorageLimitService {
	var result QuotaStorageLimitService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type QuotaStorageLimitServiceGetRequest struct {
	QuotaStorageLimitService *QuotaStorageLimitService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *QuotaStorageLimitServiceGetRequest) Header(key, value string) *QuotaStorageLimitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitServiceGetRequest) Query(key, value string) *QuotaStorageLimitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitServiceGetRequest) Follow(follow string) *QuotaStorageLimitServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *QuotaStorageLimitServiceGetRequest) Send() (*QuotaStorageLimitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaStorageLimitService.connection.URL(), p.QuotaStorageLimitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaStorageLimitService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaStorageLimitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaStorageLimitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaStorageLimitService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaStorageLimitService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QuotaStorageLimitServiceGetResponse{limit: result}, nil
}

func (p *QuotaStorageLimitServiceGetRequest) MustSend() *QuotaStorageLimitServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type QuotaStorageLimitServiceGetResponse struct {
	limit *QuotaStorageLimit
}

func (p *QuotaStorageLimitServiceGetResponse) Limit() (*QuotaStorageLimit, bool) {
	if p.limit != nil {
		return p.limit, true
	}
	return nil, false
}

func (p *QuotaStorageLimitServiceGetResponse) MustLimit() *QuotaStorageLimit {
	if p.limit == nil {
		panic("limit in response does not exist")
	}
	return p.limit
}

//
//
func (p *QuotaStorageLimitService) Get() *QuotaStorageLimitServiceGetRequest {
	return &QuotaStorageLimitServiceGetRequest{QuotaStorageLimitService: p}
}

//
//
type QuotaStorageLimitServiceRemoveRequest struct {
	QuotaStorageLimitService *QuotaStorageLimitService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *QuotaStorageLimitServiceRemoveRequest) Header(key, value string) *QuotaStorageLimitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitServiceRemoveRequest) Query(key, value string) *QuotaStorageLimitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitServiceRemoveRequest) Async(async bool) *QuotaStorageLimitServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *QuotaStorageLimitServiceRemoveRequest) Send() (*QuotaStorageLimitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaStorageLimitService.connection.URL(), p.QuotaStorageLimitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaStorageLimitService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaStorageLimitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaStorageLimitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaStorageLimitService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaStorageLimitService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(QuotaStorageLimitServiceRemoveResponse), nil
}

func (p *QuotaStorageLimitServiceRemoveRequest) MustSend() *QuotaStorageLimitServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type QuotaStorageLimitServiceRemoveResponse struct {
}

//
//
func (p *QuotaStorageLimitService) Remove() *QuotaStorageLimitServiceRemoveRequest {
	return &QuotaStorageLimitServiceRemoveRequest{QuotaStorageLimitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaStorageLimitService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaStorageLimitService) String() string {
	return fmt.Sprintf("QuotaStorageLimitService:%s", op.path)
}

//
//
type StorageDomainServerConnectionService struct {
	BaseService
}

func NewStorageDomainServerConnectionService(connection *Connection, path string) *StorageDomainServerConnectionService {
	var result StorageDomainServerConnectionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StorageDomainServerConnectionServiceGetRequest struct {
	StorageDomainServerConnectionService *StorageDomainServerConnectionService
	header                               map[string]string
	query                                map[string]string
	follow                               *string
}

func (p *StorageDomainServerConnectionServiceGetRequest) Header(key, value string) *StorageDomainServerConnectionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceGetRequest) Query(key, value string) *StorageDomainServerConnectionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceGetRequest) Follow(follow string) *StorageDomainServerConnectionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainServerConnectionServiceGetRequest) Send() (*StorageDomainServerConnectionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainServerConnectionService.connection.URL(), p.StorageDomainServerConnectionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainServerConnectionServiceGetResponse{connection: result}, nil
}

func (p *StorageDomainServerConnectionServiceGetRequest) MustSend() *StorageDomainServerConnectionServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageDomainServerConnectionServiceGetResponse struct {
	connection *StorageConnection
}

func (p *StorageDomainServerConnectionServiceGetResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageDomainServerConnectionServiceGetResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
//
func (p *StorageDomainServerConnectionService) Get() *StorageDomainServerConnectionServiceGetRequest {
	return &StorageDomainServerConnectionServiceGetRequest{StorageDomainServerConnectionService: p}
}

//
// Detaches a storage connection from storage.
//
type StorageDomainServerConnectionServiceRemoveRequest struct {
	StorageDomainServerConnectionService *StorageDomainServerConnectionService
	header                               map[string]string
	query                                map[string]string
	async                                *bool
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Header(key, value string) *StorageDomainServerConnectionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Query(key, value string) *StorageDomainServerConnectionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Async(async bool) *StorageDomainServerConnectionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) Send() (*StorageDomainServerConnectionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainServerConnectionService.connection.URL(), p.StorageDomainServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainServerConnectionServiceRemoveResponse), nil
}

func (p *StorageDomainServerConnectionServiceRemoveRequest) MustSend() *StorageDomainServerConnectionServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Detaches a storage connection from storage.
//
type StorageDomainServerConnectionServiceRemoveResponse struct {
}

//
// Detaches a storage connection from storage.
//
func (p *StorageDomainServerConnectionService) Remove() *StorageDomainServerConnectionServiceRemoveRequest {
	return &StorageDomainServerConnectionServiceRemoveRequest{StorageDomainServerConnectionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainServerConnectionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainServerConnectionService) String() string {
	return fmt.Sprintf("StorageDomainServerConnectionService:%s", op.path)
}

//
//
type VmBackupDisksService struct {
	BaseService
}

func NewVmBackupDisksService(connection *Connection, path string) *VmBackupDisksService {
	var result VmBackupDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disks in backup.
//
type VmBackupDisksServiceListRequest struct {
	VmBackupDisksService *VmBackupDisksService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *VmBackupDisksServiceListRequest) Header(key, value string) *VmBackupDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmBackupDisksServiceListRequest) Query(key, value string) *VmBackupDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmBackupDisksServiceListRequest) Follow(follow string) *VmBackupDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmBackupDisksServiceListRequest) Max(max int64) *VmBackupDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *VmBackupDisksServiceListRequest) Send() (*VmBackupDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmBackupDisksService.connection.URL(), p.VmBackupDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmBackupDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmBackupDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmBackupDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmBackupDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmBackupDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmBackupDisksServiceListResponse{disks: result}, nil
}

func (p *VmBackupDisksServiceListRequest) MustSend() *VmBackupDisksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of disks in backup.
//
type VmBackupDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *VmBackupDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *VmBackupDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks in backup.
//
func (p *VmBackupDisksService) List() *VmBackupDisksServiceListRequest {
	return &VmBackupDisksServiceListRequest{VmBackupDisksService: p}
}

//
// A reference to the service that manages a specific disk.
//
func (op *VmBackupDisksService) DiskService(id string) *VmBackupDiskService {
	return NewVmBackupDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmBackupDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *VmBackupDisksService) String() string {
	return fmt.Sprintf("VmBackupDisksService:%s", op.path)
}

//
//
type TemplateWatchdogService struct {
	BaseService
}

func NewTemplateWatchdogService(connection *Connection, path string) *TemplateWatchdogService {
	var result TemplateWatchdogService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type TemplateWatchdogServiceGetRequest struct {
	TemplateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *TemplateWatchdogServiceGetRequest) Header(key, value string) *TemplateWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceGetRequest) Query(key, value string) *TemplateWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceGetRequest) Follow(follow string) *TemplateWatchdogServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *TemplateWatchdogServiceGetRequest) Send() (*TemplateWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateWatchdogService.connection.URL(), p.TemplateWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateWatchdogServiceGetResponse{watchdog: result}, nil
}

func (p *TemplateWatchdogServiceGetRequest) MustSend() *TemplateWatchdogServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type TemplateWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogServiceGetResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *TemplateWatchdogServiceGetResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
//
func (p *TemplateWatchdogService) Get() *TemplateWatchdogServiceGetRequest {
	return &TemplateWatchdogServiceGetRequest{TemplateWatchdogService: p}
}

//
//
type TemplateWatchdogServiceRemoveRequest struct {
	TemplateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *TemplateWatchdogServiceRemoveRequest) Header(key, value string) *TemplateWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceRemoveRequest) Query(key, value string) *TemplateWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceRemoveRequest) Async(async bool) *TemplateWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *TemplateWatchdogServiceRemoveRequest) Send() (*TemplateWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateWatchdogService.connection.URL(), p.TemplateWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateWatchdogServiceRemoveResponse), nil
}

func (p *TemplateWatchdogServiceRemoveRequest) MustSend() *TemplateWatchdogServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type TemplateWatchdogServiceRemoveResponse struct {
}

//
//
func (p *TemplateWatchdogService) Remove() *TemplateWatchdogServiceRemoveRequest {
	return &TemplateWatchdogServiceRemoveRequest{TemplateWatchdogService: p}
}

//
// Update the watchdog for the template identified by the given id.
//
type TemplateWatchdogServiceUpdateRequest struct {
	TemplateWatchdogService *TemplateWatchdogService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	watchdog                *Watchdog
}

func (p *TemplateWatchdogServiceUpdateRequest) Header(key, value string) *TemplateWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogServiceUpdateRequest) Query(key, value string) *TemplateWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogServiceUpdateRequest) Async(async bool) *TemplateWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *TemplateWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *TemplateWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}

func (p *TemplateWatchdogServiceUpdateRequest) Send() (*TemplateWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateWatchdogService.connection.URL(), p.TemplateWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateWatchdogServiceUpdateResponse{watchdog: result}, nil
}

func (p *TemplateWatchdogServiceUpdateRequest) MustSend() *TemplateWatchdogServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the watchdog for the template identified by the given id.
//
type TemplateWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogServiceUpdateResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *TemplateWatchdogServiceUpdateResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Update the watchdog for the template identified by the given id.
//
func (p *TemplateWatchdogService) Update() *TemplateWatchdogServiceUpdateRequest {
	return &TemplateWatchdogServiceUpdateRequest{TemplateWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateWatchdogService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateWatchdogService) String() string {
	return fmt.Sprintf("TemplateWatchdogService:%s", op.path)
}

//
//
type BalanceService struct {
	BaseService
}

func NewBalanceService(connection *Connection, path string) *BalanceService {
	var result BalanceService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type BalanceServiceGetRequest struct {
	BalanceService *BalanceService
	header         map[string]string
	query          map[string]string
	filter         *bool
	follow         *string
}

func (p *BalanceServiceGetRequest) Header(key, value string) *BalanceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalanceServiceGetRequest) Query(key, value string) *BalanceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalanceServiceGetRequest) Filter(filter bool) *BalanceServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *BalanceServiceGetRequest) Follow(follow string) *BalanceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *BalanceServiceGetRequest) Send() (*BalanceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BalanceService.connection.URL(), p.BalanceService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BalanceService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BalanceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BalanceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BalanceService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BalanceService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &BalanceServiceGetResponse{balance: result}, nil
}

func (p *BalanceServiceGetRequest) MustSend() *BalanceServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type BalanceServiceGetResponse struct {
	balance *Balance
}

func (p *BalanceServiceGetResponse) Balance() (*Balance, bool) {
	if p.balance != nil {
		return p.balance, true
	}
	return nil, false
}

func (p *BalanceServiceGetResponse) MustBalance() *Balance {
	if p.balance == nil {
		panic("balance in response does not exist")
	}
	return p.balance
}

//
//
func (p *BalanceService) Get() *BalanceServiceGetRequest {
	return &BalanceServiceGetRequest{BalanceService: p}
}

//
//
type BalanceServiceRemoveRequest struct {
	BalanceService *BalanceService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *BalanceServiceRemoveRequest) Header(key, value string) *BalanceServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalanceServiceRemoveRequest) Query(key, value string) *BalanceServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalanceServiceRemoveRequest) Async(async bool) *BalanceServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *BalanceServiceRemoveRequest) Send() (*BalanceServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BalanceService.connection.URL(), p.BalanceService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BalanceService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BalanceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BalanceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BalanceService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BalanceService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(BalanceServiceRemoveResponse), nil
}

func (p *BalanceServiceRemoveRequest) MustSend() *BalanceServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type BalanceServiceRemoveResponse struct {
}

//
//
func (p *BalanceService) Remove() *BalanceServiceRemoveRequest {
	return &BalanceServiceRemoveRequest{BalanceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BalanceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *BalanceService) String() string {
	return fmt.Sprintf("BalanceService:%s", op.path)
}

//
//
type SnapshotNicService struct {
	BaseService
}

func NewSnapshotNicService(connection *Connection, path string) *SnapshotNicService {
	var result SnapshotNicService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type SnapshotNicServiceGetRequest struct {
	SnapshotNicService *SnapshotNicService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *SnapshotNicServiceGetRequest) Header(key, value string) *SnapshotNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotNicServiceGetRequest) Query(key, value string) *SnapshotNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotNicServiceGetRequest) Follow(follow string) *SnapshotNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *SnapshotNicServiceGetRequest) Send() (*SnapshotNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotNicService.connection.URL(), p.SnapshotNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SnapshotNicServiceGetResponse{nic: result}, nil
}

func (p *SnapshotNicServiceGetRequest) MustSend() *SnapshotNicServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SnapshotNicServiceGetResponse struct {
	nic *Nic
}

func (p *SnapshotNicServiceGetResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *SnapshotNicServiceGetResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
//
func (p *SnapshotNicService) Get() *SnapshotNicServiceGetRequest {
	return &SnapshotNicServiceGetRequest{SnapshotNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotNicService) String() string {
	return fmt.Sprintf("SnapshotNicService:%s", op.path)
}

//
// This service is used to list and manipulate affinity labels that are
// assigned to supported entities when accessed using entities/affinitylabels.
//
type AssignedAffinityLabelsService struct {
	BaseService
}

func NewAssignedAffinityLabelsService(connection *Connection, path string) *AssignedAffinityLabelsService {
	var result AssignedAffinityLabelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Attaches a label to an entity.
//
type AssignedAffinityLabelsServiceAddRequest struct {
	AssignedAffinityLabelsService *AssignedAffinityLabelsService
	header                        map[string]string
	query                         map[string]string
	label                         *AffinityLabel
}

func (p *AssignedAffinityLabelsServiceAddRequest) Header(key, value string) *AssignedAffinityLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceAddRequest) Query(key, value string) *AssignedAffinityLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceAddRequest) Label(label *AffinityLabel) *AssignedAffinityLabelsServiceAddRequest {
	p.label = label
	return p
}

func (p *AssignedAffinityLabelsServiceAddRequest) Send() (*AssignedAffinityLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedAffinityLabelsService.connection.URL(), p.AssignedAffinityLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedAffinityLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedAffinityLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedAffinityLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedAffinityLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedAffinityLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedAffinityLabelsServiceAddResponse{label: result}, nil
}

func (p *AssignedAffinityLabelsServiceAddRequest) MustSend() *AssignedAffinityLabelsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Attaches a label to an entity.
//
type AssignedAffinityLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *AssignedAffinityLabelsServiceAddResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *AssignedAffinityLabelsServiceAddResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Attaches a label to an entity.
//
func (p *AssignedAffinityLabelsService) Add() *AssignedAffinityLabelsServiceAddRequest {
	return &AssignedAffinityLabelsServiceAddRequest{AssignedAffinityLabelsService: p}
}

//
// Lists all labels that are attached to an entity.
// The order of the returned entities isn't guaranteed.
//
type AssignedAffinityLabelsServiceListRequest struct {
	AssignedAffinityLabelsService *AssignedAffinityLabelsService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *AssignedAffinityLabelsServiceListRequest) Header(key, value string) *AssignedAffinityLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceListRequest) Query(key, value string) *AssignedAffinityLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedAffinityLabelsServiceListRequest) Follow(follow string) *AssignedAffinityLabelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AssignedAffinityLabelsServiceListRequest) Send() (*AssignedAffinityLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedAffinityLabelsService.connection.URL(), p.AssignedAffinityLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedAffinityLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedAffinityLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedAffinityLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedAffinityLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedAffinityLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AssignedAffinityLabelsServiceListResponse{label: result}, nil
}

func (p *AssignedAffinityLabelsServiceListRequest) MustSend() *AssignedAffinityLabelsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all labels that are attached to an entity.
// The order of the returned entities isn't guaranteed.
//
type AssignedAffinityLabelsServiceListResponse struct {
	label *AffinityLabelSlice
}

func (p *AssignedAffinityLabelsServiceListResponse) Label() (*AffinityLabelSlice, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *AssignedAffinityLabelsServiceListResponse) MustLabel() *AffinityLabelSlice {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Lists all labels that are attached to an entity.
// The order of the returned entities isn't guaranteed.
//
func (p *AssignedAffinityLabelsService) List() *AssignedAffinityLabelsServiceListRequest {
	return &AssignedAffinityLabelsServiceListRequest{AssignedAffinityLabelsService: p}
}

//
// Link to the specific entity-label assignment to allow
// removal.
//
func (op *AssignedAffinityLabelsService) LabelService(id string) *AssignedAffinityLabelService {
	return NewAssignedAffinityLabelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedAffinityLabelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LabelService(path), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *AssignedAffinityLabelsService) String() string {
	return fmt.Sprintf("AssignedAffinityLabelsService:%s", op.path)
}

//
// A service to access host devices.
//
type HostDevicesService struct {
	BaseService
}

func NewHostDevicesService(connection *Connection, path string) *HostDevicesService {
	var result HostDevicesService
	result.connection = connection
	result.path = path
	return &result
}

//
// List the devices of a host.
// The order of the returned list of devices isn't guaranteed.
//
type HostDevicesServiceListRequest struct {
	HostDevicesService *HostDevicesService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *HostDevicesServiceListRequest) Header(key, value string) *HostDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostDevicesServiceListRequest) Query(key, value string) *HostDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostDevicesServiceListRequest) Follow(follow string) *HostDevicesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *HostDevicesServiceListRequest) Max(max int64) *HostDevicesServiceListRequest {
	p.max = &max
	return p
}

func (p *HostDevicesServiceListRequest) Send() (*HostDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostDevicesService.connection.URL(), p.HostDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostDevicesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostDevicesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostDevicesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostDevicesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostDevicesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &HostDevicesServiceListResponse{devices: result}, nil
}

func (p *HostDevicesServiceListRequest) MustSend() *HostDevicesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the devices of a host.
// The order of the returned list of devices isn't guaranteed.
//
type HostDevicesServiceListResponse struct {
	devices *HostDeviceSlice
}

func (p *HostDevicesServiceListResponse) Devices() (*HostDeviceSlice, bool) {
	if p.devices != nil {
		return p.devices, true
	}
	return nil, false
}

func (p *HostDevicesServiceListResponse) MustDevices() *HostDeviceSlice {
	if p.devices == nil {
		panic("devices in response does not exist")
	}
	return p.devices
}

//
// List the devices of a host.
// The order of the returned list of devices isn't guaranteed.
//
func (p *HostDevicesService) List() *HostDevicesServiceListRequest {
	return &HostDevicesServiceListRequest{HostDevicesService: p}
}

//
// Reference to the service that can be used to access a specific host device.
//
func (op *HostDevicesService) DeviceService(id string) *HostDeviceService {
	return NewHostDeviceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostDevicesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DeviceService(path), nil
	}
	return op.DeviceService(path[:index]).Service(path[index+1:])
}

func (op *HostDevicesService) String() string {
	return fmt.Sprintf("HostDevicesService:%s", op.path)
}

//
// Represents a permission sub-collection, scoped by user, group or some entity type.
//
type AssignedPermissionsService struct {
	BaseService
}

func NewAssignedPermissionsService(connection *Connection, path string) *AssignedPermissionsService {
	var result AssignedPermissionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
type AssignedPermissionsServiceAddRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddRequest) Header(key, value string) *AssignedPermissionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddRequest) Query(key, value string) *AssignedPermissionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddRequest) Send() (*AssignedPermissionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLPermissionWriteOne(writer, p.permission, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedPermissionsServiceAddResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddRequest) MustSend() *AssignedPermissionsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
type AssignedPermissionsServiceAddResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Assign a new permission to a user or group for specific entity.
// For example, to assign the `UserVmManager` role to the virtual machine with id `123` to the user with id `456`
// send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserVmManager</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// To assign the `SuperUser` role to the system to the user with id `456` send a request like this:
// ....
// POST /ovirt-engine/api/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>SuperUser</name>
//   </role>
//   <user id="456"/>
// </permission>
// ----
// If you want to assign permission to the group instead of the user please replace the `user` element with the
// `group` element with proper `id` of the group. For example to assign the `UserRole` role to the cluster with
// id `123` to the group with id `789` send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/permissions
// ....
// With a request body like this:
// [source,xml]
// ----
// <permission>
//   <role>
//     <name>UserRole</name>
//   </role>
//   <group id="789"/>
// </permission>
// ----
//
func (p *AssignedPermissionsService) Add() *AssignedPermissionsServiceAddRequest {
	return &AssignedPermissionsServiceAddRequest{AssignedPermissionsService: p}
}

//
// Add a new permission on the cluster to the group in the system.
//
type AssignedPermissionsServiceAddClusterPermissionRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddClusterPermissionRequest) Header(key, value string) *AssignedPermissionsServiceAddClusterPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddClusterPermissionRequest) Query(key, value string) *AssignedPermissionsServiceAddClusterPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddClusterPermissionRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddClusterPermissionRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddClusterPermissionRequest) Send() (*AssignedPermissionsServiceAddClusterPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clusterpermission", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddClusterPermissionResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddClusterPermissionRequest) MustSend() *AssignedPermissionsServiceAddClusterPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the cluster to the group in the system.
//
type AssignedPermissionsServiceAddClusterPermissionResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddClusterPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddClusterPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the cluster to the group in the system.
//
func (p *AssignedPermissionsService) AddClusterPermission() *AssignedPermissionsServiceAddClusterPermissionRequest {
	return &AssignedPermissionsServiceAddClusterPermissionRequest{AssignedPermissionsService: p}
}

//
// Add a new permission on the data center to the group in the system.
//
type AssignedPermissionsServiceAddDataCenterPermissionRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddDataCenterPermissionRequest) Header(key, value string) *AssignedPermissionsServiceAddDataCenterPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddDataCenterPermissionRequest) Query(key, value string) *AssignedPermissionsServiceAddDataCenterPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddDataCenterPermissionRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddDataCenterPermissionRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddDataCenterPermissionRequest) Send() (*AssignedPermissionsServiceAddDataCenterPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/datacenterpermission", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddDataCenterPermissionResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddDataCenterPermissionRequest) MustSend() *AssignedPermissionsServiceAddDataCenterPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the data center to the group in the system.
//
type AssignedPermissionsServiceAddDataCenterPermissionResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddDataCenterPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddDataCenterPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the data center to the group in the system.
//
func (p *AssignedPermissionsService) AddDataCenterPermission() *AssignedPermissionsServiceAddDataCenterPermissionRequest {
	return &AssignedPermissionsServiceAddDataCenterPermissionRequest{AssignedPermissionsService: p}
}

//
// Add a new group level permission for a given virtual machine.
//
type AssignedPermissionsServiceAddGroupLevelRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddGroupLevelRequest) Header(key, value string) *AssignedPermissionsServiceAddGroupLevelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddGroupLevelRequest) Query(key, value string) *AssignedPermissionsServiceAddGroupLevelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddGroupLevelRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddGroupLevelRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddGroupLevelRequest) Send() (*AssignedPermissionsServiceAddGroupLevelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/grouplevel", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddGroupLevelResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddGroupLevelRequest) MustSend() *AssignedPermissionsServiceAddGroupLevelResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new group level permission for a given virtual machine.
//
type AssignedPermissionsServiceAddGroupLevelResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddGroupLevelResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddGroupLevelResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new group level permission for a given virtual machine.
//
func (p *AssignedPermissionsService) AddGroupLevel() *AssignedPermissionsServiceAddGroupLevelRequest {
	return &AssignedPermissionsServiceAddGroupLevelRequest{AssignedPermissionsService: p}
}

//
// Add a new permission on the host to the group in the system.
//
type AssignedPermissionsServiceAddHostPermissionRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddHostPermissionRequest) Header(key, value string) *AssignedPermissionsServiceAddHostPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddHostPermissionRequest) Query(key, value string) *AssignedPermissionsServiceAddHostPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddHostPermissionRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddHostPermissionRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddHostPermissionRequest) Send() (*AssignedPermissionsServiceAddHostPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/hostpermission", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddHostPermissionResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddHostPermissionRequest) MustSend() *AssignedPermissionsServiceAddHostPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the host to the group in the system.
//
type AssignedPermissionsServiceAddHostPermissionResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddHostPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddHostPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the host to the group in the system.
//
func (p *AssignedPermissionsService) AddHostPermission() *AssignedPermissionsServiceAddHostPermissionRequest {
	return &AssignedPermissionsServiceAddHostPermissionRequest{AssignedPermissionsService: p}
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
type AssignedPermissionsServiceListRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
}

func (p *AssignedPermissionsServiceListRequest) Header(key, value string) *AssignedPermissionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceListRequest) Query(key, value string) *AssignedPermissionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceListRequest) Follow(follow string) *AssignedPermissionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AssignedPermissionsServiceListRequest) Send() (*AssignedPermissionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AssignedPermissionsServiceListResponse{permissions: result}, nil
}

func (p *AssignedPermissionsServiceListRequest) MustSend() *AssignedPermissionsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
type AssignedPermissionsServiceListResponse struct {
	permissions *PermissionSlice
}

func (p *AssignedPermissionsServiceListResponse) Permissions() (*PermissionSlice, bool) {
	if p.permissions != nil {
		return p.permissions, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceListResponse) MustPermissions() *PermissionSlice {
	if p.permissions == nil {
		panic("permissions in response does not exist")
	}
	return p.permissions
}

//
// List all the permissions of the specific entity.
// For example to list all the permissions of the cluster with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/clusters/123/permissions
// ....
// [source,xml]
// ----
// <permissions>
//   <permission id="456">
//     <cluster id="123"/>
//     <role id="789"/>
//     <user id="451"/>
//   </permission>
//   <permission id="654">
//     <cluster id="123"/>
//     <role id="789"/>
//     <group id="127"/>
//   </permission>
// </permissions>
// ----
// The order of the returned permissions isn't guaranteed.
//
func (p *AssignedPermissionsService) List() *AssignedPermissionsServiceListRequest {
	return &AssignedPermissionsServiceListRequest{AssignedPermissionsService: p}
}

//
// Add a new permission on the storage domain to the group in the system.
//
type AssignedPermissionsServiceAddStorageDomainPermissionRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddStorageDomainPermissionRequest) Header(key, value string) *AssignedPermissionsServiceAddStorageDomainPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddStorageDomainPermissionRequest) Query(key, value string) *AssignedPermissionsServiceAddStorageDomainPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddStorageDomainPermissionRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddStorageDomainPermissionRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddStorageDomainPermissionRequest) Send() (*AssignedPermissionsServiceAddStorageDomainPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/storagedomainpermission", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddStorageDomainPermissionResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddStorageDomainPermissionRequest) MustSend() *AssignedPermissionsServiceAddStorageDomainPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the storage domain to the group in the system.
//
type AssignedPermissionsServiceAddStorageDomainPermissionResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddStorageDomainPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddStorageDomainPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the storage domain to the group in the system.
//
func (p *AssignedPermissionsService) AddStorageDomainPermission() *AssignedPermissionsServiceAddStorageDomainPermissionRequest {
	return &AssignedPermissionsServiceAddStorageDomainPermissionRequest{AssignedPermissionsService: p}
}

//
// Add a new permission on the template to the group in the system.
//
type AssignedPermissionsServiceAddTemplatePermissionRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddTemplatePermissionRequest) Header(key, value string) *AssignedPermissionsServiceAddTemplatePermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddTemplatePermissionRequest) Query(key, value string) *AssignedPermissionsServiceAddTemplatePermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddTemplatePermissionRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddTemplatePermissionRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddTemplatePermissionRequest) Send() (*AssignedPermissionsServiceAddTemplatePermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/templatepermission", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddTemplatePermissionResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddTemplatePermissionRequest) MustSend() *AssignedPermissionsServiceAddTemplatePermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the template to the group in the system.
//
type AssignedPermissionsServiceAddTemplatePermissionResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddTemplatePermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddTemplatePermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the template to the group in the system.
//
func (p *AssignedPermissionsService) AddTemplatePermission() *AssignedPermissionsServiceAddTemplatePermissionRequest {
	return &AssignedPermissionsServiceAddTemplatePermissionRequest{AssignedPermissionsService: p}
}

//
// Add a new user level permission for a given virtual machine.
//
type AssignedPermissionsServiceAddUserLevelRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddUserLevelRequest) Header(key, value string) *AssignedPermissionsServiceAddUserLevelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddUserLevelRequest) Query(key, value string) *AssignedPermissionsServiceAddUserLevelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddUserLevelRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddUserLevelRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddUserLevelRequest) Send() (*AssignedPermissionsServiceAddUserLevelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/userlevel", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddUserLevelResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddUserLevelRequest) MustSend() *AssignedPermissionsServiceAddUserLevelResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new user level permission for a given virtual machine.
//
type AssignedPermissionsServiceAddUserLevelResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddUserLevelResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddUserLevelResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new user level permission for a given virtual machine.
//
func (p *AssignedPermissionsService) AddUserLevel() *AssignedPermissionsServiceAddUserLevelRequest {
	return &AssignedPermissionsServiceAddUserLevelRequest{AssignedPermissionsService: p}
}

//
// Add a new permission on the vm to the group in the system.
//
type AssignedPermissionsServiceAddVmPermissionRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddVmPermissionRequest) Header(key, value string) *AssignedPermissionsServiceAddVmPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddVmPermissionRequest) Query(key, value string) *AssignedPermissionsServiceAddVmPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddVmPermissionRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddVmPermissionRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddVmPermissionRequest) Send() (*AssignedPermissionsServiceAddVmPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vmpermission", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddVmPermissionResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddVmPermissionRequest) MustSend() *AssignedPermissionsServiceAddVmPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the vm to the group in the system.
//
type AssignedPermissionsServiceAddVmPermissionResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddVmPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddVmPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the vm to the group in the system.
//
func (p *AssignedPermissionsService) AddVmPermission() *AssignedPermissionsServiceAddVmPermissionRequest {
	return &AssignedPermissionsServiceAddVmPermissionRequest{AssignedPermissionsService: p}
}

//
// Add a new permission on the vm pool to the group in the system.
//
type AssignedPermissionsServiceAddVmPoolPermissionRequest struct {
	AssignedPermissionsService *AssignedPermissionsService
	header                     map[string]string
	query                      map[string]string
	permission                 *Permission
}

func (p *AssignedPermissionsServiceAddVmPoolPermissionRequest) Header(key, value string) *AssignedPermissionsServiceAddVmPoolPermissionRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddVmPoolPermissionRequest) Query(key, value string) *AssignedPermissionsServiceAddVmPoolPermissionRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedPermissionsServiceAddVmPoolPermissionRequest) Permission(permission *Permission) *AssignedPermissionsServiceAddVmPoolPermissionRequest {
	p.permission = permission
	return p
}

func (p *AssignedPermissionsServiceAddVmPoolPermissionRequest) Send() (*AssignedPermissionsServiceAddVmPoolPermissionResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vmpoolpermission", p.AssignedPermissionsService.connection.URL(), p.AssignedPermissionsService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Permission(p.permission)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedPermissionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedPermissionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedPermissionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedPermissionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedPermissionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPermission()
	return &AssignedPermissionsServiceAddVmPoolPermissionResponse{permission: result}, nil
}

func (p *AssignedPermissionsServiceAddVmPoolPermissionRequest) MustSend() *AssignedPermissionsServiceAddVmPoolPermissionResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new permission on the vm pool to the group in the system.
//
type AssignedPermissionsServiceAddVmPoolPermissionResponse struct {
	permission *Permission
}

func (p *AssignedPermissionsServiceAddVmPoolPermissionResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *AssignedPermissionsServiceAddVmPoolPermissionResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
// Add a new permission on the vm pool to the group in the system.
//
func (p *AssignedPermissionsService) AddVmPoolPermission() *AssignedPermissionsServiceAddVmPoolPermissionRequest {
	return &AssignedPermissionsServiceAddVmPoolPermissionRequest{AssignedPermissionsService: p}
}

//
// Sub-resource locator method, returns individual permission resource on which the remainder of the URI is
// dispatched.
//
func (op *AssignedPermissionsService) PermissionService(id string) *PermissionService {
	return NewPermissionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedPermissionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PermissionService(path), nil
	}
	return op.PermissionService(path[:index]).Service(path[index+1:])
}

func (op *AssignedPermissionsService) String() string {
	return fmt.Sprintf("AssignedPermissionsService:%s", op.path)
}

//
// A service to manage a virtual machines pool.
//
type VmPoolService struct {
	BaseService
}

func NewVmPoolService(connection *Connection, path string) *VmPoolService {
	var result VmPoolService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation allocates a virtual machine in the virtual machine pool.
// [source]
// ----
// POST /ovirt-engine/api/vmpools/123/allocatevm
// ----
// The allocate virtual machine action does not take any action specific parameters, so the request body should
// contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmPoolServiceAllocateVmRequest struct {
	VmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmPoolServiceAllocateVmRequest) Header(key, value string) *VmPoolServiceAllocateVmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceAllocateVmRequest) Query(key, value string) *VmPoolServiceAllocateVmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceAllocateVmRequest) Async(async bool) *VmPoolServiceAllocateVmRequest {
	p.async = &async
	return p
}

func (p *VmPoolServiceAllocateVmRequest) Send() (*VmPoolServiceAllocateVmResponse, error) {
	rawURL := fmt.Sprintf("%s%s/allocatevm", p.VmPoolService.connection.URL(), p.VmPoolService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmPoolService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmPoolService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmPoolService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmPoolServiceAllocateVmResponse), nil
}

func (p *VmPoolServiceAllocateVmRequest) MustSend() *VmPoolServiceAllocateVmResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation allocates a virtual machine in the virtual machine pool.
// [source]
// ----
// POST /ovirt-engine/api/vmpools/123/allocatevm
// ----
// The allocate virtual machine action does not take any action specific parameters, so the request body should
// contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmPoolServiceAllocateVmResponse struct {
}

//
// This operation allocates a virtual machine in the virtual machine pool.
// [source]
// ----
// POST /ovirt-engine/api/vmpools/123/allocatevm
// ----
// The allocate virtual machine action does not take any action specific parameters, so the request body should
// contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmPoolService) AllocateVm() *VmPoolServiceAllocateVmRequest {
	return &VmPoolServiceAllocateVmRequest{VmPoolService: p}
}

//
// Get the virtual machine pool.
// [source]
// ----
// GET /ovirt-engine/api/vmpools/123
// ----
// You will get a XML response like that one:
// [source,xml]
// ----
// <vm_pool id="123">
//   <actions>...</actions>
//   <name>MyVmPool</name>
//   <description>MyVmPool description</description>
//   <link href="/ovirt-engine/api/vmpools/123/permissions" rel="permissions"/>
//   <max_user_vms>1</max_user_vms>
//   <prestarted_vms>0</prestarted_vms>
//   <size>100</size>
//   <stateful>false</stateful>
//   <type>automatic</type>
//   <use_latest_template_version>false</use_latest_template_version>
//   <cluster id="123"/>
//   <template id="123"/>
//   <vm id="123">...</vm>
//   ...
// </vm_pool>
// ----
//
type VmPoolServiceGetRequest struct {
	VmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	filter        *bool
	follow        *string
}

func (p *VmPoolServiceGetRequest) Header(key, value string) *VmPoolServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceGetRequest) Query(key, value string) *VmPoolServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceGetRequest) Filter(filter bool) *VmPoolServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *VmPoolServiceGetRequest) Follow(follow string) *VmPoolServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmPoolServiceGetRequest) Send() (*VmPoolServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmPoolService.connection.URL(), p.VmPoolService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmPoolService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmPoolService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmPoolService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmPoolServiceGetResponse{pool: result}, nil
}

func (p *VmPoolServiceGetRequest) MustSend() *VmPoolServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get the virtual machine pool.
// [source]
// ----
// GET /ovirt-engine/api/vmpools/123
// ----
// You will get a XML response like that one:
// [source,xml]
// ----
// <vm_pool id="123">
//   <actions>...</actions>
//   <name>MyVmPool</name>
//   <description>MyVmPool description</description>
//   <link href="/ovirt-engine/api/vmpools/123/permissions" rel="permissions"/>
//   <max_user_vms>1</max_user_vms>
//   <prestarted_vms>0</prestarted_vms>
//   <size>100</size>
//   <stateful>false</stateful>
//   <type>automatic</type>
//   <use_latest_template_version>false</use_latest_template_version>
//   <cluster id="123"/>
//   <template id="123"/>
//   <vm id="123">...</vm>
//   ...
// </vm_pool>
// ----
//
type VmPoolServiceGetResponse struct {
	pool *VmPool
}

func (p *VmPoolServiceGetResponse) Pool() (*VmPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *VmPoolServiceGetResponse) MustPool() *VmPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Get the virtual machine pool.
// [source]
// ----
// GET /ovirt-engine/api/vmpools/123
// ----
// You will get a XML response like that one:
// [source,xml]
// ----
// <vm_pool id="123">
//   <actions>...</actions>
//   <name>MyVmPool</name>
//   <description>MyVmPool description</description>
//   <link href="/ovirt-engine/api/vmpools/123/permissions" rel="permissions"/>
//   <max_user_vms>1</max_user_vms>
//   <prestarted_vms>0</prestarted_vms>
//   <size>100</size>
//   <stateful>false</stateful>
//   <type>automatic</type>
//   <use_latest_template_version>false</use_latest_template_version>
//   <cluster id="123"/>
//   <template id="123"/>
//   <vm id="123">...</vm>
//   ...
// </vm_pool>
// ----
//
func (p *VmPoolService) Get() *VmPoolServiceGetRequest {
	return &VmPoolServiceGetRequest{VmPoolService: p}
}

//
// Removes a virtual machine pool.
// [source]
// ----
// DELETE /ovirt-engine/api/vmpools/123
// ----
//
type VmPoolServiceRemoveRequest struct {
	VmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmPoolServiceRemoveRequest) Header(key, value string) *VmPoolServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceRemoveRequest) Query(key, value string) *VmPoolServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceRemoveRequest) Async(async bool) *VmPoolServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VmPoolServiceRemoveRequest) Send() (*VmPoolServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmPoolService.connection.URL(), p.VmPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmPoolService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmPoolService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmPoolService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmPoolServiceRemoveResponse), nil
}

func (p *VmPoolServiceRemoveRequest) MustSend() *VmPoolServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a virtual machine pool.
// [source]
// ----
// DELETE /ovirt-engine/api/vmpools/123
// ----
//
type VmPoolServiceRemoveResponse struct {
}

//
// Removes a virtual machine pool.
// [source]
// ----
// DELETE /ovirt-engine/api/vmpools/123
// ----
//
func (p *VmPoolService) Remove() *VmPoolServiceRemoveRequest {
	return &VmPoolServiceRemoveRequest{VmPoolService: p}
}

//
// Update the virtual machine pool.
// [source]
// ----
// PUT /ovirt-engine/api/vmpools/123
// ----
// The `name`, `description`, `size`, `prestarted_vms` and `max_user_vms`
// attributes can be updated after the virtual machine pool has been
// created.
// [source,xml]
// ----
// <vmpool>
//   <name>VM_Pool_B</name>
//   <description>Virtual Machine Pool B</description>
//   <size>3</size>
//   <prestarted_vms>1</size>
//   <max_user_vms>2</size>
// </vmpool>
// ----
//
type VmPoolServiceUpdateRequest struct {
	VmPoolService *VmPoolService
	header        map[string]string
	query         map[string]string
	async         *bool
	pool          *VmPool
}

func (p *VmPoolServiceUpdateRequest) Header(key, value string) *VmPoolServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolServiceUpdateRequest) Query(key, value string) *VmPoolServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolServiceUpdateRequest) Async(async bool) *VmPoolServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *VmPoolServiceUpdateRequest) Pool(pool *VmPool) *VmPoolServiceUpdateRequest {
	p.pool = pool
	return p
}

func (p *VmPoolServiceUpdateRequest) Send() (*VmPoolServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmPoolService.connection.URL(), p.VmPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmPoolWriteOne(writer, p.pool, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmPoolService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmPoolService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmPoolService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmPoolServiceUpdateResponse{pool: result}, nil
}

func (p *VmPoolServiceUpdateRequest) MustSend() *VmPoolServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the virtual machine pool.
// [source]
// ----
// PUT /ovirt-engine/api/vmpools/123
// ----
// The `name`, `description`, `size`, `prestarted_vms` and `max_user_vms`
// attributes can be updated after the virtual machine pool has been
// created.
// [source,xml]
// ----
// <vmpool>
//   <name>VM_Pool_B</name>
//   <description>Virtual Machine Pool B</description>
//   <size>3</size>
//   <prestarted_vms>1</size>
//   <max_user_vms>2</size>
// </vmpool>
// ----
//
type VmPoolServiceUpdateResponse struct {
	pool *VmPool
}

func (p *VmPoolServiceUpdateResponse) Pool() (*VmPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *VmPoolServiceUpdateResponse) MustPool() *VmPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Update the virtual machine pool.
// [source]
// ----
// PUT /ovirt-engine/api/vmpools/123
// ----
// The `name`, `description`, `size`, `prestarted_vms` and `max_user_vms`
// attributes can be updated after the virtual machine pool has been
// created.
// [source,xml]
// ----
// <vmpool>
//   <name>VM_Pool_B</name>
//   <description>Virtual Machine Pool B</description>
//   <size>3</size>
//   <prestarted_vms>1</size>
//   <max_user_vms>2</size>
// </vmpool>
// ----
//
func (p *VmPoolService) Update() *VmPoolServiceUpdateRequest {
	return &VmPoolServiceUpdateRequest{VmPoolService: p}
}

//
// Reference to a service managing the virtual machine pool assigned permissions.
//
func (op *VmPoolService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmPoolService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmPoolService) String() string {
	return fmt.Sprintf("VmPoolService:%s", op.path)
}

//
//
type VmReportedDeviceService struct {
	BaseService
}

func NewVmReportedDeviceService(connection *Connection, path string) *VmReportedDeviceService {
	var result VmReportedDeviceService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type VmReportedDeviceServiceGetRequest struct {
	VmReportedDeviceService *VmReportedDeviceService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *VmReportedDeviceServiceGetRequest) Header(key, value string) *VmReportedDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmReportedDeviceServiceGetRequest) Query(key, value string) *VmReportedDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmReportedDeviceServiceGetRequest) Follow(follow string) *VmReportedDeviceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmReportedDeviceServiceGetRequest) Send() (*VmReportedDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmReportedDeviceService.connection.URL(), p.VmReportedDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmReportedDeviceService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmReportedDeviceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmReportedDeviceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmReportedDeviceService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmReportedDeviceService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLReportedDeviceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmReportedDeviceServiceGetResponse{reportedDevice: result}, nil
}

func (p *VmReportedDeviceServiceGetRequest) MustSend() *VmReportedDeviceServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmReportedDeviceServiceGetResponse struct {
	reportedDevice *ReportedDevice
}

func (p *VmReportedDeviceServiceGetResponse) ReportedDevice() (*ReportedDevice, bool) {
	if p.reportedDevice != nil {
		return p.reportedDevice, true
	}
	return nil, false
}

func (p *VmReportedDeviceServiceGetResponse) MustReportedDevice() *ReportedDevice {
	if p.reportedDevice == nil {
		panic("reportedDevice in response does not exist")
	}
	return p.reportedDevice
}

//
//
func (p *VmReportedDeviceService) Get() *VmReportedDeviceServiceGetRequest {
	return &VmReportedDeviceServiceGetRequest{VmReportedDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmReportedDeviceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmReportedDeviceService) String() string {
	return fmt.Sprintf("VmReportedDeviceService:%s", op.path)
}

//
// A service managing a CD-ROM device on templates.
//
type TemplateCdromService struct {
	BaseService
}

func NewTemplateCdromService(connection *Connection, path string) *TemplateCdromService {
	var result TemplateCdromService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about this CD-ROM device.
// For example, to get information about the CD-ROM device of template `123` send a request like:
// [source]
// ----
// GET /ovirt-engine/api/templates/123/cdroms/
// ----
//
type TemplateCdromServiceGetRequest struct {
	TemplateCdromService *TemplateCdromService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *TemplateCdromServiceGetRequest) Header(key, value string) *TemplateCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateCdromServiceGetRequest) Query(key, value string) *TemplateCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateCdromServiceGetRequest) Follow(follow string) *TemplateCdromServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *TemplateCdromServiceGetRequest) Send() (*TemplateCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateCdromService.connection.URL(), p.TemplateCdromService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateCdromService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateCdromService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateCdromService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateCdromService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateCdromService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateCdromServiceGetResponse{cdrom: result}, nil
}

func (p *TemplateCdromServiceGetRequest) MustSend() *TemplateCdromServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the information about this CD-ROM device.
// For example, to get information about the CD-ROM device of template `123` send a request like:
// [source]
// ----
// GET /ovirt-engine/api/templates/123/cdroms/
// ----
//
type TemplateCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *TemplateCdromServiceGetResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *TemplateCdromServiceGetResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
// Returns the information about this CD-ROM device.
// For example, to get information about the CD-ROM device of template `123` send a request like:
// [source]
// ----
// GET /ovirt-engine/api/templates/123/cdroms/
// ----
//
func (p *TemplateCdromService) Get() *TemplateCdromServiceGetRequest {
	return &TemplateCdromServiceGetRequest{TemplateCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateCdromService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateCdromService) String() string {
	return fmt.Sprintf("TemplateCdromService:%s", op.path)
}

//
//
type CopyableService struct {
	BaseService
}

func NewCopyableService(connection *Connection, path string) *CopyableService {
	var result CopyableService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type CopyableServiceCopyRequest struct {
	CopyableService *CopyableService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *CopyableServiceCopyRequest) Header(key, value string) *CopyableServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CopyableServiceCopyRequest) Query(key, value string) *CopyableServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CopyableServiceCopyRequest) Async(async bool) *CopyableServiceCopyRequest {
	p.async = &async
	return p
}

func (p *CopyableServiceCopyRequest) Send() (*CopyableServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.CopyableService.connection.URL(), p.CopyableService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.CopyableService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.CopyableService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.CopyableService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.CopyableService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.CopyableService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(CopyableServiceCopyResponse), nil
}

func (p *CopyableServiceCopyRequest) MustSend() *CopyableServiceCopyResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type CopyableServiceCopyResponse struct {
}

//
//
func (p *CopyableService) Copy() *CopyableServiceCopyRequest {
	return &CopyableServiceCopyRequest{CopyableService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CopyableService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *CopyableService) String() string {
	return fmt.Sprintf("CopyableService:%s", op.path)
}

//
//
type TemplateGraphicsConsoleService struct {
	BaseService
}

func NewTemplateGraphicsConsoleService(connection *Connection, path string) *TemplateGraphicsConsoleService {
	var result TemplateGraphicsConsoleService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets graphics console configuration of the template.
//
type TemplateGraphicsConsoleServiceGetRequest struct {
	TemplateGraphicsConsoleService *TemplateGraphicsConsoleService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Header(key, value string) *TemplateGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Query(key, value string) *TemplateGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Follow(follow string) *TemplateGraphicsConsoleServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *TemplateGraphicsConsoleServiceGetRequest) Send() (*TemplateGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateGraphicsConsoleService.connection.URL(), p.TemplateGraphicsConsoleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateGraphicsConsoleServiceGetResponse{console: result}, nil
}

func (p *TemplateGraphicsConsoleServiceGetRequest) MustSend() *TemplateGraphicsConsoleServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets graphics console configuration of the template.
//
type TemplateGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *TemplateGraphicsConsoleServiceGetResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *TemplateGraphicsConsoleServiceGetResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Gets graphics console configuration of the template.
//
func (p *TemplateGraphicsConsoleService) Get() *TemplateGraphicsConsoleServiceGetRequest {
	return &TemplateGraphicsConsoleServiceGetRequest{TemplateGraphicsConsoleService: p}
}

//
// Remove the graphics console from the template.
//
type TemplateGraphicsConsoleServiceRemoveRequest struct {
	TemplateGraphicsConsoleService *TemplateGraphicsConsoleService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Header(key, value string) *TemplateGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Query(key, value string) *TemplateGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Async(async bool) *TemplateGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) Send() (*TemplateGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateGraphicsConsoleService.connection.URL(), p.TemplateGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateGraphicsConsoleServiceRemoveResponse), nil
}

func (p *TemplateGraphicsConsoleServiceRemoveRequest) MustSend() *TemplateGraphicsConsoleServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove the graphics console from the template.
//
type TemplateGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the template.
//
func (p *TemplateGraphicsConsoleService) Remove() *TemplateGraphicsConsoleServiceRemoveRequest {
	return &TemplateGraphicsConsoleServiceRemoveRequest{TemplateGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateGraphicsConsoleService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateGraphicsConsoleService) String() string {
	return fmt.Sprintf("TemplateGraphicsConsoleService:%s", op.path)
}

//
//
type SystemService struct {
	BaseService
}

func NewSystemService(connection *Connection, path string) *SystemService {
	var result SystemService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns basic information describing the API, like the product name, the version number and a summary of the
// number of relevant objects.
// [source]
// ----
// GET /ovirt-engine/api
// ----
// We get following response:
// [source,xml]
// ----
// <api>
//   <link rel="capabilities" href="/api/capabilities"/>
//   <link rel="clusters" href="/api/clusters"/>
//   <link rel="clusters/search" href="/api/clusters?search={query}"/>
//   <link rel="datacenters" href="/api/datacenters"/>
//   <link rel="datacenters/search" href="/api/datacenters?search={query}"/>
//   <link rel="events" href="/api/events"/>
//   <link rel="events/search" href="/api/events?search={query}"/>
//   <link rel="hosts" href="/api/hosts"/>
//   <link rel="hosts/search" href="/api/hosts?search={query}"/>
//   <link rel="networks" href="/api/networks"/>
//   <link rel="roles" href="/api/roles"/>
//   <link rel="storagedomains" href="/api/storagedomains"/>
//   <link rel="storagedomains/search" href="/api/storagedomains?search={query}"/>
//   <link rel="tags" href="/api/tags"/>
//   <link rel="templates" href="/api/templates"/>
//   <link rel="templates/search" href="/api/templates?search={query}"/>
//   <link rel="users" href="/api/users"/>
//   <link rel="groups" href="/api/groups"/>
//   <link rel="domains" href="/api/domains"/>
//   <link rel="vmpools" href="/api/vmpools"/>
//   <link rel="vmpools/search" href="/api/vmpools?search={query}"/>
//   <link rel="vms" href="/api/vms"/>
//   <link rel="vms/search" href="/api/vms?search={query}"/>
//   <product_info>
//     <name>oVirt Engine</name>
//     <vendor>ovirt.org</vendor>
//     <version>
//       <build>4</build>
//       <full_version>4.0.4</full_version>
//       <major>4</major>
//       <minor>0</minor>
//       <revision>0</revision>
//     </version>
//   </product_info>
//   <special_objects>
//     <blank_template href="/ovirt-engine/api/templates/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//     <root_tag href="/ovirt-engine/api/tags/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//   </special_objects>
//   <summary>
//     <hosts>
//       <active>0</active>
//       <total>0</total>
//     </hosts>
//     <storage_domains>
//       <active>0</active>
//       <total>1</total>
//     </storage_domains>
//     <users>
//       <active>1</active>
//       <total>1</total>
//     </users>
//     <vms>
//       <active>0</active>
//       <total>0</total>
//     </vms>
//   </summary>
//   <time>2016-09-14T12:00:48.132+02:00</time>
// </api>
// ----
// The entry point provides a user with links to the collections in a
// virtualization environment. The `rel` attribute of each collection link
// provides a reference point for each link.
// The entry point also contains other data such as `product_info`,
// `special_objects` and `summary`.
//
type SystemServiceGetRequest struct {
	SystemService *SystemService
	header        map[string]string
	query         map[string]string
	follow        *string
}

func (p *SystemServiceGetRequest) Header(key, value string) *SystemServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemServiceGetRequest) Query(key, value string) *SystemServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemServiceGetRequest) Follow(follow string) *SystemServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *SystemServiceGetRequest) Send() (*SystemServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SystemService.connection.URL(), p.SystemService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApiReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SystemServiceGetResponse{api: result}, nil
}

func (p *SystemServiceGetRequest) MustSend() *SystemServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns basic information describing the API, like the product name, the version number and a summary of the
// number of relevant objects.
// [source]
// ----
// GET /ovirt-engine/api
// ----
// We get following response:
// [source,xml]
// ----
// <api>
//   <link rel="capabilities" href="/api/capabilities"/>
//   <link rel="clusters" href="/api/clusters"/>
//   <link rel="clusters/search" href="/api/clusters?search={query}"/>
//   <link rel="datacenters" href="/api/datacenters"/>
//   <link rel="datacenters/search" href="/api/datacenters?search={query}"/>
//   <link rel="events" href="/api/events"/>
//   <link rel="events/search" href="/api/events?search={query}"/>
//   <link rel="hosts" href="/api/hosts"/>
//   <link rel="hosts/search" href="/api/hosts?search={query}"/>
//   <link rel="networks" href="/api/networks"/>
//   <link rel="roles" href="/api/roles"/>
//   <link rel="storagedomains" href="/api/storagedomains"/>
//   <link rel="storagedomains/search" href="/api/storagedomains?search={query}"/>
//   <link rel="tags" href="/api/tags"/>
//   <link rel="templates" href="/api/templates"/>
//   <link rel="templates/search" href="/api/templates?search={query}"/>
//   <link rel="users" href="/api/users"/>
//   <link rel="groups" href="/api/groups"/>
//   <link rel="domains" href="/api/domains"/>
//   <link rel="vmpools" href="/api/vmpools"/>
//   <link rel="vmpools/search" href="/api/vmpools?search={query}"/>
//   <link rel="vms" href="/api/vms"/>
//   <link rel="vms/search" href="/api/vms?search={query}"/>
//   <product_info>
//     <name>oVirt Engine</name>
//     <vendor>ovirt.org</vendor>
//     <version>
//       <build>4</build>
//       <full_version>4.0.4</full_version>
//       <major>4</major>
//       <minor>0</minor>
//       <revision>0</revision>
//     </version>
//   </product_info>
//   <special_objects>
//     <blank_template href="/ovirt-engine/api/templates/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//     <root_tag href="/ovirt-engine/api/tags/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//   </special_objects>
//   <summary>
//     <hosts>
//       <active>0</active>
//       <total>0</total>
//     </hosts>
//     <storage_domains>
//       <active>0</active>
//       <total>1</total>
//     </storage_domains>
//     <users>
//       <active>1</active>
//       <total>1</total>
//     </users>
//     <vms>
//       <active>0</active>
//       <total>0</total>
//     </vms>
//   </summary>
//   <time>2016-09-14T12:00:48.132+02:00</time>
// </api>
// ----
// The entry point provides a user with links to the collections in a
// virtualization environment. The `rel` attribute of each collection link
// provides a reference point for each link.
// The entry point also contains other data such as `product_info`,
// `special_objects` and `summary`.
//
type SystemServiceGetResponse struct {
	api *Api
}

func (p *SystemServiceGetResponse) Api() (*Api, bool) {
	if p.api != nil {
		return p.api, true
	}
	return nil, false
}

func (p *SystemServiceGetResponse) MustApi() *Api {
	if p.api == nil {
		panic("api in response does not exist")
	}
	return p.api
}

//
// Returns basic information describing the API, like the product name, the version number and a summary of the
// number of relevant objects.
// [source]
// ----
// GET /ovirt-engine/api
// ----
// We get following response:
// [source,xml]
// ----
// <api>
//   <link rel="capabilities" href="/api/capabilities"/>
//   <link rel="clusters" href="/api/clusters"/>
//   <link rel="clusters/search" href="/api/clusters?search={query}"/>
//   <link rel="datacenters" href="/api/datacenters"/>
//   <link rel="datacenters/search" href="/api/datacenters?search={query}"/>
//   <link rel="events" href="/api/events"/>
//   <link rel="events/search" href="/api/events?search={query}"/>
//   <link rel="hosts" href="/api/hosts"/>
//   <link rel="hosts/search" href="/api/hosts?search={query}"/>
//   <link rel="networks" href="/api/networks"/>
//   <link rel="roles" href="/api/roles"/>
//   <link rel="storagedomains" href="/api/storagedomains"/>
//   <link rel="storagedomains/search" href="/api/storagedomains?search={query}"/>
//   <link rel="tags" href="/api/tags"/>
//   <link rel="templates" href="/api/templates"/>
//   <link rel="templates/search" href="/api/templates?search={query}"/>
//   <link rel="users" href="/api/users"/>
//   <link rel="groups" href="/api/groups"/>
//   <link rel="domains" href="/api/domains"/>
//   <link rel="vmpools" href="/api/vmpools"/>
//   <link rel="vmpools/search" href="/api/vmpools?search={query}"/>
//   <link rel="vms" href="/api/vms"/>
//   <link rel="vms/search" href="/api/vms?search={query}"/>
//   <product_info>
//     <name>oVirt Engine</name>
//     <vendor>ovirt.org</vendor>
//     <version>
//       <build>4</build>
//       <full_version>4.0.4</full_version>
//       <major>4</major>
//       <minor>0</minor>
//       <revision>0</revision>
//     </version>
//   </product_info>
//   <special_objects>
//     <blank_template href="/ovirt-engine/api/templates/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//     <root_tag href="/ovirt-engine/api/tags/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000"/>
//   </special_objects>
//   <summary>
//     <hosts>
//       <active>0</active>
//       <total>0</total>
//     </hosts>
//     <storage_domains>
//       <active>0</active>
//       <total>1</total>
//     </storage_domains>
//     <users>
//       <active>1</active>
//       <total>1</total>
//     </users>
//     <vms>
//       <active>0</active>
//       <total>0</total>
//     </vms>
//   </summary>
//   <time>2016-09-14T12:00:48.132+02:00</time>
// </api>
// ----
// The entry point provides a user with links to the collections in a
// virtualization environment. The `rel` attribute of each collection link
// provides a reference point for each link.
// The entry point also contains other data such as `product_info`,
// `special_objects` and `summary`.
//
func (p *SystemService) Get() *SystemServiceGetRequest {
	return &SystemServiceGetRequest{SystemService: p}
}

//
//
type SystemServiceReloadConfigurationsRequest struct {
	SystemService *SystemService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *SystemServiceReloadConfigurationsRequest) Header(key, value string) *SystemServiceReloadConfigurationsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemServiceReloadConfigurationsRequest) Query(key, value string) *SystemServiceReloadConfigurationsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemServiceReloadConfigurationsRequest) Async(async bool) *SystemServiceReloadConfigurationsRequest {
	p.async = &async
	return p
}

func (p *SystemServiceReloadConfigurationsRequest) Send() (*SystemServiceReloadConfigurationsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reloadconfigurations", p.SystemService.connection.URL(), p.SystemService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(SystemServiceReloadConfigurationsResponse), nil
}

func (p *SystemServiceReloadConfigurationsRequest) MustSend() *SystemServiceReloadConfigurationsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SystemServiceReloadConfigurationsResponse struct {
}

//
//
func (p *SystemService) ReloadConfigurations() *SystemServiceReloadConfigurationsRequest {
	return &SystemServiceReloadConfigurationsRequest{SystemService: p}
}

//
// List all known affinity labels.
//
func (op *SystemService) AffinityLabelsService() *AffinityLabelsService {
	return NewAffinityLabelsService(op.connection, fmt.Sprintf("%s/affinitylabels", op.path))
}

//
//
func (op *SystemService) BookmarksService() *BookmarksService {
	return NewBookmarksService(op.connection, fmt.Sprintf("%s/bookmarks", op.path))
}

//
// Reference to the service that provides information about the cluster levels supported by the system.
//
func (op *SystemService) ClusterLevelsService() *ClusterLevelsService {
	return NewClusterLevelsService(op.connection, fmt.Sprintf("%s/clusterlevels", op.path))
}

//
//
func (op *SystemService) ClustersService() *ClustersService {
	return NewClustersService(op.connection, fmt.Sprintf("%s/clusters", op.path))
}

//
//
func (op *SystemService) CpuProfilesService() *CpuProfilesService {
	return NewCpuProfilesService(op.connection, fmt.Sprintf("%s/cpuprofiles", op.path))
}

//
//
func (op *SystemService) DataCentersService() *DataCentersService {
	return NewDataCentersService(op.connection, fmt.Sprintf("%s/datacenters", op.path))
}

//
//
func (op *SystemService) DiskProfilesService() *DiskProfilesService {
	return NewDiskProfilesService(op.connection, fmt.Sprintf("%s/diskprofiles", op.path))
}

//
//
func (op *SystemService) DisksService() *DisksService {
	return NewDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
//
func (op *SystemService) DomainsService() *DomainsService {
	return NewDomainsService(op.connection, fmt.Sprintf("%s/domains", op.path))
}

//
//
func (op *SystemService) EventsService() *EventsService {
	return NewEventsService(op.connection, fmt.Sprintf("%s/events", op.path))
}

//
//
func (op *SystemService) ExternalHostProvidersService() *ExternalHostProvidersService {
	return NewExternalHostProvidersService(op.connection, fmt.Sprintf("%s/externalhostproviders", op.path))
}

//
// Reference to service facilitating import of external virtual machines.
//
func (op *SystemService) ExternalVmImportsService() *ExternalVmImportsService {
	return NewExternalVmImportsService(op.connection, fmt.Sprintf("%s/externalvmimports", op.path))
}

//
//
func (op *SystemService) GroupsService() *GroupsService {
	return NewGroupsService(op.connection, fmt.Sprintf("%s/groups", op.path))
}

//
//
func (op *SystemService) HostsService() *HostsService {
	return NewHostsService(op.connection, fmt.Sprintf("%s/hosts", op.path))
}

//
//
func (op *SystemService) IconsService() *IconsService {
	return NewIconsService(op.connection, fmt.Sprintf("%s/icons", op.path))
}

//
// List of all image transfers being performed for image I/O in oVirt.
//
func (op *SystemService) ImageTransfersService() *ImageTransfersService {
	return NewImageTransfersService(op.connection, fmt.Sprintf("%s/imagetransfers", op.path))
}

//
//
func (op *SystemService) InstanceTypesService() *InstanceTypesService {
	return NewInstanceTypesService(op.connection, fmt.Sprintf("%s/instancetypes", op.path))
}

//
// List all the jobs monitored by the engine.
//
func (op *SystemService) JobsService() *JobsService {
	return NewJobsService(op.connection, fmt.Sprintf("%s/jobs", op.path))
}

//
// List the available Katello errata assigned to the engine.
//
func (op *SystemService) KatelloErrataService() *EngineKatelloErrataService {
	return NewEngineKatelloErrataService(op.connection, fmt.Sprintf("%s/katelloerrata", op.path))
}

//
//
func (op *SystemService) MacPoolsService() *MacPoolsService {
	return NewMacPoolsService(op.connection, fmt.Sprintf("%s/macpools", op.path))
}

//
// Network filters will enhance the admin ability to manage the network packets traffic from/to the participated
// VMs.
//
func (op *SystemService) NetworkFiltersService() *NetworkFiltersService {
	return NewNetworkFiltersService(op.connection, fmt.Sprintf("%s/networkfilters", op.path))
}

//
//
func (op *SystemService) NetworksService() *NetworksService {
	return NewNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
//
func (op *SystemService) OpenstackImageProvidersService() *OpenstackImageProvidersService {
	return NewOpenstackImageProvidersService(op.connection, fmt.Sprintf("%s/openstackimageproviders", op.path))
}

//
//
func (op *SystemService) OpenstackNetworkProvidersService() *OpenstackNetworkProvidersService {
	return NewOpenstackNetworkProvidersService(op.connection, fmt.Sprintf("%s/openstacknetworkproviders", op.path))
}

//
//
func (op *SystemService) OpenstackVolumeProvidersService() *OpenstackVolumeProvidersService {
	return NewOpenstackVolumeProvidersService(op.connection, fmt.Sprintf("%s/openstackvolumeproviders", op.path))
}

//
//
func (op *SystemService) OperatingSystemsService() *OperatingSystemsService {
	return NewOperatingSystemsService(op.connection, fmt.Sprintf("%s/operatingsystems", op.path))
}

//
// Reference to the service that provides values of configuration options of the system.
//
func (op *SystemService) OptionsService() *SystemOptionsService {
	return NewSystemOptionsService(op.connection, fmt.Sprintf("%s/options", op.path))
}

//
//
func (op *SystemService) PermissionsService() *SystemPermissionsService {
	return NewSystemPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *SystemService) RolesService() *RolesService {
	return NewRolesService(op.connection, fmt.Sprintf("%s/roles", op.path))
}

//
//
func (op *SystemService) SchedulingPoliciesService() *SchedulingPoliciesService {
	return NewSchedulingPoliciesService(op.connection, fmt.Sprintf("%s/schedulingpolicies", op.path))
}

//
//
func (op *SystemService) SchedulingPolicyUnitsService() *SchedulingPolicyUnitsService {
	return NewSchedulingPolicyUnitsService(op.connection, fmt.Sprintf("%s/schedulingpolicyunits", op.path))
}

//
//
func (op *SystemService) StorageConnectionsService() *StorageServerConnectionsService {
	return NewStorageServerConnectionsService(op.connection, fmt.Sprintf("%s/storageconnections", op.path))
}

//
//
func (op *SystemService) StorageDomainsService() *StorageDomainsService {
	return NewStorageDomainsService(op.connection, fmt.Sprintf("%s/storagedomains", op.path))
}

//
//
func (op *SystemService) TagsService() *TagsService {
	return NewTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
//
func (op *SystemService) TemplatesService() *TemplatesService {
	return NewTemplatesService(op.connection, fmt.Sprintf("%s/templates", op.path))
}

//
//
func (op *SystemService) UsersService() *UsersService {
	return NewUsersService(op.connection, fmt.Sprintf("%s/users", op.path))
}

//
//
func (op *SystemService) VmPoolsService() *VmPoolsService {
	return NewVmPoolsService(op.connection, fmt.Sprintf("%s/vmpools", op.path))
}

//
//
func (op *SystemService) VmsService() *VmsService {
	return NewVmsService(op.connection, fmt.Sprintf("%s/vms", op.path))
}

//
//
func (op *SystemService) VnicProfilesService() *VnicProfilesService {
	return NewVnicProfilesService(op.connection, fmt.Sprintf("%s/vnicprofiles", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SystemService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "bookmarks" {
		return op.BookmarksService(), nil
	}
	if strings.HasPrefix(path, "bookmarks/") {
		return op.BookmarksService().Service(path[10:])
	}
	if path == "clusterlevels" {
		return op.ClusterLevelsService(), nil
	}
	if strings.HasPrefix(path, "clusterlevels/") {
		return op.ClusterLevelsService().Service(path[14:])
	}
	if path == "clusters" {
		return op.ClustersService(), nil
	}
	if strings.HasPrefix(path, "clusters/") {
		return op.ClustersService().Service(path[9:])
	}
	if path == "cpuprofiles" {
		return op.CpuProfilesService(), nil
	}
	if strings.HasPrefix(path, "cpuprofiles/") {
		return op.CpuProfilesService().Service(path[12:])
	}
	if path == "datacenters" {
		return op.DataCentersService(), nil
	}
	if strings.HasPrefix(path, "datacenters/") {
		return op.DataCentersService().Service(path[12:])
	}
	if path == "diskprofiles" {
		return op.DiskProfilesService(), nil
	}
	if strings.HasPrefix(path, "diskprofiles/") {
		return op.DiskProfilesService().Service(path[13:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "domains" {
		return op.DomainsService(), nil
	}
	if strings.HasPrefix(path, "domains/") {
		return op.DomainsService().Service(path[8:])
	}
	if path == "events" {
		return op.EventsService(), nil
	}
	if strings.HasPrefix(path, "events/") {
		return op.EventsService().Service(path[7:])
	}
	if path == "externalhostproviders" {
		return op.ExternalHostProvidersService(), nil
	}
	if strings.HasPrefix(path, "externalhostproviders/") {
		return op.ExternalHostProvidersService().Service(path[22:])
	}
	if path == "externalvmimports" {
		return op.ExternalVmImportsService(), nil
	}
	if strings.HasPrefix(path, "externalvmimports/") {
		return op.ExternalVmImportsService().Service(path[18:])
	}
	if path == "groups" {
		return op.GroupsService(), nil
	}
	if strings.HasPrefix(path, "groups/") {
		return op.GroupsService().Service(path[7:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "icons" {
		return op.IconsService(), nil
	}
	if strings.HasPrefix(path, "icons/") {
		return op.IconsService().Service(path[6:])
	}
	if path == "imagetransfers" {
		return op.ImageTransfersService(), nil
	}
	if strings.HasPrefix(path, "imagetransfers/") {
		return op.ImageTransfersService().Service(path[15:])
	}
	if path == "instancetypes" {
		return op.InstanceTypesService(), nil
	}
	if strings.HasPrefix(path, "instancetypes/") {
		return op.InstanceTypesService().Service(path[14:])
	}
	if path == "jobs" {
		return op.JobsService(), nil
	}
	if strings.HasPrefix(path, "jobs/") {
		return op.JobsService().Service(path[5:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "macpools" {
		return op.MacPoolsService(), nil
	}
	if strings.HasPrefix(path, "macpools/") {
		return op.MacPoolsService().Service(path[9:])
	}
	if path == "networkfilters" {
		return op.NetworkFiltersService(), nil
	}
	if strings.HasPrefix(path, "networkfilters/") {
		return op.NetworkFiltersService().Service(path[15:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "openstackimageproviders" {
		return op.OpenstackImageProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstackimageproviders/") {
		return op.OpenstackImageProvidersService().Service(path[24:])
	}
	if path == "openstacknetworkproviders" {
		return op.OpenstackNetworkProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstacknetworkproviders/") {
		return op.OpenstackNetworkProvidersService().Service(path[26:])
	}
	if path == "openstackvolumeproviders" {
		return op.OpenstackVolumeProvidersService(), nil
	}
	if strings.HasPrefix(path, "openstackvolumeproviders/") {
		return op.OpenstackVolumeProvidersService().Service(path[25:])
	}
	if path == "operatingsystems" {
		return op.OperatingSystemsService(), nil
	}
	if strings.HasPrefix(path, "operatingsystems/") {
		return op.OperatingSystemsService().Service(path[17:])
	}
	if path == "options" {
		return op.OptionsService(), nil
	}
	if strings.HasPrefix(path, "options/") {
		return op.OptionsService().Service(path[8:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "roles" {
		return op.RolesService(), nil
	}
	if strings.HasPrefix(path, "roles/") {
		return op.RolesService().Service(path[6:])
	}
	if path == "schedulingpolicies" {
		return op.SchedulingPoliciesService(), nil
	}
	if strings.HasPrefix(path, "schedulingpolicies/") {
		return op.SchedulingPoliciesService().Service(path[19:])
	}
	if path == "schedulingpolicyunits" {
		return op.SchedulingPolicyUnitsService(), nil
	}
	if strings.HasPrefix(path, "schedulingpolicyunits/") {
		return op.SchedulingPolicyUnitsService().Service(path[22:])
	}
	if path == "storageconnections" {
		return op.StorageConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnections/") {
		return op.StorageConnectionsService().Service(path[19:])
	}
	if path == "storagedomains" {
		return op.StorageDomainsService(), nil
	}
	if strings.HasPrefix(path, "storagedomains/") {
		return op.StorageDomainsService().Service(path[15:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "templates" {
		return op.TemplatesService(), nil
	}
	if strings.HasPrefix(path, "templates/") {
		return op.TemplatesService().Service(path[10:])
	}
	if path == "users" {
		return op.UsersService(), nil
	}
	if strings.HasPrefix(path, "users/") {
		return op.UsersService().Service(path[6:])
	}
	if path == "vmpools" {
		return op.VmPoolsService(), nil
	}
	if strings.HasPrefix(path, "vmpools/") {
		return op.VmPoolsService().Service(path[8:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	if path == "vnicprofiles" {
		return op.VnicProfilesService(), nil
	}
	if strings.HasPrefix(path, "vnicprofiles/") {
		return op.VnicProfilesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SystemService) String() string {
	return fmt.Sprintf("SystemService:%s", op.path)
}

//
// A service to view specific certificate for external provider.
//
type ExternalProviderCertificateService struct {
	BaseService
}

func NewExternalProviderCertificateService(connection *Connection, path string) *ExternalProviderCertificateService {
	var result ExternalProviderCertificateService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get specific certificate.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificate/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificate id="0">
//   <organization>provider.example.com</organization>
//   <subject>CN=provider.example.com</subject>
//   <content>...</content>
// </certificate>
// ----
//
type ExternalProviderCertificateServiceGetRequest struct {
	ExternalProviderCertificateService *ExternalProviderCertificateService
	header                             map[string]string
	query                              map[string]string
	follow                             *string
}

func (p *ExternalProviderCertificateServiceGetRequest) Header(key, value string) *ExternalProviderCertificateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderCertificateServiceGetRequest) Query(key, value string) *ExternalProviderCertificateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderCertificateServiceGetRequest) Follow(follow string) *ExternalProviderCertificateServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ExternalProviderCertificateServiceGetRequest) Send() (*ExternalProviderCertificateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalProviderCertificateService.connection.URL(), p.ExternalProviderCertificateService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalProviderCertificateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalProviderCertificateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalProviderCertificateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalProviderCertificateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalProviderCertificateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCertificateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalProviderCertificateServiceGetResponse{certificate: result}, nil
}

func (p *ExternalProviderCertificateServiceGetRequest) MustSend() *ExternalProviderCertificateServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get specific certificate.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificate/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificate id="0">
//   <organization>provider.example.com</organization>
//   <subject>CN=provider.example.com</subject>
//   <content>...</content>
// </certificate>
// ----
//
type ExternalProviderCertificateServiceGetResponse struct {
	certificate *Certificate
}

func (p *ExternalProviderCertificateServiceGetResponse) Certificate() (*Certificate, bool) {
	if p.certificate != nil {
		return p.certificate, true
	}
	return nil, false
}

func (p *ExternalProviderCertificateServiceGetResponse) MustCertificate() *Certificate {
	if p.certificate == nil {
		panic("certificate in response does not exist")
	}
	return p.certificate
}

//
// Get specific certificate.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificate/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificate id="0">
//   <organization>provider.example.com</organization>
//   <subject>CN=provider.example.com</subject>
//   <content>...</content>
// </certificate>
// ----
//
func (p *ExternalProviderCertificateService) Get() *ExternalProviderCertificateServiceGetRequest {
	return &ExternalProviderCertificateServiceGetRequest{ExternalProviderCertificateService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderCertificateService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalProviderCertificateService) String() string {
	return fmt.Sprintf("ExternalProviderCertificateService:%s", op.path)
}

//
//
type InstanceTypeGraphicsConsoleService struct {
	BaseService
}

func NewInstanceTypeGraphicsConsoleService(connection *Connection, path string) *InstanceTypeGraphicsConsoleService {
	var result InstanceTypeGraphicsConsoleService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets graphics console configuration of the instance type.
//
type InstanceTypeGraphicsConsoleServiceGetRequest struct {
	InstanceTypeGraphicsConsoleService *InstanceTypeGraphicsConsoleService
	header                             map[string]string
	query                              map[string]string
	follow                             *string
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Header(key, value string) *InstanceTypeGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Query(key, value string) *InstanceTypeGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Follow(follow string) *InstanceTypeGraphicsConsoleServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) Send() (*InstanceTypeGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeGraphicsConsoleService.connection.URL(), p.InstanceTypeGraphicsConsoleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeGraphicsConsoleServiceGetResponse{console: result}, nil
}

func (p *InstanceTypeGraphicsConsoleServiceGetRequest) MustSend() *InstanceTypeGraphicsConsoleServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets graphics console configuration of the instance type.
//
type InstanceTypeGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsoleServiceGetResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *InstanceTypeGraphicsConsoleServiceGetResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Gets graphics console configuration of the instance type.
//
func (p *InstanceTypeGraphicsConsoleService) Get() *InstanceTypeGraphicsConsoleServiceGetRequest {
	return &InstanceTypeGraphicsConsoleServiceGetRequest{InstanceTypeGraphicsConsoleService: p}
}

//
// Remove the graphics console from the instance type.
//
type InstanceTypeGraphicsConsoleServiceRemoveRequest struct {
	InstanceTypeGraphicsConsoleService *InstanceTypeGraphicsConsoleService
	header                             map[string]string
	query                              map[string]string
	async                              *bool
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Header(key, value string) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Query(key, value string) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Async(async bool) *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) Send() (*InstanceTypeGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeGraphicsConsoleService.connection.URL(), p.InstanceTypeGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(InstanceTypeGraphicsConsoleServiceRemoveResponse), nil
}

func (p *InstanceTypeGraphicsConsoleServiceRemoveRequest) MustSend() *InstanceTypeGraphicsConsoleServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove the graphics console from the instance type.
//
type InstanceTypeGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the instance type.
//
func (p *InstanceTypeGraphicsConsoleService) Remove() *InstanceTypeGraphicsConsoleServiceRemoveRequest {
	return &InstanceTypeGraphicsConsoleServiceRemoveRequest{InstanceTypeGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeGraphicsConsoleService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeGraphicsConsoleService) String() string {
	return fmt.Sprintf("InstanceTypeGraphicsConsoleService:%s", op.path)
}

//
// This service manages the attachment of a disk to a virtual machine.
//
type DiskAttachmentService struct {
	BaseService
}

func NewDiskAttachmentService(connection *Connection, path string) *DiskAttachmentService {
	var result DiskAttachmentService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the details of the attachment, including the bootable flag and link to the disk.
// An example of getting a disk attachment:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/diskattachments/456
// ----
// [source,xml]
// ----
// <disk_attachment href="/ovirt-engine/api/vms/123/diskattachments/456" id="456">
//   <active>true</active>
//   <bootable>true</bootable>
//   <interface>virtio</interface>
//   <disk href="/ovirt-engine/api/disks/456" id="456"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </disk_attachment>
// ----
//
type DiskAttachmentServiceGetRequest struct {
	DiskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *DiskAttachmentServiceGetRequest) Header(key, value string) *DiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceGetRequest) Query(key, value string) *DiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceGetRequest) Follow(follow string) *DiskAttachmentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DiskAttachmentServiceGetRequest) Send() (*DiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskAttachmentService.connection.URL(), p.DiskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskAttachmentServiceGetResponse{attachment: result}, nil
}

func (p *DiskAttachmentServiceGetRequest) MustSend() *DiskAttachmentServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the details of the attachment, including the bootable flag and link to the disk.
// An example of getting a disk attachment:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/diskattachments/456
// ----
// [source,xml]
// ----
// <disk_attachment href="/ovirt-engine/api/vms/123/diskattachments/456" id="456">
//   <active>true</active>
//   <bootable>true</bootable>
//   <interface>virtio</interface>
//   <disk href="/ovirt-engine/api/disks/456" id="456"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </disk_attachment>
// ----
//
type DiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *DiskAttachmentServiceGetResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *DiskAttachmentServiceGetResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Returns the details of the attachment, including the bootable flag and link to the disk.
// An example of getting a disk attachment:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/diskattachments/456
// ----
// [source,xml]
// ----
// <disk_attachment href="/ovirt-engine/api/vms/123/diskattachments/456" id="456">
//   <active>true</active>
//   <bootable>true</bootable>
//   <interface>virtio</interface>
//   <disk href="/ovirt-engine/api/disks/456" id="456"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </disk_attachment>
// ----
//
func (p *DiskAttachmentService) Get() *DiskAttachmentServiceGetRequest {
	return &DiskAttachmentServiceGetRequest{DiskAttachmentService: p}
}

//
// Removes the disk attachment.
// This will only detach the disk from the virtual machine, but won't remove it from
// the system, unless the `detach_only` parameter is `false`.
// An example of removing a disk attachment:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/diskattachments/456?detach_only=true
// ----
//
type DiskAttachmentServiceRemoveRequest struct {
	DiskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
	detachOnly            *bool
}

func (p *DiskAttachmentServiceRemoveRequest) Header(key, value string) *DiskAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceRemoveRequest) Query(key, value string) *DiskAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceRemoveRequest) DetachOnly(detachOnly bool) *DiskAttachmentServiceRemoveRequest {
	p.detachOnly = &detachOnly
	return p
}

func (p *DiskAttachmentServiceRemoveRequest) Send() (*DiskAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskAttachmentService.connection.URL(), p.DiskAttachmentService.path)
	values := make(url.Values)
	if p.detachOnly != nil {
		values["detach_only"] = []string{fmt.Sprintf("%v", *p.detachOnly)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DiskAttachmentServiceRemoveResponse), nil
}

func (p *DiskAttachmentServiceRemoveRequest) MustSend() *DiskAttachmentServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the disk attachment.
// This will only detach the disk from the virtual machine, but won't remove it from
// the system, unless the `detach_only` parameter is `false`.
// An example of removing a disk attachment:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/diskattachments/456?detach_only=true
// ----
//
type DiskAttachmentServiceRemoveResponse struct {
}

//
// Removes the disk attachment.
// This will only detach the disk from the virtual machine, but won't remove it from
// the system, unless the `detach_only` parameter is `false`.
// An example of removing a disk attachment:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/diskattachments/456?detach_only=true
// ----
//
func (p *DiskAttachmentService) Remove() *DiskAttachmentServiceRemoveRequest {
	return &DiskAttachmentServiceRemoveRequest{DiskAttachmentService: p}
}

//
// Update the disk attachment and the disk properties within it.
// [source]
// ----
// PUT /vms/{vm:id}/disksattachments/{attachment:id}
// <disk_attachment>
//   <bootable>true</bootable>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
//
type DiskAttachmentServiceUpdateRequest struct {
	DiskAttachmentService *DiskAttachmentService
	header                map[string]string
	query                 map[string]string
	diskAttachment        *DiskAttachment
}

func (p *DiskAttachmentServiceUpdateRequest) Header(key, value string) *DiskAttachmentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskAttachmentServiceUpdateRequest) Query(key, value string) *DiskAttachmentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskAttachmentServiceUpdateRequest) DiskAttachment(diskAttachment *DiskAttachment) *DiskAttachmentServiceUpdateRequest {
	p.diskAttachment = diskAttachment
	return p
}

func (p *DiskAttachmentServiceUpdateRequest) Send() (*DiskAttachmentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskAttachmentService.connection.URL(), p.DiskAttachmentService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskAttachmentWriteOne(writer, p.diskAttachment, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskAttachmentServiceUpdateResponse{diskAttachment: result}, nil
}

func (p *DiskAttachmentServiceUpdateRequest) MustSend() *DiskAttachmentServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the disk attachment and the disk properties within it.
// [source]
// ----
// PUT /vms/{vm:id}/disksattachments/{attachment:id}
// <disk_attachment>
//   <bootable>true</bootable>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
//
type DiskAttachmentServiceUpdateResponse struct {
	diskAttachment *DiskAttachment
}

func (p *DiskAttachmentServiceUpdateResponse) DiskAttachment() (*DiskAttachment, bool) {
	if p.diskAttachment != nil {
		return p.diskAttachment, true
	}
	return nil, false
}

func (p *DiskAttachmentServiceUpdateResponse) MustDiskAttachment() *DiskAttachment {
	if p.diskAttachment == nil {
		panic("diskAttachment in response does not exist")
	}
	return p.diskAttachment
}

//
// Update the disk attachment and the disk properties within it.
// [source]
// ----
// PUT /vms/{vm:id}/disksattachments/{attachment:id}
// <disk_attachment>
//   <bootable>true</bootable>
//   <interface>ide</interface>
//   <active>true</active>
//   <disk>
//     <name>mydisk</name>
//     <provisioned_size>1024</provisioned_size>
//     ...
//   </disk>
// </disk_attachment>
// ----
//
func (p *DiskAttachmentService) Update() *DiskAttachmentServiceUpdateRequest {
	return &DiskAttachmentServiceUpdateRequest{DiskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskAttachmentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskAttachmentService) String() string {
	return fmt.Sprintf("DiskAttachmentService:%s", op.path)
}

//
//
type MoveableService struct {
	BaseService
}

func NewMoveableService(connection *Connection, path string) *MoveableService {
	var result MoveableService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type MoveableServiceMoveRequest struct {
	MoveableService *MoveableService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *MoveableServiceMoveRequest) Header(key, value string) *MoveableServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MoveableServiceMoveRequest) Query(key, value string) *MoveableServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MoveableServiceMoveRequest) Async(async bool) *MoveableServiceMoveRequest {
	p.async = &async
	return p
}

func (p *MoveableServiceMoveRequest) Send() (*MoveableServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.MoveableService.connection.URL(), p.MoveableService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.MoveableService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.MoveableService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.MoveableService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.MoveableService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.MoveableService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(MoveableServiceMoveResponse), nil
}

func (p *MoveableServiceMoveRequest) MustSend() *MoveableServiceMoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type MoveableServiceMoveResponse struct {
}

//
//
func (p *MoveableService) Move() *MoveableServiceMoveRequest {
	return &MoveableServiceMoveRequest{MoveableService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MoveableService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MoveableService) String() string {
	return fmt.Sprintf("MoveableService:%s", op.path)
}

//
// Manages the set of templates available in a storage domain.
//
type StorageDomainTemplatesService struct {
	BaseService
}

func NewStorageDomainTemplatesService(connection *Connection, path string) *StorageDomainTemplatesService {
	var result StorageDomainTemplatesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of templates availalbe in the storage domain.
// The order of the returned list of templates isn't guaranteed.
//
type StorageDomainTemplatesServiceListRequest struct {
	StorageDomainTemplatesService *StorageDomainTemplatesService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
	max                           *int64
	unregistered                  *bool
}

func (p *StorageDomainTemplatesServiceListRequest) Header(key, value string) *StorageDomainTemplatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Query(key, value string) *StorageDomainTemplatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Follow(follow string) *StorageDomainTemplatesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Max(max int64) *StorageDomainTemplatesServiceListRequest {
	p.max = &max
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Unregistered(unregistered bool) *StorageDomainTemplatesServiceListRequest {
	p.unregistered = &unregistered
	return p
}

func (p *StorageDomainTemplatesServiceListRequest) Send() (*StorageDomainTemplatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainTemplatesService.connection.URL(), p.StorageDomainTemplatesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainTemplatesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainTemplatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainTemplatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainTemplatesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainTemplatesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageDomainTemplatesServiceListResponse{templates: result}, nil
}

func (p *StorageDomainTemplatesServiceListRequest) MustSend() *StorageDomainTemplatesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of templates availalbe in the storage domain.
// The order of the returned list of templates isn't guaranteed.
//
type StorageDomainTemplatesServiceListResponse struct {
	templates *TemplateSlice
}

func (p *StorageDomainTemplatesServiceListResponse) Templates() (*TemplateSlice, bool) {
	if p.templates != nil {
		return p.templates, true
	}
	return nil, false
}

func (p *StorageDomainTemplatesServiceListResponse) MustTemplates() *TemplateSlice {
	if p.templates == nil {
		panic("templates in response does not exist")
	}
	return p.templates
}

//
// Returns the list of templates availalbe in the storage domain.
// The order of the returned list of templates isn't guaranteed.
//
func (p *StorageDomainTemplatesService) List() *StorageDomainTemplatesServiceListRequest {
	return &StorageDomainTemplatesServiceListRequest{StorageDomainTemplatesService: p}
}

//
//
func (op *StorageDomainTemplatesService) TemplateService(id string) *StorageDomainTemplateService {
	return NewStorageDomainTemplateService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainTemplatesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TemplateService(path), nil
	}
	return op.TemplateService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainTemplatesService) String() string {
	return fmt.Sprintf("StorageDomainTemplatesService:%s", op.path)
}

//
// This service manages a single host to affinity group assignment.
//
type AffinityGroupHostService struct {
	BaseService
}

func NewAffinityGroupHostService(connection *Connection, path string) *AffinityGroupHostService {
	var result AffinityGroupHostService
	result.connection = connection
	result.path = path
	return &result
}

//
// Remove host from the affinity group.
//
type AffinityGroupHostServiceRemoveRequest struct {
	AffinityGroupHostService *AffinityGroupHostService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *AffinityGroupHostServiceRemoveRequest) Header(key, value string) *AffinityGroupHostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupHostServiceRemoveRequest) Query(key, value string) *AffinityGroupHostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupHostServiceRemoveRequest) Async(async bool) *AffinityGroupHostServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AffinityGroupHostServiceRemoveRequest) Send() (*AffinityGroupHostServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupHostService.connection.URL(), p.AffinityGroupHostService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupHostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupHostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupHostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityGroupHostServiceRemoveResponse), nil
}

func (p *AffinityGroupHostServiceRemoveRequest) MustSend() *AffinityGroupHostServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove host from the affinity group.
//
type AffinityGroupHostServiceRemoveResponse struct {
}

//
// Remove host from the affinity group.
//
func (p *AffinityGroupHostService) Remove() *AffinityGroupHostServiceRemoveRequest {
	return &AffinityGroupHostServiceRemoveRequest{AffinityGroupHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupHostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupHostService) String() string {
	return fmt.Sprintf("AffinityGroupHostService:%s", op.path)
}

//
// Manages the set of disks of an snapshot.
//
type SnapshotDisksService struct {
	BaseService
}

func NewSnapshotDisksService(connection *Connection, path string) *SnapshotDisksService {
	var result SnapshotDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disks of the snapshot.
// The order of the returned list of disks isn't guaranteed.
//
type SnapshotDisksServiceListRequest struct {
	SnapshotDisksService *SnapshotDisksService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *SnapshotDisksServiceListRequest) Header(key, value string) *SnapshotDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotDisksServiceListRequest) Query(key, value string) *SnapshotDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotDisksServiceListRequest) Follow(follow string) *SnapshotDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *SnapshotDisksServiceListRequest) Max(max int64) *SnapshotDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *SnapshotDisksServiceListRequest) Send() (*SnapshotDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotDisksService.connection.URL(), p.SnapshotDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotDisksServiceListResponse{disks: result}, nil
}

func (p *SnapshotDisksServiceListRequest) MustSend() *SnapshotDisksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of disks of the snapshot.
// The order of the returned list of disks isn't guaranteed.
//
type SnapshotDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *SnapshotDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *SnapshotDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks of the snapshot.
// The order of the returned list of disks isn't guaranteed.
//
func (p *SnapshotDisksService) List() *SnapshotDisksServiceListRequest {
	return &SnapshotDisksServiceListRequest{SnapshotDisksService: p}
}

//
//
func (op *SnapshotDisksService) DiskService(id string) *SnapshotDiskService {
	return NewSnapshotDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotDisksService) String() string {
	return fmt.Sprintf("SnapshotDisksService:%s", op.path)
}

//
//
type CpuProfileService struct {
	BaseService
}

func NewCpuProfileService(connection *Connection, path string) *CpuProfileService {
	var result CpuProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type CpuProfileServiceGetRequest struct {
	CpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *CpuProfileServiceGetRequest) Header(key, value string) *CpuProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceGetRequest) Query(key, value string) *CpuProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceGetRequest) Follow(follow string) *CpuProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *CpuProfileServiceGetRequest) Send() (*CpuProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.CpuProfileService.connection.URL(), p.CpuProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.CpuProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.CpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.CpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.CpuProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.CpuProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &CpuProfileServiceGetResponse{profile: result}, nil
}

func (p *CpuProfileServiceGetRequest) MustSend() *CpuProfileServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type CpuProfileServiceGetResponse struct {
	profile *CpuProfile
}

func (p *CpuProfileServiceGetResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *CpuProfileServiceGetResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
//
func (p *CpuProfileService) Get() *CpuProfileServiceGetRequest {
	return &CpuProfileServiceGetRequest{CpuProfileService: p}
}

//
//
type CpuProfileServiceRemoveRequest struct {
	CpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *CpuProfileServiceRemoveRequest) Header(key, value string) *CpuProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceRemoveRequest) Query(key, value string) *CpuProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceRemoveRequest) Async(async bool) *CpuProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *CpuProfileServiceRemoveRequest) Send() (*CpuProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.CpuProfileService.connection.URL(), p.CpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.CpuProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.CpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.CpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.CpuProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.CpuProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(CpuProfileServiceRemoveResponse), nil
}

func (p *CpuProfileServiceRemoveRequest) MustSend() *CpuProfileServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type CpuProfileServiceRemoveResponse struct {
}

//
//
func (p *CpuProfileService) Remove() *CpuProfileServiceRemoveRequest {
	return &CpuProfileServiceRemoveRequest{CpuProfileService: p}
}

//
// Update the specified cpu profile in the system.
//
type CpuProfileServiceUpdateRequest struct {
	CpuProfileService *CpuProfileService
	header            map[string]string
	query             map[string]string
	async             *bool
	profile           *CpuProfile
}

func (p *CpuProfileServiceUpdateRequest) Header(key, value string) *CpuProfileServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfileServiceUpdateRequest) Query(key, value string) *CpuProfileServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfileServiceUpdateRequest) Async(async bool) *CpuProfileServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *CpuProfileServiceUpdateRequest) Profile(profile *CpuProfile) *CpuProfileServiceUpdateRequest {
	p.profile = profile
	return p
}

func (p *CpuProfileServiceUpdateRequest) Send() (*CpuProfileServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.CpuProfileService.connection.URL(), p.CpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.CpuProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.CpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.CpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.CpuProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.CpuProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &CpuProfileServiceUpdateResponse{profile: result}, nil
}

func (p *CpuProfileServiceUpdateRequest) MustSend() *CpuProfileServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified cpu profile in the system.
//
type CpuProfileServiceUpdateResponse struct {
	profile *CpuProfile
}

func (p *CpuProfileServiceUpdateResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *CpuProfileServiceUpdateResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Update the specified cpu profile in the system.
//
func (p *CpuProfileService) Update() *CpuProfileServiceUpdateRequest {
	return &CpuProfileServiceUpdateRequest{CpuProfileService: p}
}

//
//
func (op *CpuProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CpuProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *CpuProfileService) String() string {
	return fmt.Sprintf("CpuProfileService:%s", op.path)
}

//
// This service lists external providers.
//
type ClusterExternalProvidersService struct {
	BaseService
}

func NewClusterExternalProvidersService(connection *Connection, path string) *ClusterExternalProvidersService {
	var result ClusterExternalProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of external providers.
// The order of the returned list of providers is not guaranteed.
//
type ClusterExternalProvidersServiceListRequest struct {
	ClusterExternalProvidersService *ClusterExternalProvidersService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
}

func (p *ClusterExternalProvidersServiceListRequest) Header(key, value string) *ClusterExternalProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterExternalProvidersServiceListRequest) Query(key, value string) *ClusterExternalProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterExternalProvidersServiceListRequest) Follow(follow string) *ClusterExternalProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ClusterExternalProvidersServiceListRequest) Send() (*ClusterExternalProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterExternalProvidersService.connection.URL(), p.ClusterExternalProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterExternalProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterExternalProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterExternalProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterExternalProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterExternalProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ClusterExternalProvidersServiceListResponse{providers: result}, nil
}

func (p *ClusterExternalProvidersServiceListRequest) MustSend() *ClusterExternalProvidersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of external providers.
// The order of the returned list of providers is not guaranteed.
//
type ClusterExternalProvidersServiceListResponse struct {
	providers *ExternalProviderSlice
}

func (p *ClusterExternalProvidersServiceListResponse) Providers() (*ExternalProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *ClusterExternalProvidersServiceListResponse) MustProviders() *ExternalProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Returns the list of external providers.
// The order of the returned list of providers is not guaranteed.
//
func (p *ClusterExternalProvidersService) List() *ClusterExternalProvidersServiceListRequest {
	return &ClusterExternalProvidersServiceListRequest{ClusterExternalProvidersService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterExternalProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterExternalProvidersService) String() string {
	return fmt.Sprintf("ClusterExternalProvidersService:%s", op.path)
}

//
//
type QosService struct {
	BaseService
}

func NewQosService(connection *Connection, path string) *QosService {
	var result QosService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get specified QoS in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will get response like this one below:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>1</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type QosServiceGetRequest struct {
	QosService *QosService
	header     map[string]string
	query      map[string]string
	follow     *string
}

func (p *QosServiceGetRequest) Header(key, value string) *QosServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceGetRequest) Query(key, value string) *QosServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceGetRequest) Follow(follow string) *QosServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *QosServiceGetRequest) Send() (*QosServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QosService.connection.URL(), p.QosService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QosService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QosService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QosService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QosService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QosService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QosServiceGetResponse{qos: result}, nil
}

func (p *QosServiceGetRequest) MustSend() *QosServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get specified QoS in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will get response like this one below:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>1</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type QosServiceGetResponse struct {
	qos *Qos
}

func (p *QosServiceGetResponse) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

func (p *QosServiceGetResponse) MustQos() *Qos {
	if p.qos == nil {
		panic("qos in response does not exist")
	}
	return p.qos
}

//
// Get specified QoS in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will get response like this one below:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>1</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
func (p *QosService) Get() *QosServiceGetRequest {
	return &QosServiceGetRequest{QosService: p}
}

//
// Remove specified QoS from datacenter.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/qoss/123
// ----
//
type QosServiceRemoveRequest struct {
	QosService *QosService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *QosServiceRemoveRequest) Header(key, value string) *QosServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceRemoveRequest) Query(key, value string) *QosServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceRemoveRequest) Async(async bool) *QosServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *QosServiceRemoveRequest) Send() (*QosServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QosService.connection.URL(), p.QosService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QosService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QosService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QosService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QosService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QosService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(QosServiceRemoveResponse), nil
}

func (p *QosServiceRemoveRequest) MustSend() *QosServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove specified QoS from datacenter.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/qoss/123
// ----
//
type QosServiceRemoveResponse struct {
}

//
// Remove specified QoS from datacenter.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/qoss/123
// ----
//
func (p *QosService) Remove() *QosServiceRemoveRequest {
	return &QosServiceRemoveRequest{QosService: p}
}

//
// Update the specified QoS in the dataCenter.
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/qoss/123
// ----
// For example with curl:
// [source]
// ----
// curl -u admin@internal:123456 -X PUT -H "content-type: application/xml" -d \
// "<qos><name>321</name><description>321</description><max_iops>10</max_iops></qos>" \
// https://engine/ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will receive response like this:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>321</name>
//   <description>321</description>
//   <max_iops>10</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type QosServiceUpdateRequest struct {
	QosService *QosService
	header     map[string]string
	query      map[string]string
	async      *bool
	qos        *Qos
}

func (p *QosServiceUpdateRequest) Header(key, value string) *QosServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QosServiceUpdateRequest) Query(key, value string) *QosServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QosServiceUpdateRequest) Async(async bool) *QosServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *QosServiceUpdateRequest) Qos(qos *Qos) *QosServiceUpdateRequest {
	p.qos = qos
	return p
}

func (p *QosServiceUpdateRequest) Send() (*QosServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QosService.connection.URL(), p.QosService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQosWriteOne(writer, p.qos, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QosService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QosService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QosService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QosService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QosService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QosServiceUpdateResponse{qos: result}, nil
}

func (p *QosServiceUpdateRequest) MustSend() *QosServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified QoS in the dataCenter.
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/qoss/123
// ----
// For example with curl:
// [source]
// ----
// curl -u admin@internal:123456 -X PUT -H "content-type: application/xml" -d \
// "<qos><name>321</name><description>321</description><max_iops>10</max_iops></qos>" \
// https://engine/ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will receive response like this:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>321</name>
//   <description>321</description>
//   <max_iops>10</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type QosServiceUpdateResponse struct {
	qos *Qos
}

func (p *QosServiceUpdateResponse) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

func (p *QosServiceUpdateResponse) MustQos() *Qos {
	if p.qos == nil {
		panic("qos in response does not exist")
	}
	return p.qos
}

//
// Update the specified QoS in the dataCenter.
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/qoss/123
// ----
// For example with curl:
// [source]
// ----
// curl -u admin@internal:123456 -X PUT -H "content-type: application/xml" -d \
// "<qos><name>321</name><description>321</description><max_iops>10</max_iops></qos>" \
// https://engine/ovirt-engine/api/datacenters/123/qoss/123
// ----
// You will receive response like this:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>321</name>
//   <description>321</description>
//   <max_iops>10</max_iops>
//   <max_throughput>1</max_throughput>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
func (p *QosService) Update() *QosServiceUpdateRequest {
	return &QosServiceUpdateRequest{QosService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QosService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QosService) String() string {
	return fmt.Sprintf("QosService:%s", op.path)
}

//
//
type InstanceTypeNicService struct {
	BaseService
}

func NewInstanceTypeNicService(connection *Connection, path string) *InstanceTypeNicService {
	var result InstanceTypeNicService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets network interface configuration of the instance type.
//
type InstanceTypeNicServiceGetRequest struct {
	InstanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *InstanceTypeNicServiceGetRequest) Header(key, value string) *InstanceTypeNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceGetRequest) Query(key, value string) *InstanceTypeNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceGetRequest) Follow(follow string) *InstanceTypeNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *InstanceTypeNicServiceGetRequest) Send() (*InstanceTypeNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeNicService.connection.URL(), p.InstanceTypeNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeNicServiceGetResponse{nic: result}, nil
}

func (p *InstanceTypeNicServiceGetRequest) MustSend() *InstanceTypeNicServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets network interface configuration of the instance type.
//
type InstanceTypeNicServiceGetResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicServiceGetResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *InstanceTypeNicServiceGetResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Gets network interface configuration of the instance type.
//
func (p *InstanceTypeNicService) Get() *InstanceTypeNicServiceGetRequest {
	return &InstanceTypeNicServiceGetRequest{InstanceTypeNicService: p}
}

//
// Remove the network interface from the instance type.
//
type InstanceTypeNicServiceRemoveRequest struct {
	InstanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *InstanceTypeNicServiceRemoveRequest) Header(key, value string) *InstanceTypeNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceRemoveRequest) Query(key, value string) *InstanceTypeNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceRemoveRequest) Async(async bool) *InstanceTypeNicServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *InstanceTypeNicServiceRemoveRequest) Send() (*InstanceTypeNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeNicService.connection.URL(), p.InstanceTypeNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(InstanceTypeNicServiceRemoveResponse), nil
}

func (p *InstanceTypeNicServiceRemoveRequest) MustSend() *InstanceTypeNicServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove the network interface from the instance type.
//
type InstanceTypeNicServiceRemoveResponse struct {
}

//
// Remove the network interface from the instance type.
//
func (p *InstanceTypeNicService) Remove() *InstanceTypeNicServiceRemoveRequest {
	return &InstanceTypeNicServiceRemoveRequest{InstanceTypeNicService: p}
}

//
// Updates the network interface configuration of the instance type.
//
type InstanceTypeNicServiceUpdateRequest struct {
	InstanceTypeNicService *InstanceTypeNicService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	nic                    *Nic
}

func (p *InstanceTypeNicServiceUpdateRequest) Header(key, value string) *InstanceTypeNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicServiceUpdateRequest) Query(key, value string) *InstanceTypeNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicServiceUpdateRequest) Async(async bool) *InstanceTypeNicServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *InstanceTypeNicServiceUpdateRequest) Nic(nic *Nic) *InstanceTypeNicServiceUpdateRequest {
	p.nic = nic
	return p
}

func (p *InstanceTypeNicServiceUpdateRequest) Send() (*InstanceTypeNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeNicService.connection.URL(), p.InstanceTypeNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeNicServiceUpdateResponse{nic: result}, nil
}

func (p *InstanceTypeNicServiceUpdateRequest) MustSend() *InstanceTypeNicServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the network interface configuration of the instance type.
//
type InstanceTypeNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicServiceUpdateResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *InstanceTypeNicServiceUpdateResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Updates the network interface configuration of the instance type.
//
func (p *InstanceTypeNicService) Update() *InstanceTypeNicServiceUpdateRequest {
	return &InstanceTypeNicServiceUpdateRequest{InstanceTypeNicService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeNicService) String() string {
	return fmt.Sprintf("InstanceTypeNicService:%s", op.path)
}

//
//
type UnmanagedNetworksService struct {
	BaseService
}

func NewUnmanagedNetworksService(connection *Connection, path string) *UnmanagedNetworksService {
	var result UnmanagedNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of unmanaged networks of the host.
// The order of the returned list of networks isn't guaranteed.
//
type UnmanagedNetworksServiceListRequest struct {
	UnmanagedNetworksService *UnmanagedNetworksService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
	max                      *int64
}

func (p *UnmanagedNetworksServiceListRequest) Header(key, value string) *UnmanagedNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *UnmanagedNetworksServiceListRequest) Query(key, value string) *UnmanagedNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *UnmanagedNetworksServiceListRequest) Follow(follow string) *UnmanagedNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *UnmanagedNetworksServiceListRequest) Max(max int64) *UnmanagedNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *UnmanagedNetworksServiceListRequest) Send() (*UnmanagedNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.UnmanagedNetworksService.connection.URL(), p.UnmanagedNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.UnmanagedNetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.UnmanagedNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.UnmanagedNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.UnmanagedNetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.UnmanagedNetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLUnmanagedNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &UnmanagedNetworksServiceListResponse{networks: result}, nil
}

func (p *UnmanagedNetworksServiceListRequest) MustSend() *UnmanagedNetworksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of unmanaged networks of the host.
// The order of the returned list of networks isn't guaranteed.
//
type UnmanagedNetworksServiceListResponse struct {
	networks *UnmanagedNetworkSlice
}

func (p *UnmanagedNetworksServiceListResponse) Networks() (*UnmanagedNetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *UnmanagedNetworksServiceListResponse) MustNetworks() *UnmanagedNetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Returns the list of unmanaged networks of the host.
// The order of the returned list of networks isn't guaranteed.
//
func (p *UnmanagedNetworksService) List() *UnmanagedNetworksServiceListRequest {
	return &UnmanagedNetworksServiceListRequest{UnmanagedNetworksService: p}
}

//
//
func (op *UnmanagedNetworksService) UnmanagedNetworkService(id string) *UnmanagedNetworkService {
	return NewUnmanagedNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *UnmanagedNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.UnmanagedNetworkService(path), nil
	}
	return op.UnmanagedNetworkService(path[:index]).Service(path[index+1:])
}

func (op *UnmanagedNetworksService) String() string {
	return fmt.Sprintf("UnmanagedNetworksService:%s", op.path)
}

//
//
type VmDiskService struct {
	BaseService
}

func NewVmDiskService(connection *Connection, path string) *VmDiskService {
	var result VmDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type VmDiskServiceActivateRequest struct {
	VmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceActivateRequest) Header(key, value string) *VmDiskServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceActivateRequest) Query(key, value string) *VmDiskServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceActivateRequest) Async(async bool) *VmDiskServiceActivateRequest {
	p.async = &async
	return p
}

func (p *VmDiskServiceActivateRequest) Send() (*VmDiskServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.VmDiskService.connection.URL(), p.VmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceActivateResponse), nil
}

func (p *VmDiskServiceActivateRequest) MustSend() *VmDiskServiceActivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmDiskServiceActivateResponse struct {
}

//
//
func (p *VmDiskService) Activate() *VmDiskServiceActivateRequest {
	return &VmDiskServiceActivateRequest{VmDiskService: p}
}

//
//
type VmDiskServiceDeactivateRequest struct {
	VmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceDeactivateRequest) Header(key, value string) *VmDiskServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceDeactivateRequest) Query(key, value string) *VmDiskServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceDeactivateRequest) Async(async bool) *VmDiskServiceDeactivateRequest {
	p.async = &async
	return p
}

func (p *VmDiskServiceDeactivateRequest) Send() (*VmDiskServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.VmDiskService.connection.URL(), p.VmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceDeactivateResponse), nil
}

func (p *VmDiskServiceDeactivateRequest) MustSend() *VmDiskServiceDeactivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmDiskServiceDeactivateResponse struct {
}

//
//
func (p *VmDiskService) Deactivate() *VmDiskServiceDeactivateRequest {
	return &VmDiskServiceDeactivateRequest{VmDiskService: p}
}

//
//
type VmDiskServiceExportRequest struct {
	VmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
}

func (p *VmDiskServiceExportRequest) Header(key, value string) *VmDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceExportRequest) Query(key, value string) *VmDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceExportRequest) Async(async bool) *VmDiskServiceExportRequest {
	p.async = &async
	return p
}

func (p *VmDiskServiceExportRequest) Filter(filter bool) *VmDiskServiceExportRequest {
	p.filter = &filter
	return p
}

func (p *VmDiskServiceExportRequest) Send() (*VmDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.VmDiskService.connection.URL(), p.VmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceExportResponse), nil
}

func (p *VmDiskServiceExportRequest) MustSend() *VmDiskServiceExportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmDiskServiceExportResponse struct {
}

//
//
func (p *VmDiskService) Export() *VmDiskServiceExportRequest {
	return &VmDiskServiceExportRequest{VmDiskService: p}
}

//
//
type VmDiskServiceGetRequest struct {
	VmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	follow        *string
}

func (p *VmDiskServiceGetRequest) Header(key, value string) *VmDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceGetRequest) Query(key, value string) *VmDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceGetRequest) Follow(follow string) *VmDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmDiskServiceGetRequest) Send() (*VmDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmDiskService.connection.URL(), p.VmDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmDiskServiceGetResponse{disk: result}, nil
}

func (p *VmDiskServiceGetRequest) MustSend() *VmDiskServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmDiskServiceGetResponse struct {
	disk *Disk
}

func (p *VmDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *VmDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *VmDiskService) Get() *VmDiskServiceGetRequest {
	return &VmDiskServiceGetRequest{VmDiskService: p}
}

//
//
type VmDiskServiceMoveRequest struct {
	VmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
}

func (p *VmDiskServiceMoveRequest) Header(key, value string) *VmDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceMoveRequest) Query(key, value string) *VmDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceMoveRequest) Async(async bool) *VmDiskServiceMoveRequest {
	p.async = &async
	return p
}

func (p *VmDiskServiceMoveRequest) Filter(filter bool) *VmDiskServiceMoveRequest {
	p.filter = &filter
	return p
}

func (p *VmDiskServiceMoveRequest) Send() (*VmDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.VmDiskService.connection.URL(), p.VmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceMoveResponse), nil
}

func (p *VmDiskServiceMoveRequest) MustSend() *VmDiskServiceMoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmDiskServiceMoveResponse struct {
}

//
//
func (p *VmDiskService) Move() *VmDiskServiceMoveRequest {
	return &VmDiskServiceMoveRequest{VmDiskService: p}
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
type VmDiskServiceReduceRequest struct {
	VmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceReduceRequest) Header(key, value string) *VmDiskServiceReduceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceReduceRequest) Query(key, value string) *VmDiskServiceReduceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceReduceRequest) Async(async bool) *VmDiskServiceReduceRequest {
	p.async = &async
	return p
}

func (p *VmDiskServiceReduceRequest) Send() (*VmDiskServiceReduceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reduce", p.VmDiskService.connection.URL(), p.VmDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmDiskServiceReduceResponse), nil
}

func (p *VmDiskServiceReduceRequest) MustSend() *VmDiskServiceReduceResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
type VmDiskServiceReduceResponse struct {
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
func (p *VmDiskService) Reduce() *VmDiskServiceReduceRequest {
	return &VmDiskServiceReduceRequest{VmDiskService: p}
}

//
// Detach the disk from the virtual machine.
// NOTE: In version 3 of the API this used to also remove the disk completely from the system, but starting with
// version 4 it doesn't. If you need to remove it completely use the <<services/disk/methods/remove,remove
// method of the top level disk service>>.
//
type VmDiskServiceRemoveRequest struct {
	VmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *VmDiskServiceRemoveRequest) Header(key, value string) *VmDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceRemoveRequest) Query(key, value string) *VmDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceRemoveRequest) Async(async bool) *VmDiskServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VmDiskServiceRemoveRequest) Send() (*VmDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmDiskService.connection.URL(), p.VmDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmDiskServiceRemoveResponse), nil
}

func (p *VmDiskServiceRemoveRequest) MustSend() *VmDiskServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Detach the disk from the virtual machine.
// NOTE: In version 3 of the API this used to also remove the disk completely from the system, but starting with
// version 4 it doesn't. If you need to remove it completely use the <<services/disk/methods/remove,remove
// method of the top level disk service>>.
//
type VmDiskServiceRemoveResponse struct {
}

//
// Detach the disk from the virtual machine.
// NOTE: In version 3 of the API this used to also remove the disk completely from the system, but starting with
// version 4 it doesn't. If you need to remove it completely use the <<services/disk/methods/remove,remove
// method of the top level disk service>>.
//
func (p *VmDiskService) Remove() *VmDiskServiceRemoveRequest {
	return &VmDiskServiceRemoveRequest{VmDiskService: p}
}

//
//
type VmDiskServiceUpdateRequest struct {
	VmDiskService *VmDiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	disk          *Disk
}

func (p *VmDiskServiceUpdateRequest) Header(key, value string) *VmDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDiskServiceUpdateRequest) Query(key, value string) *VmDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDiskServiceUpdateRequest) Async(async bool) *VmDiskServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *VmDiskServiceUpdateRequest) Disk(disk *Disk) *VmDiskServiceUpdateRequest {
	p.disk = disk
	return p
}

func (p *VmDiskServiceUpdateRequest) Send() (*VmDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmDiskService.connection.URL(), p.VmDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmDiskServiceUpdateResponse{disk: result}, nil
}

func (p *VmDiskServiceUpdateRequest) MustSend() *VmDiskServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *VmDiskServiceUpdateResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *VmDiskServiceUpdateResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *VmDiskService) Update() *VmDiskServiceUpdateRequest {
	return &VmDiskServiceUpdateRequest{VmDiskService: p}
}

//
//
func (op *VmDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *VmDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmDiskService) String() string {
	return fmt.Sprintf("VmDiskService:%s", op.path)
}

//
// Manages the virtual machine template and template versions.
//
type TemplateService struct {
	BaseService
}

func NewTemplateService(connection *Connection, path string) *TemplateService {
	var result TemplateService
	result.connection = connection
	result.path = path
	return &result
}

//
// Exports a template to the data center export domain.
// For example, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/templates/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <exclusive>true<exclusive/>
// </action>
// ----
//
type TemplateServiceExportRequest struct {
	TemplateService *TemplateService
	header          map[string]string
	query           map[string]string
	exclusive       *bool
	storageDomain   *StorageDomain
}

func (p *TemplateServiceExportRequest) Header(key, value string) *TemplateServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceExportRequest) Query(key, value string) *TemplateServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceExportRequest) Exclusive(exclusive bool) *TemplateServiceExportRequest {
	p.exclusive = &exclusive
	return p
}

func (p *TemplateServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *TemplateServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *TemplateServiceExportRequest) Send() (*TemplateServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.TemplateService.connection.URL(), p.TemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateServiceExportResponse), nil
}

func (p *TemplateServiceExportRequest) MustSend() *TemplateServiceExportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports a template to the data center export domain.
// For example, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/templates/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <exclusive>true<exclusive/>
// </action>
// ----
//
type TemplateServiceExportResponse struct {
}

//
// Exports a template to the data center export domain.
// For example, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/templates/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <exclusive>true<exclusive/>
// </action>
// ----
//
func (p *TemplateService) Export() *TemplateServiceExportRequest {
	return &TemplateServiceExportRequest{TemplateService: p}
}

//
// Returns the information about this template or template version.
//
type TemplateServiceGetRequest struct {
	TemplateService *TemplateService
	header          map[string]string
	query           map[string]string
	filter          *bool
	follow          *string
}

func (p *TemplateServiceGetRequest) Header(key, value string) *TemplateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceGetRequest) Query(key, value string) *TemplateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceGetRequest) Filter(filter bool) *TemplateServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *TemplateServiceGetRequest) Follow(follow string) *TemplateServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *TemplateServiceGetRequest) Send() (*TemplateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateService.connection.URL(), p.TemplateService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateServiceGetResponse{template: result}, nil
}

func (p *TemplateServiceGetRequest) MustSend() *TemplateServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the information about this template or template version.
//
type TemplateServiceGetResponse struct {
	template *Template
}

func (p *TemplateServiceGetResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *TemplateServiceGetResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Returns the information about this template or template version.
//
func (p *TemplateService) Get() *TemplateServiceGetRequest {
	return &TemplateServiceGetRequest{TemplateService: p}
}

//
// Removes a virtual machine template.
// [source]
// ----
// DELETE /ovirt-engine/api/templates/123
// ----
//
type TemplateServiceRemoveRequest struct {
	TemplateService *TemplateService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *TemplateServiceRemoveRequest) Header(key, value string) *TemplateServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceRemoveRequest) Query(key, value string) *TemplateServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceRemoveRequest) Async(async bool) *TemplateServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *TemplateServiceRemoveRequest) Send() (*TemplateServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateService.connection.URL(), p.TemplateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateServiceRemoveResponse), nil
}

func (p *TemplateServiceRemoveRequest) MustSend() *TemplateServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a virtual machine template.
// [source]
// ----
// DELETE /ovirt-engine/api/templates/123
// ----
//
type TemplateServiceRemoveResponse struct {
}

//
// Removes a virtual machine template.
// [source]
// ----
// DELETE /ovirt-engine/api/templates/123
// ----
//
func (p *TemplateService) Remove() *TemplateServiceRemoveRequest {
	return &TemplateServiceRemoveRequest{TemplateService: p}
}

//
// Exports a template to an export domain.
//
type TemplateServiceExportToExportDomainRequest struct {
	TemplateService *TemplateService
	header          map[string]string
	query           map[string]string
	exclusive       *bool
	storageDomain   *StorageDomain
}

func (p *TemplateServiceExportToExportDomainRequest) Header(key, value string) *TemplateServiceExportToExportDomainRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceExportToExportDomainRequest) Query(key, value string) *TemplateServiceExportToExportDomainRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceExportToExportDomainRequest) Exclusive(exclusive bool) *TemplateServiceExportToExportDomainRequest {
	p.exclusive = &exclusive
	return p
}

func (p *TemplateServiceExportToExportDomainRequest) StorageDomain(storageDomain *StorageDomain) *TemplateServiceExportToExportDomainRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *TemplateServiceExportToExportDomainRequest) Send() (*TemplateServiceExportToExportDomainResponse, error) {
	rawURL := fmt.Sprintf("%s%s/toexportdomain", p.TemplateService.connection.URL(), p.TemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateServiceExportToExportDomainResponse), nil
}

func (p *TemplateServiceExportToExportDomainRequest) MustSend() *TemplateServiceExportToExportDomainResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports a template to an export domain.
//
type TemplateServiceExportToExportDomainResponse struct {
}

//
// Exports a template to an export domain.
//
func (p *TemplateService) ExportToExportDomain() *TemplateServiceExportToExportDomainRequest {
	return &TemplateServiceExportToExportDomainRequest{TemplateService: p}
}

//
// Exports a template as an OVA file to a given path on a specified host.
//
type TemplateServiceExportToPathOnHostRequest struct {
	TemplateService *TemplateService
	header          map[string]string
	query           map[string]string
	directory       *string
	exclusive       *bool
	filename        *string
	host            *Host
	storageDomain   *StorageDomain
}

func (p *TemplateServiceExportToPathOnHostRequest) Header(key, value string) *TemplateServiceExportToPathOnHostRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceExportToPathOnHostRequest) Query(key, value string) *TemplateServiceExportToPathOnHostRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceExportToPathOnHostRequest) Directory(directory string) *TemplateServiceExportToPathOnHostRequest {
	p.directory = &directory
	return p
}

func (p *TemplateServiceExportToPathOnHostRequest) Exclusive(exclusive bool) *TemplateServiceExportToPathOnHostRequest {
	p.exclusive = &exclusive
	return p
}

func (p *TemplateServiceExportToPathOnHostRequest) Filename(filename string) *TemplateServiceExportToPathOnHostRequest {
	p.filename = &filename
	return p
}

func (p *TemplateServiceExportToPathOnHostRequest) Host(host *Host) *TemplateServiceExportToPathOnHostRequest {
	p.host = host
	return p
}

func (p *TemplateServiceExportToPathOnHostRequest) StorageDomain(storageDomain *StorageDomain) *TemplateServiceExportToPathOnHostRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *TemplateServiceExportToPathOnHostRequest) Send() (*TemplateServiceExportToPathOnHostResponse, error) {
	rawURL := fmt.Sprintf("%s%s/topathonhost", p.TemplateService.connection.URL(), p.TemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.directory != nil {
		actionBuilder.Directory(*p.directory)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	if p.filename != nil {
		actionBuilder.Filename(*p.filename)
	}
	actionBuilder.Host(p.host)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateServiceExportToPathOnHostResponse), nil
}

func (p *TemplateServiceExportToPathOnHostRequest) MustSend() *TemplateServiceExportToPathOnHostResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports a template as an OVA file to a given path on a specified host.
//
type TemplateServiceExportToPathOnHostResponse struct {
}

//
// Exports a template as an OVA file to a given path on a specified host.
//
func (p *TemplateService) ExportToPathOnHost() *TemplateServiceExportToPathOnHostRequest {
	return &TemplateServiceExportToPathOnHostRequest{TemplateService: p}
}

//
// Updates the template.
// The `name`, `description`, `type`, `memory`, `cpu`, `topology`, `os`, `high_availability`, `display`,
// `stateless`, `usb`, and `timezone` elements can be updated after a template has been created.
// For example, to update a template so that it has 1 GiB of memory send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/templates/123
// ----
// With the following request body:
// [source,xml]
// ----
// <template>
//   <memory>1073741824</memory>
// </template>
// ----
// The `version_name` name attribute is the only one that can be updated within the `version` attribute used for
// template versions:
// [source,xml]
// ----
// <template>
//   <version>
//     <version_name>mytemplate_2</version_name>
//   </version>
// </template>
// ----
//
type TemplateServiceUpdateRequest struct {
	TemplateService *TemplateService
	header          map[string]string
	query           map[string]string
	async           *bool
	template        *Template
}

func (p *TemplateServiceUpdateRequest) Header(key, value string) *TemplateServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateServiceUpdateRequest) Query(key, value string) *TemplateServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateServiceUpdateRequest) Async(async bool) *TemplateServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *TemplateServiceUpdateRequest) Template(template *Template) *TemplateServiceUpdateRequest {
	p.template = template
	return p
}

func (p *TemplateServiceUpdateRequest) Send() (*TemplateServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateService.connection.URL(), p.TemplateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTemplateWriteOne(writer, p.template, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateServiceUpdateResponse{template: result}, nil
}

func (p *TemplateServiceUpdateRequest) MustSend() *TemplateServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the template.
// The `name`, `description`, `type`, `memory`, `cpu`, `topology`, `os`, `high_availability`, `display`,
// `stateless`, `usb`, and `timezone` elements can be updated after a template has been created.
// For example, to update a template so that it has 1 GiB of memory send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/templates/123
// ----
// With the following request body:
// [source,xml]
// ----
// <template>
//   <memory>1073741824</memory>
// </template>
// ----
// The `version_name` name attribute is the only one that can be updated within the `version` attribute used for
// template versions:
// [source,xml]
// ----
// <template>
//   <version>
//     <version_name>mytemplate_2</version_name>
//   </version>
// </template>
// ----
//
type TemplateServiceUpdateResponse struct {
	template *Template
}

func (p *TemplateServiceUpdateResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *TemplateServiceUpdateResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Updates the template.
// The `name`, `description`, `type`, `memory`, `cpu`, `topology`, `os`, `high_availability`, `display`,
// `stateless`, `usb`, and `timezone` elements can be updated after a template has been created.
// For example, to update a template so that it has 1 GiB of memory send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/templates/123
// ----
// With the following request body:
// [source,xml]
// ----
// <template>
//   <memory>1073741824</memory>
// </template>
// ----
// The `version_name` name attribute is the only one that can be updated within the `version` attribute used for
// template versions:
// [source,xml]
// ----
// <template>
//   <version>
//     <version_name>mytemplate_2</version_name>
//   </version>
// </template>
// ----
//
func (p *TemplateService) Update() *TemplateServiceUpdateRequest {
	return &TemplateServiceUpdateRequest{TemplateService: p}
}

//
// Returns a reference to the service that manages the CD-ROMs that are associated with the template.
//
func (op *TemplateService) CdromsService() *TemplateCdromsService {
	return NewTemplateCdromsService(op.connection, fmt.Sprintf("%s/cdroms", op.path))
}

//
// Returns a reference to the service that manages a specific
// disk attachment of the template.
//
func (op *TemplateService) DiskAttachmentsService() *TemplateDiskAttachmentsService {
	return NewTemplateDiskAttachmentsService(op.connection, fmt.Sprintf("%s/diskattachments", op.path))
}

//
// Returns a reference to the service that manages the graphical consoles that are associated with the template.
//
func (op *TemplateService) GraphicsConsolesService() *TemplateGraphicsConsolesService {
	return NewTemplateGraphicsConsolesService(op.connection, fmt.Sprintf("%s/graphicsconsoles", op.path))
}

//
// Returns a reference to the service that manages the NICs that are associated with the template.
//
func (op *TemplateService) NicsService() *TemplateNicsService {
	return NewTemplateNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
// Returns a reference to the service that manages the permissions that are associated with the template.
//
func (op *TemplateService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Returns a reference to the service that manages the tags that are associated with the template.
//
func (op *TemplateService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
// Returns a reference to the service that manages the _watchdogs_ that are associated with the template.
//
func (op *TemplateService) WatchdogsService() *TemplateWatchdogsService {
	return NewTemplateWatchdogsService(op.connection, fmt.Sprintf("%s/watchdogs", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateService) String() string {
	return fmt.Sprintf("TemplateService:%s", op.path)
}

//
// A service to manage a host.
//
type HostService struct {
	BaseService
}

func NewHostService(connection *Connection, path string) *HostService {
	var result HostService
	result.connection = connection
	result.path = path
	return &result
}

//
// Activates the host for use, for example to run virtual machines.
//
type HostServiceActivateRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceActivateRequest) Header(key, value string) *HostServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceActivateRequest) Query(key, value string) *HostServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceActivateRequest) Async(async bool) *HostServiceActivateRequest {
	p.async = &async
	return p
}

func (p *HostServiceActivateRequest) Send() (*HostServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceActivateResponse), nil
}

func (p *HostServiceActivateRequest) MustSend() *HostServiceActivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Activates the host for use, for example to run virtual machines.
//
type HostServiceActivateResponse struct {
}

//
// Activates the host for use, for example to run virtual machines.
//
func (p *HostService) Activate() *HostServiceActivateRequest {
	return &HostServiceActivateRequest{HostService: p}
}

//
// Approve a pre-installed Hypervisor host for usage in the virtualization environment.
// This action also accepts an optional cluster element to define the target cluster for this host.
//
type HostServiceApproveRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	activate    *bool
	async       *bool
	cluster     *Cluster
	host        *Host
}

func (p *HostServiceApproveRequest) Header(key, value string) *HostServiceApproveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceApproveRequest) Query(key, value string) *HostServiceApproveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceApproveRequest) Activate(activate bool) *HostServiceApproveRequest {
	p.activate = &activate
	return p
}

func (p *HostServiceApproveRequest) Async(async bool) *HostServiceApproveRequest {
	p.async = &async
	return p
}

func (p *HostServiceApproveRequest) Cluster(cluster *Cluster) *HostServiceApproveRequest {
	p.cluster = cluster
	return p
}

func (p *HostServiceApproveRequest) Host(host *Host) *HostServiceApproveRequest {
	p.host = host
	return p
}

func (p *HostServiceApproveRequest) Send() (*HostServiceApproveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/approve", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.activate != nil {
		actionBuilder.Activate(*p.activate)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceApproveResponse), nil
}

func (p *HostServiceApproveRequest) MustSend() *HostServiceApproveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Approve a pre-installed Hypervisor host for usage in the virtualization environment.
// This action also accepts an optional cluster element to define the target cluster for this host.
//
type HostServiceApproveResponse struct {
}

//
// Approve a pre-installed Hypervisor host for usage in the virtualization environment.
// This action also accepts an optional cluster element to define the target cluster for this host.
//
func (p *HostService) Approve() *HostServiceApproveRequest {
	return &HostServiceApproveRequest{HostService: p}
}

//
// Marks the network configuration as good and persists it inside the host.
// An API user commits the network configuration to persist a host network interface attachment or detachment, or
// persist the creation and deletion of a bonded interface.
// IMPORTANT: Networking configuration is only committed after the engine has established that host connectivity is
// not lost as a result of the configuration changes. If host connectivity is lost, the host requires a reboot and
// automatically reverts to the previous networking configuration.
// For example, to commit the network configuration of host with id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/commitnetconfig
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// IMPORTANT: Since {engine-name} 4.3, it is possible to also specify `commit_on_success` in
// the <<services/host/methods/setup_networks, setupnetworks>> request, in which case the new
// configuration is automatically saved in the {hypervisor-name} upon completing the setup and
// re-establishing connectivity between the {hypervisor-name} and {engine-name}, and without
// waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>> request.
//
type HostServiceCommitNetConfigRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceCommitNetConfigRequest) Header(key, value string) *HostServiceCommitNetConfigRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceCommitNetConfigRequest) Query(key, value string) *HostServiceCommitNetConfigRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceCommitNetConfigRequest) Async(async bool) *HostServiceCommitNetConfigRequest {
	p.async = &async
	return p
}

func (p *HostServiceCommitNetConfigRequest) Send() (*HostServiceCommitNetConfigResponse, error) {
	rawURL := fmt.Sprintf("%s%s/commitnetconfig", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceCommitNetConfigResponse), nil
}

func (p *HostServiceCommitNetConfigRequest) MustSend() *HostServiceCommitNetConfigResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Marks the network configuration as good and persists it inside the host.
// An API user commits the network configuration to persist a host network interface attachment or detachment, or
// persist the creation and deletion of a bonded interface.
// IMPORTANT: Networking configuration is only committed after the engine has established that host connectivity is
// not lost as a result of the configuration changes. If host connectivity is lost, the host requires a reboot and
// automatically reverts to the previous networking configuration.
// For example, to commit the network configuration of host with id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/commitnetconfig
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// IMPORTANT: Since {engine-name} 4.3, it is possible to also specify `commit_on_success` in
// the <<services/host/methods/setup_networks, setupnetworks>> request, in which case the new
// configuration is automatically saved in the {hypervisor-name} upon completing the setup and
// re-establishing connectivity between the {hypervisor-name} and {engine-name}, and without
// waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>> request.
//
type HostServiceCommitNetConfigResponse struct {
}

//
// Marks the network configuration as good and persists it inside the host.
// An API user commits the network configuration to persist a host network interface attachment or detachment, or
// persist the creation and deletion of a bonded interface.
// IMPORTANT: Networking configuration is only committed after the engine has established that host connectivity is
// not lost as a result of the configuration changes. If host connectivity is lost, the host requires a reboot and
// automatically reverts to the previous networking configuration.
// For example, to commit the network configuration of host with id `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/commitnetconfig
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
// IMPORTANT: Since {engine-name} 4.3, it is possible to also specify `commit_on_success` in
// the <<services/host/methods/setup_networks, setupnetworks>> request, in which case the new
// configuration is automatically saved in the {hypervisor-name} upon completing the setup and
// re-establishing connectivity between the {hypervisor-name} and {engine-name}, and without
// waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>> request.
//
func (p *HostService) CommitNetConfig() *HostServiceCommitNetConfigRequest {
	return &HostServiceCommitNetConfigRequest{HostService: p}
}

//
// Copy the network configuration of the specified host to current host.
// To copy networks from another host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/copyhostnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//    <sourceHost id="456" />
// </action>
// ----
//
type HostServiceCopyHostNetworksRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	sourceHost  *Host
}

func (p *HostServiceCopyHostNetworksRequest) Header(key, value string) *HostServiceCopyHostNetworksRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceCopyHostNetworksRequest) Query(key, value string) *HostServiceCopyHostNetworksRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceCopyHostNetworksRequest) Async(async bool) *HostServiceCopyHostNetworksRequest {
	p.async = &async
	return p
}

func (p *HostServiceCopyHostNetworksRequest) SourceHost(sourceHost *Host) *HostServiceCopyHostNetworksRequest {
	p.sourceHost = sourceHost
	return p
}

func (p *HostServiceCopyHostNetworksRequest) Send() (*HostServiceCopyHostNetworksResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copyhostnetworks", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.SourceHost(p.sourceHost)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceCopyHostNetworksResponse), nil
}

func (p *HostServiceCopyHostNetworksRequest) MustSend() *HostServiceCopyHostNetworksResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Copy the network configuration of the specified host to current host.
// To copy networks from another host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/copyhostnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//    <sourceHost id="456" />
// </action>
// ----
//
type HostServiceCopyHostNetworksResponse struct {
}

//
// Copy the network configuration of the specified host to current host.
// To copy networks from another host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/copyhostnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//    <sourceHost id="456" />
// </action>
// ----
//
func (p *HostService) CopyHostNetworks() *HostServiceCopyHostNetworksRequest {
	return &HostServiceCopyHostNetworksRequest{HostService: p}
}

//
// Deactivates the host to perform maintenance tasks.
//
type HostServiceDeactivateRequest struct {
	HostService        *HostService
	header             map[string]string
	query              map[string]string
	async              *bool
	reason             *string
	stopGlusterService *bool
}

func (p *HostServiceDeactivateRequest) Header(key, value string) *HostServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceDeactivateRequest) Query(key, value string) *HostServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceDeactivateRequest) Async(async bool) *HostServiceDeactivateRequest {
	p.async = &async
	return p
}

func (p *HostServiceDeactivateRequest) Reason(reason string) *HostServiceDeactivateRequest {
	p.reason = &reason
	return p
}

func (p *HostServiceDeactivateRequest) StopGlusterService(stopGlusterService bool) *HostServiceDeactivateRequest {
	p.stopGlusterService = &stopGlusterService
	return p
}

func (p *HostServiceDeactivateRequest) Send() (*HostServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.reason != nil {
		actionBuilder.Reason(*p.reason)
	}
	if p.stopGlusterService != nil {
		actionBuilder.StopGlusterService(*p.stopGlusterService)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceDeactivateResponse), nil
}

func (p *HostServiceDeactivateRequest) MustSend() *HostServiceDeactivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Deactivates the host to perform maintenance tasks.
//
type HostServiceDeactivateResponse struct {
}

//
// Deactivates the host to perform maintenance tasks.
//
func (p *HostService) Deactivate() *HostServiceDeactivateRequest {
	return &HostServiceDeactivateRequest{HostService: p}
}

//
// Enrolls the certificate of the host. Useful in case you get a warning that it is about to expire or has already
// expired.
//
type HostServiceEnrollCertificateRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceEnrollCertificateRequest) Header(key, value string) *HostServiceEnrollCertificateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceEnrollCertificateRequest) Query(key, value string) *HostServiceEnrollCertificateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceEnrollCertificateRequest) Async(async bool) *HostServiceEnrollCertificateRequest {
	p.async = &async
	return p
}

func (p *HostServiceEnrollCertificateRequest) Send() (*HostServiceEnrollCertificateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/enrollcertificate", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceEnrollCertificateResponse), nil
}

func (p *HostServiceEnrollCertificateRequest) MustSend() *HostServiceEnrollCertificateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Enrolls the certificate of the host. Useful in case you get a warning that it is about to expire or has already
// expired.
//
type HostServiceEnrollCertificateResponse struct {
}

//
// Enrolls the certificate of the host. Useful in case you get a warning that it is about to expire or has already
// expired.
//
func (p *HostService) EnrollCertificate() *HostServiceEnrollCertificateRequest {
	return &HostServiceEnrollCertificateRequest{HostService: p}
}

//
// Controls the host's power management device.
// For example, to start the host. This can be done via:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <fence_type>start</fence_type>
// </action>
// ' \
// "${url}/hosts/123/fence"
// ----
//
type HostServiceFenceRequest struct {
	HostService             *HostService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	fenceType               *string
	maintenanceAfterRestart *bool
}

func (p *HostServiceFenceRequest) Header(key, value string) *HostServiceFenceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceFenceRequest) Query(key, value string) *HostServiceFenceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceFenceRequest) Async(async bool) *HostServiceFenceRequest {
	p.async = &async
	return p
}

func (p *HostServiceFenceRequest) FenceType(fenceType string) *HostServiceFenceRequest {
	p.fenceType = &fenceType
	return p
}

func (p *HostServiceFenceRequest) MaintenanceAfterRestart(maintenanceAfterRestart bool) *HostServiceFenceRequest {
	p.maintenanceAfterRestart = &maintenanceAfterRestart
	return p
}

func (p *HostServiceFenceRequest) Send() (*HostServiceFenceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fence", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.fenceType != nil {
		actionBuilder.FenceType(*p.fenceType)
	}
	if p.maintenanceAfterRestart != nil {
		actionBuilder.MaintenanceAfterRestart(*p.maintenanceAfterRestart)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustPowerManagement()
	return &HostServiceFenceResponse{powerManagement: result}, nil
}

func (p *HostServiceFenceRequest) MustSend() *HostServiceFenceResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Controls the host's power management device.
// For example, to start the host. This can be done via:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <fence_type>start</fence_type>
// </action>
// ' \
// "${url}/hosts/123/fence"
// ----
//
type HostServiceFenceResponse struct {
	powerManagement *PowerManagement
}

func (p *HostServiceFenceResponse) PowerManagement() (*PowerManagement, bool) {
	if p.powerManagement != nil {
		return p.powerManagement, true
	}
	return nil, false
}

func (p *HostServiceFenceResponse) MustPowerManagement() *PowerManagement {
	if p.powerManagement == nil {
		panic("powerManagement in response does not exist")
	}
	return p.powerManagement
}

//
// Controls the host's power management device.
// For example, to start the host. This can be done via:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <fence_type>start</fence_type>
// </action>
// ' \
// "${url}/hosts/123/fence"
// ----
//
func (p *HostService) Fence() *HostServiceFenceRequest {
	return &HostServiceFenceRequest{HostService: p}
}

//
// To manually set a host as the storage pool manager (SPM).
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/forceselectspm
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type HostServiceForceSelectSpmRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceForceSelectSpmRequest) Header(key, value string) *HostServiceForceSelectSpmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceForceSelectSpmRequest) Query(key, value string) *HostServiceForceSelectSpmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceForceSelectSpmRequest) Async(async bool) *HostServiceForceSelectSpmRequest {
	p.async = &async
	return p
}

func (p *HostServiceForceSelectSpmRequest) Send() (*HostServiceForceSelectSpmResponse, error) {
	rawURL := fmt.Sprintf("%s%s/forceselectspm", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceForceSelectSpmResponse), nil
}

func (p *HostServiceForceSelectSpmRequest) MustSend() *HostServiceForceSelectSpmResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// To manually set a host as the storage pool manager (SPM).
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/forceselectspm
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type HostServiceForceSelectSpmResponse struct {
}

//
// To manually set a host as the storage pool manager (SPM).
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/forceselectspm
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *HostService) ForceSelectSpm() *HostServiceForceSelectSpmRequest {
	return &HostServiceForceSelectSpmRequest{HostService: p}
}

//
// Gets the host details.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123
// ----
//
type HostServiceGetRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	allContent  *bool
	filter      *bool
	follow      *string
}

func (p *HostServiceGetRequest) Header(key, value string) *HostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceGetRequest) Query(key, value string) *HostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceGetRequest) AllContent(allContent bool) *HostServiceGetRequest {
	p.allContent = &allContent
	return p
}

func (p *HostServiceGetRequest) Filter(filter bool) *HostServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *HostServiceGetRequest) Follow(follow string) *HostServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *HostServiceGetRequest) Send() (*HostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostService.connection.URL(), p.HostService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &HostServiceGetResponse{host: result}, nil
}

func (p *HostServiceGetRequest) MustSend() *HostServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the host details.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123
// ----
//
type HostServiceGetResponse struct {
	host *Host
}

func (p *HostServiceGetResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *HostServiceGetResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Gets the host details.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123
// ----
//
func (p *HostService) Get() *HostServiceGetRequest {
	return &HostServiceGetRequest{HostService: p}
}

//
// Installs the latest version of VDSM and related software on the host.
// The action also performs every configuration steps on the host which is done during adding host to the engine:
// kdump configuration, hosted-engine deploy, kernel options changes, etc.
// The host type defines additional parameters for the action.
// Example of installing a host, using `curl` and JSON, plain:
// [source,bash]
// ----
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123"
// ----
// Example of installing a host using `curl` and JSON with hosted engine components:
// [source,bash]
// ----
// curl \
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123?deploy_hosted_engine=true"
// ----
// IMPORTANT: Since version 4.1.2 of the engine, when a host is reinstalled we override the host firewall
// definitions by default.
//
type HostServiceInstallRequest struct {
	HostService          *HostService
	header               map[string]string
	query                map[string]string
	activate             *bool
	async                *bool
	deployHostedEngine   *bool
	host                 *Host
	image                *string
	rootPassword         *string
	ssh                  *Ssh
	undeployHostedEngine *bool
}

func (p *HostServiceInstallRequest) Header(key, value string) *HostServiceInstallRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceInstallRequest) Query(key, value string) *HostServiceInstallRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceInstallRequest) Activate(activate bool) *HostServiceInstallRequest {
	p.activate = &activate
	return p
}

func (p *HostServiceInstallRequest) Async(async bool) *HostServiceInstallRequest {
	p.async = &async
	return p
}

func (p *HostServiceInstallRequest) DeployHostedEngine(deployHostedEngine bool) *HostServiceInstallRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *HostServiceInstallRequest) Host(host *Host) *HostServiceInstallRequest {
	p.host = host
	return p
}

func (p *HostServiceInstallRequest) Image(image string) *HostServiceInstallRequest {
	p.image = &image
	return p
}

func (p *HostServiceInstallRequest) RootPassword(rootPassword string) *HostServiceInstallRequest {
	p.rootPassword = &rootPassword
	return p
}

func (p *HostServiceInstallRequest) Ssh(ssh *Ssh) *HostServiceInstallRequest {
	p.ssh = ssh
	return p
}

func (p *HostServiceInstallRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostServiceInstallRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *HostServiceInstallRequest) Send() (*HostServiceInstallResponse, error) {
	rawURL := fmt.Sprintf("%s%s/install", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.activate != nil {
		actionBuilder.Activate(*p.activate)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceInstallResponse), nil
}

func (p *HostServiceInstallRequest) MustSend() *HostServiceInstallResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Installs the latest version of VDSM and related software on the host.
// The action also performs every configuration steps on the host which is done during adding host to the engine:
// kdump configuration, hosted-engine deploy, kernel options changes, etc.
// The host type defines additional parameters for the action.
// Example of installing a host, using `curl` and JSON, plain:
// [source,bash]
// ----
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123"
// ----
// Example of installing a host using `curl` and JSON with hosted engine components:
// [source,bash]
// ----
// curl \
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123?deploy_hosted_engine=true"
// ----
// IMPORTANT: Since version 4.1.2 of the engine, when a host is reinstalled we override the host firewall
// definitions by default.
//
type HostServiceInstallResponse struct {
}

//
// Installs the latest version of VDSM and related software on the host.
// The action also performs every configuration steps on the host which is done during adding host to the engine:
// kdump configuration, hosted-engine deploy, kernel options changes, etc.
// The host type defines additional parameters for the action.
// Example of installing a host, using `curl` and JSON, plain:
// [source,bash]
// ----
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123"
// ----
// Example of installing a host using `curl` and JSON with hosted engine components:
// [source,bash]
// ----
// curl \
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --request PUT \
// --header "Content-Type: application/json" \
// --header "Accept: application/json" \
// --header "Version: 4" \
// --user "admin@internal:..." \
// --data '
// {
//   "root_password": "myrootpassword"
// }
// ' \
// "https://engine.example.com/ovirt-engine/api/hosts/123?deploy_hosted_engine=true"
// ----
// IMPORTANT: Since version 4.1.2 of the engine, when a host is reinstalled we override the host firewall
// definitions by default.
//
func (p *HostService) Install() *HostServiceInstallRequest {
	return &HostServiceInstallRequest{HostService: p}
}

//
// Discovers iSCSI targets on the host, using the initiator details.
// For example, to discover iSCSI targets available in `myiscsi.example.com`,
// from host `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/iscsidiscover
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <iscsi>
//     <address>myiscsi.example.com</address>
//   </iscsi>
// </action>
// ----
// The result will be like this:
// [source,xml]
// ----
// <discovered_targets>
//   <iscsi_details>
//     <address>10.35.1.72</address>
//     <port>3260</port>
//     <portal>10.35.1.72:3260,1</portal>
//     <target>iqn.2015-08.com.tgt:444</target>
//   </iscsi_details>
// </discovered_targets>
// ----
//
type HostServiceIscsiDiscoverRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceIscsiDiscoverRequest) Header(key, value string) *HostServiceIscsiDiscoverRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceIscsiDiscoverRequest) Query(key, value string) *HostServiceIscsiDiscoverRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceIscsiDiscoverRequest) Async(async bool) *HostServiceIscsiDiscoverRequest {
	p.async = &async
	return p
}

func (p *HostServiceIscsiDiscoverRequest) Iscsi(iscsi *IscsiDetails) *HostServiceIscsiDiscoverRequest {
	p.iscsi = iscsi
	return p
}

func (p *HostServiceIscsiDiscoverRequest) Send() (*HostServiceIscsiDiscoverResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsidiscover", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustIscsiTargets()
	return &HostServiceIscsiDiscoverResponse{iscsiTargets: result}, nil
}

func (p *HostServiceIscsiDiscoverRequest) MustSend() *HostServiceIscsiDiscoverResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Discovers iSCSI targets on the host, using the initiator details.
// For example, to discover iSCSI targets available in `myiscsi.example.com`,
// from host `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/iscsidiscover
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <iscsi>
//     <address>myiscsi.example.com</address>
//   </iscsi>
// </action>
// ----
// The result will be like this:
// [source,xml]
// ----
// <discovered_targets>
//   <iscsi_details>
//     <address>10.35.1.72</address>
//     <port>3260</port>
//     <portal>10.35.1.72:3260,1</portal>
//     <target>iqn.2015-08.com.tgt:444</target>
//   </iscsi_details>
// </discovered_targets>
// ----
//
type HostServiceIscsiDiscoverResponse struct {
	discoveredTargets *IscsiDetailsSlice
	iscsiTargets      []string
}

func (p *HostServiceIscsiDiscoverResponse) DiscoveredTargets() (*IscsiDetailsSlice, bool) {
	if p.discoveredTargets != nil {
		return p.discoveredTargets, true
	}
	return nil, false
}

func (p *HostServiceIscsiDiscoverResponse) MustDiscoveredTargets() *IscsiDetailsSlice {
	if p.discoveredTargets == nil {
		panic("discoveredTargets in response does not exist")
	}
	return p.discoveredTargets
}

func (p *HostServiceIscsiDiscoverResponse) IscsiTargets() ([]string, bool) {
	if p.iscsiTargets != nil {
		return p.iscsiTargets, true
	}
	return nil, false
}

func (p *HostServiceIscsiDiscoverResponse) MustIscsiTargets() []string {
	if p.iscsiTargets == nil {
		panic("iscsiTargets in response does not exist")
	}
	return p.iscsiTargets
}

//
// Discovers iSCSI targets on the host, using the initiator details.
// For example, to discover iSCSI targets available in `myiscsi.example.com`,
// from host `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/iscsidiscover
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <iscsi>
//     <address>myiscsi.example.com</address>
//   </iscsi>
// </action>
// ----
// The result will be like this:
// [source,xml]
// ----
// <discovered_targets>
//   <iscsi_details>
//     <address>10.35.1.72</address>
//     <port>3260</port>
//     <portal>10.35.1.72:3260,1</portal>
//     <target>iqn.2015-08.com.tgt:444</target>
//   </iscsi_details>
// </discovered_targets>
// ----
//
func (p *HostService) IscsiDiscover() *HostServiceIscsiDiscoverRequest {
	return &HostServiceIscsiDiscoverRequest{HostService: p}
}

//
// Login to iSCSI targets on the host, using the target details.
//
type HostServiceIscsiLoginRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceIscsiLoginRequest) Header(key, value string) *HostServiceIscsiLoginRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceIscsiLoginRequest) Query(key, value string) *HostServiceIscsiLoginRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceIscsiLoginRequest) Async(async bool) *HostServiceIscsiLoginRequest {
	p.async = &async
	return p
}

func (p *HostServiceIscsiLoginRequest) Iscsi(iscsi *IscsiDetails) *HostServiceIscsiLoginRequest {
	p.iscsi = iscsi
	return p
}

func (p *HostServiceIscsiLoginRequest) Send() (*HostServiceIscsiLoginResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsilogin", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceIscsiLoginResponse), nil
}

func (p *HostServiceIscsiLoginRequest) MustSend() *HostServiceIscsiLoginResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Login to iSCSI targets on the host, using the target details.
//
type HostServiceIscsiLoginResponse struct {
}

//
// Login to iSCSI targets on the host, using the target details.
//
func (p *HostService) IscsiLogin() *HostServiceIscsiLoginRequest {
	return &HostServiceIscsiLoginRequest{HostService: p}
}

//
// Refresh the host devices and capabilities.
//
type HostServiceRefreshRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceRefreshRequest) Header(key, value string) *HostServiceRefreshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceRefreshRequest) Query(key, value string) *HostServiceRefreshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceRefreshRequest) Async(async bool) *HostServiceRefreshRequest {
	p.async = &async
	return p
}

func (p *HostServiceRefreshRequest) Send() (*HostServiceRefreshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refresh", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceRefreshResponse), nil
}

func (p *HostServiceRefreshRequest) MustSend() *HostServiceRefreshResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Refresh the host devices and capabilities.
//
type HostServiceRefreshResponse struct {
}

//
// Refresh the host devices and capabilities.
//
func (p *HostService) Refresh() *HostServiceRefreshRequest {
	return &HostServiceRefreshRequest{HostService: p}
}

//
// Remove the host from the system.
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request DELETE \
// --header "Version: 4" \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc"
// ----
//
type HostServiceRemoveRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	force       *bool
}

func (p *HostServiceRemoveRequest) Header(key, value string) *HostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceRemoveRequest) Query(key, value string) *HostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceRemoveRequest) Async(async bool) *HostServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *HostServiceRemoveRequest) Force(force bool) *HostServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *HostServiceRemoveRequest) Send() (*HostServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostService.connection.URL(), p.HostService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(HostServiceRemoveResponse), nil
}

func (p *HostServiceRemoveRequest) MustSend() *HostServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove the host from the system.
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request DELETE \
// --header "Version: 4" \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc"
// ----
//
type HostServiceRemoveResponse struct {
}

//
// Remove the host from the system.
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request DELETE \
// --header "Version: 4" \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc"
// ----
//
func (p *HostService) Remove() *HostServiceRemoveRequest {
	return &HostServiceRemoveRequest{HostService: p}
}

//
// This method is used to change the configuration of the network interfaces of a host.
// For example, if you have a host with three network interfaces `eth0`, `eth1` and `eth2` and you want to configure
// a new bond using `eth0` and `eth1`, and put a VLAN on top of it. Using a simple shell script and the `curl`
// command line HTTP client that can be done as follows:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <modified_bonds>
//     <host_nic>
//       <name>bond0</name>
//       <bonding>
//         <options>
//           <option>
//             <name>mode</name>
//             <value>4</value>
//           </option>
//           <option>
//             <name>miimon</name>
//             <value>100</value>
//           </option>
//         </options>
//         <slaves>
//           <host_nic>
//             <name>eth1</name>
//           </host_nic>
//           <host_nic>
//             <name>eth2</name>
//           </host_nic>
//         </slaves>
//       </bonding>
//     </host_nic>
//   </modified_bonds>
//   <modified_network_attachments>
//     <network_attachment>
//       <network>
//         <name>myvlan</name>
//       </network>
//       <host_nic>
//         <name>bond0</name>
//       </host_nic>
//       <ip_address_assignments>
//         <assignment_method>static</assignment_method>
//         <ip_address_assignment>
//           <ip>
//             <address>192.168.122.10</address>
//             <netmask>255.255.255.0</netmask>
//           </ip>
//         </ip_address_assignment>
//       </ip_address_assignments>
//       <dns_resolver_configuration>
//         <name_servers>
//           <name_server>1.1.1.1</name_server>
//           <name_server>2.2.2.2</name_server>
//         </name_servers>
//       </dns_resolver_configuration>
//     </network_attachment>
//   </modified_network_attachments>
//  </action>
// ' \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc/setupnetworks"
// ----
// NOTE: This is valid for version 4 of the API. In previous versions some elements were represented as XML
// attributes instead of XML elements. In particular the `options` and `ip` elements were represented as follows:
// [source,xml]
// ----
// <options name="mode" value="4"/>
// <options name="miimon" value="100"/>
// <ip address="192.168.122.10" netmask="255.255.255.0"/>
// ----
// The same thing can be done using the Python SDK with the following code:
// [source,python]
// ----
// # Find the service that manages the collection of hosts:
// hosts_service = connection.system_service().hosts_service()
// # Find the host:
// host = hosts_service.list(search='name=myhost')[0]
// # Find the service that manages the host:
// host_service = hosts_service.host_service(host.id)
// # Configure the network adding a bond with two slaves and attaching it to a
// # network with an static IP address:
// host_service.setup_networks(
//     modified_bonds=[
//         types.HostNic(
//             name='bond0',
//             bonding=types.Bonding(
//                 options=[
//                     types.Option(
//                         name='mode',
//                         value='4',
//                     ),
//                     types.Option(
//                         name='miimon',
//                         value='100',
//                     ),
//                 ],
//                 slaves=[
//                     types.HostNic(
//                         name='eth1',
//                     ),
//                     types.HostNic(
//                         name='eth2',
//                     ),
//                 ],
//             ),
//         ),
//     ],
//     modified_network_attachments=[
//         types.NetworkAttachment(
//             network=types.Network(
//                 name='myvlan',
//             ),
//             host_nic=types.HostNic(
//                 name='bond0',
//             ),
//             ip_address_assignments=[
//                 types.IpAddressAssignment(
//                     assignment_method=types.BootProtocol.STATIC,
//                     ip=types.Ip(
//                         address='192.168.122.10',
//                         netmask='255.255.255.0',
//                     ),
//                 ),
//             ],
//             dns_resolver_configuration=types.DnsResolverConfiguration(
//                 name_servers=[
//                     '1.1.1.1',
//                     '2.2.2.2',
//                 ],
//             ),
//         ),
//     ],
// )
// # After modifying the network configuration it is very important to make it
// # persistent:
// host_service.commit_net_config()
// ----
// IMPORTANT: To make sure that the network configuration has been saved in the host, and that it will be applied
// when the host is rebooted, remember to call <<services/host/methods/commit_net_config, commitnetconfig>>.
// IMPORTANT: Since {engine-name} 4.3, it is possible to also specify `commit_on_success` in
// the <<services/host/methods/setup_networks, setupnetworks>> request, in which case the new
// configuration is automatically saved in the {hypervisor-name} upon completing the setup and
// re-establishing connectivity between the {hypervisor-name} and {engine-name}, and without
// waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>> request.
//
type HostServiceSetupNetworksRequest struct {
	HostService                    *HostService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	checkConnectivity              *bool
	commitOnSuccess                *bool
	connectivityTimeout            *int64
	modifiedBonds                  *HostNicSlice
	modifiedLabels                 *NetworkLabelSlice
	modifiedNetworkAttachments     *NetworkAttachmentSlice
	removedBonds                   *HostNicSlice
	removedLabels                  *NetworkLabelSlice
	removedNetworkAttachments      *NetworkAttachmentSlice
	synchronizedNetworkAttachments *NetworkAttachmentSlice
}

func (p *HostServiceSetupNetworksRequest) Header(key, value string) *HostServiceSetupNetworksRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceSetupNetworksRequest) Query(key, value string) *HostServiceSetupNetworksRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceSetupNetworksRequest) Async(async bool) *HostServiceSetupNetworksRequest {
	p.async = &async
	return p
}

func (p *HostServiceSetupNetworksRequest) CheckConnectivity(checkConnectivity bool) *HostServiceSetupNetworksRequest {
	p.checkConnectivity = &checkConnectivity
	return p
}

func (p *HostServiceSetupNetworksRequest) CommitOnSuccess(commitOnSuccess bool) *HostServiceSetupNetworksRequest {
	p.commitOnSuccess = &commitOnSuccess
	return p
}

func (p *HostServiceSetupNetworksRequest) ConnectivityTimeout(connectivityTimeout int64) *HostServiceSetupNetworksRequest {
	p.connectivityTimeout = &connectivityTimeout
	return p
}

func (p *HostServiceSetupNetworksRequest) ModifiedBonds(modifiedBonds *HostNicSlice) *HostServiceSetupNetworksRequest {
	p.modifiedBonds = modifiedBonds
	return p
}

func (p *HostServiceSetupNetworksRequest) ModifiedBondsOfAny(anys ...*HostNic) *HostServiceSetupNetworksRequest {
	if p.modifiedBonds == nil {
		p.modifiedBonds = new(HostNicSlice)
	}
	p.modifiedBonds.slice = append(p.modifiedBonds.slice, anys...)
	return p
}

func (p *HostServiceSetupNetworksRequest) ModifiedLabels(modifiedLabels *NetworkLabelSlice) *HostServiceSetupNetworksRequest {
	p.modifiedLabels = modifiedLabels
	return p
}

func (p *HostServiceSetupNetworksRequest) ModifiedLabelsOfAny(anys ...*NetworkLabel) *HostServiceSetupNetworksRequest {
	if p.modifiedLabels == nil {
		p.modifiedLabels = new(NetworkLabelSlice)
	}
	p.modifiedLabels.slice = append(p.modifiedLabels.slice, anys...)
	return p
}

func (p *HostServiceSetupNetworksRequest) ModifiedNetworkAttachments(modifiedNetworkAttachments *NetworkAttachmentSlice) *HostServiceSetupNetworksRequest {
	p.modifiedNetworkAttachments = modifiedNetworkAttachments
	return p
}

func (p *HostServiceSetupNetworksRequest) ModifiedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *HostServiceSetupNetworksRequest {
	if p.modifiedNetworkAttachments == nil {
		p.modifiedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	p.modifiedNetworkAttachments.slice = append(p.modifiedNetworkAttachments.slice, anys...)
	return p
}

func (p *HostServiceSetupNetworksRequest) RemovedBonds(removedBonds *HostNicSlice) *HostServiceSetupNetworksRequest {
	p.removedBonds = removedBonds
	return p
}

func (p *HostServiceSetupNetworksRequest) RemovedBondsOfAny(anys ...*HostNic) *HostServiceSetupNetworksRequest {
	if p.removedBonds == nil {
		p.removedBonds = new(HostNicSlice)
	}
	p.removedBonds.slice = append(p.removedBonds.slice, anys...)
	return p
}

func (p *HostServiceSetupNetworksRequest) RemovedLabels(removedLabels *NetworkLabelSlice) *HostServiceSetupNetworksRequest {
	p.removedLabels = removedLabels
	return p
}

func (p *HostServiceSetupNetworksRequest) RemovedLabelsOfAny(anys ...*NetworkLabel) *HostServiceSetupNetworksRequest {
	if p.removedLabels == nil {
		p.removedLabels = new(NetworkLabelSlice)
	}
	p.removedLabels.slice = append(p.removedLabels.slice, anys...)
	return p
}

func (p *HostServiceSetupNetworksRequest) RemovedNetworkAttachments(removedNetworkAttachments *NetworkAttachmentSlice) *HostServiceSetupNetworksRequest {
	p.removedNetworkAttachments = removedNetworkAttachments
	return p
}

func (p *HostServiceSetupNetworksRequest) RemovedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *HostServiceSetupNetworksRequest {
	if p.removedNetworkAttachments == nil {
		p.removedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	p.removedNetworkAttachments.slice = append(p.removedNetworkAttachments.slice, anys...)
	return p
}

func (p *HostServiceSetupNetworksRequest) SynchronizedNetworkAttachments(synchronizedNetworkAttachments *NetworkAttachmentSlice) *HostServiceSetupNetworksRequest {
	p.synchronizedNetworkAttachments = synchronizedNetworkAttachments
	return p
}

func (p *HostServiceSetupNetworksRequest) SynchronizedNetworkAttachmentsOfAny(anys ...*NetworkAttachment) *HostServiceSetupNetworksRequest {
	if p.synchronizedNetworkAttachments == nil {
		p.synchronizedNetworkAttachments = new(NetworkAttachmentSlice)
	}
	p.synchronizedNetworkAttachments.slice = append(p.synchronizedNetworkAttachments.slice, anys...)
	return p
}

func (p *HostServiceSetupNetworksRequest) Send() (*HostServiceSetupNetworksResponse, error) {
	rawURL := fmt.Sprintf("%s%s/setupnetworks", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.checkConnectivity != nil {
		actionBuilder.CheckConnectivity(*p.checkConnectivity)
	}
	if p.commitOnSuccess != nil {
		actionBuilder.CommitOnSuccess(*p.commitOnSuccess)
	}
	if p.connectivityTimeout != nil {
		actionBuilder.ConnectivityTimeout(*p.connectivityTimeout)
	}
	actionBuilder.ModifiedBonds(p.modifiedBonds)
	actionBuilder.ModifiedLabels(p.modifiedLabels)
	actionBuilder.ModifiedNetworkAttachments(p.modifiedNetworkAttachments)
	actionBuilder.RemovedBonds(p.removedBonds)
	actionBuilder.RemovedLabels(p.removedLabels)
	actionBuilder.RemovedNetworkAttachments(p.removedNetworkAttachments)
	actionBuilder.SynchronizedNetworkAttachments(p.synchronizedNetworkAttachments)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceSetupNetworksResponse), nil
}

func (p *HostServiceSetupNetworksRequest) MustSend() *HostServiceSetupNetworksResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This method is used to change the configuration of the network interfaces of a host.
// For example, if you have a host with three network interfaces `eth0`, `eth1` and `eth2` and you want to configure
// a new bond using `eth0` and `eth1`, and put a VLAN on top of it. Using a simple shell script and the `curl`
// command line HTTP client that can be done as follows:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <modified_bonds>
//     <host_nic>
//       <name>bond0</name>
//       <bonding>
//         <options>
//           <option>
//             <name>mode</name>
//             <value>4</value>
//           </option>
//           <option>
//             <name>miimon</name>
//             <value>100</value>
//           </option>
//         </options>
//         <slaves>
//           <host_nic>
//             <name>eth1</name>
//           </host_nic>
//           <host_nic>
//             <name>eth2</name>
//           </host_nic>
//         </slaves>
//       </bonding>
//     </host_nic>
//   </modified_bonds>
//   <modified_network_attachments>
//     <network_attachment>
//       <network>
//         <name>myvlan</name>
//       </network>
//       <host_nic>
//         <name>bond0</name>
//       </host_nic>
//       <ip_address_assignments>
//         <assignment_method>static</assignment_method>
//         <ip_address_assignment>
//           <ip>
//             <address>192.168.122.10</address>
//             <netmask>255.255.255.0</netmask>
//           </ip>
//         </ip_address_assignment>
//       </ip_address_assignments>
//       <dns_resolver_configuration>
//         <name_servers>
//           <name_server>1.1.1.1</name_server>
//           <name_server>2.2.2.2</name_server>
//         </name_servers>
//       </dns_resolver_configuration>
//     </network_attachment>
//   </modified_network_attachments>
//  </action>
// ' \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc/setupnetworks"
// ----
// NOTE: This is valid for version 4 of the API. In previous versions some elements were represented as XML
// attributes instead of XML elements. In particular the `options` and `ip` elements were represented as follows:
// [source,xml]
// ----
// <options name="mode" value="4"/>
// <options name="miimon" value="100"/>
// <ip address="192.168.122.10" netmask="255.255.255.0"/>
// ----
// The same thing can be done using the Python SDK with the following code:
// [source,python]
// ----
// # Find the service that manages the collection of hosts:
// hosts_service = connection.system_service().hosts_service()
// # Find the host:
// host = hosts_service.list(search='name=myhost')[0]
// # Find the service that manages the host:
// host_service = hosts_service.host_service(host.id)
// # Configure the network adding a bond with two slaves and attaching it to a
// # network with an static IP address:
// host_service.setup_networks(
//     modified_bonds=[
//         types.HostNic(
//             name='bond0',
//             bonding=types.Bonding(
//                 options=[
//                     types.Option(
//                         name='mode',
//                         value='4',
//                     ),
//                     types.Option(
//                         name='miimon',
//                         value='100',
//                     ),
//                 ],
//                 slaves=[
//                     types.HostNic(
//                         name='eth1',
//                     ),
//                     types.HostNic(
//                         name='eth2',
//                     ),
//                 ],
//             ),
//         ),
//     ],
//     modified_network_attachments=[
//         types.NetworkAttachment(
//             network=types.Network(
//                 name='myvlan',
//             ),
//             host_nic=types.HostNic(
//                 name='bond0',
//             ),
//             ip_address_assignments=[
//                 types.IpAddressAssignment(
//                     assignment_method=types.BootProtocol.STATIC,
//                     ip=types.Ip(
//                         address='192.168.122.10',
//                         netmask='255.255.255.0',
//                     ),
//                 ),
//             ],
//             dns_resolver_configuration=types.DnsResolverConfiguration(
//                 name_servers=[
//                     '1.1.1.1',
//                     '2.2.2.2',
//                 ],
//             ),
//         ),
//     ],
// )
// # After modifying the network configuration it is very important to make it
// # persistent:
// host_service.commit_net_config()
// ----
// IMPORTANT: To make sure that the network configuration has been saved in the host, and that it will be applied
// when the host is rebooted, remember to call <<services/host/methods/commit_net_config, commitnetconfig>>.
// IMPORTANT: Since {engine-name} 4.3, it is possible to also specify `commit_on_success` in
// the <<services/host/methods/setup_networks, setupnetworks>> request, in which case the new
// configuration is automatically saved in the {hypervisor-name} upon completing the setup and
// re-establishing connectivity between the {hypervisor-name} and {engine-name}, and without
// waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>> request.
//
type HostServiceSetupNetworksResponse struct {
}

//
// This method is used to change the configuration of the network interfaces of a host.
// For example, if you have a host with three network interfaces `eth0`, `eth1` and `eth2` and you want to configure
// a new bond using `eth0` and `eth1`, and put a VLAN on top of it. Using a simple shell script and the `curl`
// command line HTTP client that can be done as follows:
// [source]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <action>
//   <modified_bonds>
//     <host_nic>
//       <name>bond0</name>
//       <bonding>
//         <options>
//           <option>
//             <name>mode</name>
//             <value>4</value>
//           </option>
//           <option>
//             <name>miimon</name>
//             <value>100</value>
//           </option>
//         </options>
//         <slaves>
//           <host_nic>
//             <name>eth1</name>
//           </host_nic>
//           <host_nic>
//             <name>eth2</name>
//           </host_nic>
//         </slaves>
//       </bonding>
//     </host_nic>
//   </modified_bonds>
//   <modified_network_attachments>
//     <network_attachment>
//       <network>
//         <name>myvlan</name>
//       </network>
//       <host_nic>
//         <name>bond0</name>
//       </host_nic>
//       <ip_address_assignments>
//         <assignment_method>static</assignment_method>
//         <ip_address_assignment>
//           <ip>
//             <address>192.168.122.10</address>
//             <netmask>255.255.255.0</netmask>
//           </ip>
//         </ip_address_assignment>
//       </ip_address_assignments>
//       <dns_resolver_configuration>
//         <name_servers>
//           <name_server>1.1.1.1</name_server>
//           <name_server>2.2.2.2</name_server>
//         </name_servers>
//       </dns_resolver_configuration>
//     </network_attachment>
//   </modified_network_attachments>
//  </action>
// ' \
// "${url}/hosts/1ff7a191-2f3b-4eff-812b-9f91a30c3acc/setupnetworks"
// ----
// NOTE: This is valid for version 4 of the API. In previous versions some elements were represented as XML
// attributes instead of XML elements. In particular the `options` and `ip` elements were represented as follows:
// [source,xml]
// ----
// <options name="mode" value="4"/>
// <options name="miimon" value="100"/>
// <ip address="192.168.122.10" netmask="255.255.255.0"/>
// ----
// The same thing can be done using the Python SDK with the following code:
// [source,python]
// ----
// # Find the service that manages the collection of hosts:
// hosts_service = connection.system_service().hosts_service()
// # Find the host:
// host = hosts_service.list(search='name=myhost')[0]
// # Find the service that manages the host:
// host_service = hosts_service.host_service(host.id)
// # Configure the network adding a bond with two slaves and attaching it to a
// # network with an static IP address:
// host_service.setup_networks(
//     modified_bonds=[
//         types.HostNic(
//             name='bond0',
//             bonding=types.Bonding(
//                 options=[
//                     types.Option(
//                         name='mode',
//                         value='4',
//                     ),
//                     types.Option(
//                         name='miimon',
//                         value='100',
//                     ),
//                 ],
//                 slaves=[
//                     types.HostNic(
//                         name='eth1',
//                     ),
//                     types.HostNic(
//                         name='eth2',
//                     ),
//                 ],
//             ),
//         ),
//     ],
//     modified_network_attachments=[
//         types.NetworkAttachment(
//             network=types.Network(
//                 name='myvlan',
//             ),
//             host_nic=types.HostNic(
//                 name='bond0',
//             ),
//             ip_address_assignments=[
//                 types.IpAddressAssignment(
//                     assignment_method=types.BootProtocol.STATIC,
//                     ip=types.Ip(
//                         address='192.168.122.10',
//                         netmask='255.255.255.0',
//                     ),
//                 ),
//             ],
//             dns_resolver_configuration=types.DnsResolverConfiguration(
//                 name_servers=[
//                     '1.1.1.1',
//                     '2.2.2.2',
//                 ],
//             ),
//         ),
//     ],
// )
// # After modifying the network configuration it is very important to make it
// # persistent:
// host_service.commit_net_config()
// ----
// IMPORTANT: To make sure that the network configuration has been saved in the host, and that it will be applied
// when the host is rebooted, remember to call <<services/host/methods/commit_net_config, commitnetconfig>>.
// IMPORTANT: Since {engine-name} 4.3, it is possible to also specify `commit_on_success` in
// the <<services/host/methods/setup_networks, setupnetworks>> request, in which case the new
// configuration is automatically saved in the {hypervisor-name} upon completing the setup and
// re-establishing connectivity between the {hypervisor-name} and {engine-name}, and without
// waiting for a separate <<services/host/methods/commit_net_config, commitnetconfig>> request.
//
func (p *HostService) SetupNetworks() *HostServiceSetupNetworksRequest {
	return &HostServiceSetupNetworksRequest{HostService: p}
}

//
// To synchronize all networks on the host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type HostServiceSyncAllNetworksRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *HostServiceSyncAllNetworksRequest) Header(key, value string) *HostServiceSyncAllNetworksRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceSyncAllNetworksRequest) Query(key, value string) *HostServiceSyncAllNetworksRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceSyncAllNetworksRequest) Async(async bool) *HostServiceSyncAllNetworksRequest {
	p.async = &async
	return p
}

func (p *HostServiceSyncAllNetworksRequest) Send() (*HostServiceSyncAllNetworksResponse, error) {
	rawURL := fmt.Sprintf("%s%s/syncallnetworks", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceSyncAllNetworksResponse), nil
}

func (p *HostServiceSyncAllNetworksRequest) MustSend() *HostServiceSyncAllNetworksResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// To synchronize all networks on the host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type HostServiceSyncAllNetworksResponse struct {
}

//
// To synchronize all networks on the host, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *HostService) SyncAllNetworks() *HostServiceSyncAllNetworksRequest {
	return &HostServiceSyncAllNetworksRequest{HostService: p}
}

//
// Discovers the block Storage Domains which are candidates to be imported to the setup. For FCP no arguments are
// required.
//
type HostServiceUnregisteredStorageDomainsDiscoverRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	iscsi       *IscsiDetails
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Header(key, value string) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Query(key, value string) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Async(async bool) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	p.async = &async
	return p
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Iscsi(iscsi *IscsiDetails) *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	p.iscsi = iscsi
	return p
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) Send() (*HostServiceUnregisteredStorageDomainsDiscoverResponse, error) {
	rawURL := fmt.Sprintf("%s%s/unregisteredstoragedomainsdiscover", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Iscsi(p.iscsi)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustStorageDomains()
	return &HostServiceUnregisteredStorageDomainsDiscoverResponse{storageDomains: result}, nil
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverRequest) MustSend() *HostServiceUnregisteredStorageDomainsDiscoverResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Discovers the block Storage Domains which are candidates to be imported to the setup. For FCP no arguments are
// required.
//
type HostServiceUnregisteredStorageDomainsDiscoverResponse struct {
	storageDomains *StorageDomainSlice
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverResponse) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *HostServiceUnregisteredStorageDomainsDiscoverResponse) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("storageDomains in response does not exist")
	}
	return p.storageDomains
}

//
// Discovers the block Storage Domains which are candidates to be imported to the setup. For FCP no arguments are
// required.
//
func (p *HostService) UnregisteredStorageDomainsDiscover() *HostServiceUnregisteredStorageDomainsDiscoverRequest {
	return &HostServiceUnregisteredStorageDomainsDiscoverRequest{HostService: p}
}

//
// Update the host properties.
// For example, to update a the kernel command line of a host send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123
// ----
// With request body like this:
// [source, xml]
// ----
// <host>
//   <os>
//     <custom_kernel_cmdline>vfio_iommu_type1.allow_unsafe_interrupts=1</custom_kernel_cmdline>
//   </os>
// </host>
// ----
//
type HostServiceUpdateRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	host        *Host
}

func (p *HostServiceUpdateRequest) Header(key, value string) *HostServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpdateRequest) Query(key, value string) *HostServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpdateRequest) Async(async bool) *HostServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *HostServiceUpdateRequest) Host(host *Host) *HostServiceUpdateRequest {
	p.host = host
	return p
}

func (p *HostServiceUpdateRequest) Send() (*HostServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostService.connection.URL(), p.HostService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &HostServiceUpdateResponse{host: result}, nil
}

func (p *HostServiceUpdateRequest) MustSend() *HostServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the host properties.
// For example, to update a the kernel command line of a host send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123
// ----
// With request body like this:
// [source, xml]
// ----
// <host>
//   <os>
//     <custom_kernel_cmdline>vfio_iommu_type1.allow_unsafe_interrupts=1</custom_kernel_cmdline>
//   </os>
// </host>
// ----
//
type HostServiceUpdateResponse struct {
	host *Host
}

func (p *HostServiceUpdateResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *HostServiceUpdateResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Update the host properties.
// For example, to update a the kernel command line of a host send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/hosts/123
// ----
// With request body like this:
// [source, xml]
// ----
// <host>
//   <os>
//     <custom_kernel_cmdline>vfio_iommu_type1.allow_unsafe_interrupts=1</custom_kernel_cmdline>
//   </os>
// </host>
// ----
//
func (p *HostService) Update() *HostServiceUpdateRequest {
	return &HostServiceUpdateRequest{HostService: p}
}

//
// Upgrades VDSM and selected software on the host.
//
type HostServiceUpgradeRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	image       *string
	reboot      *bool
	timeout     *int64
}

func (p *HostServiceUpgradeRequest) Header(key, value string) *HostServiceUpgradeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpgradeRequest) Query(key, value string) *HostServiceUpgradeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpgradeRequest) Async(async bool) *HostServiceUpgradeRequest {
	p.async = &async
	return p
}

func (p *HostServiceUpgradeRequest) Image(image string) *HostServiceUpgradeRequest {
	p.image = &image
	return p
}

func (p *HostServiceUpgradeRequest) Reboot(reboot bool) *HostServiceUpgradeRequest {
	p.reboot = &reboot
	return p
}

func (p *HostServiceUpgradeRequest) Timeout(timeout int64) *HostServiceUpgradeRequest {
	p.timeout = &timeout
	return p
}

func (p *HostServiceUpgradeRequest) Send() (*HostServiceUpgradeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/upgrade", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.reboot != nil {
		actionBuilder.Reboot(*p.reboot)
	}
	if p.timeout != nil {
		actionBuilder.Timeout(*p.timeout)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceUpgradeResponse), nil
}

func (p *HostServiceUpgradeRequest) MustSend() *HostServiceUpgradeResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Upgrades VDSM and selected software on the host.
//
type HostServiceUpgradeResponse struct {
}

//
// Upgrades VDSM and selected software on the host.
//
func (p *HostService) Upgrade() *HostServiceUpgradeRequest {
	return &HostServiceUpgradeRequest{HostService: p}
}

//
// Check if there are upgrades available for the host. If there are upgrades available an icon will be displayed
// next to host status icon in the Administration Portal. Audit log messages are also added to indicate the
// availability of upgrades. The upgrade can be started from the webadmin or by using the
// <<services/host/methods/upgrade, upgrade>> host action.
//
type HostServiceUpgradeCheckRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
}

func (p *HostServiceUpgradeCheckRequest) Header(key, value string) *HostServiceUpgradeCheckRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpgradeCheckRequest) Query(key, value string) *HostServiceUpgradeCheckRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpgradeCheckRequest) Send() (*HostServiceUpgradeCheckResponse, error) {
	rawURL := fmt.Sprintf("%s%s/upgradecheck", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceUpgradeCheckResponse), nil
}

func (p *HostServiceUpgradeCheckRequest) MustSend() *HostServiceUpgradeCheckResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Check if there are upgrades available for the host. If there are upgrades available an icon will be displayed
// next to host status icon in the Administration Portal. Audit log messages are also added to indicate the
// availability of upgrades. The upgrade can be started from the webadmin or by using the
// <<services/host/methods/upgrade, upgrade>> host action.
//
type HostServiceUpgradeCheckResponse struct {
}

//
// Check if there are upgrades available for the host. If there are upgrades available an icon will be displayed
// next to host status icon in the Administration Portal. Audit log messages are also added to indicate the
// availability of upgrades. The upgrade can be started from the webadmin or by using the
// <<services/host/methods/upgrade, upgrade>> host action.
//
func (p *HostService) UpgradeCheck() *HostServiceUpgradeCheckRequest {
	return &HostServiceUpgradeCheckRequest{HostService: p}
}

//
//
type HostServiceApproveUsingRootPasswordRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	activate    *bool
	async       *bool
	cluster     *Cluster
	host        *Host
}

func (p *HostServiceApproveUsingRootPasswordRequest) Header(key, value string) *HostServiceApproveUsingRootPasswordRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceApproveUsingRootPasswordRequest) Query(key, value string) *HostServiceApproveUsingRootPasswordRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceApproveUsingRootPasswordRequest) Activate(activate bool) *HostServiceApproveUsingRootPasswordRequest {
	p.activate = &activate
	return p
}

func (p *HostServiceApproveUsingRootPasswordRequest) Async(async bool) *HostServiceApproveUsingRootPasswordRequest {
	p.async = &async
	return p
}

func (p *HostServiceApproveUsingRootPasswordRequest) Cluster(cluster *Cluster) *HostServiceApproveUsingRootPasswordRequest {
	p.cluster = cluster
	return p
}

func (p *HostServiceApproveUsingRootPasswordRequest) Host(host *Host) *HostServiceApproveUsingRootPasswordRequest {
	p.host = host
	return p
}

func (p *HostServiceApproveUsingRootPasswordRequest) Send() (*HostServiceApproveUsingRootPasswordResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.activate != nil {
		actionBuilder.Activate(*p.activate)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceApproveUsingRootPasswordResponse), nil
}

func (p *HostServiceApproveUsingRootPasswordRequest) MustSend() *HostServiceApproveUsingRootPasswordResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type HostServiceApproveUsingRootPasswordResponse struct {
}

//
//
func (p *HostService) ApproveUsingRootPassword() *HostServiceApproveUsingRootPasswordRequest {
	return &HostServiceApproveUsingRootPasswordRequest{HostService: p}
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the root
// password. This has been deprecated.
//
type HostServiceInstallUsingRootPasswordRequest struct {
	HostService          *HostService
	header               map[string]string
	query                map[string]string
	activate             *bool
	async                *bool
	deployHostedEngine   *bool
	host                 *Host
	image                *string
	rootPassword         *string
	ssh                  *Ssh
	undeployHostedEngine *bool
}

func (p *HostServiceInstallUsingRootPasswordRequest) Header(key, value string) *HostServiceInstallUsingRootPasswordRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) Query(key, value string) *HostServiceInstallUsingRootPasswordRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) Activate(activate bool) *HostServiceInstallUsingRootPasswordRequest {
	p.activate = &activate
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) Async(async bool) *HostServiceInstallUsingRootPasswordRequest {
	p.async = &async
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) DeployHostedEngine(deployHostedEngine bool) *HostServiceInstallUsingRootPasswordRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) Host(host *Host) *HostServiceInstallUsingRootPasswordRequest {
	p.host = host
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) Image(image string) *HostServiceInstallUsingRootPasswordRequest {
	p.image = &image
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) RootPassword(rootPassword string) *HostServiceInstallUsingRootPasswordRequest {
	p.rootPassword = &rootPassword
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) Ssh(ssh *Ssh) *HostServiceInstallUsingRootPasswordRequest {
	p.ssh = ssh
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostServiceInstallUsingRootPasswordRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *HostServiceInstallUsingRootPasswordRequest) Send() (*HostServiceInstallUsingRootPasswordResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.activate != nil {
		actionBuilder.Activate(*p.activate)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceInstallUsingRootPasswordResponse), nil
}

func (p *HostServiceInstallUsingRootPasswordRequest) MustSend() *HostServiceInstallUsingRootPasswordResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the root
// password. This has been deprecated.
//
type HostServiceInstallUsingRootPasswordResponse struct {
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the root
// password. This has been deprecated.
//
func (p *HostService) InstallUsingRootPassword() *HostServiceInstallUsingRootPasswordRequest {
	return &HostServiceInstallUsingRootPasswordRequest{HostService: p}
}

//
// Update the specified host in the system. This is deprecated and is provided only for backwards compatibility.
//
type HostServiceUpdateUsingRootPasswordRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	host        *Host
}

func (p *HostServiceUpdateUsingRootPasswordRequest) Header(key, value string) *HostServiceUpdateUsingRootPasswordRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpdateUsingRootPasswordRequest) Query(key, value string) *HostServiceUpdateUsingRootPasswordRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpdateUsingRootPasswordRequest) Async(async bool) *HostServiceUpdateUsingRootPasswordRequest {
	p.async = &async
	return p
}

func (p *HostServiceUpdateUsingRootPasswordRequest) Host(host *Host) *HostServiceUpdateUsingRootPasswordRequest {
	p.host = host
	return p
}

func (p *HostServiceUpdateUsingRootPasswordRequest) Send() (*HostServiceUpdateUsingRootPasswordResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustHost()
	return &HostServiceUpdateUsingRootPasswordResponse{host: result}, nil
}

func (p *HostServiceUpdateUsingRootPasswordRequest) MustSend() *HostServiceUpdateUsingRootPasswordResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified host in the system. This is deprecated and is provided only for backwards compatibility.
//
type HostServiceUpdateUsingRootPasswordResponse struct {
	host *Host
}

func (p *HostServiceUpdateUsingRootPasswordResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *HostServiceUpdateUsingRootPasswordResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Update the specified host in the system. This is deprecated and is provided only for backwards compatibility.
//
func (p *HostService) UpdateUsingRootPassword() *HostServiceUpdateUsingRootPasswordRequest {
	return &HostServiceUpdateUsingRootPasswordRequest{HostService: p}
}

//
// Approve the specified host to be added to the engine by using ssh authentication. This occurs when the host
// registers itself with the engine.
//
type HostServiceApproveUsingSshRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	activate    *bool
	async       *bool
	cluster     *Cluster
	host        *Host
}

func (p *HostServiceApproveUsingSshRequest) Header(key, value string) *HostServiceApproveUsingSshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceApproveUsingSshRequest) Query(key, value string) *HostServiceApproveUsingSshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceApproveUsingSshRequest) Activate(activate bool) *HostServiceApproveUsingSshRequest {
	p.activate = &activate
	return p
}

func (p *HostServiceApproveUsingSshRequest) Async(async bool) *HostServiceApproveUsingSshRequest {
	p.async = &async
	return p
}

func (p *HostServiceApproveUsingSshRequest) Cluster(cluster *Cluster) *HostServiceApproveUsingSshRequest {
	p.cluster = cluster
	return p
}

func (p *HostServiceApproveUsingSshRequest) Host(host *Host) *HostServiceApproveUsingSshRequest {
	p.host = host
	return p
}

func (p *HostServiceApproveUsingSshRequest) Send() (*HostServiceApproveUsingSshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.activate != nil {
		actionBuilder.Activate(*p.activate)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceApproveUsingSshResponse), nil
}

func (p *HostServiceApproveUsingSshRequest) MustSend() *HostServiceApproveUsingSshResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Approve the specified host to be added to the engine by using ssh authentication. This occurs when the host
// registers itself with the engine.
//
type HostServiceApproveUsingSshResponse struct {
}

//
// Approve the specified host to be added to the engine by using ssh authentication. This occurs when the host
// registers itself with the engine.
//
func (p *HostService) ApproveUsingSsh() *HostServiceApproveUsingSshRequest {
	return &HostServiceApproveUsingSshRequest{HostService: p}
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the SSH
// password.
//
type HostServiceInstallUsingSshRequest struct {
	HostService          *HostService
	header               map[string]string
	query                map[string]string
	activate             *bool
	async                *bool
	deployHostedEngine   *bool
	host                 *Host
	image                *string
	rootPassword         *string
	ssh                  *Ssh
	undeployHostedEngine *bool
}

func (p *HostServiceInstallUsingSshRequest) Header(key, value string) *HostServiceInstallUsingSshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceInstallUsingSshRequest) Query(key, value string) *HostServiceInstallUsingSshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceInstallUsingSshRequest) Activate(activate bool) *HostServiceInstallUsingSshRequest {
	p.activate = &activate
	return p
}

func (p *HostServiceInstallUsingSshRequest) Async(async bool) *HostServiceInstallUsingSshRequest {
	p.async = &async
	return p
}

func (p *HostServiceInstallUsingSshRequest) DeployHostedEngine(deployHostedEngine bool) *HostServiceInstallUsingSshRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *HostServiceInstallUsingSshRequest) Host(host *Host) *HostServiceInstallUsingSshRequest {
	p.host = host
	return p
}

func (p *HostServiceInstallUsingSshRequest) Image(image string) *HostServiceInstallUsingSshRequest {
	p.image = &image
	return p
}

func (p *HostServiceInstallUsingSshRequest) RootPassword(rootPassword string) *HostServiceInstallUsingSshRequest {
	p.rootPassword = &rootPassword
	return p
}

func (p *HostServiceInstallUsingSshRequest) Ssh(ssh *Ssh) *HostServiceInstallUsingSshRequest {
	p.ssh = ssh
	return p
}

func (p *HostServiceInstallUsingSshRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostServiceInstallUsingSshRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *HostServiceInstallUsingSshRequest) Send() (*HostServiceInstallUsingSshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.activate != nil {
		actionBuilder.Activate(*p.activate)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.image != nil {
		actionBuilder.Image(*p.image)
	}
	if p.rootPassword != nil {
		actionBuilder.RootPassword(*p.rootPassword)
	}
	actionBuilder.Ssh(p.ssh)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(HostServiceInstallUsingSshResponse), nil
}

func (p *HostServiceInstallUsingSshRequest) MustSend() *HostServiceInstallUsingSshResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the SSH
// password.
//
type HostServiceInstallUsingSshResponse struct {
}

//
// Install VDSM and other packages required to get the host ready to be used in the engine providing the SSH
// password.
//
func (p *HostService) InstallUsingSsh() *HostServiceInstallUsingSshRequest {
	return &HostServiceInstallUsingSshRequest{HostService: p}
}

//
// Updates the specified host in the system.
//
type HostServiceUpdateUsingSshRequest struct {
	HostService *HostService
	header      map[string]string
	query       map[string]string
	async       *bool
	host        *Host
}

func (p *HostServiceUpdateUsingSshRequest) Header(key, value string) *HostServiceUpdateUsingSshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostServiceUpdateUsingSshRequest) Query(key, value string) *HostServiceUpdateUsingSshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostServiceUpdateUsingSshRequest) Async(async bool) *HostServiceUpdateUsingSshRequest {
	p.async = &async
	return p
}

func (p *HostServiceUpdateUsingSshRequest) Host(host *Host) *HostServiceUpdateUsingSshRequest {
	p.host = host
	return p
}

func (p *HostServiceUpdateUsingSshRequest) Send() (*HostServiceUpdateUsingSshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.HostService.connection.URL(), p.HostService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustHost()
	return &HostServiceUpdateUsingSshResponse{host: result}, nil
}

func (p *HostServiceUpdateUsingSshRequest) MustSend() *HostServiceUpdateUsingSshResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the specified host in the system.
//
type HostServiceUpdateUsingSshResponse struct {
	host *Host
}

func (p *HostServiceUpdateUsingSshResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *HostServiceUpdateUsingSshResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Updates the specified host in the system.
//
func (p *HostService) UpdateUsingSsh() *HostServiceUpdateUsingSshRequest {
	return &HostServiceUpdateUsingSshRequest{HostService: p}
}

//
// List of scheduling labels assigned to this host.
//
func (op *HostService) AffinityLabelsService() *AssignedAffinityLabelsService {
	return NewAssignedAffinityLabelsService(op.connection, fmt.Sprintf("%s/affinitylabels", op.path))
}

//
// A reference to the host devices service. Use this service to view the devices of the host object.
//
func (op *HostService) DevicesService() *HostDevicesService {
	return NewHostDevicesService(op.connection, fmt.Sprintf("%s/devices", op.path))
}

//
// External network providers provisioned by the system on the host.
//
func (op *HostService) ExternalNetworkProviderConfigurationsService() *ExternalNetworkProviderConfigurationsService {
	return NewExternalNetworkProviderConfigurationsService(op.connection, fmt.Sprintf("%s/externalnetworkproviderconfigurations", op.path))
}

//
// A reference to the fence agents service. Use this service to manage fence and power management agents on the host
// object.
//
func (op *HostService) FenceAgentsService() *FenceAgentsService {
	return NewFenceAgentsService(op.connection, fmt.Sprintf("%s/fenceagents", op.path))
}

//
// A reference to the host hooks service. Use this service to view the hooks available in the host object.
//
func (op *HostService) HooksService() *HostHooksService {
	return NewHostHooksService(op.connection, fmt.Sprintf("%s/hooks", op.path))
}

//
// A reference to the service that can show the applicable errata available on the host. This information is taken
// from Katello.
//
func (op *HostService) KatelloErrataService() *KatelloErrataService {
	return NewKatelloErrataService(op.connection, fmt.Sprintf("%s/katelloerrata", op.path))
}

//
// A reference to the network attachments service. You can use this service to attach Logical networks to host
// interfaces.
//
func (op *HostService) NetworkAttachmentsService() *NetworkAttachmentsService {
	return NewNetworkAttachmentsService(op.connection, fmt.Sprintf("%s/networkattachments", op.path))
}

//
// A reference to the service that manages the network interface devices on the host.
//
func (op *HostService) NicsService() *HostNicsService {
	return NewHostNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
// A reference to the service that manage NUMA nodes for the host.
//
func (op *HostService) NumaNodesService() *HostNumaNodesService {
	return NewHostNumaNodesService(op.connection, fmt.Sprintf("%s/numanodes", op.path))
}

//
// A reference to the host permission service.
// Use this service to manage permissions on the host object.
//
func (op *HostService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *HostService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// A reference to the service that manages the host's storage.
//
func (op *HostService) StorageService() *HostStorageService {
	return NewHostStorageService(op.connection, fmt.Sprintf("%s/storage", op.path))
}

//
// A reference to storage connection extensions.
//
func (op *HostService) StorageConnectionExtensionsService() *StorageServerConnectionExtensionsService {
	return NewStorageServerConnectionExtensionsService(op.connection, fmt.Sprintf("%s/storageconnectionextensions", op.path))
}

//
// A reference to the host tags service. Use this service to manage tags on the host object.
//
func (op *HostService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
// A reference to unmanaged networks.
//
func (op *HostService) UnmanagedNetworksService() *UnmanagedNetworksService {
	return NewUnmanagedNetworksService(op.connection, fmt.Sprintf("%s/unmanagednetworks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "devices" {
		return op.DevicesService(), nil
	}
	if strings.HasPrefix(path, "devices/") {
		return op.DevicesService().Service(path[8:])
	}
	if path == "externalnetworkproviderconfigurations" {
		return op.ExternalNetworkProviderConfigurationsService(), nil
	}
	if strings.HasPrefix(path, "externalnetworkproviderconfigurations/") {
		return op.ExternalNetworkProviderConfigurationsService().Service(path[38:])
	}
	if path == "fenceagents" {
		return op.FenceAgentsService(), nil
	}
	if strings.HasPrefix(path, "fenceagents/") {
		return op.FenceAgentsService().Service(path[12:])
	}
	if path == "hooks" {
		return op.HooksService(), nil
	}
	if strings.HasPrefix(path, "hooks/") {
		return op.HooksService().Service(path[6:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "networkattachments" {
		return op.NetworkAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "networkattachments/") {
		return op.NetworkAttachmentsService().Service(path[19:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "numanodes" {
		return op.NumaNodesService(), nil
	}
	if strings.HasPrefix(path, "numanodes/") {
		return op.NumaNodesService().Service(path[10:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "storage" {
		return op.StorageService(), nil
	}
	if strings.HasPrefix(path, "storage/") {
		return op.StorageService().Service(path[8:])
	}
	if path == "storageconnectionextensions" {
		return op.StorageConnectionExtensionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnectionextensions/") {
		return op.StorageConnectionExtensionsService().Service(path[28:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "unmanagednetworks" {
		return op.UnmanagedNetworksService(), nil
	}
	if strings.HasPrefix(path, "unmanagednetworks/") {
		return op.UnmanagedNetworksService().Service(path[18:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostService) String() string {
	return fmt.Sprintf("HostService:%s", op.path)
}

//
//
type TemplateDiskService struct {
	BaseService
}

func NewTemplateDiskService(connection *Connection, path string) *TemplateDiskService {
	var result TemplateDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
// Copy the specified disk attached to the template to a specific storage domain.
//
type TemplateDiskServiceCopyRequest struct {
	TemplateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
	filter              *bool
	storageDomain       *StorageDomain
}

func (p *TemplateDiskServiceCopyRequest) Header(key, value string) *TemplateDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceCopyRequest) Query(key, value string) *TemplateDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceCopyRequest) Async(async bool) *TemplateDiskServiceCopyRequest {
	p.async = &async
	return p
}

func (p *TemplateDiskServiceCopyRequest) Filter(filter bool) *TemplateDiskServiceCopyRequest {
	p.filter = &filter
	return p
}

func (p *TemplateDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *TemplateDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *TemplateDiskServiceCopyRequest) Send() (*TemplateDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.TemplateDiskService.connection.URL(), p.TemplateDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateDiskServiceCopyResponse), nil
}

func (p *TemplateDiskServiceCopyRequest) MustSend() *TemplateDiskServiceCopyResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Copy the specified disk attached to the template to a specific storage domain.
//
type TemplateDiskServiceCopyResponse struct {
}

//
// Copy the specified disk attached to the template to a specific storage domain.
//
func (p *TemplateDiskService) Copy() *TemplateDiskServiceCopyRequest {
	return &TemplateDiskServiceCopyRequest{TemplateDiskService: p}
}

//
//
type TemplateDiskServiceExportRequest struct {
	TemplateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
	filter              *bool
	storageDomain       *StorageDomain
}

func (p *TemplateDiskServiceExportRequest) Header(key, value string) *TemplateDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceExportRequest) Query(key, value string) *TemplateDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceExportRequest) Async(async bool) *TemplateDiskServiceExportRequest {
	p.async = &async
	return p
}

func (p *TemplateDiskServiceExportRequest) Filter(filter bool) *TemplateDiskServiceExportRequest {
	p.filter = &filter
	return p
}

func (p *TemplateDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *TemplateDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *TemplateDiskServiceExportRequest) Send() (*TemplateDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.TemplateDiskService.connection.URL(), p.TemplateDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(TemplateDiskServiceExportResponse), nil
}

func (p *TemplateDiskServiceExportRequest) MustSend() *TemplateDiskServiceExportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type TemplateDiskServiceExportResponse struct {
}

//
//
func (p *TemplateDiskService) Export() *TemplateDiskServiceExportRequest {
	return &TemplateDiskServiceExportRequest{TemplateDiskService: p}
}

//
//
type TemplateDiskServiceGetRequest struct {
	TemplateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *TemplateDiskServiceGetRequest) Header(key, value string) *TemplateDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceGetRequest) Query(key, value string) *TemplateDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceGetRequest) Follow(follow string) *TemplateDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *TemplateDiskServiceGetRequest) Send() (*TemplateDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateDiskService.connection.URL(), p.TemplateDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateDiskServiceGetResponse{disk: result}, nil
}

func (p *TemplateDiskServiceGetRequest) MustSend() *TemplateDiskServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type TemplateDiskServiceGetResponse struct {
	disk *Disk
}

func (p *TemplateDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *TemplateDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *TemplateDiskService) Get() *TemplateDiskServiceGetRequest {
	return &TemplateDiskServiceGetRequest{TemplateDiskService: p}
}

//
//
type TemplateDiskServiceRemoveRequest struct {
	TemplateDiskService *TemplateDiskService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *TemplateDiskServiceRemoveRequest) Header(key, value string) *TemplateDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskServiceRemoveRequest) Query(key, value string) *TemplateDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskServiceRemoveRequest) Async(async bool) *TemplateDiskServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *TemplateDiskServiceRemoveRequest) Send() (*TemplateDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateDiskService.connection.URL(), p.TemplateDiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateDiskServiceRemoveResponse), nil
}

func (p *TemplateDiskServiceRemoveRequest) MustSend() *TemplateDiskServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type TemplateDiskServiceRemoveResponse struct {
}

//
//
func (p *TemplateDiskService) Remove() *TemplateDiskServiceRemoveRequest {
	return &TemplateDiskServiceRemoveRequest{TemplateDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateDiskService) String() string {
	return fmt.Sprintf("TemplateDiskService:%s", op.path)
}

//
//
type VmGraphicsConsolesService struct {
	BaseService
}

func NewVmGraphicsConsolesService(connection *Connection, path string) *VmGraphicsConsolesService {
	var result VmGraphicsConsolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new graphics console to the virtual machine.
//
type VmGraphicsConsolesServiceAddRequest struct {
	VmGraphicsConsolesService *VmGraphicsConsolesService
	header                    map[string]string
	query                     map[string]string
	console                   *GraphicsConsole
}

func (p *VmGraphicsConsolesServiceAddRequest) Header(key, value string) *VmGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceAddRequest) Query(key, value string) *VmGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *VmGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}

func (p *VmGraphicsConsolesServiceAddRequest) Send() (*VmGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmGraphicsConsolesService.connection.URL(), p.VmGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmGraphicsConsolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmGraphicsConsolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmGraphicsConsolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmGraphicsConsolesServiceAddResponse{console: result}, nil
}

func (p *VmGraphicsConsolesServiceAddRequest) MustSend() *VmGraphicsConsolesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add new graphics console to the virtual machine.
//
type VmGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *VmGraphicsConsolesServiceAddResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *VmGraphicsConsolesServiceAddResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Add new graphics console to the virtual machine.
//
func (p *VmGraphicsConsolesService) Add() *VmGraphicsConsolesServiceAddRequest {
	return &VmGraphicsConsolesServiceAddRequest{VmGraphicsConsolesService: p}
}

//
// Lists all the configured graphics consoles of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
// The order of the returned list of graphics consoles is not guaranteed.
//
type VmGraphicsConsolesServiceListRequest struct {
	VmGraphicsConsolesService *VmGraphicsConsolesService
	header                    map[string]string
	query                     map[string]string
	current                   *bool
	follow                    *string
	max                       *int64
}

func (p *VmGraphicsConsolesServiceListRequest) Header(key, value string) *VmGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Query(key, value string) *VmGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Current(current bool) *VmGraphicsConsolesServiceListRequest {
	p.current = &current
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Follow(follow string) *VmGraphicsConsolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Max(max int64) *VmGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}

func (p *VmGraphicsConsolesServiceListRequest) Send() (*VmGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmGraphicsConsolesService.connection.URL(), p.VmGraphicsConsolesService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmGraphicsConsolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmGraphicsConsolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmGraphicsConsolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmGraphicsConsolesServiceListResponse{consoles: result}, nil
}

func (p *VmGraphicsConsolesServiceListRequest) MustSend() *VmGraphicsConsolesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all the configured graphics consoles of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
// The order of the returned list of graphics consoles is not guaranteed.
//
type VmGraphicsConsolesServiceListResponse struct {
	consoles *GraphicsConsoleSlice
}

func (p *VmGraphicsConsolesServiceListResponse) Consoles() (*GraphicsConsoleSlice, bool) {
	if p.consoles != nil {
		return p.consoles, true
	}
	return nil, false
}

func (p *VmGraphicsConsolesServiceListResponse) MustConsoles() *GraphicsConsoleSlice {
	if p.consoles == nil {
		panic("consoles in response does not exist")
	}
	return p.consoles
}

//
// Lists all the configured graphics consoles of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
// The order of the returned list of graphics consoles is not guaranteed.
//
func (p *VmGraphicsConsolesService) List() *VmGraphicsConsolesServiceListRequest {
	return &VmGraphicsConsolesServiceListRequest{VmGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific virtual machine graphics console.
//
func (op *VmGraphicsConsolesService) ConsoleService(id string) *VmGraphicsConsoleService {
	return NewVmGraphicsConsoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmGraphicsConsolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConsoleService(path), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *VmGraphicsConsolesService) String() string {
	return fmt.Sprintf("VmGraphicsConsolesService:%s", op.path)
}

//
// Manages a network filter.
// [source,xml]
// ----
// <network_filter id="00000019-0019-0019-0019-00000000026b">
//   <name>example-network-filter-b</name>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//     <build>-1</build>
//     <revision>-1</revision>
//   </version>
// </network_filter>
// ----
// Please note that version is referring to the minimal support version for the specific filter.
//
type NetworkFilterService struct {
	BaseService
}

func NewNetworkFilterService(connection *Connection, path string) *NetworkFilterService {
	var result NetworkFilterService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a representation of the network filter.
//
type NetworkFilterServiceGetRequest struct {
	NetworkFilterService *NetworkFilterService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *NetworkFilterServiceGetRequest) Header(key, value string) *NetworkFilterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkFilterServiceGetRequest) Query(key, value string) *NetworkFilterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkFilterServiceGetRequest) Follow(follow string) *NetworkFilterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *NetworkFilterServiceGetRequest) Send() (*NetworkFilterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkFilterService.connection.URL(), p.NetworkFilterService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkFilterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkFilterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkFilterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkFilterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkFilterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworkFilterServiceGetResponse{networkFilter: result}, nil
}

func (p *NetworkFilterServiceGetRequest) MustSend() *NetworkFilterServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves a representation of the network filter.
//
type NetworkFilterServiceGetResponse struct {
	networkFilter *NetworkFilter
}

func (p *NetworkFilterServiceGetResponse) NetworkFilter() (*NetworkFilter, bool) {
	if p.networkFilter != nil {
		return p.networkFilter, true
	}
	return nil, false
}

func (p *NetworkFilterServiceGetResponse) MustNetworkFilter() *NetworkFilter {
	if p.networkFilter == nil {
		panic("networkFilter in response does not exist")
	}
	return p.networkFilter
}

//
// Retrieves a representation of the network filter.
//
func (p *NetworkFilterService) Get() *NetworkFilterServiceGetRequest {
	return &NetworkFilterServiceGetRequest{NetworkFilterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkFilterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkFilterService) String() string {
	return fmt.Sprintf("NetworkFilterService:%s", op.path)
}

//
//
type AssignedVnicProfilesService struct {
	BaseService
}

func NewAssignedVnicProfilesService(connection *Connection, path string) *AssignedVnicProfilesService {
	var result AssignedVnicProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new virtual network interface card profile for the network.
//
type AssignedVnicProfilesServiceAddRequest struct {
	AssignedVnicProfilesService *AssignedVnicProfilesService
	header                      map[string]string
	query                       map[string]string
	profile                     *VnicProfile
}

func (p *AssignedVnicProfilesServiceAddRequest) Header(key, value string) *AssignedVnicProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceAddRequest) Query(key, value string) *AssignedVnicProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceAddRequest) Profile(profile *VnicProfile) *AssignedVnicProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *AssignedVnicProfilesServiceAddRequest) Send() (*AssignedVnicProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedVnicProfilesService.connection.URL(), p.AssignedVnicProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedVnicProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedVnicProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedVnicProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedVnicProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedVnicProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedVnicProfilesServiceAddResponse{profile: result}, nil
}

func (p *AssignedVnicProfilesServiceAddRequest) MustSend() *AssignedVnicProfilesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new virtual network interface card profile for the network.
//
type AssignedVnicProfilesServiceAddResponse struct {
	profile *VnicProfile
}

func (p *AssignedVnicProfilesServiceAddResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *AssignedVnicProfilesServiceAddResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new virtual network interface card profile for the network.
//
func (p *AssignedVnicProfilesService) Add() *AssignedVnicProfilesServiceAddRequest {
	return &AssignedVnicProfilesServiceAddRequest{AssignedVnicProfilesService: p}
}

//
// Returns the list of VNIC profiles assifned to the network.
// The order of the returned VNIC profiles isn't guaranteed.
//
type AssignedVnicProfilesServiceListRequest struct {
	AssignedVnicProfilesService *AssignedVnicProfilesService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
	max                         *int64
}

func (p *AssignedVnicProfilesServiceListRequest) Header(key, value string) *AssignedVnicProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceListRequest) Query(key, value string) *AssignedVnicProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfilesServiceListRequest) Follow(follow string) *AssignedVnicProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AssignedVnicProfilesServiceListRequest) Max(max int64) *AssignedVnicProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *AssignedVnicProfilesServiceListRequest) Send() (*AssignedVnicProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedVnicProfilesService.connection.URL(), p.AssignedVnicProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedVnicProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedVnicProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedVnicProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedVnicProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedVnicProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AssignedVnicProfilesServiceListResponse{profiles: result}, nil
}

func (p *AssignedVnicProfilesServiceListRequest) MustSend() *AssignedVnicProfilesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of VNIC profiles assifned to the network.
// The order of the returned VNIC profiles isn't guaranteed.
//
type AssignedVnicProfilesServiceListResponse struct {
	profiles *VnicProfileSlice
}

func (p *AssignedVnicProfilesServiceListResponse) Profiles() (*VnicProfileSlice, bool) {
	if p.profiles != nil {
		return p.profiles, true
	}
	return nil, false
}

func (p *AssignedVnicProfilesServiceListResponse) MustProfiles() *VnicProfileSlice {
	if p.profiles == nil {
		panic("profiles in response does not exist")
	}
	return p.profiles
}

//
// Returns the list of VNIC profiles assifned to the network.
// The order of the returned VNIC profiles isn't guaranteed.
//
func (p *AssignedVnicProfilesService) List() *AssignedVnicProfilesServiceListRequest {
	return &AssignedVnicProfilesServiceListRequest{AssignedVnicProfilesService: p}
}

//
//
func (op *AssignedVnicProfilesService) ProfileService(id string) *AssignedVnicProfileService {
	return NewAssignedVnicProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedVnicProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedVnicProfilesService) String() string {
	return fmt.Sprintf("AssignedVnicProfilesService:%s", op.path)
}

//
//
type VmNumaNodeService struct {
	BaseService
}

func NewVmNumaNodeService(connection *Connection, path string) *VmNumaNodeService {
	var result VmNumaNodeService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type VmNumaNodeServiceGetRequest struct {
	VmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *VmNumaNodeServiceGetRequest) Header(key, value string) *VmNumaNodeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceGetRequest) Query(key, value string) *VmNumaNodeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceGetRequest) Follow(follow string) *VmNumaNodeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmNumaNodeServiceGetRequest) Send() (*VmNumaNodeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNumaNodeService.connection.URL(), p.VmNumaNodeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNumaNodeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNumaNodeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNumaNodeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNumaNodeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNumaNodeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmNumaNodeServiceGetResponse{node: result}, nil
}

func (p *VmNumaNodeServiceGetRequest) MustSend() *VmNumaNodeServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmNumaNodeServiceGetResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodeServiceGetResponse) Node() (*VirtualNumaNode, bool) {
	if p.node != nil {
		return p.node, true
	}
	return nil, false
}

func (p *VmNumaNodeServiceGetResponse) MustNode() *VirtualNumaNode {
	if p.node == nil {
		panic("node in response does not exist")
	}
	return p.node
}

//
//
func (p *VmNumaNodeService) Get() *VmNumaNodeServiceGetRequest {
	return &VmNumaNodeServiceGetRequest{VmNumaNodeService: p}
}

//
// Removes a virtual NUMA node.
// An example of removing a virtual NUMA node:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/numanodes/456
// ----
// NOTE: It's required to remove the numa nodes from the highest index
// first.
//
type VmNumaNodeServiceRemoveRequest struct {
	VmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *VmNumaNodeServiceRemoveRequest) Header(key, value string) *VmNumaNodeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceRemoveRequest) Query(key, value string) *VmNumaNodeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceRemoveRequest) Async(async bool) *VmNumaNodeServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VmNumaNodeServiceRemoveRequest) Send() (*VmNumaNodeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNumaNodeService.connection.URL(), p.VmNumaNodeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNumaNodeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNumaNodeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNumaNodeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNumaNodeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNumaNodeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmNumaNodeServiceRemoveResponse), nil
}

func (p *VmNumaNodeServiceRemoveRequest) MustSend() *VmNumaNodeServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a virtual NUMA node.
// An example of removing a virtual NUMA node:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/numanodes/456
// ----
// NOTE: It's required to remove the numa nodes from the highest index
// first.
//
type VmNumaNodeServiceRemoveResponse struct {
}

//
// Removes a virtual NUMA node.
// An example of removing a virtual NUMA node:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/numanodes/456
// ----
// NOTE: It's required to remove the numa nodes from the highest index
// first.
//
func (p *VmNumaNodeService) Remove() *VmNumaNodeServiceRemoveRequest {
	return &VmNumaNodeServiceRemoveRequest{VmNumaNodeService: p}
}

//
// Updates a virtual NUMA node.
// An example of pinning a virtual NUMA node to a physical NUMA node on the host:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/numanodes/456
// ----
// The request body should contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <numa_node_pins>
//     <numa_node_pin>
//       <index>0</index>
//     </numa_node_pin>
//   </numa_node_pins>
// </vm_numa_node>
// ----
//
type VmNumaNodeServiceUpdateRequest struct {
	VmNumaNodeService *VmNumaNodeService
	header            map[string]string
	query             map[string]string
	async             *bool
	node              *VirtualNumaNode
}

func (p *VmNumaNodeServiceUpdateRequest) Header(key, value string) *VmNumaNodeServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNumaNodeServiceUpdateRequest) Query(key, value string) *VmNumaNodeServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNumaNodeServiceUpdateRequest) Async(async bool) *VmNumaNodeServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *VmNumaNodeServiceUpdateRequest) Node(node *VirtualNumaNode) *VmNumaNodeServiceUpdateRequest {
	p.node = node
	return p
}

func (p *VmNumaNodeServiceUpdateRequest) Send() (*VmNumaNodeServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNumaNodeService.connection.URL(), p.VmNumaNodeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVirtualNumaNodeWriteOne(writer, p.node, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNumaNodeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNumaNodeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNumaNodeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNumaNodeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNumaNodeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVirtualNumaNodeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmNumaNodeServiceUpdateResponse{node: result}, nil
}

func (p *VmNumaNodeServiceUpdateRequest) MustSend() *VmNumaNodeServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates a virtual NUMA node.
// An example of pinning a virtual NUMA node to a physical NUMA node on the host:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/numanodes/456
// ----
// The request body should contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <numa_node_pins>
//     <numa_node_pin>
//       <index>0</index>
//     </numa_node_pin>
//   </numa_node_pins>
// </vm_numa_node>
// ----
//
type VmNumaNodeServiceUpdateResponse struct {
	node *VirtualNumaNode
}

func (p *VmNumaNodeServiceUpdateResponse) Node() (*VirtualNumaNode, bool) {
	if p.node != nil {
		return p.node, true
	}
	return nil, false
}

func (p *VmNumaNodeServiceUpdateResponse) MustNode() *VirtualNumaNode {
	if p.node == nil {
		panic("node in response does not exist")
	}
	return p.node
}

//
// Updates a virtual NUMA node.
// An example of pinning a virtual NUMA node to a physical NUMA node on the host:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/numanodes/456
// ----
// The request body should contain the following:
// [source,xml]
// ----
// <vm_numa_node>
//   <numa_node_pins>
//     <numa_node_pin>
//       <index>0</index>
//     </numa_node_pin>
//   </numa_node_pins>
// </vm_numa_node>
// ----
//
func (p *VmNumaNodeService) Update() *VmNumaNodeServiceUpdateRequest {
	return &VmNumaNodeServiceUpdateRequest{VmNumaNodeService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNumaNodeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmNumaNodeService) String() string {
	return fmt.Sprintf("VmNumaNodeService:%s", op.path)
}

//
// Provides read-write access to virtual machines pools.
//
type VmPoolsService struct {
	BaseService
}

func NewVmPoolsService(connection *Connection, path string) *VmPoolsService {
	var result VmPoolsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new virtual machine pool.
// A new pool requires the `name`, `cluster` and `template` attributes. Identify the cluster and template with the
// `id` or `name` nested attributes:
// [source]
// ----
// POST /ovirt-engine/api/vmpools
// ----
// With the following body:
// [source,xml]
// ----
// <vmpool>
//   <name>mypool</name>
//   <cluster id="123"/>
//   <template id="456"/>
// </vmpool>
// ----
//
type VmPoolsServiceAddRequest struct {
	VmPoolsService *VmPoolsService
	header         map[string]string
	query          map[string]string
	pool           *VmPool
}

func (p *VmPoolsServiceAddRequest) Header(key, value string) *VmPoolsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolsServiceAddRequest) Query(key, value string) *VmPoolsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolsServiceAddRequest) Pool(pool *VmPool) *VmPoolsServiceAddRequest {
	p.pool = pool
	return p
}

func (p *VmPoolsServiceAddRequest) Send() (*VmPoolsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmPoolsService.connection.URL(), p.VmPoolsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmPoolWriteOne(writer, p.pool, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmPoolsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmPoolsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmPoolsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmPoolsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmPoolsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmPoolsServiceAddResponse{pool: result}, nil
}

func (p *VmPoolsServiceAddRequest) MustSend() *VmPoolsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new virtual machine pool.
// A new pool requires the `name`, `cluster` and `template` attributes. Identify the cluster and template with the
// `id` or `name` nested attributes:
// [source]
// ----
// POST /ovirt-engine/api/vmpools
// ----
// With the following body:
// [source,xml]
// ----
// <vmpool>
//   <name>mypool</name>
//   <cluster id="123"/>
//   <template id="456"/>
// </vmpool>
// ----
//
type VmPoolsServiceAddResponse struct {
	pool *VmPool
}

func (p *VmPoolsServiceAddResponse) Pool() (*VmPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *VmPoolsServiceAddResponse) MustPool() *VmPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Creates a new virtual machine pool.
// A new pool requires the `name`, `cluster` and `template` attributes. Identify the cluster and template with the
// `id` or `name` nested attributes:
// [source]
// ----
// POST /ovirt-engine/api/vmpools
// ----
// With the following body:
// [source,xml]
// ----
// <vmpool>
//   <name>mypool</name>
//   <cluster id="123"/>
//   <template id="456"/>
// </vmpool>
// ----
//
func (p *VmPoolsService) Add() *VmPoolsServiceAddRequest {
	return &VmPoolsServiceAddRequest{VmPoolsService: p}
}

//
// Get a list of available virtual machines pools.
// [source]
// ----
// GET /ovirt-engine/api/vmpools
// ----
// You will receive the following response:
// [source,xml]
// ----
// <vm_pools>
//   <vm_pool id="123">
//     ...
//   </vm_pool>
//   ...
// </vm_pools>
// ----
// The order of the returned list of pools is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type VmPoolsServiceListRequest struct {
	VmPoolsService *VmPoolsService
	header         map[string]string
	query          map[string]string
	caseSensitive  *bool
	filter         *bool
	follow         *string
	max            *int64
	search         *string
}

func (p *VmPoolsServiceListRequest) Header(key, value string) *VmPoolsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmPoolsServiceListRequest) Query(key, value string) *VmPoolsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmPoolsServiceListRequest) CaseSensitive(caseSensitive bool) *VmPoolsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *VmPoolsServiceListRequest) Filter(filter bool) *VmPoolsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *VmPoolsServiceListRequest) Follow(follow string) *VmPoolsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmPoolsServiceListRequest) Max(max int64) *VmPoolsServiceListRequest {
	p.max = &max
	return p
}

func (p *VmPoolsServiceListRequest) Search(search string) *VmPoolsServiceListRequest {
	p.search = &search
	return p
}

func (p *VmPoolsServiceListRequest) Send() (*VmPoolsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmPoolsService.connection.URL(), p.VmPoolsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmPoolsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmPoolsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmPoolsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmPoolsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmPoolsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmPoolReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmPoolsServiceListResponse{pools: result}, nil
}

func (p *VmPoolsServiceListRequest) MustSend() *VmPoolsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get a list of available virtual machines pools.
// [source]
// ----
// GET /ovirt-engine/api/vmpools
// ----
// You will receive the following response:
// [source,xml]
// ----
// <vm_pools>
//   <vm_pool id="123">
//     ...
//   </vm_pool>
//   ...
// </vm_pools>
// ----
// The order of the returned list of pools is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type VmPoolsServiceListResponse struct {
	pools *VmPoolSlice
}

func (p *VmPoolsServiceListResponse) Pools() (*VmPoolSlice, bool) {
	if p.pools != nil {
		return p.pools, true
	}
	return nil, false
}

func (p *VmPoolsServiceListResponse) MustPools() *VmPoolSlice {
	if p.pools == nil {
		panic("pools in response does not exist")
	}
	return p.pools
}

//
// Get a list of available virtual machines pools.
// [source]
// ----
// GET /ovirt-engine/api/vmpools
// ----
// You will receive the following response:
// [source,xml]
// ----
// <vm_pools>
//   <vm_pool id="123">
//     ...
//   </vm_pool>
//   ...
// </vm_pools>
// ----
// The order of the returned list of pools is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *VmPoolsService) List() *VmPoolsServiceListRequest {
	return &VmPoolsServiceListRequest{VmPoolsService: p}
}

//
// Reference to the service that manages a specific virtual machine pool.
//
func (op *VmPoolsService) PoolService(id string) *VmPoolService {
	return NewVmPoolService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmPoolsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.PoolService(path), nil
	}
	return op.PoolService(path[:index]).Service(path[index+1:])
}

func (op *VmPoolsService) String() string {
	return fmt.Sprintf("VmPoolsService:%s", op.path)
}

//
//
type RoleService struct {
	BaseService
}

func NewRoleService(connection *Connection, path string) *RoleService {
	var result RoleService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get the role.
// [source]
// ----
// GET /ovirt-engine/api/roles/123
// ----
// You will receive XML response like this one:
// [source,xml]
// ----
// <role id="123">
//   <name>MyRole</name>
//   <description>MyRole description</description>
//   <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//   <administrative>true</administrative>
//   <mutable>false</mutable>
// </role>
// ----
//
type RoleServiceGetRequest struct {
	RoleService *RoleService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *RoleServiceGetRequest) Header(key, value string) *RoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceGetRequest) Query(key, value string) *RoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceGetRequest) Follow(follow string) *RoleServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *RoleServiceGetRequest) Send() (*RoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.RoleService.connection.URL(), p.RoleService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.RoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.RoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.RoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.RoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.RoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &RoleServiceGetResponse{role: result}, nil
}

func (p *RoleServiceGetRequest) MustSend() *RoleServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get the role.
// [source]
// ----
// GET /ovirt-engine/api/roles/123
// ----
// You will receive XML response like this one:
// [source,xml]
// ----
// <role id="123">
//   <name>MyRole</name>
//   <description>MyRole description</description>
//   <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//   <administrative>true</administrative>
//   <mutable>false</mutable>
// </role>
// ----
//
type RoleServiceGetResponse struct {
	role *Role
}

func (p *RoleServiceGetResponse) Role() (*Role, bool) {
	if p.role != nil {
		return p.role, true
	}
	return nil, false
}

func (p *RoleServiceGetResponse) MustRole() *Role {
	if p.role == nil {
		panic("role in response does not exist")
	}
	return p.role
}

//
// Get the role.
// [source]
// ----
// GET /ovirt-engine/api/roles/123
// ----
// You will receive XML response like this one:
// [source,xml]
// ----
// <role id="123">
//   <name>MyRole</name>
//   <description>MyRole description</description>
//   <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//   <administrative>true</administrative>
//   <mutable>false</mutable>
// </role>
// ----
//
func (p *RoleService) Get() *RoleServiceGetRequest {
	return &RoleServiceGetRequest{RoleService: p}
}

//
// Removes the role.
// To remove the role you need to know its id, then send request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/roles/{role_id}
// ----
//
type RoleServiceRemoveRequest struct {
	RoleService *RoleService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *RoleServiceRemoveRequest) Header(key, value string) *RoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceRemoveRequest) Query(key, value string) *RoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceRemoveRequest) Async(async bool) *RoleServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *RoleServiceRemoveRequest) Send() (*RoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.RoleService.connection.URL(), p.RoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.RoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.RoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.RoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.RoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.RoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(RoleServiceRemoveResponse), nil
}

func (p *RoleServiceRemoveRequest) MustSend() *RoleServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the role.
// To remove the role you need to know its id, then send request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/roles/{role_id}
// ----
//
type RoleServiceRemoveResponse struct {
}

//
// Removes the role.
// To remove the role you need to know its id, then send request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/roles/{role_id}
// ----
//
func (p *RoleService) Remove() *RoleServiceRemoveRequest {
	return &RoleServiceRemoveRequest{RoleService: p}
}

//
// Updates a role. You are allowed to update `name`, `description` and `administrative` attributes after role is
// created. Within this endpoint you can't add or remove roles permits you need to use
// <<services/permits, service>> that manages permits of role.
// For example to update role's `name`, `description` and `administrative` attributes send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/roles/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyNewRoleName</name>
//   <description>My new description of the role</description>
//   <administrative>true</administrative>
// </group>
// ----
//
type RoleServiceUpdateRequest struct {
	RoleService *RoleService
	header      map[string]string
	query       map[string]string
	async       *bool
	role        *Role
}

func (p *RoleServiceUpdateRequest) Header(key, value string) *RoleServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RoleServiceUpdateRequest) Query(key, value string) *RoleServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RoleServiceUpdateRequest) Async(async bool) *RoleServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *RoleServiceUpdateRequest) Role(role *Role) *RoleServiceUpdateRequest {
	p.role = role
	return p
}

func (p *RoleServiceUpdateRequest) Send() (*RoleServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.RoleService.connection.URL(), p.RoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLRoleWriteOne(writer, p.role, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.RoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.RoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.RoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.RoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.RoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &RoleServiceUpdateResponse{role: result}, nil
}

func (p *RoleServiceUpdateRequest) MustSend() *RoleServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates a role. You are allowed to update `name`, `description` and `administrative` attributes after role is
// created. Within this endpoint you can't add or remove roles permits you need to use
// <<services/permits, service>> that manages permits of role.
// For example to update role's `name`, `description` and `administrative` attributes send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/roles/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyNewRoleName</name>
//   <description>My new description of the role</description>
//   <administrative>true</administrative>
// </group>
// ----
//
type RoleServiceUpdateResponse struct {
	role *Role
}

func (p *RoleServiceUpdateResponse) Role() (*Role, bool) {
	if p.role != nil {
		return p.role, true
	}
	return nil, false
}

func (p *RoleServiceUpdateResponse) MustRole() *Role {
	if p.role == nil {
		panic("role in response does not exist")
	}
	return p.role
}

//
// Updates a role. You are allowed to update `name`, `description` and `administrative` attributes after role is
// created. Within this endpoint you can't add or remove roles permits you need to use
// <<services/permits, service>> that manages permits of role.
// For example to update role's `name`, `description` and `administrative` attributes send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/roles/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyNewRoleName</name>
//   <description>My new description of the role</description>
//   <administrative>true</administrative>
// </group>
// ----
//
func (p *RoleService) Update() *RoleServiceUpdateRequest {
	return &RoleServiceUpdateRequest{RoleService: p}
}

//
// Sub-resource locator method, returns permits service.
//
func (op *RoleService) PermitsService() *PermitsService {
	return NewPermitsService(op.connection, fmt.Sprintf("%s/permits", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *RoleService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permits" {
		return op.PermitsService(), nil
	}
	if strings.HasPrefix(path, "permits/") {
		return op.PermitsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *RoleService) String() string {
	return fmt.Sprintf("RoleService:%s", op.path)
}

//
//
type InstanceTypeService struct {
	BaseService
}

func NewInstanceTypeService(connection *Connection, path string) *InstanceTypeService {
	var result InstanceTypeService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get a specific instance type and it's attributes.
// [source]
// ----
// GET /ovirt-engine/api/instancetypes/123
// ----
//
type InstanceTypeServiceGetRequest struct {
	InstanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *InstanceTypeServiceGetRequest) Header(key, value string) *InstanceTypeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceGetRequest) Query(key, value string) *InstanceTypeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceGetRequest) Follow(follow string) *InstanceTypeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *InstanceTypeServiceGetRequest) Send() (*InstanceTypeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeService.connection.URL(), p.InstanceTypeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeServiceGetResponse{instanceType: result}, nil
}

func (p *InstanceTypeServiceGetRequest) MustSend() *InstanceTypeServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get a specific instance type and it's attributes.
// [source]
// ----
// GET /ovirt-engine/api/instancetypes/123
// ----
//
type InstanceTypeServiceGetResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypeServiceGetResponse) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

func (p *InstanceTypeServiceGetResponse) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("instanceType in response does not exist")
	}
	return p.instanceType
}

//
// Get a specific instance type and it's attributes.
// [source]
// ----
// GET /ovirt-engine/api/instancetypes/123
// ----
//
func (p *InstanceTypeService) Get() *InstanceTypeServiceGetRequest {
	return &InstanceTypeServiceGetRequest{InstanceTypeService: p}
}

//
// Removes a specific instance type from the system.
// If a virtual machine was created using an instance type X after removal of the instance type
// the virtual machine's instance type will be set to `custom`.
// [source]
// ----
// DELETE /ovirt-engine/api/instancetypes/123
// ----
//
type InstanceTypeServiceRemoveRequest struct {
	InstanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *InstanceTypeServiceRemoveRequest) Header(key, value string) *InstanceTypeServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceRemoveRequest) Query(key, value string) *InstanceTypeServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceRemoveRequest) Async(async bool) *InstanceTypeServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *InstanceTypeServiceRemoveRequest) Send() (*InstanceTypeServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeService.connection.URL(), p.InstanceTypeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(InstanceTypeServiceRemoveResponse), nil
}

func (p *InstanceTypeServiceRemoveRequest) MustSend() *InstanceTypeServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a specific instance type from the system.
// If a virtual machine was created using an instance type X after removal of the instance type
// the virtual machine's instance type will be set to `custom`.
// [source]
// ----
// DELETE /ovirt-engine/api/instancetypes/123
// ----
//
type InstanceTypeServiceRemoveResponse struct {
}

//
// Removes a specific instance type from the system.
// If a virtual machine was created using an instance type X after removal of the instance type
// the virtual machine's instance type will be set to `custom`.
// [source]
// ----
// DELETE /ovirt-engine/api/instancetypes/123
// ----
//
func (p *InstanceTypeService) Remove() *InstanceTypeServiceRemoveRequest {
	return &InstanceTypeServiceRemoveRequest{InstanceTypeService: p}
}

//
// Update a specific instance type and it's attributes.
// All the attributes are editable after creation.
// If a virtual machine was created using an instance type X and some configuration in instance
// type X was updated, the virtual machine's configuration will be updated automatically by the
// engine.
// [source]
// ----
// PUT /ovirt-engine/api/instancetypes/123
// ----
// For example, to update the memory of instance type `123` to 1 GiB and set the cpu topology
// to 2 sockets and 1 core, send a request like this:
// [source, xml]
// ----
// <instance_type>
//   <memory>1073741824</memory>
//   <cpu>
//     <topology>
//       <cores>1</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
// </instance_type>
// ----
//
type InstanceTypeServiceUpdateRequest struct {
	InstanceTypeService *InstanceTypeService
	header              map[string]string
	query               map[string]string
	async               *bool
	instanceType        *InstanceType
}

func (p *InstanceTypeServiceUpdateRequest) Header(key, value string) *InstanceTypeServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeServiceUpdateRequest) Query(key, value string) *InstanceTypeServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeServiceUpdateRequest) Async(async bool) *InstanceTypeServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *InstanceTypeServiceUpdateRequest) InstanceType(instanceType *InstanceType) *InstanceTypeServiceUpdateRequest {
	p.instanceType = instanceType
	return p
}

func (p *InstanceTypeServiceUpdateRequest) Send() (*InstanceTypeServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeService.connection.URL(), p.InstanceTypeService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLInstanceTypeWriteOne(writer, p.instanceType, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeServiceUpdateResponse{instanceType: result}, nil
}

func (p *InstanceTypeServiceUpdateRequest) MustSend() *InstanceTypeServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update a specific instance type and it's attributes.
// All the attributes are editable after creation.
// If a virtual machine was created using an instance type X and some configuration in instance
// type X was updated, the virtual machine's configuration will be updated automatically by the
// engine.
// [source]
// ----
// PUT /ovirt-engine/api/instancetypes/123
// ----
// For example, to update the memory of instance type `123` to 1 GiB and set the cpu topology
// to 2 sockets and 1 core, send a request like this:
// [source, xml]
// ----
// <instance_type>
//   <memory>1073741824</memory>
//   <cpu>
//     <topology>
//       <cores>1</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
// </instance_type>
// ----
//
type InstanceTypeServiceUpdateResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypeServiceUpdateResponse) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

func (p *InstanceTypeServiceUpdateResponse) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("instanceType in response does not exist")
	}
	return p.instanceType
}

//
// Update a specific instance type and it's attributes.
// All the attributes are editable after creation.
// If a virtual machine was created using an instance type X and some configuration in instance
// type X was updated, the virtual machine's configuration will be updated automatically by the
// engine.
// [source]
// ----
// PUT /ovirt-engine/api/instancetypes/123
// ----
// For example, to update the memory of instance type `123` to 1 GiB and set the cpu topology
// to 2 sockets and 1 core, send a request like this:
// [source, xml]
// ----
// <instance_type>
//   <memory>1073741824</memory>
//   <cpu>
//     <topology>
//       <cores>1</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
// </instance_type>
// ----
//
func (p *InstanceTypeService) Update() *InstanceTypeServiceUpdateRequest {
	return &InstanceTypeServiceUpdateRequest{InstanceTypeService: p}
}

//
// Reference to the service that manages the graphic consoles that are attached to this
// instance type.
//
func (op *InstanceTypeService) GraphicsConsolesService() *InstanceTypeGraphicsConsolesService {
	return NewInstanceTypeGraphicsConsolesService(op.connection, fmt.Sprintf("%s/graphicsconsoles", op.path))
}

//
// Reference to the service that manages the NICs that are attached to this instance type.
//
func (op *InstanceTypeService) NicsService() *InstanceTypeNicsService {
	return NewInstanceTypeNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
// Reference to the service that manages the watchdogs that are attached to this instance type.
//
func (op *InstanceTypeService) WatchdogsService() *InstanceTypeWatchdogsService {
	return NewInstanceTypeWatchdogsService(op.connection, fmt.Sprintf("%s/watchdogs", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeService) String() string {
	return fmt.Sprintf("InstanceTypeService:%s", op.path)
}

//
//
type TemplateNicsService struct {
	BaseService
}

func NewTemplateNicsService(connection *Connection, path string) *TemplateNicsService {
	var result TemplateNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new network interface card to the template.
//
type TemplateNicsServiceAddRequest struct {
	TemplateNicsService *TemplateNicsService
	header              map[string]string
	query               map[string]string
	nic                 *Nic
}

func (p *TemplateNicsServiceAddRequest) Header(key, value string) *TemplateNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicsServiceAddRequest) Query(key, value string) *TemplateNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicsServiceAddRequest) Nic(nic *Nic) *TemplateNicsServiceAddRequest {
	p.nic = nic
	return p
}

func (p *TemplateNicsServiceAddRequest) Send() (*TemplateNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateNicsService.connection.URL(), p.TemplateNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateNicsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateNicsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateNicsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateNicsServiceAddResponse{nic: result}, nil
}

func (p *TemplateNicsServiceAddRequest) MustSend() *TemplateNicsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new network interface card to the template.
//
type TemplateNicsServiceAddResponse struct {
	nic *Nic
}

func (p *TemplateNicsServiceAddResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *TemplateNicsServiceAddResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Add a new network interface card to the template.
//
func (p *TemplateNicsService) Add() *TemplateNicsServiceAddRequest {
	return &TemplateNicsServiceAddRequest{TemplateNicsService: p}
}

//
// Returns the list of NICs of the template.
// The order of the returned list of NICs isn't guaranteed.
//
type TemplateNicsServiceListRequest struct {
	TemplateNicsService *TemplateNicsService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *TemplateNicsServiceListRequest) Header(key, value string) *TemplateNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateNicsServiceListRequest) Query(key, value string) *TemplateNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateNicsServiceListRequest) Follow(follow string) *TemplateNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *TemplateNicsServiceListRequest) Max(max int64) *TemplateNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *TemplateNicsServiceListRequest) Send() (*TemplateNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateNicsService.connection.URL(), p.TemplateNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateNicsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateNicsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateNicsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &TemplateNicsServiceListResponse{nics: result}, nil
}

func (p *TemplateNicsServiceListRequest) MustSend() *TemplateNicsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of NICs of the template.
// The order of the returned list of NICs isn't guaranteed.
//
type TemplateNicsServiceListResponse struct {
	nics *NicSlice
}

func (p *TemplateNicsServiceListResponse) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *TemplateNicsServiceListResponse) MustNics() *NicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Returns the list of NICs of the template.
// The order of the returned list of NICs isn't guaranteed.
//
func (p *TemplateNicsService) List() *TemplateNicsServiceListRequest {
	return &TemplateNicsServiceListRequest{TemplateNicsService: p}
}

//
//
func (op *TemplateNicsService) NicService(id string) *TemplateNicService {
	return NewTemplateNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *TemplateNicsService) String() string {
	return fmt.Sprintf("TemplateNicsService:%s", op.path)
}

//
// Manages the CDROM devices of a virtual machine.
// Currently virtual machines have exactly one CDROM device. No new devices can be added, and the existing one can't
// be removed, thus there are no `add` or `remove` methods. Changing and ejecting CDROM disks is done with the
// <<services/vm_cdrom/methods/update, update>> method of the <<services/vm_cdrom, service>> that manages the
// CDROM device.
//
type VmCdromsService struct {
	BaseService
}

func NewVmCdromsService(connection *Connection, path string) *VmCdromsService {
	var result VmCdromsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a cdrom to a virtual machine identified by the given id.
//
type VmCdromsServiceAddRequest struct {
	VmCdromsService *VmCdromsService
	header          map[string]string
	query           map[string]string
	cdrom           *Cdrom
}

func (p *VmCdromsServiceAddRequest) Header(key, value string) *VmCdromsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromsServiceAddRequest) Query(key, value string) *VmCdromsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromsServiceAddRequest) Cdrom(cdrom *Cdrom) *VmCdromsServiceAddRequest {
	p.cdrom = cdrom
	return p
}

func (p *VmCdromsServiceAddRequest) Send() (*VmCdromsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmCdromsService.connection.URL(), p.VmCdromsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCdromWriteOne(writer, p.cdrom, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmCdromsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmCdromsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmCdromsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmCdromsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmCdromsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmCdromsServiceAddResponse{cdrom: result}, nil
}

func (p *VmCdromsServiceAddRequest) MustSend() *VmCdromsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a cdrom to a virtual machine identified by the given id.
//
type VmCdromsServiceAddResponse struct {
	cdrom *Cdrom
}

func (p *VmCdromsServiceAddResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *VmCdromsServiceAddResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
// Add a cdrom to a virtual machine identified by the given id.
//
func (p *VmCdromsService) Add() *VmCdromsServiceAddRequest {
	return &VmCdromsServiceAddRequest{VmCdromsService: p}
}

//
// Returns the list of CDROM devices of the virtual machine.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type VmCdromsServiceListRequest struct {
	VmCdromsService *VmCdromsService
	header          map[string]string
	query           map[string]string
	follow          *string
	max             *int64
}

func (p *VmCdromsServiceListRequest) Header(key, value string) *VmCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromsServiceListRequest) Query(key, value string) *VmCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromsServiceListRequest) Follow(follow string) *VmCdromsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmCdromsServiceListRequest) Max(max int64) *VmCdromsServiceListRequest {
	p.max = &max
	return p
}

func (p *VmCdromsServiceListRequest) Send() (*VmCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmCdromsService.connection.URL(), p.VmCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmCdromsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmCdromsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmCdromsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmCdromsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmCdromsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmCdromsServiceListResponse{cdroms: result}, nil
}

func (p *VmCdromsServiceListRequest) MustSend() *VmCdromsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of CDROM devices of the virtual machine.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type VmCdromsServiceListResponse struct {
	cdroms *CdromSlice
}

func (p *VmCdromsServiceListResponse) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *VmCdromsServiceListResponse) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("cdroms in response does not exist")
	}
	return p.cdroms
}

//
// Returns the list of CDROM devices of the virtual machine.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
func (p *VmCdromsService) List() *VmCdromsServiceListRequest {
	return &VmCdromsServiceListRequest{VmCdromsService: p}
}

//
// Returns a reference to the service that manages a specific CDROM device.
//
func (op *VmCdromsService) CdromService(id string) *VmCdromService {
	return NewVmCdromService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmCdromsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.CdromService(path), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *VmCdromsService) String() string {
	return fmt.Sprintf("VmCdromsService:%s", op.path)
}

//
//
type QuotaService struct {
	BaseService
}

func NewQuotaService(connection *Connection, path string) *QuotaService {
	var result QuotaService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a quota.
// An example of retrieving a quota:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota id="456">
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
//   <cluster_hard_limit_pct>20</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>80</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
type QuotaServiceGetRequest struct {
	QuotaService *QuotaService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *QuotaServiceGetRequest) Header(key, value string) *QuotaServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceGetRequest) Query(key, value string) *QuotaServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceGetRequest) Follow(follow string) *QuotaServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *QuotaServiceGetRequest) Send() (*QuotaServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaService.connection.URL(), p.QuotaService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QuotaServiceGetResponse{quota: result}, nil
}

func (p *QuotaServiceGetRequest) MustSend() *QuotaServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves a quota.
// An example of retrieving a quota:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota id="456">
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
//   <cluster_hard_limit_pct>20</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>80</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
type QuotaServiceGetResponse struct {
	quota *Quota
}

func (p *QuotaServiceGetResponse) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

func (p *QuotaServiceGetResponse) MustQuota() *Quota {
	if p.quota == nil {
		panic("quota in response does not exist")
	}
	return p.quota
}

//
// Retrieves a quota.
// An example of retrieving a quota:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota id="456">
//   <name>myquota</name>
//   <description>My new quota for virtual machines</description>
//   <cluster_hard_limit_pct>20</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>80</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
func (p *QuotaService) Get() *QuotaServiceGetRequest {
	return &QuotaServiceGetRequest{QuotaService: p}
}

//
// Delete a quota.
// An example of deleting a quota:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123-456/quotas/654-321
// -0472718ab224 HTTP/1.1
// Accept: application/xml
// Content-type: application/xml
// ----
//
type QuotaServiceRemoveRequest struct {
	QuotaService *QuotaService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *QuotaServiceRemoveRequest) Header(key, value string) *QuotaServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceRemoveRequest) Query(key, value string) *QuotaServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceRemoveRequest) Async(async bool) *QuotaServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *QuotaServiceRemoveRequest) Send() (*QuotaServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaService.connection.URL(), p.QuotaService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(QuotaServiceRemoveResponse), nil
}

func (p *QuotaServiceRemoveRequest) MustSend() *QuotaServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Delete a quota.
// An example of deleting a quota:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123-456/quotas/654-321
// -0472718ab224 HTTP/1.1
// Accept: application/xml
// Content-type: application/xml
// ----
//
type QuotaServiceRemoveResponse struct {
}

//
// Delete a quota.
// An example of deleting a quota:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123-456/quotas/654-321
// -0472718ab224 HTTP/1.1
// Accept: application/xml
// Content-type: application/xml
// ----
//
func (p *QuotaService) Remove() *QuotaServiceRemoveRequest {
	return &QuotaServiceRemoveRequest{QuotaService: p}
}

//
// Updates a quota.
// An example of updating a quota:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota>
//   <cluster_hard_limit_pct>30</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>70</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
type QuotaServiceUpdateRequest struct {
	QuotaService *QuotaService
	header       map[string]string
	query        map[string]string
	async        *bool
	quota        *Quota
}

func (p *QuotaServiceUpdateRequest) Header(key, value string) *QuotaServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaServiceUpdateRequest) Query(key, value string) *QuotaServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaServiceUpdateRequest) Async(async bool) *QuotaServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *QuotaServiceUpdateRequest) Quota(quota *Quota) *QuotaServiceUpdateRequest {
	p.quota = quota
	return p
}

func (p *QuotaServiceUpdateRequest) Send() (*QuotaServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaService.connection.URL(), p.QuotaService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaWriteOne(writer, p.quota, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QuotaServiceUpdateResponse{quota: result}, nil
}

func (p *QuotaServiceUpdateRequest) MustSend() *QuotaServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates a quota.
// An example of updating a quota:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota>
//   <cluster_hard_limit_pct>30</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>70</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
type QuotaServiceUpdateResponse struct {
	quota *Quota
}

func (p *QuotaServiceUpdateResponse) Quota() (*Quota, bool) {
	if p.quota != nil {
		return p.quota, true
	}
	return nil, false
}

func (p *QuotaServiceUpdateResponse) MustQuota() *Quota {
	if p.quota == nil {
		panic("quota in response does not exist")
	}
	return p.quota
}

//
// Updates a quota.
// An example of updating a quota:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/quotas/456
// ----
// [source,xml]
// ----
// <quota>
//   <cluster_hard_limit_pct>30</cluster_hard_limit_pct>
//   <cluster_soft_limit_pct>70</cluster_soft_limit_pct>
//   <storage_hard_limit_pct>20</storage_hard_limit_pct>
//   <storage_soft_limit_pct>80</storage_soft_limit_pct>
// </quota>
// ----
//
func (p *QuotaService) Update() *QuotaServiceUpdateRequest {
	return &QuotaServiceUpdateRequest{QuotaService: p}
}

//
//
func (op *QuotaService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *QuotaService) QuotaClusterLimitsService() *QuotaClusterLimitsService {
	return NewQuotaClusterLimitsService(op.connection, fmt.Sprintf("%s/quotaclusterlimits", op.path))
}

//
//
func (op *QuotaService) QuotaStorageLimitsService() *QuotaStorageLimitsService {
	return NewQuotaStorageLimitsService(op.connection, fmt.Sprintf("%s/quotastoragelimits", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "quotaclusterlimits" {
		return op.QuotaClusterLimitsService(), nil
	}
	if strings.HasPrefix(path, "quotaclusterlimits/") {
		return op.QuotaClusterLimitsService().Service(path[19:])
	}
	if path == "quotastoragelimits" {
		return op.QuotaStorageLimitsService(), nil
	}
	if strings.HasPrefix(path, "quotastoragelimits/") {
		return op.QuotaStorageLimitsService().Service(path[19:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaService) String() string {
	return fmt.Sprintf("QuotaService:%s", op.path)
}

//
// This service represents a vm that has a specific
// label when accessed through the affinitylabels/vms
// subcollection.
//
type AffinityLabelVmService struct {
	BaseService
}

func NewAffinityLabelVmService(connection *Connection, path string) *AffinityLabelVmService {
	var result AffinityLabelVmService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves details about a vm that has this label assigned.
//
type AffinityLabelVmServiceGetRequest struct {
	AffinityLabelVmService *AffinityLabelVmService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *AffinityLabelVmServiceGetRequest) Header(key, value string) *AffinityLabelVmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmServiceGetRequest) Query(key, value string) *AffinityLabelVmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmServiceGetRequest) Follow(follow string) *AffinityLabelVmServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AffinityLabelVmServiceGetRequest) Send() (*AffinityLabelVmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelVmService.connection.URL(), p.AffinityLabelVmService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelVmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelVmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelVmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityLabelVmServiceGetResponse{vm: result}, nil
}

func (p *AffinityLabelVmServiceGetRequest) MustSend() *AffinityLabelVmServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves details about a vm that has this label assigned.
//
type AffinityLabelVmServiceGetResponse struct {
	vm *Vm
}

func (p *AffinityLabelVmServiceGetResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *AffinityLabelVmServiceGetResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Retrieves details about a vm that has this label assigned.
//
func (p *AffinityLabelVmService) Get() *AffinityLabelVmServiceGetRequest {
	return &AffinityLabelVmServiceGetRequest{AffinityLabelVmService: p}
}

//
// Remove a label from a vm.
//
type AffinityLabelVmServiceRemoveRequest struct {
	AffinityLabelVmService *AffinityLabelVmService
	header                 map[string]string
	query                  map[string]string
}

func (p *AffinityLabelVmServiceRemoveRequest) Header(key, value string) *AffinityLabelVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmServiceRemoveRequest) Query(key, value string) *AffinityLabelVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmServiceRemoveRequest) Send() (*AffinityLabelVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelVmService.connection.URL(), p.AffinityLabelVmService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelVmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelVmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelVmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityLabelVmServiceRemoveResponse), nil
}

func (p *AffinityLabelVmServiceRemoveRequest) MustSend() *AffinityLabelVmServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove a label from a vm.
//
type AffinityLabelVmServiceRemoveResponse struct {
}

//
// Remove a label from a vm.
//
func (p *AffinityLabelVmService) Remove() *AffinityLabelVmServiceRemoveRequest {
	return &AffinityLabelVmServiceRemoveRequest{AffinityLabelVmService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelVmService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelVmService) String() string {
	return fmt.Sprintf("AffinityLabelVmService:%s", op.path)
}

//
// This service manages the virtual machine templates available in the system.
//
type TemplatesService struct {
	BaseService
}

func NewTemplatesService(connection *Connection, path string) *TemplatesService {
	var result TemplatesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new template.
// This requires the `name` and `vm` elements. To identify the virtual machine use the `vm.id` or `vm.name`
// attributes. For example, to create a template from a virtual machine with the identifier `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/templates
// ----
// With a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
// </template>
// ----
// Since version 4.3, in order to create virtual machine template from a snapshot send a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <snapshots>
//       <snapshot id="456"/>
//     </snapshots>
//   </vm>
// </template>
// ----
// The disks of the template can be customized, making some of their characteristics different from the disks of the
// original virtual machine. To do so use the `vm.disk_attachments` attribute, specifying the identifier of the disk
// of the original virtual machine and the characteristics that you want to change. For example, if the original
// virtual machine has a disk with the identifier `456`, and, for that disk, you want to change the name to `mydisk`
// the format to <<types/disk_format, _Copy On Write_>> and make it <<types/disk, sparse>>, send a request body like
// this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <name>mydisk</name>
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// The template can be created as a sub-version of an existing template. This requires the `name` and `vm` attributes
// for the new template, and the `base_template` and `version_name` attributes for the new template version. The
// `base_template` and `version_name` attributes must be specified within a `version` section enclosed in the
// `template` section. Identify the virtual machine with the `id` or `name` attributes.
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
//   <version>
//     <base_template id="456"/>
//     <version_name>mytemplate_001</version_name>
//   </version>
// </template>
// ----
// The destination storage domain of the template can be customized, in one of two ways:
// 1. Globally, at the request level. The request must list the desired disk attachments to be created on the
// storage domain. If the disk attachments are not listed, the global storage domain parameter will be ignored.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <storage_domain id="123"/>
//   <vm id="456">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="789">
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// 2. Per each disk attachment. Specify the desired storage domain for each disk attachment.
// Specifying the global storage definition will override the storage domain per disk attachment specification.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <format>cow</format>
//           <sparse>true</sparse>
//           <storage_domains>
//              <storage_domain id="789"/>
//           </storage_domains>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
//
type TemplatesServiceAddRequest struct {
	TemplatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	clonePermissions *bool
	seal             *bool
	template         *Template
}

func (p *TemplatesServiceAddRequest) Header(key, value string) *TemplatesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceAddRequest) Query(key, value string) *TemplatesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceAddRequest) ClonePermissions(clonePermissions bool) *TemplatesServiceAddRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *TemplatesServiceAddRequest) Seal(seal bool) *TemplatesServiceAddRequest {
	p.seal = &seal
	return p
}

func (p *TemplatesServiceAddRequest) Template(template *Template) *TemplatesServiceAddRequest {
	p.template = template
	return p
}

func (p *TemplatesServiceAddRequest) Send() (*TemplatesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplatesService.connection.URL(), p.TemplatesService.path)
	values := make(url.Values)
	if p.clonePermissions != nil {
		values["clone_permissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}

	if p.seal != nil {
		values["seal"] = []string{fmt.Sprintf("%v", *p.seal)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTemplateWriteOne(writer, p.template, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplatesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplatesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplatesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplatesServiceAddResponse{template: result}, nil
}

func (p *TemplatesServiceAddRequest) MustSend() *TemplatesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new template.
// This requires the `name` and `vm` elements. To identify the virtual machine use the `vm.id` or `vm.name`
// attributes. For example, to create a template from a virtual machine with the identifier `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/templates
// ----
// With a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
// </template>
// ----
// Since version 4.3, in order to create virtual machine template from a snapshot send a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <snapshots>
//       <snapshot id="456"/>
//     </snapshots>
//   </vm>
// </template>
// ----
// The disks of the template can be customized, making some of their characteristics different from the disks of the
// original virtual machine. To do so use the `vm.disk_attachments` attribute, specifying the identifier of the disk
// of the original virtual machine and the characteristics that you want to change. For example, if the original
// virtual machine has a disk with the identifier `456`, and, for that disk, you want to change the name to `mydisk`
// the format to <<types/disk_format, _Copy On Write_>> and make it <<types/disk, sparse>>, send a request body like
// this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <name>mydisk</name>
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// The template can be created as a sub-version of an existing template. This requires the `name` and `vm` attributes
// for the new template, and the `base_template` and `version_name` attributes for the new template version. The
// `base_template` and `version_name` attributes must be specified within a `version` section enclosed in the
// `template` section. Identify the virtual machine with the `id` or `name` attributes.
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
//   <version>
//     <base_template id="456"/>
//     <version_name>mytemplate_001</version_name>
//   </version>
// </template>
// ----
// The destination storage domain of the template can be customized, in one of two ways:
// 1. Globally, at the request level. The request must list the desired disk attachments to be created on the
// storage domain. If the disk attachments are not listed, the global storage domain parameter will be ignored.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <storage_domain id="123"/>
//   <vm id="456">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="789">
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// 2. Per each disk attachment. Specify the desired storage domain for each disk attachment.
// Specifying the global storage definition will override the storage domain per disk attachment specification.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <format>cow</format>
//           <sparse>true</sparse>
//           <storage_domains>
//              <storage_domain id="789"/>
//           </storage_domains>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
//
type TemplatesServiceAddResponse struct {
	template *Template
}

func (p *TemplatesServiceAddResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *TemplatesServiceAddResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Creates a new template.
// This requires the `name` and `vm` elements. To identify the virtual machine use the `vm.id` or `vm.name`
// attributes. For example, to create a template from a virtual machine with the identifier `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/templates
// ----
// With a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
// </template>
// ----
// Since version 4.3, in order to create virtual machine template from a snapshot send a request body like this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <snapshots>
//       <snapshot id="456"/>
//     </snapshots>
//   </vm>
// </template>
// ----
// The disks of the template can be customized, making some of their characteristics different from the disks of the
// original virtual machine. To do so use the `vm.disk_attachments` attribute, specifying the identifier of the disk
// of the original virtual machine and the characteristics that you want to change. For example, if the original
// virtual machine has a disk with the identifier `456`, and, for that disk, you want to change the name to `mydisk`
// the format to <<types/disk_format, _Copy On Write_>> and make it <<types/disk, sparse>>, send a request body like
// this:
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <name>mydisk</name>
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// The template can be created as a sub-version of an existing template. This requires the `name` and `vm` attributes
// for the new template, and the `base_template` and `version_name` attributes for the new template version. The
// `base_template` and `version_name` attributes must be specified within a `version` section enclosed in the
// `template` section. Identify the virtual machine with the `id` or `name` attributes.
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123"/>
//   <version>
//     <base_template id="456"/>
//     <version_name>mytemplate_001</version_name>
//   </version>
// </template>
// ----
// The destination storage domain of the template can be customized, in one of two ways:
// 1. Globally, at the request level. The request must list the desired disk attachments to be created on the
// storage domain. If the disk attachments are not listed, the global storage domain parameter will be ignored.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <storage_domain id="123"/>
//   <vm id="456">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="789">
//           <format>cow</format>
//           <sparse>true</sparse>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
// 2. Per each disk attachment. Specify the desired storage domain for each disk attachment.
// Specifying the global storage definition will override the storage domain per disk attachment specification.
// +
// [source,xml]
// ----
// <template>
//   <name>mytemplate</name>
//   <vm id="123">
//     <disk_attachments>
//       <disk_attachment>
//         <disk id="456">
//           <format>cow</format>
//           <sparse>true</sparse>
//           <storage_domains>
//              <storage_domain id="789"/>
//           </storage_domains>
//         </disk>
//       </disk_attachment>
//     </disk_attachments>
//   </vm>
// </template>
// ----
//
func (p *TemplatesService) Add() *TemplatesServiceAddRequest {
	return &TemplatesServiceAddRequest{TemplatesService: p}
}

//
// Add a virtual machine template to the system from a configuration. Requires the configuration type, the configuration data, and the target cluster.
//
type TemplatesServiceAddFromConfigurationRequest struct {
	TemplatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	clonePermissions *bool
	seal             *bool
	template         *Template
}

func (p *TemplatesServiceAddFromConfigurationRequest) Header(key, value string) *TemplatesServiceAddFromConfigurationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceAddFromConfigurationRequest) Query(key, value string) *TemplatesServiceAddFromConfigurationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceAddFromConfigurationRequest) ClonePermissions(clonePermissions bool) *TemplatesServiceAddFromConfigurationRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *TemplatesServiceAddFromConfigurationRequest) Seal(seal bool) *TemplatesServiceAddFromConfigurationRequest {
	p.seal = &seal
	return p
}

func (p *TemplatesServiceAddFromConfigurationRequest) Template(template *Template) *TemplatesServiceAddFromConfigurationRequest {
	p.template = template
	return p
}

func (p *TemplatesServiceAddFromConfigurationRequest) Send() (*TemplatesServiceAddFromConfigurationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromconfiguration", p.TemplatesService.connection.URL(), p.TemplatesService.path)
	actionBuilder := NewActionBuilder()
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	if p.seal != nil {
		actionBuilder.Seal(*p.seal)
	}
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplatesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplatesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplatesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustTemplate()
	return &TemplatesServiceAddFromConfigurationResponse{template: result}, nil
}

func (p *TemplatesServiceAddFromConfigurationRequest) MustSend() *TemplatesServiceAddFromConfigurationResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a virtual machine template to the system from a configuration. Requires the configuration type, the configuration data, and the target cluster.
//
type TemplatesServiceAddFromConfigurationResponse struct {
	template *Template
}

func (p *TemplatesServiceAddFromConfigurationResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *TemplatesServiceAddFromConfigurationResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Add a virtual machine template to the system from a configuration. Requires the configuration type, the configuration data, and the target cluster.
//
func (p *TemplatesService) AddFromConfiguration() *TemplatesServiceAddFromConfigurationRequest {
	return &TemplatesServiceAddFromConfigurationRequest{TemplatesService: p}
}

//
// Add a virtual machine template to the system from an existing virtual machine.
//
type TemplatesServiceAddFromVmRequest struct {
	TemplatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	clonePermissions *bool
	seal             *bool
	template         *Template
}

func (p *TemplatesServiceAddFromVmRequest) Header(key, value string) *TemplatesServiceAddFromVmRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceAddFromVmRequest) Query(key, value string) *TemplatesServiceAddFromVmRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceAddFromVmRequest) ClonePermissions(clonePermissions bool) *TemplatesServiceAddFromVmRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *TemplatesServiceAddFromVmRequest) Seal(seal bool) *TemplatesServiceAddFromVmRequest {
	p.seal = &seal
	return p
}

func (p *TemplatesServiceAddFromVmRequest) Template(template *Template) *TemplatesServiceAddFromVmRequest {
	p.template = template
	return p
}

func (p *TemplatesServiceAddFromVmRequest) Send() (*TemplatesServiceAddFromVmResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromvm", p.TemplatesService.connection.URL(), p.TemplatesService.path)
	actionBuilder := NewActionBuilder()
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	if p.seal != nil {
		actionBuilder.Seal(*p.seal)
	}
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplatesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplatesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplatesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustTemplate()
	return &TemplatesServiceAddFromVmResponse{template: result}, nil
}

func (p *TemplatesServiceAddFromVmRequest) MustSend() *TemplatesServiceAddFromVmResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a virtual machine template to the system from an existing virtual machine.
//
type TemplatesServiceAddFromVmResponse struct {
	template *Template
}

func (p *TemplatesServiceAddFromVmResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *TemplatesServiceAddFromVmResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Add a virtual machine template to the system from an existing virtual machine.
//
func (p *TemplatesService) AddFromVm() *TemplatesServiceAddFromVmRequest {
	return &TemplatesServiceAddFromVmRequest{TemplatesService: p}
}

//
// Add a virtual machine template to the system from a snapshot.
//
type TemplatesServiceAddFromVmSnapshotRequest struct {
	TemplatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	clonePermissions *bool
	seal             *bool
	template         *Template
}

func (p *TemplatesServiceAddFromVmSnapshotRequest) Header(key, value string) *TemplatesServiceAddFromVmSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceAddFromVmSnapshotRequest) Query(key, value string) *TemplatesServiceAddFromVmSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceAddFromVmSnapshotRequest) ClonePermissions(clonePermissions bool) *TemplatesServiceAddFromVmSnapshotRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *TemplatesServiceAddFromVmSnapshotRequest) Seal(seal bool) *TemplatesServiceAddFromVmSnapshotRequest {
	p.seal = &seal
	return p
}

func (p *TemplatesServiceAddFromVmSnapshotRequest) Template(template *Template) *TemplatesServiceAddFromVmSnapshotRequest {
	p.template = template
	return p
}

func (p *TemplatesServiceAddFromVmSnapshotRequest) Send() (*TemplatesServiceAddFromVmSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromvmsnapshot", p.TemplatesService.connection.URL(), p.TemplatesService.path)
	actionBuilder := NewActionBuilder()
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	if p.seal != nil {
		actionBuilder.Seal(*p.seal)
	}
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplatesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplatesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplatesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustTemplate()
	return &TemplatesServiceAddFromVmSnapshotResponse{template: result}, nil
}

func (p *TemplatesServiceAddFromVmSnapshotRequest) MustSend() *TemplatesServiceAddFromVmSnapshotResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a virtual machine template to the system from a snapshot.
//
type TemplatesServiceAddFromVmSnapshotResponse struct {
	template *Template
}

func (p *TemplatesServiceAddFromVmSnapshotResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *TemplatesServiceAddFromVmSnapshotResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
// Add a virtual machine template to the system from a snapshot.
//
func (p *TemplatesService) AddFromVmSnapshot() *TemplatesServiceAddFromVmSnapshotRequest {
	return &TemplatesServiceAddFromVmSnapshotRequest{TemplatesService: p}
}

//
// Returns the list of virtual machine templates.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/templates
// ----
// Will return the list of virtual machines and virtual machine templates.
// The order of the returned list of templates is not guaranteed.
//
type TemplatesServiceListRequest struct {
	TemplatesService *TemplatesService
	header           map[string]string
	query            map[string]string
	caseSensitive    *bool
	filter           *bool
	follow           *string
	max              *int64
	search           *string
}

func (p *TemplatesServiceListRequest) Header(key, value string) *TemplatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplatesServiceListRequest) Query(key, value string) *TemplatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplatesServiceListRequest) CaseSensitive(caseSensitive bool) *TemplatesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *TemplatesServiceListRequest) Filter(filter bool) *TemplatesServiceListRequest {
	p.filter = &filter
	return p
}

func (p *TemplatesServiceListRequest) Follow(follow string) *TemplatesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *TemplatesServiceListRequest) Max(max int64) *TemplatesServiceListRequest {
	p.max = &max
	return p
}

func (p *TemplatesServiceListRequest) Search(search string) *TemplatesServiceListRequest {
	p.search = &search
	return p
}

func (p *TemplatesServiceListRequest) Send() (*TemplatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplatesService.connection.URL(), p.TemplatesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplatesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplatesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplatesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &TemplatesServiceListResponse{templates: result}, nil
}

func (p *TemplatesServiceListRequest) MustSend() *TemplatesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of virtual machine templates.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/templates
// ----
// Will return the list of virtual machines and virtual machine templates.
// The order of the returned list of templates is not guaranteed.
//
type TemplatesServiceListResponse struct {
	templates *TemplateSlice
}

func (p *TemplatesServiceListResponse) Templates() (*TemplateSlice, bool) {
	if p.templates != nil {
		return p.templates, true
	}
	return nil, false
}

func (p *TemplatesServiceListResponse) MustTemplates() *TemplateSlice {
	if p.templates == nil {
		panic("templates in response does not exist")
	}
	return p.templates
}

//
// Returns the list of virtual machine templates.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/templates
// ----
// Will return the list of virtual machines and virtual machine templates.
// The order of the returned list of templates is not guaranteed.
//
func (p *TemplatesService) List() *TemplatesServiceListRequest {
	return &TemplatesServiceListRequest{TemplatesService: p}
}

//
// Returns a reference to the service that manages a specific virtual machine template.
//
func (op *TemplatesService) TemplateService(id string) *TemplateService {
	return NewTemplateService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplatesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TemplateService(path), nil
	}
	return op.TemplateService(path[:index]).Service(path[index+1:])
}

func (op *TemplatesService) String() string {
	return fmt.Sprintf("TemplatesService:%s", op.path)
}

//
//
type VmsService struct {
	BaseService
}

func NewVmsService(connection *Connection, path string) *VmsService {
	var result VmsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new virtual machine.
// The virtual machine can be created in different ways:
// - From a template. In this case the identifier or name of the template must be provided. For example, using a
//   plain shell script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <template>
//     <name>Blank</name>
//   </template>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// - From a snapshot. In this case the identifier of the snapshot has to be provided. For example, using a plain
//   shel script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <snapshots>
//     <snapshot id="266742a5-6a65-483c-816d-d2ce49746680"/>
//   </snapshots>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// When creating a virtual machine from a template or from a snapshot it is usually useful to explicitly indicate
// in what storage domain to create the disks for the virtual machine. If the virtual machine is created from
// a template then this is achieved passing a set of `disk_attachment` elements that indicate the mapping:
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="8d4bd566-6c86-4592-a4a7-912dbf93c298">
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// When the virtual machine is created from a snapshot this set of disks is slightly different, it uses the
// `image_id` attribute instead of `id`.
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk>
//         <image_id>8d4bd566-6c86-4592-a4a7-912dbf93c298</image_id>
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// It is possible to specify additional virtual machine parameters in the XML description, e.g. a virtual machine
// of `desktop` type, with 2 GiB of RAM and additional description can be added sending a request body like the
// following:
// [source,xml]
// ----
// <vm>
//   <name>myvm</name>
//   <description>My Desktop Virtual Machine</description>
//   <type>desktop</type>
//   <memory>2147483648</memory>
//   ...
// </vm>
// ----
// A bootable CDROM device can be set like this:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot dev="cdrom"/>
//   </os>
// </vm>
// ----
// In order to boot from CDROM, you first need to insert a disk, as described in the
// <<services/vm_cdrom, CDROM service>>. Then booting from that CDROM can be specified using the `os.boot.devices`
// attribute:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot>
//       <devices>
//         <device>cdrom</device>
//       </devices>
//     </boot>
//   </os>
// </vm>
// ----
// In all cases the name or identifier of the cluster where the virtual machine will be created is mandatory.
//
type VmsServiceAddRequest struct {
	VmsService       *VmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	filter           *bool
	vm               *Vm
}

func (p *VmsServiceAddRequest) Header(key, value string) *VmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceAddRequest) Query(key, value string) *VmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceAddRequest) Clone(clone bool) *VmsServiceAddRequest {
	p.clone = &clone
	return p
}

func (p *VmsServiceAddRequest) ClonePermissions(clonePermissions bool) *VmsServiceAddRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *VmsServiceAddRequest) Filter(filter bool) *VmsServiceAddRequest {
	p.filter = &filter
	return p
}

func (p *VmsServiceAddRequest) Vm(vm *Vm) *VmsServiceAddRequest {
	p.vm = vm
	return p
}

func (p *VmsServiceAddRequest) Send() (*VmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmsService.connection.URL(), p.VmsService.path)
	values := make(url.Values)
	if p.clone != nil {
		values["clone"] = []string{fmt.Sprintf("%v", *p.clone)}
	}

	if p.clonePermissions != nil {
		values["clone_permissions"] = []string{fmt.Sprintf("%v", *p.clonePermissions)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmsServiceAddResponse{vm: result}, nil
}

func (p *VmsServiceAddRequest) MustSend() *VmsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new virtual machine.
// The virtual machine can be created in different ways:
// - From a template. In this case the identifier or name of the template must be provided. For example, using a
//   plain shell script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <template>
//     <name>Blank</name>
//   </template>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// - From a snapshot. In this case the identifier of the snapshot has to be provided. For example, using a plain
//   shel script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <snapshots>
//     <snapshot id="266742a5-6a65-483c-816d-d2ce49746680"/>
//   </snapshots>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// When creating a virtual machine from a template or from a snapshot it is usually useful to explicitly indicate
// in what storage domain to create the disks for the virtual machine. If the virtual machine is created from
// a template then this is achieved passing a set of `disk_attachment` elements that indicate the mapping:
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="8d4bd566-6c86-4592-a4a7-912dbf93c298">
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// When the virtual machine is created from a snapshot this set of disks is slightly different, it uses the
// `image_id` attribute instead of `id`.
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk>
//         <image_id>8d4bd566-6c86-4592-a4a7-912dbf93c298</image_id>
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// It is possible to specify additional virtual machine parameters in the XML description, e.g. a virtual machine
// of `desktop` type, with 2 GiB of RAM and additional description can be added sending a request body like the
// following:
// [source,xml]
// ----
// <vm>
//   <name>myvm</name>
//   <description>My Desktop Virtual Machine</description>
//   <type>desktop</type>
//   <memory>2147483648</memory>
//   ...
// </vm>
// ----
// A bootable CDROM device can be set like this:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot dev="cdrom"/>
//   </os>
// </vm>
// ----
// In order to boot from CDROM, you first need to insert a disk, as described in the
// <<services/vm_cdrom, CDROM service>>. Then booting from that CDROM can be specified using the `os.boot.devices`
// attribute:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot>
//       <devices>
//         <device>cdrom</device>
//       </devices>
//     </boot>
//   </os>
// </vm>
// ----
// In all cases the name or identifier of the cluster where the virtual machine will be created is mandatory.
//
type VmsServiceAddResponse struct {
	vm *Vm
}

func (p *VmsServiceAddResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *VmsServiceAddResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Creates a new virtual machine.
// The virtual machine can be created in different ways:
// - From a template. In this case the identifier or name of the template must be provided. For example, using a
//   plain shell script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Version: 4" \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <template>
//     <name>Blank</name>
//   </template>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// - From a snapshot. In this case the identifier of the snapshot has to be provided. For example, using a plain
//   shel script and XML:
// [source,bash]
// ----
// #!/bin/sh -ex
// url="https://engine.example.com/ovirt-engine/api"
// user="admin@internal"
// password="..."
// curl \
// --verbose \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --user "${user}:${password}" \
// --request POST \
// --header "Content-Type: application/xml" \
// --header "Accept: application/xml" \
// --data '
// <vm>
//   <name>myvm</name>
//   <snapshots>
//     <snapshot id="266742a5-6a65-483c-816d-d2ce49746680"/>
//   </snapshots>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </vm>
// ' \
// "${url}/vms"
// ----
// When creating a virtual machine from a template or from a snapshot it is usually useful to explicitly indicate
// in what storage domain to create the disks for the virtual machine. If the virtual machine is created from
// a template then this is achieved passing a set of `disk_attachment` elements that indicate the mapping:
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk id="8d4bd566-6c86-4592-a4a7-912dbf93c298">
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// When the virtual machine is created from a snapshot this set of disks is slightly different, it uses the
// `image_id` attribute instead of `id`.
// [source,xml]
// ----
// <vm>
//   ...
//   <disk_attachments>
//     <disk_attachment>
//       <disk>
//         <image_id>8d4bd566-6c86-4592-a4a7-912dbf93c298</image_id>
//         <storage_domains>
//           <storage_domain id="9cb6cb0a-cf1d-41c2-92ca-5a6d665649c9"/>
//         </storage_domains>
//       </disk>
//     <disk_attachment>
//   </disk_attachments>
// </vm>
// ----
// It is possible to specify additional virtual machine parameters in the XML description, e.g. a virtual machine
// of `desktop` type, with 2 GiB of RAM and additional description can be added sending a request body like the
// following:
// [source,xml]
// ----
// <vm>
//   <name>myvm</name>
//   <description>My Desktop Virtual Machine</description>
//   <type>desktop</type>
//   <memory>2147483648</memory>
//   ...
// </vm>
// ----
// A bootable CDROM device can be set like this:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot dev="cdrom"/>
//   </os>
// </vm>
// ----
// In order to boot from CDROM, you first need to insert a disk, as described in the
// <<services/vm_cdrom, CDROM service>>. Then booting from that CDROM can be specified using the `os.boot.devices`
// attribute:
// [source,xml]
// ----
// <vm>
//   ...
//   <os>
//     <boot>
//       <devices>
//         <device>cdrom</device>
//       </devices>
//     </boot>
//   </os>
// </vm>
// ----
// In all cases the name or identifier of the cluster where the virtual machine will be created is mandatory.
//
func (p *VmsService) Add() *VmsServiceAddRequest {
	return &VmsServiceAddRequest{VmsService: p}
}

//
// add a virtual machine to the system from a configuration - requires the configuration type and the configuration data
//
type VmsServiceAddFromConfigurationRequest struct {
	VmsService       *VmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	filter           *bool
	vm               *Vm
}

func (p *VmsServiceAddFromConfigurationRequest) Header(key, value string) *VmsServiceAddFromConfigurationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceAddFromConfigurationRequest) Query(key, value string) *VmsServiceAddFromConfigurationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceAddFromConfigurationRequest) Clone(clone bool) *VmsServiceAddFromConfigurationRequest {
	p.clone = &clone
	return p
}

func (p *VmsServiceAddFromConfigurationRequest) ClonePermissions(clonePermissions bool) *VmsServiceAddFromConfigurationRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *VmsServiceAddFromConfigurationRequest) Filter(filter bool) *VmsServiceAddFromConfigurationRequest {
	p.filter = &filter
	return p
}

func (p *VmsServiceAddFromConfigurationRequest) Vm(vm *Vm) *VmsServiceAddFromConfigurationRequest {
	p.vm = vm
	return p
}

func (p *VmsServiceAddFromConfigurationRequest) Send() (*VmsServiceAddFromConfigurationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromconfiguration", p.VmsService.connection.URL(), p.VmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustVm()
	return &VmsServiceAddFromConfigurationResponse{vm: result}, nil
}

func (p *VmsServiceAddFromConfigurationRequest) MustSend() *VmsServiceAddFromConfigurationResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// add a virtual machine to the system from a configuration - requires the configuration type and the configuration data
//
type VmsServiceAddFromConfigurationResponse struct {
	vm *Vm
}

func (p *VmsServiceAddFromConfigurationResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *VmsServiceAddFromConfigurationResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// add a virtual machine to the system from a configuration - requires the configuration type and the configuration data
//
func (p *VmsService) AddFromConfiguration() *VmsServiceAddFromConfigurationRequest {
	return &VmsServiceAddFromConfigurationRequest{VmsService: p}
}

//
// add a virtual machine to the system from scratch
//
type VmsServiceAddFromScratchRequest struct {
	VmsService       *VmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	filter           *bool
	vm               *Vm
}

func (p *VmsServiceAddFromScratchRequest) Header(key, value string) *VmsServiceAddFromScratchRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceAddFromScratchRequest) Query(key, value string) *VmsServiceAddFromScratchRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceAddFromScratchRequest) Clone(clone bool) *VmsServiceAddFromScratchRequest {
	p.clone = &clone
	return p
}

func (p *VmsServiceAddFromScratchRequest) ClonePermissions(clonePermissions bool) *VmsServiceAddFromScratchRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *VmsServiceAddFromScratchRequest) Filter(filter bool) *VmsServiceAddFromScratchRequest {
	p.filter = &filter
	return p
}

func (p *VmsServiceAddFromScratchRequest) Vm(vm *Vm) *VmsServiceAddFromScratchRequest {
	p.vm = vm
	return p
}

func (p *VmsServiceAddFromScratchRequest) Send() (*VmsServiceAddFromScratchResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromscratch", p.VmsService.connection.URL(), p.VmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustVm()
	return &VmsServiceAddFromScratchResponse{vm: result}, nil
}

func (p *VmsServiceAddFromScratchRequest) MustSend() *VmsServiceAddFromScratchResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// add a virtual machine to the system from scratch
//
type VmsServiceAddFromScratchResponse struct {
	vm *Vm
}

func (p *VmsServiceAddFromScratchResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *VmsServiceAddFromScratchResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// add a virtual machine to the system from scratch
//
func (p *VmsService) AddFromScratch() *VmsServiceAddFromScratchRequest {
	return &VmsServiceAddFromScratchRequest{VmsService: p}
}

//
// add a virtual machine to the system by cloning from a snapshot
//
type VmsServiceAddFromSnapshotRequest struct {
	VmsService       *VmsService
	header           map[string]string
	query            map[string]string
	clone            *bool
	clonePermissions *bool
	filter           *bool
	vm               *Vm
}

func (p *VmsServiceAddFromSnapshotRequest) Header(key, value string) *VmsServiceAddFromSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceAddFromSnapshotRequest) Query(key, value string) *VmsServiceAddFromSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceAddFromSnapshotRequest) Clone(clone bool) *VmsServiceAddFromSnapshotRequest {
	p.clone = &clone
	return p
}

func (p *VmsServiceAddFromSnapshotRequest) ClonePermissions(clonePermissions bool) *VmsServiceAddFromSnapshotRequest {
	p.clonePermissions = &clonePermissions
	return p
}

func (p *VmsServiceAddFromSnapshotRequest) Filter(filter bool) *VmsServiceAddFromSnapshotRequest {
	p.filter = &filter
	return p
}

func (p *VmsServiceAddFromSnapshotRequest) Vm(vm *Vm) *VmsServiceAddFromSnapshotRequest {
	p.vm = vm
	return p
}

func (p *VmsServiceAddFromSnapshotRequest) Send() (*VmsServiceAddFromSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/fromsnapshot", p.VmsService.connection.URL(), p.VmsService.path)
	actionBuilder := NewActionBuilder()
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	if p.clonePermissions != nil {
		actionBuilder.ClonePermissions(*p.clonePermissions)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustVm()
	return &VmsServiceAddFromSnapshotResponse{vm: result}, nil
}

func (p *VmsServiceAddFromSnapshotRequest) MustSend() *VmsServiceAddFromSnapshotResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// add a virtual machine to the system by cloning from a snapshot
//
type VmsServiceAddFromSnapshotResponse struct {
	vm *Vm
}

func (p *VmsServiceAddFromSnapshotResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *VmsServiceAddFromSnapshotResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// add a virtual machine to the system by cloning from a snapshot
//
func (p *VmsService) AddFromSnapshot() *VmsServiceAddFromSnapshotRequest {
	return &VmsServiceAddFromSnapshotRequest{VmsService: p}
}

//
// Returns the list of virtual machines of the system.
// The order of the returned list of virtual machines is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
type VmsServiceListRequest struct {
	VmsService    *VmsService
	header        map[string]string
	query         map[string]string
	allContent    *bool
	caseSensitive *bool
	filter        *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *VmsServiceListRequest) Header(key, value string) *VmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmsServiceListRequest) Query(key, value string) *VmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmsServiceListRequest) AllContent(allContent bool) *VmsServiceListRequest {
	p.allContent = &allContent
	return p
}

func (p *VmsServiceListRequest) CaseSensitive(caseSensitive bool) *VmsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *VmsServiceListRequest) Filter(filter bool) *VmsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *VmsServiceListRequest) Follow(follow string) *VmsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmsServiceListRequest) Max(max int64) *VmsServiceListRequest {
	p.max = &max
	return p
}

func (p *VmsServiceListRequest) Search(search string) *VmsServiceListRequest {
	p.search = &search
	return p
}

func (p *VmsServiceListRequest) Send() (*VmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmsService.connection.URL(), p.VmsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmsServiceListResponse{vms: result}, nil
}

func (p *VmsServiceListRequest) MustSend() *VmsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of virtual machines of the system.
// The order of the returned list of virtual machines is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
type VmsServiceListResponse struct {
	vms *VmSlice
}

func (p *VmsServiceListResponse) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *VmsServiceListResponse) MustVms() *VmSlice {
	if p.vms == nil {
		panic("vms in response does not exist")
	}
	return p.vms
}

//
// Returns the list of virtual machines of the system.
// The order of the returned list of virtual machines is guaranteed only if the `sortby` clause is included
// in the `search` parameter.
//
func (p *VmsService) List() *VmsServiceListRequest {
	return &VmsServiceListRequest{VmsService: p}
}

//
//
func (op *VmsService) VmService(id string) *VmService {
	return NewVmService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VmService(path), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *VmsService) String() string {
	return fmt.Sprintf("VmsService:%s", op.path)
}

//
//
type StorageDomainContentDiskService struct {
	BaseService
}

func NewStorageDomainContentDiskService(connection *Connection, path string) *StorageDomainContentDiskService {
	var result StorageDomainContentDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StorageDomainContentDiskServiceGetRequest struct {
	StorageDomainContentDiskService *StorageDomainContentDiskService
	header                          map[string]string
	query                           map[string]string
	filter                          *bool
	follow                          *string
}

func (p *StorageDomainContentDiskServiceGetRequest) Header(key, value string) *StorageDomainContentDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainContentDiskServiceGetRequest) Query(key, value string) *StorageDomainContentDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainContentDiskServiceGetRequest) Filter(filter bool) *StorageDomainContentDiskServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *StorageDomainContentDiskServiceGetRequest) Follow(follow string) *StorageDomainContentDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainContentDiskServiceGetRequest) Send() (*StorageDomainContentDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainContentDiskService.connection.URL(), p.StorageDomainContentDiskService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainContentDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainContentDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainContentDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainContentDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainContentDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainContentDiskServiceGetResponse{disk: result}, nil
}

func (p *StorageDomainContentDiskServiceGetRequest) MustSend() *StorageDomainContentDiskServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageDomainContentDiskServiceGetResponse struct {
	disk *Disk
}

func (p *StorageDomainContentDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *StorageDomainContentDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *StorageDomainContentDiskService) Get() *StorageDomainContentDiskServiceGetRequest {
	return &StorageDomainContentDiskServiceGetRequest{StorageDomainContentDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainContentDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainContentDiskService) String() string {
	return fmt.Sprintf("StorageDomainContentDiskService:%s", op.path)
}

//
// A service to manage cluster networks.
//
type ClusterNetworksService struct {
	BaseService
}

func NewClusterNetworksService(connection *Connection, path string) *ClusterNetworksService {
	var result ClusterNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Assigns the network to a cluster.
// Post a request like in the example below to assign the network to a cluster:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network id="123" />
// ----
//
type ClusterNetworksServiceAddRequest struct {
	ClusterNetworksService *ClusterNetworksService
	header                 map[string]string
	query                  map[string]string
	network                *Network
}

func (p *ClusterNetworksServiceAddRequest) Header(key, value string) *ClusterNetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterNetworksServiceAddRequest) Query(key, value string) *ClusterNetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterNetworksServiceAddRequest) Network(network *Network) *ClusterNetworksServiceAddRequest {
	p.network = network
	return p
}

func (p *ClusterNetworksServiceAddRequest) Send() (*ClusterNetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterNetworksService.connection.URL(), p.ClusterNetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterNetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterNetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterNetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterNetworksServiceAddResponse{network: result}, nil
}

func (p *ClusterNetworksServiceAddRequest) MustSend() *ClusterNetworksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Assigns the network to a cluster.
// Post a request like in the example below to assign the network to a cluster:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network id="123" />
// ----
//
type ClusterNetworksServiceAddResponse struct {
	network *Network
}

func (p *ClusterNetworksServiceAddResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *ClusterNetworksServiceAddResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Assigns the network to a cluster.
// Post a request like in the example below to assign the network to a cluster:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/networks
// ----
// Use the following example in its body:
// [source,xml]
// ----
// <network id="123" />
// ----
//
func (p *ClusterNetworksService) Add() *ClusterNetworksServiceAddRequest {
	return &ClusterNetworksServiceAddRequest{ClusterNetworksService: p}
}

//
// Lists the networks that are assigned to the cluster.
// The order of the returned clusters isn't guaranteed.
//
type ClusterNetworksServiceListRequest struct {
	ClusterNetworksService *ClusterNetworksService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
	max                    *int64
}

func (p *ClusterNetworksServiceListRequest) Header(key, value string) *ClusterNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterNetworksServiceListRequest) Query(key, value string) *ClusterNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterNetworksServiceListRequest) Follow(follow string) *ClusterNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ClusterNetworksServiceListRequest) Max(max int64) *ClusterNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *ClusterNetworksServiceListRequest) Send() (*ClusterNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterNetworksService.connection.URL(), p.ClusterNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterNetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterNetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterNetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ClusterNetworksServiceListResponse{networks: result}, nil
}

func (p *ClusterNetworksServiceListRequest) MustSend() *ClusterNetworksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists the networks that are assigned to the cluster.
// The order of the returned clusters isn't guaranteed.
//
type ClusterNetworksServiceListResponse struct {
	networks *NetworkSlice
}

func (p *ClusterNetworksServiceListResponse) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *ClusterNetworksServiceListResponse) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Lists the networks that are assigned to the cluster.
// The order of the returned clusters isn't guaranteed.
//
func (p *ClusterNetworksService) List() *ClusterNetworksServiceListRequest {
	return &ClusterNetworksServiceListRequest{ClusterNetworksService: p}
}

//
// Access the cluster network service that manages the cluster network specified by an ID.
//
func (op *ClusterNetworksService) NetworkService(id string) *ClusterNetworkService {
	return NewClusterNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *ClusterNetworksService) String() string {
	return fmt.Sprintf("ClusterNetworksService:%s", op.path)
}

//
// Returns the details of a disk attached to a virtual machine in the export domain.
//
type StorageDomainVmDiskAttachmentsService struct {
	BaseService
}

func NewStorageDomainVmDiskAttachmentsService(connection *Connection, path string) *StorageDomainVmDiskAttachmentsService {
	var result StorageDomainVmDiskAttachmentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// List the disks that are attached to the virtual machine.
// The order of the returned list of disk attachments isn't guaranteed.
//
type StorageDomainVmDiskAttachmentsServiceListRequest struct {
	StorageDomainVmDiskAttachmentsService *StorageDomainVmDiskAttachmentsService
	header                                map[string]string
	query                                 map[string]string
	follow                                *string
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Header(key, value string) *StorageDomainVmDiskAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Query(key, value string) *StorageDomainVmDiskAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Follow(follow string) *StorageDomainVmDiskAttachmentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) Send() (*StorageDomainVmDiskAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainVmDiskAttachmentsService.connection.URL(), p.StorageDomainVmDiskAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainVmDiskAttachmentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainVmDiskAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainVmDiskAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainVmDiskAttachmentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainVmDiskAttachmentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageDomainVmDiskAttachmentsServiceListResponse{attachments: result}, nil
}

func (p *StorageDomainVmDiskAttachmentsServiceListRequest) MustSend() *StorageDomainVmDiskAttachmentsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the disks that are attached to the virtual machine.
// The order of the returned list of disk attachments isn't guaranteed.
//
type StorageDomainVmDiskAttachmentsServiceListResponse struct {
	attachments *DiskAttachmentSlice
}

func (p *StorageDomainVmDiskAttachmentsServiceListResponse) Attachments() (*DiskAttachmentSlice, bool) {
	if p.attachments != nil {
		return p.attachments, true
	}
	return nil, false
}

func (p *StorageDomainVmDiskAttachmentsServiceListResponse) MustAttachments() *DiskAttachmentSlice {
	if p.attachments == nil {
		panic("attachments in response does not exist")
	}
	return p.attachments
}

//
// List the disks that are attached to the virtual machine.
// The order of the returned list of disk attachments isn't guaranteed.
//
func (p *StorageDomainVmDiskAttachmentsService) List() *StorageDomainVmDiskAttachmentsServiceListRequest {
	return &StorageDomainVmDiskAttachmentsServiceListRequest{StorageDomainVmDiskAttachmentsService: p}
}

//
// Reference to the service that manages a specific attachment.
//
func (op *StorageDomainVmDiskAttachmentsService) AttachmentService(id string) *StorageDomainVmDiskAttachmentService {
	return NewStorageDomainVmDiskAttachmentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmDiskAttachmentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AttachmentService(path), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainVmDiskAttachmentsService) String() string {
	return fmt.Sprintf("StorageDomainVmDiskAttachmentsService:%s", op.path)
}

//
// A service to manage a specific cluster.
//
type ClusterService struct {
	BaseService
}

func NewClusterService(connection *Connection, path string) *ClusterService {
	var result ClusterService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets information about the cluster.
// An example of getting a cluster:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123
// ----
// [source,xml]
// ----
// <cluster href="/ovirt-engine/api/clusters/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/clusters/123/resetemulatedmachine" rel="resetemulatedmachine"/>
//   </actions>
//   <name>Default</name>
//   <description>The default server cluster</description>
//   <link href="/ovirt-engine/api/clusters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/clusters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/clusters/123/glustervolumes" rel="glustervolumes"/>
//   <link href="/ovirt-engine/api/clusters/123/glusterhooks" rel="glusterhooks"/>
//   <link href="/ovirt-engine/api/clusters/123/affinitygroups" rel="affinitygroups"/>
//   <link href="/ovirt-engine/api/clusters/123/cpuprofiles" rel="cpuprofiles"/>
//   <ballooning_enabled>false</ballooning_enabled>
//   <cpu>
//     <architecture>x86_64</architecture>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <error_handling>
//     <on_error>migrate</on_error>
//   </error_handling>
//   <fencing_policy>
//     <enabled>true</enabled>
//     <skip_if_connectivity_broken>
//       <enabled>false</enabled>
//       <threshold>50</threshold>
//     </skip_if_connectivity_broken>
//     <skip_if_sd_active>
//       <enabled>false</enabled>
//     </skip_if_sd_active>
//   </fencing_policy>
//   <gluster_service>false</gluster_service>
//   <ha_reservation>false</ha_reservation>
//   <ksm>
//     <enabled>true</enabled>
//     <merge_across_nodes>true</merge_across_nodes>
//   </ksm>
//   <memory_policy>
//     <over_commit>
//       <percent>100</percent>
//     </over_commit>
//     <transparent_hugepages>
//       <enabled>true</enabled>
//     </transparent_hugepages>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <bandwidth>
//       <assignment_method>auto</assignment_method>
//     </bandwidth>
//     <compressed>inherit</compressed>
//   </migration>
//   <required_rng_sources>
//     <required_rng_source>random</required_rng_source>
//   </required_rng_sources>
//   <scheduling_policy href="/ovirt-engine/api/schedulingpolicies/456" id="456"/>
//   <threads_as_cores>false</threads_as_cores>
//   <trusted_service>false</trusted_service>
//   <tunnel_migration>false</tunnel_migration>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <virt_service>true</virt_service>
//   <data_center href="/ovirt-engine/api/datacenters/111" id="111"/>
// </cluster>
// ----
//
type ClusterServiceGetRequest struct {
	ClusterService *ClusterService
	header         map[string]string
	query          map[string]string
	filter         *bool
	follow         *string
}

func (p *ClusterServiceGetRequest) Header(key, value string) *ClusterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceGetRequest) Query(key, value string) *ClusterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceGetRequest) Filter(filter bool) *ClusterServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *ClusterServiceGetRequest) Follow(follow string) *ClusterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ClusterServiceGetRequest) Send() (*ClusterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterService.connection.URL(), p.ClusterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterServiceGetResponse{cluster: result}, nil
}

func (p *ClusterServiceGetRequest) MustSend() *ClusterServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets information about the cluster.
// An example of getting a cluster:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123
// ----
// [source,xml]
// ----
// <cluster href="/ovirt-engine/api/clusters/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/clusters/123/resetemulatedmachine" rel="resetemulatedmachine"/>
//   </actions>
//   <name>Default</name>
//   <description>The default server cluster</description>
//   <link href="/ovirt-engine/api/clusters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/clusters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/clusters/123/glustervolumes" rel="glustervolumes"/>
//   <link href="/ovirt-engine/api/clusters/123/glusterhooks" rel="glusterhooks"/>
//   <link href="/ovirt-engine/api/clusters/123/affinitygroups" rel="affinitygroups"/>
//   <link href="/ovirt-engine/api/clusters/123/cpuprofiles" rel="cpuprofiles"/>
//   <ballooning_enabled>false</ballooning_enabled>
//   <cpu>
//     <architecture>x86_64</architecture>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <error_handling>
//     <on_error>migrate</on_error>
//   </error_handling>
//   <fencing_policy>
//     <enabled>true</enabled>
//     <skip_if_connectivity_broken>
//       <enabled>false</enabled>
//       <threshold>50</threshold>
//     </skip_if_connectivity_broken>
//     <skip_if_sd_active>
//       <enabled>false</enabled>
//     </skip_if_sd_active>
//   </fencing_policy>
//   <gluster_service>false</gluster_service>
//   <ha_reservation>false</ha_reservation>
//   <ksm>
//     <enabled>true</enabled>
//     <merge_across_nodes>true</merge_across_nodes>
//   </ksm>
//   <memory_policy>
//     <over_commit>
//       <percent>100</percent>
//     </over_commit>
//     <transparent_hugepages>
//       <enabled>true</enabled>
//     </transparent_hugepages>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <bandwidth>
//       <assignment_method>auto</assignment_method>
//     </bandwidth>
//     <compressed>inherit</compressed>
//   </migration>
//   <required_rng_sources>
//     <required_rng_source>random</required_rng_source>
//   </required_rng_sources>
//   <scheduling_policy href="/ovirt-engine/api/schedulingpolicies/456" id="456"/>
//   <threads_as_cores>false</threads_as_cores>
//   <trusted_service>false</trusted_service>
//   <tunnel_migration>false</tunnel_migration>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <virt_service>true</virt_service>
//   <data_center href="/ovirt-engine/api/datacenters/111" id="111"/>
// </cluster>
// ----
//
type ClusterServiceGetResponse struct {
	cluster *Cluster
}

func (p *ClusterServiceGetResponse) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

func (p *ClusterServiceGetResponse) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("cluster in response does not exist")
	}
	return p.cluster
}

//
// Gets information about the cluster.
// An example of getting a cluster:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123
// ----
// [source,xml]
// ----
// <cluster href="/ovirt-engine/api/clusters/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/clusters/123/resetemulatedmachine" rel="resetemulatedmachine"/>
//   </actions>
//   <name>Default</name>
//   <description>The default server cluster</description>
//   <link href="/ovirt-engine/api/clusters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/clusters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/clusters/123/glustervolumes" rel="glustervolumes"/>
//   <link href="/ovirt-engine/api/clusters/123/glusterhooks" rel="glusterhooks"/>
//   <link href="/ovirt-engine/api/clusters/123/affinitygroups" rel="affinitygroups"/>
//   <link href="/ovirt-engine/api/clusters/123/cpuprofiles" rel="cpuprofiles"/>
//   <ballooning_enabled>false</ballooning_enabled>
//   <cpu>
//     <architecture>x86_64</architecture>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <error_handling>
//     <on_error>migrate</on_error>
//   </error_handling>
//   <fencing_policy>
//     <enabled>true</enabled>
//     <skip_if_connectivity_broken>
//       <enabled>false</enabled>
//       <threshold>50</threshold>
//     </skip_if_connectivity_broken>
//     <skip_if_sd_active>
//       <enabled>false</enabled>
//     </skip_if_sd_active>
//   </fencing_policy>
//   <gluster_service>false</gluster_service>
//   <ha_reservation>false</ha_reservation>
//   <ksm>
//     <enabled>true</enabled>
//     <merge_across_nodes>true</merge_across_nodes>
//   </ksm>
//   <memory_policy>
//     <over_commit>
//       <percent>100</percent>
//     </over_commit>
//     <transparent_hugepages>
//       <enabled>true</enabled>
//     </transparent_hugepages>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <bandwidth>
//       <assignment_method>auto</assignment_method>
//     </bandwidth>
//     <compressed>inherit</compressed>
//   </migration>
//   <required_rng_sources>
//     <required_rng_source>random</required_rng_source>
//   </required_rng_sources>
//   <scheduling_policy href="/ovirt-engine/api/schedulingpolicies/456" id="456"/>
//   <threads_as_cores>false</threads_as_cores>
//   <trusted_service>false</trusted_service>
//   <tunnel_migration>false</tunnel_migration>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <virt_service>true</virt_service>
//   <data_center href="/ovirt-engine/api/datacenters/111" id="111"/>
// </cluster>
// ----
//
func (p *ClusterService) Get() *ClusterServiceGetRequest {
	return &ClusterServiceGetRequest{ClusterService: p}
}

//
// Refresh the Gluster heal info for all volumes in cluster.
// For example, Cluster `123`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/refreshglusterhealstatus
// ----
//
type ClusterServiceRefreshGlusterHealStatusRequest struct {
	ClusterService *ClusterService
	header         map[string]string
	query          map[string]string
}

func (p *ClusterServiceRefreshGlusterHealStatusRequest) Header(key, value string) *ClusterServiceRefreshGlusterHealStatusRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceRefreshGlusterHealStatusRequest) Query(key, value string) *ClusterServiceRefreshGlusterHealStatusRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceRefreshGlusterHealStatusRequest) Send() (*ClusterServiceRefreshGlusterHealStatusResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refreshglusterhealstatus", p.ClusterService.connection.URL(), p.ClusterService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ClusterServiceRefreshGlusterHealStatusResponse), nil
}

func (p *ClusterServiceRefreshGlusterHealStatusRequest) MustSend() *ClusterServiceRefreshGlusterHealStatusResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Refresh the Gluster heal info for all volumes in cluster.
// For example, Cluster `123`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/refreshglusterhealstatus
// ----
//
type ClusterServiceRefreshGlusterHealStatusResponse struct {
}

//
// Refresh the Gluster heal info for all volumes in cluster.
// For example, Cluster `123`, send a request like
// this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/refreshglusterhealstatus
// ----
//
func (p *ClusterService) RefreshGlusterHealStatus() *ClusterServiceRefreshGlusterHealStatusRequest {
	return &ClusterServiceRefreshGlusterHealStatusRequest{ClusterService: p}
}

//
// Removes the cluster from the system.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/00000000-0000-0000-0000-000000000000
// ----
//
type ClusterServiceRemoveRequest struct {
	ClusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *ClusterServiceRemoveRequest) Header(key, value string) *ClusterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceRemoveRequest) Query(key, value string) *ClusterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceRemoveRequest) Async(async bool) *ClusterServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *ClusterServiceRemoveRequest) Send() (*ClusterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterService.connection.URL(), p.ClusterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(ClusterServiceRemoveResponse), nil
}

func (p *ClusterServiceRemoveRequest) MustSend() *ClusterServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the cluster from the system.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/00000000-0000-0000-0000-000000000000
// ----
//
type ClusterServiceRemoveResponse struct {
}

//
// Removes the cluster from the system.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/00000000-0000-0000-0000-000000000000
// ----
//
func (p *ClusterService) Remove() *ClusterServiceRemoveRequest {
	return &ClusterServiceRemoveRequest{ClusterService: p}
}

//
//
type ClusterServiceResetEmulatedMachineRequest struct {
	ClusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *ClusterServiceResetEmulatedMachineRequest) Header(key, value string) *ClusterServiceResetEmulatedMachineRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceResetEmulatedMachineRequest) Query(key, value string) *ClusterServiceResetEmulatedMachineRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceResetEmulatedMachineRequest) Async(async bool) *ClusterServiceResetEmulatedMachineRequest {
	p.async = &async
	return p
}

func (p *ClusterServiceResetEmulatedMachineRequest) Send() (*ClusterServiceResetEmulatedMachineResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resetemulatedmachine", p.ClusterService.connection.URL(), p.ClusterService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ClusterServiceResetEmulatedMachineResponse), nil
}

func (p *ClusterServiceResetEmulatedMachineRequest) MustSend() *ClusterServiceResetEmulatedMachineResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type ClusterServiceResetEmulatedMachineResponse struct {
}

//
//
func (p *ClusterService) ResetEmulatedMachine() *ClusterServiceResetEmulatedMachineRequest {
	return &ClusterServiceResetEmulatedMachineRequest{ClusterService: p}
}

//
// Synchronizes all networks on the cluster.
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type ClusterServiceSyncAllNetworksRequest struct {
	ClusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *ClusterServiceSyncAllNetworksRequest) Header(key, value string) *ClusterServiceSyncAllNetworksRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceSyncAllNetworksRequest) Query(key, value string) *ClusterServiceSyncAllNetworksRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceSyncAllNetworksRequest) Async(async bool) *ClusterServiceSyncAllNetworksRequest {
	p.async = &async
	return p
}

func (p *ClusterServiceSyncAllNetworksRequest) Send() (*ClusterServiceSyncAllNetworksResponse, error) {
	rawURL := fmt.Sprintf("%s%s/syncallnetworks", p.ClusterService.connection.URL(), p.ClusterService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ClusterServiceSyncAllNetworksResponse), nil
}

func (p *ClusterServiceSyncAllNetworksRequest) MustSend() *ClusterServiceSyncAllNetworksResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Synchronizes all networks on the cluster.
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
type ClusterServiceSyncAllNetworksResponse struct {
}

//
// Synchronizes all networks on the cluster.
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/syncallnetworks
// ----
// With a request body like this:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *ClusterService) SyncAllNetworks() *ClusterServiceSyncAllNetworksRequest {
	return &ClusterServiceSyncAllNetworksRequest{ClusterService: p}
}

//
// Updates information about the cluster.
// Only the specified fields are updated; others remain unchanged.
// For example, to update the cluster's CPU:
// [source]
// ----
// PUT /ovirt-engine/api/clusters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <cpu>
//     <type>Intel Haswell-noTSX Family</type>
//   </cpu>
// </cluster>
// ----
//
type ClusterServiceUpdateRequest struct {
	ClusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
	cluster        *Cluster
}

func (p *ClusterServiceUpdateRequest) Header(key, value string) *ClusterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceUpdateRequest) Query(key, value string) *ClusterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceUpdateRequest) Async(async bool) *ClusterServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *ClusterServiceUpdateRequest) Cluster(cluster *Cluster) *ClusterServiceUpdateRequest {
	p.cluster = cluster
	return p
}

func (p *ClusterServiceUpdateRequest) Send() (*ClusterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterService.connection.URL(), p.ClusterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterWriteOne(writer, p.cluster, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterServiceUpdateResponse{cluster: result}, nil
}

func (p *ClusterServiceUpdateRequest) MustSend() *ClusterServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates information about the cluster.
// Only the specified fields are updated; others remain unchanged.
// For example, to update the cluster's CPU:
// [source]
// ----
// PUT /ovirt-engine/api/clusters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <cpu>
//     <type>Intel Haswell-noTSX Family</type>
//   </cpu>
// </cluster>
// ----
//
type ClusterServiceUpdateResponse struct {
	cluster *Cluster
}

func (p *ClusterServiceUpdateResponse) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

func (p *ClusterServiceUpdateResponse) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("cluster in response does not exist")
	}
	return p.cluster
}

//
// Updates information about the cluster.
// Only the specified fields are updated; others remain unchanged.
// For example, to update the cluster's CPU:
// [source]
// ----
// PUT /ovirt-engine/api/clusters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <cpu>
//     <type>Intel Haswell-noTSX Family</type>
//   </cpu>
// </cluster>
// ----
//
func (p *ClusterService) Update() *ClusterServiceUpdateRequest {
	return &ClusterServiceUpdateRequest{ClusterService: p}
}

//
// Start or finish upgrade process for the cluster based on the action value. This action marks the cluster for
// upgrade or clears the upgrade running flag on the cluster based on the action value which takes values of
// start or stop.
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/upgrade
// ----
// With a request body like this to mark the cluster for upgrade:
// [source,xml]
// ----
// <action>
//     <upgrade_action>
//         start
//     </upgrade_action>
// </action>
// ----
//
type ClusterServiceUpgradeRequest struct {
	ClusterService *ClusterService
	header         map[string]string
	query          map[string]string
	async          *bool
	upgradeAction  *ClusterUpgradeAction
}

func (p *ClusterServiceUpgradeRequest) Header(key, value string) *ClusterServiceUpgradeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterServiceUpgradeRequest) Query(key, value string) *ClusterServiceUpgradeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterServiceUpgradeRequest) Async(async bool) *ClusterServiceUpgradeRequest {
	p.async = &async
	return p
}

func (p *ClusterServiceUpgradeRequest) UpgradeAction(upgradeAction ClusterUpgradeAction) *ClusterServiceUpgradeRequest {
	p.upgradeAction = &upgradeAction
	return p
}

func (p *ClusterServiceUpgradeRequest) Send() (*ClusterServiceUpgradeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/upgrade", p.ClusterService.connection.URL(), p.ClusterService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.upgradeAction != nil {
		actionBuilder.UpgradeAction(*p.upgradeAction)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ClusterServiceUpgradeResponse), nil
}

func (p *ClusterServiceUpgradeRequest) MustSend() *ClusterServiceUpgradeResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Start or finish upgrade process for the cluster based on the action value. This action marks the cluster for
// upgrade or clears the upgrade running flag on the cluster based on the action value which takes values of
// start or stop.
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/upgrade
// ----
// With a request body like this to mark the cluster for upgrade:
// [source,xml]
// ----
// <action>
//     <upgrade_action>
//         start
//     </upgrade_action>
// </action>
// ----
//
type ClusterServiceUpgradeResponse struct {
}

//
// Start or finish upgrade process for the cluster based on the action value. This action marks the cluster for
// upgrade or clears the upgrade running flag on the cluster based on the action value which takes values of
// start or stop.
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/upgrade
// ----
// With a request body like this to mark the cluster for upgrade:
// [source,xml]
// ----
// <action>
//     <upgrade_action>
//         start
//     </upgrade_action>
// </action>
// ----
//
func (p *ClusterService) Upgrade() *ClusterServiceUpgradeRequest {
	return &ClusterServiceUpgradeRequest{ClusterService: p}
}

//
// A reference to the service that manages affinity groups.
//
func (op *ClusterService) AffinityGroupsService() *AffinityGroupsService {
	return NewAffinityGroupsService(op.connection, fmt.Sprintf("%s/affinitygroups", op.path))
}

//
// A reference to the service that manages assigned CPU profiles for the cluster.
//
func (op *ClusterService) CpuProfilesService() *AssignedCpuProfilesService {
	return NewAssignedCpuProfilesService(op.connection, fmt.Sprintf("%s/cpuprofiles", op.path))
}

//
// A reference to the service that manages the collection of enabled features for the cluster.
//
func (op *ClusterService) EnabledFeaturesService() *ClusterEnabledFeaturesService {
	return NewClusterEnabledFeaturesService(op.connection, fmt.Sprintf("%s/enabledfeatures", op.path))
}

//
// A reference to the service that manages the collection of external network providers.
//
func (op *ClusterService) ExternalNetworkProvidersService() *ClusterExternalProvidersService {
	return NewClusterExternalProvidersService(op.connection, fmt.Sprintf("%s/externalnetworkproviders", op.path))
}

//
// A reference to the service that manages the Gluster hooks for the cluster.
//
func (op *ClusterService) GlusterHooksService() *GlusterHooksService {
	return NewGlusterHooksService(op.connection, fmt.Sprintf("%s/glusterhooks", op.path))
}

//
// A reference to the service that manages Gluster volumes for the cluster.
//
func (op *ClusterService) GlusterVolumesService() *GlusterVolumesService {
	return NewGlusterVolumesService(op.connection, fmt.Sprintf("%s/glustervolumes", op.path))
}

//
// A sub-collection with all the supported network filters for the cluster.
//
func (op *ClusterService) NetworkFiltersService() *NetworkFiltersService {
	return NewNetworkFiltersService(op.connection, fmt.Sprintf("%s/networkfilters", op.path))
}

//
// A reference to the service that manages assigned networks for the cluster.
//
func (op *ClusterService) NetworksService() *ClusterNetworksService {
	return NewClusterNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
// A reference to permissions.
//
func (op *ClusterService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitygroups" {
		return op.AffinityGroupsService(), nil
	}
	if strings.HasPrefix(path, "affinitygroups/") {
		return op.AffinityGroupsService().Service(path[15:])
	}
	if path == "cpuprofiles" {
		return op.CpuProfilesService(), nil
	}
	if strings.HasPrefix(path, "cpuprofiles/") {
		return op.CpuProfilesService().Service(path[12:])
	}
	if path == "enabledfeatures" {
		return op.EnabledFeaturesService(), nil
	}
	if strings.HasPrefix(path, "enabledfeatures/") {
		return op.EnabledFeaturesService().Service(path[16:])
	}
	if path == "externalnetworkproviders" {
		return op.ExternalNetworkProvidersService(), nil
	}
	if strings.HasPrefix(path, "externalnetworkproviders/") {
		return op.ExternalNetworkProvidersService().Service(path[25:])
	}
	if path == "glusterhooks" {
		return op.GlusterHooksService(), nil
	}
	if strings.HasPrefix(path, "glusterhooks/") {
		return op.GlusterHooksService().Service(path[13:])
	}
	if path == "glustervolumes" {
		return op.GlusterVolumesService(), nil
	}
	if strings.HasPrefix(path, "glustervolumes/") {
		return op.GlusterVolumesService().Service(path[15:])
	}
	if path == "networkfilters" {
		return op.NetworkFiltersService(), nil
	}
	if strings.HasPrefix(path, "networkfilters/") {
		return op.NetworkFiltersService().Service(path[15:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterService) String() string {
	return fmt.Sprintf("ClusterService:%s", op.path)
}

//
// The affinity groups service manages virtual machine relationships and dependencies.
//
type AffinityGroupsService struct {
	BaseService
}

func NewAffinityGroupsService(connection *Connection, path string) *AffinityGroupsService {
	var result AffinityGroupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Create a new affinity group.
// Post a request like in the example below to create a new affinity group:
// [source]
// ----
// POST /ovirt-engine/api/clusters/000-000/affinitygroups
// ----
// And use the following example in its body:
// [source,xml]
// ----
// <affinity_group>
//   <name>AF_GROUP_001</name>
//   <hosts_rule>
//     <enforcing>true</enforcing>
//     <positive>true</positive>
//   </hosts_rule>
//   <vms_rule>
//     <enabled>false</enabled>
//   </vms_rule>
// </affinity_group>
// ----
//
type AffinityGroupsServiceAddRequest struct {
	AffinityGroupsService *AffinityGroupsService
	header                map[string]string
	query                 map[string]string
	group                 *AffinityGroup
}

func (p *AffinityGroupsServiceAddRequest) Header(key, value string) *AffinityGroupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupsServiceAddRequest) Query(key, value string) *AffinityGroupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupsServiceAddRequest) Group(group *AffinityGroup) *AffinityGroupsServiceAddRequest {
	p.group = group
	return p
}

func (p *AffinityGroupsServiceAddRequest) Send() (*AffinityGroupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupsService.connection.URL(), p.AffinityGroupsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityGroupWriteOne(writer, p.group, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityGroupsServiceAddResponse{group: result}, nil
}

func (p *AffinityGroupsServiceAddRequest) MustSend() *AffinityGroupsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Create a new affinity group.
// Post a request like in the example below to create a new affinity group:
// [source]
// ----
// POST /ovirt-engine/api/clusters/000-000/affinitygroups
// ----
// And use the following example in its body:
// [source,xml]
// ----
// <affinity_group>
//   <name>AF_GROUP_001</name>
//   <hosts_rule>
//     <enforcing>true</enforcing>
//     <positive>true</positive>
//   </hosts_rule>
//   <vms_rule>
//     <enabled>false</enabled>
//   </vms_rule>
// </affinity_group>
// ----
//
type AffinityGroupsServiceAddResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupsServiceAddResponse) Group() (*AffinityGroup, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *AffinityGroupsServiceAddResponse) MustGroup() *AffinityGroup {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Create a new affinity group.
// Post a request like in the example below to create a new affinity group:
// [source]
// ----
// POST /ovirt-engine/api/clusters/000-000/affinitygroups
// ----
// And use the following example in its body:
// [source,xml]
// ----
// <affinity_group>
//   <name>AF_GROUP_001</name>
//   <hosts_rule>
//     <enforcing>true</enforcing>
//     <positive>true</positive>
//   </hosts_rule>
//   <vms_rule>
//     <enabled>false</enabled>
//   </vms_rule>
// </affinity_group>
// ----
//
func (p *AffinityGroupsService) Add() *AffinityGroupsServiceAddRequest {
	return &AffinityGroupsServiceAddRequest{AffinityGroupsService: p}
}

//
// List existing affinity groups.
// The order of the affinity groups results isn't guaranteed.
//
type AffinityGroupsServiceListRequest struct {
	AffinityGroupsService *AffinityGroupsService
	header                map[string]string
	query                 map[string]string
	follow                *string
	max                   *int64
}

func (p *AffinityGroupsServiceListRequest) Header(key, value string) *AffinityGroupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupsServiceListRequest) Query(key, value string) *AffinityGroupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupsServiceListRequest) Follow(follow string) *AffinityGroupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AffinityGroupsServiceListRequest) Max(max int64) *AffinityGroupsServiceListRequest {
	p.max = &max
	return p
}

func (p *AffinityGroupsServiceListRequest) Send() (*AffinityGroupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupsService.connection.URL(), p.AffinityGroupsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AffinityGroupsServiceListResponse{groups: result}, nil
}

func (p *AffinityGroupsServiceListRequest) MustSend() *AffinityGroupsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List existing affinity groups.
// The order of the affinity groups results isn't guaranteed.
//
type AffinityGroupsServiceListResponse struct {
	groups *AffinityGroupSlice
}

func (p *AffinityGroupsServiceListResponse) Groups() (*AffinityGroupSlice, bool) {
	if p.groups != nil {
		return p.groups, true
	}
	return nil, false
}

func (p *AffinityGroupsServiceListResponse) MustGroups() *AffinityGroupSlice {
	if p.groups == nil {
		panic("groups in response does not exist")
	}
	return p.groups
}

//
// List existing affinity groups.
// The order of the affinity groups results isn't guaranteed.
//
func (p *AffinityGroupsService) List() *AffinityGroupsServiceListRequest {
	return &AffinityGroupsServiceListRequest{AffinityGroupsService: p}
}

//
// Access the affinity group service that manages the affinity group specified by an ID.
//
func (op *AffinityGroupsService) GroupService(id string) *AffinityGroupService {
	return NewAffinityGroupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.GroupService(path), nil
	}
	return op.GroupService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupsService) String() string {
	return fmt.Sprintf("AffinityGroupsService:%s", op.path)
}

//
//
type OperatingSystemService struct {
	BaseService
}

func NewOperatingSystemService(connection *Connection, path string) *OperatingSystemService {
	var result OperatingSystemService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OperatingSystemServiceGetRequest struct {
	OperatingSystemService *OperatingSystemService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *OperatingSystemServiceGetRequest) Header(key, value string) *OperatingSystemServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OperatingSystemServiceGetRequest) Query(key, value string) *OperatingSystemServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OperatingSystemServiceGetRequest) Follow(follow string) *OperatingSystemServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OperatingSystemServiceGetRequest) Send() (*OperatingSystemServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OperatingSystemService.connection.URL(), p.OperatingSystemService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OperatingSystemService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OperatingSystemService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OperatingSystemService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OperatingSystemService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OperatingSystemService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOperatingSystemInfoReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OperatingSystemServiceGetResponse{operatingSystem: result}, nil
}

func (p *OperatingSystemServiceGetRequest) MustSend() *OperatingSystemServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OperatingSystemServiceGetResponse struct {
	operatingSystem *OperatingSystemInfo
}

func (p *OperatingSystemServiceGetResponse) OperatingSystem() (*OperatingSystemInfo, bool) {
	if p.operatingSystem != nil {
		return p.operatingSystem, true
	}
	return nil, false
}

func (p *OperatingSystemServiceGetResponse) MustOperatingSystem() *OperatingSystemInfo {
	if p.operatingSystem == nil {
		panic("operatingSystem in response does not exist")
	}
	return p.operatingSystem
}

//
//
func (p *OperatingSystemService) Get() *OperatingSystemServiceGetRequest {
	return &OperatingSystemServiceGetRequest{OperatingSystemService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OperatingSystemService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OperatingSystemService) String() string {
	return fmt.Sprintf("OperatingSystemService:%s", op.path)
}

//
// Manages the collection of disk snapshots available in an storage domain.
//
type DiskSnapshotsService struct {
	BaseService
}

func NewDiskSnapshotsService(connection *Connection, path string) *DiskSnapshotsService {
	var result DiskSnapshotsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disk snapshots of the storage domain.
// The order of the returned list of disk snapshots isn't guaranteed.
//
type DiskSnapshotsServiceListRequest struct {
	DiskSnapshotsService *DiskSnapshotsService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *DiskSnapshotsServiceListRequest) Header(key, value string) *DiskSnapshotsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotsServiceListRequest) Query(key, value string) *DiskSnapshotsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotsServiceListRequest) Follow(follow string) *DiskSnapshotsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DiskSnapshotsServiceListRequest) Max(max int64) *DiskSnapshotsServiceListRequest {
	p.max = &max
	return p
}

func (p *DiskSnapshotsServiceListRequest) Send() (*DiskSnapshotsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskSnapshotsService.connection.URL(), p.DiskSnapshotsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskSnapshotsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskSnapshotsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskSnapshotsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskSnapshotsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskSnapshotsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskSnapshotReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DiskSnapshotsServiceListResponse{snapshots: result}, nil
}

func (p *DiskSnapshotsServiceListRequest) MustSend() *DiskSnapshotsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of disk snapshots of the storage domain.
// The order of the returned list of disk snapshots isn't guaranteed.
//
type DiskSnapshotsServiceListResponse struct {
	snapshots *DiskSnapshotSlice
}

func (p *DiskSnapshotsServiceListResponse) Snapshots() (*DiskSnapshotSlice, bool) {
	if p.snapshots != nil {
		return p.snapshots, true
	}
	return nil, false
}

func (p *DiskSnapshotsServiceListResponse) MustSnapshots() *DiskSnapshotSlice {
	if p.snapshots == nil {
		panic("snapshots in response does not exist")
	}
	return p.snapshots
}

//
// Returns the list of disk snapshots of the storage domain.
// The order of the returned list of disk snapshots isn't guaranteed.
//
func (p *DiskSnapshotsService) List() *DiskSnapshotsServiceListRequest {
	return &DiskSnapshotsServiceListRequest{DiskSnapshotsService: p}
}

//
//
func (op *DiskSnapshotsService) SnapshotService(id string) *DiskSnapshotService {
	return NewDiskSnapshotService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskSnapshotsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.SnapshotService(path), nil
	}
	return op.SnapshotService(path[:index]).Service(path[index+1:])
}

func (op *DiskSnapshotsService) String() string {
	return fmt.Sprintf("DiskSnapshotsService:%s", op.path)
}

//
// Manages the collection of disks available inside a specific storage domain.
//
type StorageDomainDisksService struct {
	BaseService
}

func NewStorageDomainDisksService(connection *Connection, path string) *StorageDomainDisksService {
	var result StorageDomainDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the {engine-name} this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
type StorageDomainDisksServiceAddRequest struct {
	StorageDomainDisksService *StorageDomainDisksService
	header                    map[string]string
	query                     map[string]string
	disk                      *Disk
	unregistered              *bool
}

func (p *StorageDomainDisksServiceAddRequest) Header(key, value string) *StorageDomainDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDisksServiceAddRequest) Query(key, value string) *StorageDomainDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDisksServiceAddRequest) Disk(disk *Disk) *StorageDomainDisksServiceAddRequest {
	p.disk = disk
	return p
}

func (p *StorageDomainDisksServiceAddRequest) Unregistered(unregistered bool) *StorageDomainDisksServiceAddRequest {
	p.unregistered = &unregistered
	return p
}

func (p *StorageDomainDisksServiceAddRequest) Send() (*StorageDomainDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainDisksService.connection.URL(), p.StorageDomainDisksService.path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainDisksServiceAddResponse{disk: result}, nil
}

func (p *StorageDomainDisksServiceAddRequest) MustSend() *StorageDomainDisksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the {engine-name} this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
type StorageDomainDisksServiceAddResponse struct {
	disk *Disk
}

func (p *StorageDomainDisksServiceAddResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *StorageDomainDisksServiceAddResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the {engine-name} this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
func (p *StorageDomainDisksService) Add() *StorageDomainDisksServiceAddRequest {
	return &StorageDomainDisksServiceAddRequest{StorageDomainDisksService: p}
}

//
// Retrieves the list of disks that are available in the storage domain.
// The order of the returned list of disks is not guaranteed.
//
type StorageDomainDisksServiceListRequest struct {
	StorageDomainDisksService *StorageDomainDisksService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
	unregistered              *bool
}

func (p *StorageDomainDisksServiceListRequest) Header(key, value string) *StorageDomainDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDisksServiceListRequest) Query(key, value string) *StorageDomainDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDisksServiceListRequest) Follow(follow string) *StorageDomainDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainDisksServiceListRequest) Max(max int64) *StorageDomainDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *StorageDomainDisksServiceListRequest) Unregistered(unregistered bool) *StorageDomainDisksServiceListRequest {
	p.unregistered = &unregistered
	return p
}

func (p *StorageDomainDisksServiceListRequest) Send() (*StorageDomainDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainDisksService.connection.URL(), p.StorageDomainDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageDomainDisksServiceListResponse{disks: result}, nil
}

func (p *StorageDomainDisksServiceListRequest) MustSend() *StorageDomainDisksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the list of disks that are available in the storage domain.
// The order of the returned list of disks is not guaranteed.
//
type StorageDomainDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *StorageDomainDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *StorageDomainDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Retrieves the list of disks that are available in the storage domain.
// The order of the returned list of disks is not guaranteed.
//
func (p *StorageDomainDisksService) List() *StorageDomainDisksServiceListRequest {
	return &StorageDomainDisksServiceListRequest{StorageDomainDisksService: p}
}

//
// A reference to the service that manages a specific disk.
//
func (op *StorageDomainDisksService) DiskService(id string) *StorageDomainDiskService {
	return NewStorageDomainDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainDisksService) String() string {
	return fmt.Sprintf("StorageDomainDisksService:%s", op.path)
}

//
// A service to manage a data center.
//
type DataCenterService struct {
	BaseService
}

func NewDataCenterService(connection *Connection, path string) *DataCenterService {
	var result DataCenterService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get a data center.
// An example of getting a data center:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123
// ----
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <storage_format>v3</storage_format>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//    </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <mac_pool href="/ovirt-engine/api/macpools/456" id="456"/>
// </data_center>
// ----
//
type DataCenterServiceGetRequest struct {
	DataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	filter            *bool
	follow            *string
}

func (p *DataCenterServiceGetRequest) Header(key, value string) *DataCenterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceGetRequest) Query(key, value string) *DataCenterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceGetRequest) Filter(filter bool) *DataCenterServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *DataCenterServiceGetRequest) Follow(follow string) *DataCenterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DataCenterServiceGetRequest) Send() (*DataCenterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCenterService.connection.URL(), p.DataCenterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCenterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCenterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCenterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCenterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCenterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DataCenterServiceGetResponse{dataCenter: result}, nil
}

func (p *DataCenterServiceGetRequest) MustSend() *DataCenterServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get a data center.
// An example of getting a data center:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123
// ----
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <storage_format>v3</storage_format>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//    </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <mac_pool href="/ovirt-engine/api/macpools/456" id="456"/>
// </data_center>
// ----
//
type DataCenterServiceGetResponse struct {
	dataCenter *DataCenter
}

func (p *DataCenterServiceGetResponse) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *DataCenterServiceGetResponse) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("dataCenter in response does not exist")
	}
	return p.dataCenter
}

//
// Get a data center.
// An example of getting a data center:
// [source]
// ----
// GET /ovirt-engine/api/datacenters/123
// ----
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <storage_format>v3</storage_format>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//    </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
//   <mac_pool href="/ovirt-engine/api/macpools/456" id="456"/>
// </data_center>
// ----
//
func (p *DataCenterService) Get() *DataCenterServiceGetRequest {
	return &DataCenterServiceGetRequest{DataCenterService: p}
}

//
// Removes the data center.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123
// ----
// Without any special parameters, the storage domains attached to the data center are detached and then removed
// from the storage. If something fails when performing this operation, for example if there is no host available to
// remove the storage domains from the storage, the complete operation will fail.
// If the `force` parameter is `true` then the operation will always succeed, even if something fails while removing
// one storage domain, for example. The failure is just ignored and the data center is removed from the database
// anyway.
//
type DataCenterServiceRemoveRequest struct {
	DataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	async             *bool
	force             *bool
}

func (p *DataCenterServiceRemoveRequest) Header(key, value string) *DataCenterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceRemoveRequest) Query(key, value string) *DataCenterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceRemoveRequest) Async(async bool) *DataCenterServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *DataCenterServiceRemoveRequest) Force(force bool) *DataCenterServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *DataCenterServiceRemoveRequest) Send() (*DataCenterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCenterService.connection.URL(), p.DataCenterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCenterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCenterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCenterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCenterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCenterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DataCenterServiceRemoveResponse), nil
}

func (p *DataCenterServiceRemoveRequest) MustSend() *DataCenterServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the data center.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123
// ----
// Without any special parameters, the storage domains attached to the data center are detached and then removed
// from the storage. If something fails when performing this operation, for example if there is no host available to
// remove the storage domains from the storage, the complete operation will fail.
// If the `force` parameter is `true` then the operation will always succeed, even if something fails while removing
// one storage domain, for example. The failure is just ignored and the data center is removed from the database
// anyway.
//
type DataCenterServiceRemoveResponse struct {
}

//
// Removes the data center.
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123
// ----
// Without any special parameters, the storage domains attached to the data center are detached and then removed
// from the storage. If something fails when performing this operation, for example if there is no host available to
// remove the storage domains from the storage, the complete operation will fail.
// If the `force` parameter is `true` then the operation will always succeed, even if something fails while removing
// one storage domain, for example. The failure is just ignored and the data center is removed from the database
// anyway.
//
func (p *DataCenterService) Remove() *DataCenterServiceRemoveRequest {
	return &DataCenterServiceRemoveRequest{DataCenterService: p}
}

//
// Updates the data center.
// The `name`, `description`, `storage_type`, `version`, `storage_format` and `mac_pool` elements are updatable
// post-creation. For example, to change the name and description of data center `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>myupdatedname</name>
//   <description>An updated description for the data center</description>
// </data_center>
// ----
//
type DataCenterServiceUpdateRequest struct {
	DataCenterService *DataCenterService
	header            map[string]string
	query             map[string]string
	async             *bool
	dataCenter        *DataCenter
}

func (p *DataCenterServiceUpdateRequest) Header(key, value string) *DataCenterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterServiceUpdateRequest) Query(key, value string) *DataCenterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterServiceUpdateRequest) Async(async bool) *DataCenterServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *DataCenterServiceUpdateRequest) DataCenter(dataCenter *DataCenter) *DataCenterServiceUpdateRequest {
	p.dataCenter = dataCenter
	return p
}

func (p *DataCenterServiceUpdateRequest) Send() (*DataCenterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCenterService.connection.URL(), p.DataCenterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDataCenterWriteOne(writer, p.dataCenter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCenterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCenterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCenterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCenterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCenterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DataCenterServiceUpdateResponse{dataCenter: result}, nil
}

func (p *DataCenterServiceUpdateRequest) MustSend() *DataCenterServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the data center.
// The `name`, `description`, `storage_type`, `version`, `storage_format` and `mac_pool` elements are updatable
// post-creation. For example, to change the name and description of data center `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>myupdatedname</name>
//   <description>An updated description for the data center</description>
// </data_center>
// ----
//
type DataCenterServiceUpdateResponse struct {
	dataCenter *DataCenter
}

func (p *DataCenterServiceUpdateResponse) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *DataCenterServiceUpdateResponse) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("dataCenter in response does not exist")
	}
	return p.dataCenter
}

//
// Updates the data center.
// The `name`, `description`, `storage_type`, `version`, `storage_format` and `mac_pool` elements are updatable
// post-creation. For example, to change the name and description of data center `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>myupdatedname</name>
//   <description>An updated description for the data center</description>
// </data_center>
// ----
//
func (p *DataCenterService) Update() *DataCenterServiceUpdateRequest {
	return &DataCenterServiceUpdateRequest{DataCenterService: p}
}

//
//
func (op *DataCenterService) ClustersService() *ClustersService {
	return NewClustersService(op.connection, fmt.Sprintf("%s/clusters", op.path))
}

//
// Reference to the iSCSI bonds service.
//
func (op *DataCenterService) IscsiBondsService() *IscsiBondsService {
	return NewIscsiBondsService(op.connection, fmt.Sprintf("%s/iscsibonds", op.path))
}

//
// Returns a reference to the service, that manages the networks, that are associated with the data center.
//
func (op *DataCenterService) NetworksService() *DataCenterNetworksService {
	return NewDataCenterNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
// Reference to the permissions service.
//
func (op *DataCenterService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Reference to the QOSs service.
//
func (op *DataCenterService) QossService() *QossService {
	return NewQossService(op.connection, fmt.Sprintf("%s/qoss", op.path))
}

//
// Reference to the quotas service.
//
func (op *DataCenterService) QuotasService() *QuotasService {
	return NewQuotasService(op.connection, fmt.Sprintf("%s/quotas", op.path))
}

//
// Attach and detach storage domains to and from a data center.
// For attaching a single storage domain we should use the following POST request:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/storagedomains
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_domain>
//   <name>data1</name>
// </storage_domain>
// ----
// For detaching a single storage domain we should use the following DELETE request:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/storagedomains/123
// ----
//
func (op *DataCenterService) StorageDomainsService() *AttachedStorageDomainsService {
	return NewAttachedStorageDomainsService(op.connection, fmt.Sprintf("%s/storagedomains", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DataCenterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "clusters" {
		return op.ClustersService(), nil
	}
	if strings.HasPrefix(path, "clusters/") {
		return op.ClustersService().Service(path[9:])
	}
	if path == "iscsibonds" {
		return op.IscsiBondsService(), nil
	}
	if strings.HasPrefix(path, "iscsibonds/") {
		return op.IscsiBondsService().Service(path[11:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "qoss" {
		return op.QossService(), nil
	}
	if strings.HasPrefix(path, "qoss/") {
		return op.QossService().Service(path[5:])
	}
	if path == "quotas" {
		return op.QuotasService(), nil
	}
	if strings.HasPrefix(path, "quotas/") {
		return op.QuotasService().Service(path[7:])
	}
	if path == "storagedomains" {
		return op.StorageDomainsService(), nil
	}
	if strings.HasPrefix(path, "storagedomains/") {
		return op.StorageDomainsService().Service(path[15:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DataCenterService) String() string {
	return fmt.Sprintf("DataCenterService:%s", op.path)
}

//
//
type NetworkAttachmentService struct {
	BaseService
}

func NewNetworkAttachmentService(connection *Connection, path string) *NetworkAttachmentService {
	var result NetworkAttachmentService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type NetworkAttachmentServiceGetRequest struct {
	NetworkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *NetworkAttachmentServiceGetRequest) Header(key, value string) *NetworkAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceGetRequest) Query(key, value string) *NetworkAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceGetRequest) Follow(follow string) *NetworkAttachmentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *NetworkAttachmentServiceGetRequest) Send() (*NetworkAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkAttachmentService.connection.URL(), p.NetworkAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworkAttachmentServiceGetResponse{attachment: result}, nil
}

func (p *NetworkAttachmentServiceGetRequest) MustSend() *NetworkAttachmentServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type NetworkAttachmentServiceGetResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentServiceGetResponse) Attachment() (*NetworkAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *NetworkAttachmentServiceGetResponse) MustAttachment() *NetworkAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
//
func (p *NetworkAttachmentService) Get() *NetworkAttachmentServiceGetRequest {
	return &NetworkAttachmentServiceGetRequest{NetworkAttachmentService: p}
}

//
//
type NetworkAttachmentServiceRemoveRequest struct {
	NetworkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *NetworkAttachmentServiceRemoveRequest) Header(key, value string) *NetworkAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceRemoveRequest) Query(key, value string) *NetworkAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceRemoveRequest) Async(async bool) *NetworkAttachmentServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *NetworkAttachmentServiceRemoveRequest) Send() (*NetworkAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkAttachmentService.connection.URL(), p.NetworkAttachmentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(NetworkAttachmentServiceRemoveResponse), nil
}

func (p *NetworkAttachmentServiceRemoveRequest) MustSend() *NetworkAttachmentServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type NetworkAttachmentServiceRemoveResponse struct {
}

//
//
func (p *NetworkAttachmentService) Remove() *NetworkAttachmentServiceRemoveRequest {
	return &NetworkAttachmentServiceRemoveRequest{NetworkAttachmentService: p}
}

//
// Update the specified network attachment on the host.
//
type NetworkAttachmentServiceUpdateRequest struct {
	NetworkAttachmentService *NetworkAttachmentService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
	attachment               *NetworkAttachment
}

func (p *NetworkAttachmentServiceUpdateRequest) Header(key, value string) *NetworkAttachmentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentServiceUpdateRequest) Query(key, value string) *NetworkAttachmentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentServiceUpdateRequest) Async(async bool) *NetworkAttachmentServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *NetworkAttachmentServiceUpdateRequest) Attachment(attachment *NetworkAttachment) *NetworkAttachmentServiceUpdateRequest {
	p.attachment = attachment
	return p
}

func (p *NetworkAttachmentServiceUpdateRequest) Send() (*NetworkAttachmentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkAttachmentService.connection.URL(), p.NetworkAttachmentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworkAttachmentServiceUpdateResponse{attachment: result}, nil
}

func (p *NetworkAttachmentServiceUpdateRequest) MustSend() *NetworkAttachmentServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified network attachment on the host.
//
type NetworkAttachmentServiceUpdateResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentServiceUpdateResponse) Attachment() (*NetworkAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *NetworkAttachmentServiceUpdateResponse) MustAttachment() *NetworkAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Update the specified network attachment on the host.
//
func (p *NetworkAttachmentService) Update() *NetworkAttachmentServiceUpdateRequest {
	return &NetworkAttachmentServiceUpdateRequest{NetworkAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkAttachmentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkAttachmentService) String() string {
	return fmt.Sprintf("NetworkAttachmentService:%s", op.path)
}

//
// A service to manage events in the system.
//
type EventsService struct {
	BaseService
}

func NewEventsService(connection *Connection, path string) *EventsService {
	var result EventsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds an external event to the internal audit log.
// This is intended for integration with external systems that detect or produce events relevant for the
// administrator of the system. For example, an external monitoring tool may be able to detect that a file system
// is full inside the guest operating system of a virtual machine. This event can be added to the internal audit
// log sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
// </event>
// ----
// Events can also be linked to specific objects. For example, the above event could be linked to the specific
// virtual machine where it happened, using the `vm` link:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
//   <vm id="aae98225-5b73-490d-a252-899209af17e9"/>
// </event>
// ----
// NOTE: When using links, like the `vm` in the previous example, only the `id` attribute is accepted. The `name`
// attribute, if provided, is simply ignored.
//
type EventsServiceAddRequest struct {
	EventsService *EventsService
	header        map[string]string
	query         map[string]string
	event         *Event
}

func (p *EventsServiceAddRequest) Header(key, value string) *EventsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceAddRequest) Query(key, value string) *EventsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceAddRequest) Event(event *Event) *EventsServiceAddRequest {
	p.event = event
	return p
}

func (p *EventsServiceAddRequest) Send() (*EventsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EventsService.connection.URL(), p.EventsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLEventWriteOne(writer, p.event, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &EventsServiceAddResponse{event: result}, nil
}

func (p *EventsServiceAddRequest) MustSend() *EventsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds an external event to the internal audit log.
// This is intended for integration with external systems that detect or produce events relevant for the
// administrator of the system. For example, an external monitoring tool may be able to detect that a file system
// is full inside the guest operating system of a virtual machine. This event can be added to the internal audit
// log sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
// </event>
// ----
// Events can also be linked to specific objects. For example, the above event could be linked to the specific
// virtual machine where it happened, using the `vm` link:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
//   <vm id="aae98225-5b73-490d-a252-899209af17e9"/>
// </event>
// ----
// NOTE: When using links, like the `vm` in the previous example, only the `id` attribute is accepted. The `name`
// attribute, if provided, is simply ignored.
//
type EventsServiceAddResponse struct {
	event *Event
}

func (p *EventsServiceAddResponse) Event() (*Event, bool) {
	if p.event != nil {
		return p.event, true
	}
	return nil, false
}

func (p *EventsServiceAddResponse) MustEvent() *Event {
	if p.event == nil {
		panic("event in response does not exist")
	}
	return p.event
}

//
// Adds an external event to the internal audit log.
// This is intended for integration with external systems that detect or produce events relevant for the
// administrator of the system. For example, an external monitoring tool may be able to detect that a file system
// is full inside the guest operating system of a virtual machine. This event can be added to the internal audit
// log sending a request like this:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
// </event>
// ----
// Events can also be linked to specific objects. For example, the above event could be linked to the specific
// virtual machine where it happened, using the `vm` link:
// [source]
// ----
// POST /ovirt-engine/api/events
// <event>
//   <description>File system /home is full</description>
//   <severity>alert</severity>
//   <origin>mymonitor</origin>
//   <custom_id>1467879754</custom_id>
//   <vm id="aae98225-5b73-490d-a252-899209af17e9"/>
// </event>
// ----
// NOTE: When using links, like the `vm` in the previous example, only the `id` attribute is accepted. The `name`
// attribute, if provided, is simply ignored.
//
func (p *EventsService) Add() *EventsServiceAddRequest {
	return &EventsServiceAddRequest{EventsService: p}
}

//
// Get list of events.
// [source]
// ----
// GET /ovirt-engine/api/events
// ----
// To the above request we get following response:
// [source,xml]
// ----
// <events>
//   <event href="/ovirt-engine/api/events/2" id="2">
//     <description>User admin@internal-authz logged out.</description>
//     <code>31</code>
//     <correlation_id>1e892ea9</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T12:14:34.541+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
//   <event href="/ovirt-engine/api/events/1" id="1">
//     <description>User admin logged in.</description>
//     <code>30</code>
//     <correlation_id>1fbd81f4</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:54:35.229+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
// </events>
// ----
// The following events occur:
// * id="1" - The API logs in the admin user account.
// * id="2" - The API logs out of the admin user account.
// The order of the returned list of events is always garanteed. If the `sortby` clause is included in the
// `search` parameter, then the events will be ordered according to that clause. If the `sortby` clause isn't
// included, then the events will be sorted by the numeric value of the `id` attribute, starting with the
// highest value. This, combined with the `max` parameter, simplifies obtaining the most recent event:
// ....
// GET /ovirt-engine/api/events?max=1
// ....
//
type EventsServiceListRequest struct {
	EventsService *EventsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	from          *int64
	max           *int64
	search        *string
}

func (p *EventsServiceListRequest) Header(key, value string) *EventsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceListRequest) Query(key, value string) *EventsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceListRequest) CaseSensitive(caseSensitive bool) *EventsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *EventsServiceListRequest) Follow(follow string) *EventsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *EventsServiceListRequest) From(from int64) *EventsServiceListRequest {
	p.from = &from
	return p
}

func (p *EventsServiceListRequest) Max(max int64) *EventsServiceListRequest {
	p.max = &max
	return p
}

func (p *EventsServiceListRequest) Search(search string) *EventsServiceListRequest {
	p.search = &search
	return p
}

func (p *EventsServiceListRequest) Send() (*EventsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EventsService.connection.URL(), p.EventsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.from != nil {
		values["from"] = []string{fmt.Sprintf("%v", *p.from)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &EventsServiceListResponse{events: result}, nil
}

func (p *EventsServiceListRequest) MustSend() *EventsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get list of events.
// [source]
// ----
// GET /ovirt-engine/api/events
// ----
// To the above request we get following response:
// [source,xml]
// ----
// <events>
//   <event href="/ovirt-engine/api/events/2" id="2">
//     <description>User admin@internal-authz logged out.</description>
//     <code>31</code>
//     <correlation_id>1e892ea9</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T12:14:34.541+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
//   <event href="/ovirt-engine/api/events/1" id="1">
//     <description>User admin logged in.</description>
//     <code>30</code>
//     <correlation_id>1fbd81f4</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:54:35.229+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
// </events>
// ----
// The following events occur:
// * id="1" - The API logs in the admin user account.
// * id="2" - The API logs out of the admin user account.
// The order of the returned list of events is always garanteed. If the `sortby` clause is included in the
// `search` parameter, then the events will be ordered according to that clause. If the `sortby` clause isn't
// included, then the events will be sorted by the numeric value of the `id` attribute, starting with the
// highest value. This, combined with the `max` parameter, simplifies obtaining the most recent event:
// ....
// GET /ovirt-engine/api/events?max=1
// ....
//
type EventsServiceListResponse struct {
	events *EventSlice
}

func (p *EventsServiceListResponse) Events() (*EventSlice, bool) {
	if p.events != nil {
		return p.events, true
	}
	return nil, false
}

func (p *EventsServiceListResponse) MustEvents() *EventSlice {
	if p.events == nil {
		panic("events in response does not exist")
	}
	return p.events
}

//
// Get list of events.
// [source]
// ----
// GET /ovirt-engine/api/events
// ----
// To the above request we get following response:
// [source,xml]
// ----
// <events>
//   <event href="/ovirt-engine/api/events/2" id="2">
//     <description>User admin@internal-authz logged out.</description>
//     <code>31</code>
//     <correlation_id>1e892ea9</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T12:14:34.541+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
//   <event href="/ovirt-engine/api/events/1" id="1">
//     <description>User admin logged in.</description>
//     <code>30</code>
//     <correlation_id>1fbd81f4</correlation_id>
//     <custom_id>-1</custom_id>
//     <flood_rate>30</flood_rate>
//     <origin>oVirt</origin>
//     <severity>normal</severity>
//     <time>2016-09-14T11:54:35.229+02:00</time>
//     <user href="/ovirt-engine/api/users/57d91d48-00da-0137-0138-000000000244" id="57d91d48-00da-0137-0138-000000000244"/>
//   </event>
// </events>
// ----
// The following events occur:
// * id="1" - The API logs in the admin user account.
// * id="2" - The API logs out of the admin user account.
// The order of the returned list of events is always garanteed. If the `sortby` clause is included in the
// `search` parameter, then the events will be ordered according to that clause. If the `sortby` clause isn't
// included, then the events will be sorted by the numeric value of the `id` attribute, starting with the
// highest value. This, combined with the `max` parameter, simplifies obtaining the most recent event:
// ....
// GET /ovirt-engine/api/events?max=1
// ....
//
func (p *EventsService) List() *EventsServiceListRequest {
	return &EventsServiceListRequest{EventsService: p}
}

//
//
type EventsServiceUndeleteRequest struct {
	EventsService *EventsService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *EventsServiceUndeleteRequest) Header(key, value string) *EventsServiceUndeleteRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventsServiceUndeleteRequest) Query(key, value string) *EventsServiceUndeleteRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventsServiceUndeleteRequest) Async(async bool) *EventsServiceUndeleteRequest {
	p.async = &async
	return p
}

func (p *EventsServiceUndeleteRequest) Send() (*EventsServiceUndeleteResponse, error) {
	rawURL := fmt.Sprintf("%s%s/undelete", p.EventsService.connection.URL(), p.EventsService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(EventsServiceUndeleteResponse), nil
}

func (p *EventsServiceUndeleteRequest) MustSend() *EventsServiceUndeleteResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type EventsServiceUndeleteResponse struct {
}

//
//
func (p *EventsService) Undelete() *EventsServiceUndeleteRequest {
	return &EventsServiceUndeleteRequest{EventsService: p}
}

//
// Reference to the service that manages a specific event.
//
func (op *EventsService) EventService(id string) *EventService {
	return NewEventService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EventsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.EventService(path), nil
	}
	return op.EventService(path[:index]).Service(path[index+1:])
}

func (op *EventsService) String() string {
	return fmt.Sprintf("EventsService:%s", op.path)
}

//
// This service manages a collection of all virtual machine labels assigned to an affinity group.
//
type AffinityGroupVmLabelsService struct {
	BaseService
}

func NewAffinityGroupVmLabelsService(connection *Connection, path string) *AffinityGroupVmLabelsService {
	var result AffinityGroupVmLabelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a virtual machine label to the affinity group.
// For example, to add the label `789` to the affinity group `456` of cluster `123`,
// send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vmlabels
// ....
// With the following body:
// [source,xml]
// ----
// <affinity_label id="789"/>
// ----
//
type AffinityGroupVmLabelsServiceAddRequest struct {
	AffinityGroupVmLabelsService *AffinityGroupVmLabelsService
	header                       map[string]string
	query                        map[string]string
	label                        *AffinityLabel
}

func (p *AffinityGroupVmLabelsServiceAddRequest) Header(key, value string) *AffinityGroupVmLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmLabelsServiceAddRequest) Query(key, value string) *AffinityGroupVmLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmLabelsServiceAddRequest) Label(label *AffinityLabel) *AffinityGroupVmLabelsServiceAddRequest {
	p.label = label
	return p
}

func (p *AffinityGroupVmLabelsServiceAddRequest) Send() (*AffinityGroupVmLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupVmLabelsService.connection.URL(), p.AffinityGroupVmLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupVmLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupVmLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupVmLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupVmLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupVmLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityGroupVmLabelsServiceAddResponse{label: result}, nil
}

func (p *AffinityGroupVmLabelsServiceAddRequest) MustSend() *AffinityGroupVmLabelsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a virtual machine label to the affinity group.
// For example, to add the label `789` to the affinity group `456` of cluster `123`,
// send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vmlabels
// ....
// With the following body:
// [source,xml]
// ----
// <affinity_label id="789"/>
// ----
//
type AffinityGroupVmLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *AffinityGroupVmLabelsServiceAddResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *AffinityGroupVmLabelsServiceAddResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Adds a virtual machine label to the affinity group.
// For example, to add the label `789` to the affinity group `456` of cluster `123`,
// send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vmlabels
// ....
// With the following body:
// [source,xml]
// ----
// <affinity_label id="789"/>
// ----
//
func (p *AffinityGroupVmLabelsService) Add() *AffinityGroupVmLabelsServiceAddRequest {
	return &AffinityGroupVmLabelsServiceAddRequest{AffinityGroupVmLabelsService: p}
}

//
// List all virtual machine labels assigned to this affinity group.
// The order of the returned labels isn't guaranteed.
//
type AffinityGroupVmLabelsServiceListRequest struct {
	AffinityGroupVmLabelsService *AffinityGroupVmLabelsService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
	max                          *int64
}

func (p *AffinityGroupVmLabelsServiceListRequest) Header(key, value string) *AffinityGroupVmLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmLabelsServiceListRequest) Query(key, value string) *AffinityGroupVmLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmLabelsServiceListRequest) Follow(follow string) *AffinityGroupVmLabelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AffinityGroupVmLabelsServiceListRequest) Max(max int64) *AffinityGroupVmLabelsServiceListRequest {
	p.max = &max
	return p
}

func (p *AffinityGroupVmLabelsServiceListRequest) Send() (*AffinityGroupVmLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupVmLabelsService.connection.URL(), p.AffinityGroupVmLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupVmLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupVmLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupVmLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupVmLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupVmLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AffinityGroupVmLabelsServiceListResponse{labels: result}, nil
}

func (p *AffinityGroupVmLabelsServiceListRequest) MustSend() *AffinityGroupVmLabelsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all virtual machine labels assigned to this affinity group.
// The order of the returned labels isn't guaranteed.
//
type AffinityGroupVmLabelsServiceListResponse struct {
	labels *AffinityLabelSlice
}

func (p *AffinityGroupVmLabelsServiceListResponse) Labels() (*AffinityLabelSlice, bool) {
	if p.labels != nil {
		return p.labels, true
	}
	return nil, false
}

func (p *AffinityGroupVmLabelsServiceListResponse) MustLabels() *AffinityLabelSlice {
	if p.labels == nil {
		panic("labels in response does not exist")
	}
	return p.labels
}

//
// List all virtual machine labels assigned to this affinity group.
// The order of the returned labels isn't guaranteed.
//
func (p *AffinityGroupVmLabelsService) List() *AffinityGroupVmLabelsServiceListRequest {
	return &AffinityGroupVmLabelsServiceListRequest{AffinityGroupVmLabelsService: p}
}

//
// Access the service that manages the virtual machine label assignment to this affinity group.
//
func (op *AffinityGroupVmLabelsService) LabelService(id string) *AffinityGroupVmLabelService {
	return NewAffinityGroupVmLabelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupVmLabelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LabelService(path), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupVmLabelsService) String() string {
	return fmt.Sprintf("AffinityGroupVmLabelsService:%s", op.path)
}

//
// Manages the storage domains attached to a data center.
//
type AttachedStorageDomainsService struct {
	BaseService
}

func NewAttachedStorageDomainsService(connection *Connection, path string) *AttachedStorageDomainsService {
	var result AttachedStorageDomainsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Attaches an existing storage domain to the data center.
//
type AttachedStorageDomainsServiceAddRequest struct {
	AttachedStorageDomainsService *AttachedStorageDomainsService
	header                        map[string]string
	query                         map[string]string
	storageDomain                 *StorageDomain
}

func (p *AttachedStorageDomainsServiceAddRequest) Header(key, value string) *AttachedStorageDomainsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceAddRequest) Query(key, value string) *AttachedStorageDomainsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceAddRequest) StorageDomain(storageDomain *StorageDomain) *AttachedStorageDomainsServiceAddRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *AttachedStorageDomainsServiceAddRequest) Send() (*AttachedStorageDomainsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainsService.connection.URL(), p.AttachedStorageDomainsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AttachedStorageDomainsServiceAddResponse{storageDomain: result}, nil
}

func (p *AttachedStorageDomainsServiceAddRequest) MustSend() *AttachedStorageDomainsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Attaches an existing storage domain to the data center.
//
type AttachedStorageDomainsServiceAddResponse struct {
	storageDomain *StorageDomain
}

func (p *AttachedStorageDomainsServiceAddResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *AttachedStorageDomainsServiceAddResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Attaches an existing storage domain to the data center.
//
func (p *AttachedStorageDomainsService) Add() *AttachedStorageDomainsServiceAddRequest {
	return &AttachedStorageDomainsServiceAddRequest{AttachedStorageDomainsService: p}
}

//
// Returns the list of storage domains attached to the data center.
// The order of the returned storage domains isn't guaranteed.
//
type AttachedStorageDomainsServiceListRequest struct {
	AttachedStorageDomainsService *AttachedStorageDomainsService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
	max                           *int64
}

func (p *AttachedStorageDomainsServiceListRequest) Header(key, value string) *AttachedStorageDomainsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceListRequest) Query(key, value string) *AttachedStorageDomainsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainsServiceListRequest) Follow(follow string) *AttachedStorageDomainsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AttachedStorageDomainsServiceListRequest) Max(max int64) *AttachedStorageDomainsServiceListRequest {
	p.max = &max
	return p
}

func (p *AttachedStorageDomainsServiceListRequest) Send() (*AttachedStorageDomainsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainsService.connection.URL(), p.AttachedStorageDomainsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AttachedStorageDomainsServiceListResponse{storageDomains: result}, nil
}

func (p *AttachedStorageDomainsServiceListRequest) MustSend() *AttachedStorageDomainsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of storage domains attached to the data center.
// The order of the returned storage domains isn't guaranteed.
//
type AttachedStorageDomainsServiceListResponse struct {
	storageDomains *StorageDomainSlice
}

func (p *AttachedStorageDomainsServiceListResponse) StorageDomains() (*StorageDomainSlice, bool) {
	if p.storageDomains != nil {
		return p.storageDomains, true
	}
	return nil, false
}

func (p *AttachedStorageDomainsServiceListResponse) MustStorageDomains() *StorageDomainSlice {
	if p.storageDomains == nil {
		panic("storageDomains in response does not exist")
	}
	return p.storageDomains
}

//
// Returns the list of storage domains attached to the data center.
// The order of the returned storage domains isn't guaranteed.
//
func (p *AttachedStorageDomainsService) List() *AttachedStorageDomainsServiceListRequest {
	return &AttachedStorageDomainsServiceListRequest{AttachedStorageDomainsService: p}
}

//
//
func (op *AttachedStorageDomainsService) StorageDomainService(id string) *AttachedStorageDomainService {
	return NewAttachedStorageDomainService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageDomainService(path), nil
	}
	return op.StorageDomainService(path[:index]).Service(path[index+1:])
}

func (op *AttachedStorageDomainsService) String() string {
	return fmt.Sprintf("AttachedStorageDomainsService:%s", op.path)
}

//
//
type PermissionService struct {
	BaseService
}

func NewPermissionService(connection *Connection, path string) *PermissionService {
	var result PermissionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type PermissionServiceGetRequest struct {
	PermissionService *PermissionService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *PermissionServiceGetRequest) Header(key, value string) *PermissionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermissionServiceGetRequest) Query(key, value string) *PermissionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermissionServiceGetRequest) Follow(follow string) *PermissionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *PermissionServiceGetRequest) Send() (*PermissionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.PermissionService.connection.URL(), p.PermissionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.PermissionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.PermissionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.PermissionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.PermissionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.PermissionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLPermissionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &PermissionServiceGetResponse{permission: result}, nil
}

func (p *PermissionServiceGetRequest) MustSend() *PermissionServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type PermissionServiceGetResponse struct {
	permission *Permission
}

func (p *PermissionServiceGetResponse) Permission() (*Permission, bool) {
	if p.permission != nil {
		return p.permission, true
	}
	return nil, false
}

func (p *PermissionServiceGetResponse) MustPermission() *Permission {
	if p.permission == nil {
		panic("permission in response does not exist")
	}
	return p.permission
}

//
//
func (p *PermissionService) Get() *PermissionServiceGetRequest {
	return &PermissionServiceGetRequest{PermissionService: p}
}

//
//
type PermissionServiceRemoveRequest struct {
	PermissionService *PermissionService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *PermissionServiceRemoveRequest) Header(key, value string) *PermissionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *PermissionServiceRemoveRequest) Query(key, value string) *PermissionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *PermissionServiceRemoveRequest) Async(async bool) *PermissionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *PermissionServiceRemoveRequest) Send() (*PermissionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.PermissionService.connection.URL(), p.PermissionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.PermissionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.PermissionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.PermissionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.PermissionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.PermissionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(PermissionServiceRemoveResponse), nil
}

func (p *PermissionServiceRemoveRequest) MustSend() *PermissionServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type PermissionServiceRemoveResponse struct {
}

//
//
func (p *PermissionService) Remove() *PermissionServiceRemoveRequest {
	return &PermissionServiceRemoveRequest{PermissionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *PermissionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *PermissionService) String() string {
	return fmt.Sprintf("PermissionService:%s", op.path)
}

//
// A service to manage a specific tag in the system.
//
type TagService struct {
	BaseService
}

func NewTagService(connection *Connection, path string) *TagService {
	var result TagService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the information about the tag.
// For example to retrieve the information about the tag with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/tags/123
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/123" id="123">
//   <name>root</name>
//   <description>root</description>
// </tag>
// ----
//
type TagServiceGetRequest struct {
	TagService *TagService
	header     map[string]string
	query      map[string]string
	follow     *string
}

func (p *TagServiceGetRequest) Header(key, value string) *TagServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceGetRequest) Query(key, value string) *TagServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceGetRequest) Follow(follow string) *TagServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *TagServiceGetRequest) Send() (*TagServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TagService.connection.URL(), p.TagService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TagService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TagService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TagService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TagServiceGetResponse{tag: result}, nil
}

func (p *TagServiceGetRequest) MustSend() *TagServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the information about the tag.
// For example to retrieve the information about the tag with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/tags/123
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/123" id="123">
//   <name>root</name>
//   <description>root</description>
// </tag>
// ----
//
type TagServiceGetResponse struct {
	tag *Tag
}

func (p *TagServiceGetResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *TagServiceGetResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Gets the information about the tag.
// For example to retrieve the information about the tag with the id `123` send a request like this:
// ....
// GET /ovirt-engine/api/tags/123
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/123" id="123">
//   <name>root</name>
//   <description>root</description>
// </tag>
// ----
//
func (p *TagService) Get() *TagServiceGetRequest {
	return &TagServiceGetRequest{TagService: p}
}

//
// Removes the tag from the system.
// For example to remove the tag with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/tags/123
// ....
//
type TagServiceRemoveRequest struct {
	TagService *TagService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *TagServiceRemoveRequest) Header(key, value string) *TagServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceRemoveRequest) Query(key, value string) *TagServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceRemoveRequest) Async(async bool) *TagServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *TagServiceRemoveRequest) Send() (*TagServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TagService.connection.URL(), p.TagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TagService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TagService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TagService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TagServiceRemoveResponse), nil
}

func (p *TagServiceRemoveRequest) MustSend() *TagServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the tag from the system.
// For example to remove the tag with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/tags/123
// ....
//
type TagServiceRemoveResponse struct {
}

//
// Removes the tag from the system.
// For example to remove the tag with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/tags/123
// ....
//
func (p *TagService) Remove() *TagServiceRemoveRequest {
	return &TagServiceRemoveRequest{TagService: p}
}

//
// Updates the tag entity.
// For example to update parent tag to tag with id `456` of the tag with id `123` send a request like this:
// ....
// PUT /ovirt-engine/api/tags/123
// ....
// With request body like:
// [source,xml]
// ----
// <tag>
//   <parent id="456"/>
// </tag>
// ----
// You may also specify a tag name instead of id. For example to update parent tag to tag with name `mytag`
// of the tag with id `123` send a request like this:
// [source,xml]
// ----
// <tag>
//   <parent>
//     <name>mytag</name>
//   </parent>
// </tag>
// ----
//
type TagServiceUpdateRequest struct {
	TagService *TagService
	header     map[string]string
	query      map[string]string
	async      *bool
	tag        *Tag
}

func (p *TagServiceUpdateRequest) Header(key, value string) *TagServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagServiceUpdateRequest) Query(key, value string) *TagServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagServiceUpdateRequest) Async(async bool) *TagServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *TagServiceUpdateRequest) Tag(tag *Tag) *TagServiceUpdateRequest {
	p.tag = tag
	return p
}

func (p *TagServiceUpdateRequest) Send() (*TagServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TagService.connection.URL(), p.TagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TagService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TagService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TagService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TagServiceUpdateResponse{tag: result}, nil
}

func (p *TagServiceUpdateRequest) MustSend() *TagServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the tag entity.
// For example to update parent tag to tag with id `456` of the tag with id `123` send a request like this:
// ....
// PUT /ovirt-engine/api/tags/123
// ....
// With request body like:
// [source,xml]
// ----
// <tag>
//   <parent id="456"/>
// </tag>
// ----
// You may also specify a tag name instead of id. For example to update parent tag to tag with name `mytag`
// of the tag with id `123` send a request like this:
// [source,xml]
// ----
// <tag>
//   <parent>
//     <name>mytag</name>
//   </parent>
// </tag>
// ----
//
type TagServiceUpdateResponse struct {
	tag *Tag
}

func (p *TagServiceUpdateResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *TagServiceUpdateResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Updates the tag entity.
// For example to update parent tag to tag with id `456` of the tag with id `123` send a request like this:
// ....
// PUT /ovirt-engine/api/tags/123
// ....
// With request body like:
// [source,xml]
// ----
// <tag>
//   <parent id="456"/>
// </tag>
// ----
// You may also specify a tag name instead of id. For example to update parent tag to tag with name `mytag`
// of the tag with id `123` send a request like this:
// [source,xml]
// ----
// <tag>
//   <parent>
//     <name>mytag</name>
//   </parent>
// </tag>
// ----
//
func (p *TagService) Update() *TagServiceUpdateRequest {
	return &TagServiceUpdateRequest{TagService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TagService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TagService) String() string {
	return fmt.Sprintf("TagService:%s", op.path)
}

//
// Lists the CD-ROM devices of a template.
//
type TemplateCdromsService struct {
	BaseService
}

func NewTemplateCdromsService(connection *Connection, path string) *TemplateCdromsService {
	var result TemplateCdromsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of CD-ROM devices of the template.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type TemplateCdromsServiceListRequest struct {
	TemplateCdromsService *TemplateCdromsService
	header                map[string]string
	query                 map[string]string
	follow                *string
	max                   *int64
}

func (p *TemplateCdromsServiceListRequest) Header(key, value string) *TemplateCdromsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateCdromsServiceListRequest) Query(key, value string) *TemplateCdromsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateCdromsServiceListRequest) Follow(follow string) *TemplateCdromsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *TemplateCdromsServiceListRequest) Max(max int64) *TemplateCdromsServiceListRequest {
	p.max = &max
	return p
}

func (p *TemplateCdromsServiceListRequest) Send() (*TemplateCdromsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateCdromsService.connection.URL(), p.TemplateCdromsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateCdromsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateCdromsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateCdromsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateCdromsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateCdromsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &TemplateCdromsServiceListResponse{cdroms: result}, nil
}

func (p *TemplateCdromsServiceListRequest) MustSend() *TemplateCdromsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of CD-ROM devices of the template.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
type TemplateCdromsServiceListResponse struct {
	cdroms *CdromSlice
}

func (p *TemplateCdromsServiceListResponse) Cdroms() (*CdromSlice, bool) {
	if p.cdroms != nil {
		return p.cdroms, true
	}
	return nil, false
}

func (p *TemplateCdromsServiceListResponse) MustCdroms() *CdromSlice {
	if p.cdroms == nil {
		panic("cdroms in response does not exist")
	}
	return p.cdroms
}

//
// Returns the list of CD-ROM devices of the template.
// The order of the returned list of CD-ROM devices isn't guaranteed.
//
func (p *TemplateCdromsService) List() *TemplateCdromsServiceListRequest {
	return &TemplateCdromsServiceListRequest{TemplateCdromsService: p}
}

//
// Returns a reference to the service that manages a specific CD-ROM device.
//
func (op *TemplateCdromsService) CdromService(id string) *TemplateCdromService {
	return NewTemplateCdromService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateCdromsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.CdromService(path), nil
	}
	return op.CdromService(path[:index]).Service(path[index+1:])
}

func (op *TemplateCdromsService) String() string {
	return fmt.Sprintf("TemplateCdromsService:%s", op.path)
}

//
// A service to manage fence agents for a specific host.
//
type FenceAgentsService struct {
	BaseService
}

func NewFenceAgentsService(connection *Connection, path string) *FenceAgentsService {
	var result FenceAgentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new fencing-agent to the host.
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/fenceagents
// You should consult the /usr/sbin/fence_<agent_name> manual page for
// the legal parameters to [name1=value1, name2=value2,...] in the options field.
// If any parameter in options appears by name that means that it is mandatory.
// For example in <options>slot=7[,name1=value1, name2=value2,...]</options>
// slot is mandatory.
// ----
// apc, bladecenter, wti fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>slot=7[,name1=value1, name2=value2,...]</options>
//   </agent>
// apc_snmp, hpblade, ilo, ilo2, ilo_ssh, redfish, rsa fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>apc_snmp</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>[name1=value1, name2=value2,...]</options>
//   </agent>
// cisco_ucs, drac5, eps fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>cisco_ucs</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <options>slot=7[,name1=value1, name2=value2,...]</options>
//   </agent>
// drac7, ilo3, ilo4, ipmilan, rsb fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>drac7</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <options>[name1=value1, name2=value2,...]</options>
//   </agent>
//
type FenceAgentsServiceAddRequest struct {
	FenceAgentsService *FenceAgentsService
	header             map[string]string
	query              map[string]string
	agent              *Agent
}

func (p *FenceAgentsServiceAddRequest) Header(key, value string) *FenceAgentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentsServiceAddRequest) Query(key, value string) *FenceAgentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentsServiceAddRequest) Agent(agent *Agent) *FenceAgentsServiceAddRequest {
	p.agent = agent
	return p
}

func (p *FenceAgentsServiceAddRequest) Send() (*FenceAgentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FenceAgentsService.connection.URL(), p.FenceAgentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAgentWriteOne(writer, p.agent, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FenceAgentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FenceAgentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FenceAgentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FenceAgentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FenceAgentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &FenceAgentsServiceAddResponse{agent: result}, nil
}

func (p *FenceAgentsServiceAddRequest) MustSend() *FenceAgentsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new fencing-agent to the host.
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/fenceagents
// You should consult the /usr/sbin/fence_<agent_name> manual page for
// the legal parameters to [name1=value1, name2=value2,...] in the options field.
// If any parameter in options appears by name that means that it is mandatory.
// For example in <options>slot=7[,name1=value1, name2=value2,...]</options>
// slot is mandatory.
// ----
// apc, bladecenter, wti fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>slot=7[,name1=value1, name2=value2,...]</options>
//   </agent>
// apc_snmp, hpblade, ilo, ilo2, ilo_ssh, redfish, rsa fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>apc_snmp</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>[name1=value1, name2=value2,...]</options>
//   </agent>
// cisco_ucs, drac5, eps fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>cisco_ucs</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <options>slot=7[,name1=value1, name2=value2,...]</options>
//   </agent>
// drac7, ilo3, ilo4, ipmilan, rsb fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>drac7</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <options>[name1=value1, name2=value2,...]</options>
//   </agent>
//
type FenceAgentsServiceAddResponse struct {
	agent *Agent
}

func (p *FenceAgentsServiceAddResponse) Agent() (*Agent, bool) {
	if p.agent != nil {
		return p.agent, true
	}
	return nil, false
}

func (p *FenceAgentsServiceAddResponse) MustAgent() *Agent {
	if p.agent == nil {
		panic("agent in response does not exist")
	}
	return p.agent
}

//
// Add a new fencing-agent to the host.
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/fenceagents
// You should consult the /usr/sbin/fence_<agent_name> manual page for
// the legal parameters to [name1=value1, name2=value2,...] in the options field.
// If any parameter in options appears by name that means that it is mandatory.
// For example in <options>slot=7[,name1=value1, name2=value2,...]</options>
// slot is mandatory.
// ----
// apc, bladecenter, wti fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>slot=7[,name1=value1, name2=value2,...]</options>
//   </agent>
// apc_snmp, hpblade, ilo, ilo2, ilo_ssh, redfish, rsa fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>apc_snmp</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>[name1=value1, name2=value2,...]</options>
//   </agent>
// cisco_ucs, drac5, eps fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>cisco_ucs</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <options>slot=7[,name1=value1, name2=value2,...]</options>
//   </agent>
// drac7, ilo3, ilo4, ipmilan, rsb fencing agent/s sample request:
// [source,xml]
//   <agent>
//     <type>drac7</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <options>[name1=value1, name2=value2,...]</options>
//   </agent>
//
func (p *FenceAgentsService) Add() *FenceAgentsServiceAddRequest {
	return &FenceAgentsServiceAddRequest{FenceAgentsService: p}
}

//
// Returns the list of fencing agents configured for the host.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents
// ----
// And here is sample response:
// [source,xml]
// ----
// <agents>
//   <agent id="0">
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>name1=value1, name2=value2</options>
//   </agent>
// </agents>
// ----
// The order of the returned list of fencing agents isn't guaranteed.
//
type FenceAgentsServiceListRequest struct {
	FenceAgentsService *FenceAgentsService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *FenceAgentsServiceListRequest) Header(key, value string) *FenceAgentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentsServiceListRequest) Query(key, value string) *FenceAgentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentsServiceListRequest) Follow(follow string) *FenceAgentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *FenceAgentsServiceListRequest) Max(max int64) *FenceAgentsServiceListRequest {
	p.max = &max
	return p
}

func (p *FenceAgentsServiceListRequest) Send() (*FenceAgentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FenceAgentsService.connection.URL(), p.FenceAgentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FenceAgentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FenceAgentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FenceAgentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FenceAgentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FenceAgentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &FenceAgentsServiceListResponse{agents: result}, nil
}

func (p *FenceAgentsServiceListRequest) MustSend() *FenceAgentsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of fencing agents configured for the host.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents
// ----
// And here is sample response:
// [source,xml]
// ----
// <agents>
//   <agent id="0">
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>name1=value1, name2=value2</options>
//   </agent>
// </agents>
// ----
// The order of the returned list of fencing agents isn't guaranteed.
//
type FenceAgentsServiceListResponse struct {
	agents *AgentSlice
}

func (p *FenceAgentsServiceListResponse) Agents() (*AgentSlice, bool) {
	if p.agents != nil {
		return p.agents, true
	}
	return nil, false
}

func (p *FenceAgentsServiceListResponse) MustAgents() *AgentSlice {
	if p.agents == nil {
		panic("agents in response does not exist")
	}
	return p.agents
}

//
// Returns the list of fencing agents configured for the host.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents
// ----
// And here is sample response:
// [source,xml]
// ----
// <agents>
//   <agent id="0">
//     <type>apc</type>
//     <order>1</order>
//     <ip>192.168.1.101</ip>
//     <user>user</user>
//     <password>xxx</password>
//     <port>9</port>
//     <options>name1=value1, name2=value2</options>
//   </agent>
// </agents>
// ----
// The order of the returned list of fencing agents isn't guaranteed.
//
func (p *FenceAgentsService) List() *FenceAgentsServiceListRequest {
	return &FenceAgentsServiceListRequest{FenceAgentsService: p}
}

//
// Reference to service that manages a specific fence agent
// for this host.
//
func (op *FenceAgentsService) AgentService(id string) *FenceAgentService {
	return NewFenceAgentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FenceAgentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AgentService(path), nil
	}
	return op.AgentService(path[:index]).Service(path[index+1:])
}

func (op *FenceAgentsService) String() string {
	return fmt.Sprintf("FenceAgentsService:%s", op.path)
}

//
// Provides information about the additional features that are enabled for this cluster.
// The features that are enabled are the available features for the cluster level
//
type ClusterEnabledFeaturesService struct {
	BaseService
}

func NewClusterEnabledFeaturesService(connection *Connection, path string) *ClusterEnabledFeaturesService {
	var result ClusterEnabledFeaturesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Enable an additional feature for a cluster.
// For example, to enable a feature `456` on cluster `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// The request body should look like this:
// [source,xml]
// ----
// <cluster_feature id="456"/>
// ----
//
type ClusterEnabledFeaturesServiceAddRequest struct {
	ClusterEnabledFeaturesService *ClusterEnabledFeaturesService
	header                        map[string]string
	query                         map[string]string
	feature                       *ClusterFeature
}

func (p *ClusterEnabledFeaturesServiceAddRequest) Header(key, value string) *ClusterEnabledFeaturesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterEnabledFeaturesServiceAddRequest) Query(key, value string) *ClusterEnabledFeaturesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterEnabledFeaturesServiceAddRequest) Feature(feature *ClusterFeature) *ClusterEnabledFeaturesServiceAddRequest {
	p.feature = feature
	return p
}

func (p *ClusterEnabledFeaturesServiceAddRequest) Send() (*ClusterEnabledFeaturesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterEnabledFeaturesService.connection.URL(), p.ClusterEnabledFeaturesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterFeatureWriteOne(writer, p.feature, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterEnabledFeaturesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterEnabledFeaturesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterEnabledFeaturesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterEnabledFeaturesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterEnabledFeaturesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterEnabledFeaturesServiceAddResponse{feature: result}, nil
}

func (p *ClusterEnabledFeaturesServiceAddRequest) MustSend() *ClusterEnabledFeaturesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Enable an additional feature for a cluster.
// For example, to enable a feature `456` on cluster `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// The request body should look like this:
// [source,xml]
// ----
// <cluster_feature id="456"/>
// ----
//
type ClusterEnabledFeaturesServiceAddResponse struct {
	feature *ClusterFeature
}

func (p *ClusterEnabledFeaturesServiceAddResponse) Feature() (*ClusterFeature, bool) {
	if p.feature != nil {
		return p.feature, true
	}
	return nil, false
}

func (p *ClusterEnabledFeaturesServiceAddResponse) MustFeature() *ClusterFeature {
	if p.feature == nil {
		panic("feature in response does not exist")
	}
	return p.feature
}

//
// Enable an additional feature for a cluster.
// For example, to enable a feature `456` on cluster `123`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// The request body should look like this:
// [source,xml]
// ----
// <cluster_feature id="456"/>
// ----
//
func (p *ClusterEnabledFeaturesService) Add() *ClusterEnabledFeaturesServiceAddRequest {
	return &ClusterEnabledFeaturesServiceAddRequest{ClusterEnabledFeaturesService: p}
}

//
// Lists the additional features enabled for the cluster.
// For example, to get the features enabled for cluster `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// This will return a list of features:
// [source,xml]
// ----
// <enabled_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </enabled_features>
// ----
//
type ClusterEnabledFeaturesServiceListRequest struct {
	ClusterEnabledFeaturesService *ClusterEnabledFeaturesService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *ClusterEnabledFeaturesServiceListRequest) Header(key, value string) *ClusterEnabledFeaturesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterEnabledFeaturesServiceListRequest) Query(key, value string) *ClusterEnabledFeaturesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterEnabledFeaturesServiceListRequest) Follow(follow string) *ClusterEnabledFeaturesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ClusterEnabledFeaturesServiceListRequest) Send() (*ClusterEnabledFeaturesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterEnabledFeaturesService.connection.URL(), p.ClusterEnabledFeaturesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterEnabledFeaturesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterEnabledFeaturesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterEnabledFeaturesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterEnabledFeaturesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterEnabledFeaturesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ClusterEnabledFeaturesServiceListResponse{features: result}, nil
}

func (p *ClusterEnabledFeaturesServiceListRequest) MustSend() *ClusterEnabledFeaturesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists the additional features enabled for the cluster.
// For example, to get the features enabled for cluster `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// This will return a list of features:
// [source,xml]
// ----
// <enabled_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </enabled_features>
// ----
//
type ClusterEnabledFeaturesServiceListResponse struct {
	features *ClusterFeatureSlice
}

func (p *ClusterEnabledFeaturesServiceListResponse) Features() (*ClusterFeatureSlice, bool) {
	if p.features != nil {
		return p.features, true
	}
	return nil, false
}

func (p *ClusterEnabledFeaturesServiceListResponse) MustFeatures() *ClusterFeatureSlice {
	if p.features == nil {
		panic("features in response does not exist")
	}
	return p.features
}

//
// Lists the additional features enabled for the cluster.
// For example, to get the features enabled for cluster `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures
// ----
// This will return a list of features:
// [source,xml]
// ----
// <enabled_features>
//   <cluster_feature id="123">
//      <name>test_feature</name>
//   </cluster_feature>
//   ...
// </enabled_features>
// ----
//
func (p *ClusterEnabledFeaturesService) List() *ClusterEnabledFeaturesServiceListRequest {
	return &ClusterEnabledFeaturesServiceListRequest{ClusterEnabledFeaturesService: p}
}

//
// A reference to the service that provides information about a specific
// feature enabled for the cluster.
//
func (op *ClusterEnabledFeaturesService) FeatureService(id string) *ClusterEnabledFeatureService {
	return NewClusterEnabledFeatureService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterEnabledFeaturesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.FeatureService(path), nil
	}
	return op.FeatureService(path[:index]).Service(path[index+1:])
}

func (op *ClusterEnabledFeaturesService) String() string {
	return fmt.Sprintf("ClusterEnabledFeaturesService:%s", op.path)
}

//
//
type VmGraphicsConsoleService struct {
	BaseService
}

func NewVmGraphicsConsoleService(connection *Connection, path string) *VmGraphicsConsoleService {
	var result VmGraphicsConsoleService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the graphics console configuration of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
//
type VmGraphicsConsoleServiceGetRequest struct {
	VmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	current                  *bool
	follow                   *string
}

func (p *VmGraphicsConsoleServiceGetRequest) Header(key, value string) *VmGraphicsConsoleServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceGetRequest) Query(key, value string) *VmGraphicsConsoleServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceGetRequest) Current(current bool) *VmGraphicsConsoleServiceGetRequest {
	p.current = &current
	return p
}

func (p *VmGraphicsConsoleServiceGetRequest) Follow(follow string) *VmGraphicsConsoleServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmGraphicsConsoleServiceGetRequest) Send() (*VmGraphicsConsoleServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmGraphicsConsoleService.connection.URL(), p.VmGraphicsConsoleService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmGraphicsConsoleServiceGetResponse{console: result}, nil
}

func (p *VmGraphicsConsoleServiceGetRequest) MustSend() *VmGraphicsConsoleServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the graphics console configuration of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
//
type VmGraphicsConsoleServiceGetResponse struct {
	console *GraphicsConsole
}

func (p *VmGraphicsConsoleServiceGetResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *VmGraphicsConsoleServiceGetResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Retrieves the graphics console configuration of the virtual machine.
// IMPORTANT: By default, when the `current` parameter is not specified, the data returned
// corresponds to the next execution of the virtual machine. In the current implementation of
// the system this means that the `address` and `port` attributes will not be populated because
// the system does not know what address and port will be used for the next execution. Since in most
// cases those attributes are needed, it is strongly advised to aways explicitly include the
// `current` parameter with the value `true`.
//
func (p *VmGraphicsConsoleService) Get() *VmGraphicsConsoleServiceGetRequest {
	return &VmGraphicsConsoleServiceGetRequest{VmGraphicsConsoleService: p}
}

//
//
type VmGraphicsConsoleServiceProxyTicketRequest struct {
	VmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Header(key, value string) *VmGraphicsConsoleServiceProxyTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Query(key, value string) *VmGraphicsConsoleServiceProxyTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Async(async bool) *VmGraphicsConsoleServiceProxyTicketRequest {
	p.async = &async
	return p
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) Send() (*VmGraphicsConsoleServiceProxyTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/proxyticket", p.VmGraphicsConsoleService.connection.URL(), p.VmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustProxyTicket()
	return &VmGraphicsConsoleServiceProxyTicketResponse{proxyTicket: result}, nil
}

func (p *VmGraphicsConsoleServiceProxyTicketRequest) MustSend() *VmGraphicsConsoleServiceProxyTicketResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmGraphicsConsoleServiceProxyTicketResponse struct {
	proxyTicket *ProxyTicket
}

func (p *VmGraphicsConsoleServiceProxyTicketResponse) ProxyTicket() (*ProxyTicket, bool) {
	if p.proxyTicket != nil {
		return p.proxyTicket, true
	}
	return nil, false
}

func (p *VmGraphicsConsoleServiceProxyTicketResponse) MustProxyTicket() *ProxyTicket {
	if p.proxyTicket == nil {
		panic("proxyTicket in response does not exist")
	}
	return p.proxyTicket
}

//
//
func (p *VmGraphicsConsoleService) ProxyTicket() *VmGraphicsConsoleServiceProxyTicketRequest {
	return &VmGraphicsConsoleServiceProxyTicketRequest{VmGraphicsConsoleService: p}
}

//
// Generates the file which is compatible with `remote-viewer` client.
// Use the following request to generate remote viewer connection file of the graphics console.
// Note that this action generates the file only if virtual machine is running.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/remoteviewerconnectionfile
// ----
// The `remoteviewerconnectionfile` action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// The response contains the file, which can be used with `remote-viewer` client.
// [source,xml]
// ----
// <action>
//   <remote_viewer_connection_file>
//     [virt-viewer]
//     type=spice
//     host=192.168.1.101
//     port=-1
//     password=123456789
//     delete-this-file=1
//     fullscreen=0
//     toggle-fullscreen=shift+f11
//     release-cursor=shift+f12
//     secure-attention=ctrl+alt+end
//     tls-port=5900
//     enable-smartcard=0
//     enable-usb-autoshare=0
//     usb-filter=null
//     tls-ciphers=DEFAULT
//     host-subject=O=local,CN=example.com
//     ca=...
//   </remote_viewer_connection_file>
// </action>
// ----
// E.g., to fetch the content of remote viewer connection file and save it into temporary file, user can use
// oVirt Python SDK as follows:
// [source,python]
// ----
// # Find the virtual machine:
// vm = vms_service.list(search='name=myvm')[0]
// # Locate the service that manages the virtual machine, as that is where
// # the locators are defined:
// vm_service = vms_service.vm_service(vm.id)
// # Find the graphic console of the virtual machine:
// graphics_consoles_service = vm_service.graphics_consoles_service()
// graphics_console = graphics_consoles_service.list()[0]
// # Generate the remote viewer connection file:
// console_service = graphics_consoles_service.console_service(graphics_console.id)
// remote_viewer_connection_file = console_service.remote_viewer_connection_file()
// # Write the content to file "/tmp/remote_viewer_connection_file.vv"
// path = "/tmp/remote_viewer_connection_file.vv"
// with open(path, "w") as f:
//     f.write(remote_viewer_connection_file)
// ----
// When you create the remote viewer connection file, then you can connect to virtual machine graphic console,
// as follows:
// [source,bash]
// ----
// #!/bin/sh -ex
// remote-viewer --ovirt-ca-file=/etc/pki/ovirt-engine/ca.pem /tmp/remote_viewer_connection_file.vv
// ----
//
type VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest struct {
	VmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Header(key, value string) *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Query(key, value string) *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) Send() (*VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse, error) {
	rawURL := fmt.Sprintf("%s%s/remoteviewerconnectionfile", p.VmGraphicsConsoleService.connection.URL(), p.VmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustRemoteViewerConnectionFile()
	return &VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse{remoteViewerConnectionFile: &result}, nil
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest) MustSend() *VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Generates the file which is compatible with `remote-viewer` client.
// Use the following request to generate remote viewer connection file of the graphics console.
// Note that this action generates the file only if virtual machine is running.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/remoteviewerconnectionfile
// ----
// The `remoteviewerconnectionfile` action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// The response contains the file, which can be used with `remote-viewer` client.
// [source,xml]
// ----
// <action>
//   <remote_viewer_connection_file>
//     [virt-viewer]
//     type=spice
//     host=192.168.1.101
//     port=-1
//     password=123456789
//     delete-this-file=1
//     fullscreen=0
//     toggle-fullscreen=shift+f11
//     release-cursor=shift+f12
//     secure-attention=ctrl+alt+end
//     tls-port=5900
//     enable-smartcard=0
//     enable-usb-autoshare=0
//     usb-filter=null
//     tls-ciphers=DEFAULT
//     host-subject=O=local,CN=example.com
//     ca=...
//   </remote_viewer_connection_file>
// </action>
// ----
// E.g., to fetch the content of remote viewer connection file and save it into temporary file, user can use
// oVirt Python SDK as follows:
// [source,python]
// ----
// # Find the virtual machine:
// vm = vms_service.list(search='name=myvm')[0]
// # Locate the service that manages the virtual machine, as that is where
// # the locators are defined:
// vm_service = vms_service.vm_service(vm.id)
// # Find the graphic console of the virtual machine:
// graphics_consoles_service = vm_service.graphics_consoles_service()
// graphics_console = graphics_consoles_service.list()[0]
// # Generate the remote viewer connection file:
// console_service = graphics_consoles_service.console_service(graphics_console.id)
// remote_viewer_connection_file = console_service.remote_viewer_connection_file()
// # Write the content to file "/tmp/remote_viewer_connection_file.vv"
// path = "/tmp/remote_viewer_connection_file.vv"
// with open(path, "w") as f:
//     f.write(remote_viewer_connection_file)
// ----
// When you create the remote viewer connection file, then you can connect to virtual machine graphic console,
// as follows:
// [source,bash]
// ----
// #!/bin/sh -ex
// remote-viewer --ovirt-ca-file=/etc/pki/ovirt-engine/ca.pem /tmp/remote_viewer_connection_file.vv
// ----
//
type VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse struct {
	remoteViewerConnectionFile *string
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse) RemoteViewerConnectionFile() (string, bool) {
	if p.remoteViewerConnectionFile != nil {
		return *p.remoteViewerConnectionFile, true
	}
	var zero string
	return zero, false
}

func (p *VmGraphicsConsoleServiceRemoteViewerConnectionFileResponse) MustRemoteViewerConnectionFile() string {
	if p.remoteViewerConnectionFile == nil {
		panic("remoteViewerConnectionFile in response does not exist")
	}
	return *p.remoteViewerConnectionFile
}

//
// Generates the file which is compatible with `remote-viewer` client.
// Use the following request to generate remote viewer connection file of the graphics console.
// Note that this action generates the file only if virtual machine is running.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/remoteviewerconnectionfile
// ----
// The `remoteviewerconnectionfile` action does not take any action specific parameters,
// so the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
// The response contains the file, which can be used with `remote-viewer` client.
// [source,xml]
// ----
// <action>
//   <remote_viewer_connection_file>
//     [virt-viewer]
//     type=spice
//     host=192.168.1.101
//     port=-1
//     password=123456789
//     delete-this-file=1
//     fullscreen=0
//     toggle-fullscreen=shift+f11
//     release-cursor=shift+f12
//     secure-attention=ctrl+alt+end
//     tls-port=5900
//     enable-smartcard=0
//     enable-usb-autoshare=0
//     usb-filter=null
//     tls-ciphers=DEFAULT
//     host-subject=O=local,CN=example.com
//     ca=...
//   </remote_viewer_connection_file>
// </action>
// ----
// E.g., to fetch the content of remote viewer connection file and save it into temporary file, user can use
// oVirt Python SDK as follows:
// [source,python]
// ----
// # Find the virtual machine:
// vm = vms_service.list(search='name=myvm')[0]
// # Locate the service that manages the virtual machine, as that is where
// # the locators are defined:
// vm_service = vms_service.vm_service(vm.id)
// # Find the graphic console of the virtual machine:
// graphics_consoles_service = vm_service.graphics_consoles_service()
// graphics_console = graphics_consoles_service.list()[0]
// # Generate the remote viewer connection file:
// console_service = graphics_consoles_service.console_service(graphics_console.id)
// remote_viewer_connection_file = console_service.remote_viewer_connection_file()
// # Write the content to file "/tmp/remote_viewer_connection_file.vv"
// path = "/tmp/remote_viewer_connection_file.vv"
// with open(path, "w") as f:
//     f.write(remote_viewer_connection_file)
// ----
// When you create the remote viewer connection file, then you can connect to virtual machine graphic console,
// as follows:
// [source,bash]
// ----
// #!/bin/sh -ex
// remote-viewer --ovirt-ca-file=/etc/pki/ovirt-engine/ca.pem /tmp/remote_viewer_connection_file.vv
// ----
//
func (p *VmGraphicsConsoleService) RemoteViewerConnectionFile() *VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest {
	return &VmGraphicsConsoleServiceRemoteViewerConnectionFileRequest{VmGraphicsConsoleService: p}
}

//
// Remove the graphics console from the virtual machine.
//
type VmGraphicsConsoleServiceRemoveRequest struct {
	VmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Header(key, value string) *VmGraphicsConsoleServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Query(key, value string) *VmGraphicsConsoleServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Async(async bool) *VmGraphicsConsoleServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VmGraphicsConsoleServiceRemoveRequest) Send() (*VmGraphicsConsoleServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmGraphicsConsoleService.connection.URL(), p.VmGraphicsConsoleService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmGraphicsConsoleServiceRemoveResponse), nil
}

func (p *VmGraphicsConsoleServiceRemoveRequest) MustSend() *VmGraphicsConsoleServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove the graphics console from the virtual machine.
//
type VmGraphicsConsoleServiceRemoveResponse struct {
}

//
// Remove the graphics console from the virtual machine.
//
func (p *VmGraphicsConsoleService) Remove() *VmGraphicsConsoleServiceRemoveRequest {
	return &VmGraphicsConsoleServiceRemoveRequest{VmGraphicsConsoleService: p}
}

//
// Generates a time-sensitive authentication token for accessing this virtual machine's console.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// In any case, the response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
//
type VmGraphicsConsoleServiceTicketRequest struct {
	VmGraphicsConsoleService *VmGraphicsConsoleService
	header                   map[string]string
	query                    map[string]string
	ticket                   *Ticket
}

func (p *VmGraphicsConsoleServiceTicketRequest) Header(key, value string) *VmGraphicsConsoleServiceTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceTicketRequest) Query(key, value string) *VmGraphicsConsoleServiceTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmGraphicsConsoleServiceTicketRequest) Ticket(ticket *Ticket) *VmGraphicsConsoleServiceTicketRequest {
	p.ticket = ticket
	return p
}

func (p *VmGraphicsConsoleServiceTicketRequest) Send() (*VmGraphicsConsoleServiceTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/ticket", p.VmGraphicsConsoleService.connection.URL(), p.VmGraphicsConsoleService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Ticket(p.ticket)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmGraphicsConsoleService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmGraphicsConsoleService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmGraphicsConsoleService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmGraphicsConsoleService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmGraphicsConsoleService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustTicket()
	return &VmGraphicsConsoleServiceTicketResponse{ticket: result}, nil
}

func (p *VmGraphicsConsoleServiceTicketRequest) MustSend() *VmGraphicsConsoleServiceTicketResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Generates a time-sensitive authentication token for accessing this virtual machine's console.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// In any case, the response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
//
type VmGraphicsConsoleServiceTicketResponse struct {
	ticket *Ticket
}

func (p *VmGraphicsConsoleServiceTicketResponse) Ticket() (*Ticket, bool) {
	if p.ticket != nil {
		return p.ticket, true
	}
	return nil, false
}

func (p *VmGraphicsConsoleServiceTicketResponse) MustTicket() *Ticket {
	if p.ticket == nil {
		panic("ticket in response does not exist")
	}
	return p.ticket
}

//
// Generates a time-sensitive authentication token for accessing this virtual machine's console.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// In any case, the response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
//
func (p *VmGraphicsConsoleService) Ticket() *VmGraphicsConsoleServiceTicketRequest {
	return &VmGraphicsConsoleServiceTicketRequest{VmGraphicsConsoleService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmGraphicsConsoleService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmGraphicsConsoleService) String() string {
	return fmt.Sprintf("VmGraphicsConsoleService:%s", op.path)
}

//
// Provides capability to import external virtual machines.
//
type ExternalVmImportsService struct {
	BaseService
}

func NewExternalVmImportsService(connection *Connection, path string) *ExternalVmImportsService {
	var result ExternalVmImportsService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation is used to import a virtual machine from external hypervisor, such as KVM, XEN or VMware.
// For example import of a virtual machine from VMware can be facilitated using the following request:
// [source]
// ----
// POST /externalvmimports
// ----
// With request body of type <<types/external_vm_import,ExternalVmImport>>, for example:
// [source,xml]
// ----
// <external_vm_import>
//   <vm>
//     <name>my_vm</name>
//   </vm>
//   <cluster id="360014051136c20574f743bdbd28177fd" />
//   <storage_domain id="8bb5ade5-e988-4000-8b93-dbfc6717fe50" />
//   <name>vm_name_as_is_in_vmware</name>
//   <sparse>true</sparse>
//   <username>vmware_user</username>
//   <password>123456</password>
//   <provider>VMWARE</provider>
//   <url>vpx://wmware_user@vcenter-host/DataCenter/Cluster/esxi-host?no_verify=1</url>
//   <drivers_iso id="virtio-win-1.6.7.iso" />
// </external_vm_import>
// ----
//
type ExternalVmImportsServiceAddRequest struct {
	ExternalVmImportsService *ExternalVmImportsService
	header                   map[string]string
	query                    map[string]string
	import_                  *ExternalVmImport
}

func (p *ExternalVmImportsServiceAddRequest) Header(key, value string) *ExternalVmImportsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalVmImportsServiceAddRequest) Query(key, value string) *ExternalVmImportsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalVmImportsServiceAddRequest) Import(import_ *ExternalVmImport) *ExternalVmImportsServiceAddRequest {
	p.import_ = import_
	return p
}

func (p *ExternalVmImportsServiceAddRequest) Send() (*ExternalVmImportsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalVmImportsService.connection.URL(), p.ExternalVmImportsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLExternalVmImportWriteOne(writer, p.import_, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalVmImportsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalVmImportsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalVmImportsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalVmImportsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalVmImportsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalVmImportReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ExternalVmImportsServiceAddResponse{import_: result}, nil
}

func (p *ExternalVmImportsServiceAddRequest) MustSend() *ExternalVmImportsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation is used to import a virtual machine from external hypervisor, such as KVM, XEN or VMware.
// For example import of a virtual machine from VMware can be facilitated using the following request:
// [source]
// ----
// POST /externalvmimports
// ----
// With request body of type <<types/external_vm_import,ExternalVmImport>>, for example:
// [source,xml]
// ----
// <external_vm_import>
//   <vm>
//     <name>my_vm</name>
//   </vm>
//   <cluster id="360014051136c20574f743bdbd28177fd" />
//   <storage_domain id="8bb5ade5-e988-4000-8b93-dbfc6717fe50" />
//   <name>vm_name_as_is_in_vmware</name>
//   <sparse>true</sparse>
//   <username>vmware_user</username>
//   <password>123456</password>
//   <provider>VMWARE</provider>
//   <url>vpx://wmware_user@vcenter-host/DataCenter/Cluster/esxi-host?no_verify=1</url>
//   <drivers_iso id="virtio-win-1.6.7.iso" />
// </external_vm_import>
// ----
//
type ExternalVmImportsServiceAddResponse struct {
	import_ *ExternalVmImport
}

func (p *ExternalVmImportsServiceAddResponse) Import() (*ExternalVmImport, bool) {
	if p.import_ != nil {
		return p.import_, true
	}
	return nil, false
}

func (p *ExternalVmImportsServiceAddResponse) MustImport() *ExternalVmImport {
	if p.import_ == nil {
		panic("import_ in response does not exist")
	}
	return p.import_
}

//
// This operation is used to import a virtual machine from external hypervisor, such as KVM, XEN or VMware.
// For example import of a virtual machine from VMware can be facilitated using the following request:
// [source]
// ----
// POST /externalvmimports
// ----
// With request body of type <<types/external_vm_import,ExternalVmImport>>, for example:
// [source,xml]
// ----
// <external_vm_import>
//   <vm>
//     <name>my_vm</name>
//   </vm>
//   <cluster id="360014051136c20574f743bdbd28177fd" />
//   <storage_domain id="8bb5ade5-e988-4000-8b93-dbfc6717fe50" />
//   <name>vm_name_as_is_in_vmware</name>
//   <sparse>true</sparse>
//   <username>vmware_user</username>
//   <password>123456</password>
//   <provider>VMWARE</provider>
//   <url>vpx://wmware_user@vcenter-host/DataCenter/Cluster/esxi-host?no_verify=1</url>
//   <drivers_iso id="virtio-win-1.6.7.iso" />
// </external_vm_import>
// ----
//
func (p *ExternalVmImportsService) Add() *ExternalVmImportsServiceAddRequest {
	return &ExternalVmImportsServiceAddRequest{ExternalVmImportsService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalVmImportsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalVmImportsService) String() string {
	return fmt.Sprintf("ExternalVmImportsService:%s", op.path)
}

//
// Lists the backups of a virtual machine.
//
type VmBackupsService struct {
	BaseService
}

func NewVmBackupsService(connection *Connection, path string) *VmBackupsService {
	var result VmBackupsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new backup entity to a virtual machine.
// For example, to start a new incremental backup of a virtual machine
// since checkpoint id `previous-checkpoint-uuid`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/backups
// ----
// With a request body like this:
// [source,xml]
// ----
// POST /ovirt-engine/api/vms/123/backups
// <backup>
//   <from_checkpoint_id>previous-checkpoint-uuid</from_checkpoint_id>
//   <disks>
//       <disk id="disk-uuid" />
//       ...
//   </disks>
// </backup>
// ----
// The response body:
// [source,xml]
// ----
// <backup id="backup-uuid">
//     <from_checkpoint_id>previous-checkpoint-uuid</from_checkpoint_id>
//     <to_checkpoint_id>new-checkpoint-uuid</to_checkpoint_id>
//     <disks>
//         <disk id="disk-uuid" />
//         ...
//         ...
//     </disks>
//     <status>initializing</status>
//     <creation_date>
// </backup>
// ----
//
type VmBackupsServiceAddRequest struct {
	VmBackupsService *VmBackupsService
	header           map[string]string
	query            map[string]string
	backup           *Backup
}

func (p *VmBackupsServiceAddRequest) Header(key, value string) *VmBackupsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmBackupsServiceAddRequest) Query(key, value string) *VmBackupsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmBackupsServiceAddRequest) Backup(backup *Backup) *VmBackupsServiceAddRequest {
	p.backup = backup
	return p
}

func (p *VmBackupsServiceAddRequest) Send() (*VmBackupsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmBackupsService.connection.URL(), p.VmBackupsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBackupWriteOne(writer, p.backup, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmBackupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmBackupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmBackupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmBackupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmBackupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBackupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmBackupsServiceAddResponse{backup: result}, nil
}

func (p *VmBackupsServiceAddRequest) MustSend() *VmBackupsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a new backup entity to a virtual machine.
// For example, to start a new incremental backup of a virtual machine
// since checkpoint id `previous-checkpoint-uuid`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/backups
// ----
// With a request body like this:
// [source,xml]
// ----
// POST /ovirt-engine/api/vms/123/backups
// <backup>
//   <from_checkpoint_id>previous-checkpoint-uuid</from_checkpoint_id>
//   <disks>
//       <disk id="disk-uuid" />
//       ...
//   </disks>
// </backup>
// ----
// The response body:
// [source,xml]
// ----
// <backup id="backup-uuid">
//     <from_checkpoint_id>previous-checkpoint-uuid</from_checkpoint_id>
//     <to_checkpoint_id>new-checkpoint-uuid</to_checkpoint_id>
//     <disks>
//         <disk id="disk-uuid" />
//         ...
//         ...
//     </disks>
//     <status>initializing</status>
//     <creation_date>
// </backup>
// ----
//
type VmBackupsServiceAddResponse struct {
	backup *Backup
}

func (p *VmBackupsServiceAddResponse) Backup() (*Backup, bool) {
	if p.backup != nil {
		return p.backup, true
	}
	return nil, false
}

func (p *VmBackupsServiceAddResponse) MustBackup() *Backup {
	if p.backup == nil {
		panic("backup in response does not exist")
	}
	return p.backup
}

//
// Adds a new backup entity to a virtual machine.
// For example, to start a new incremental backup of a virtual machine
// since checkpoint id `previous-checkpoint-uuid`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/backups
// ----
// With a request body like this:
// [source,xml]
// ----
// POST /ovirt-engine/api/vms/123/backups
// <backup>
//   <from_checkpoint_id>previous-checkpoint-uuid</from_checkpoint_id>
//   <disks>
//       <disk id="disk-uuid" />
//       ...
//   </disks>
// </backup>
// ----
// The response body:
// [source,xml]
// ----
// <backup id="backup-uuid">
//     <from_checkpoint_id>previous-checkpoint-uuid</from_checkpoint_id>
//     <to_checkpoint_id>new-checkpoint-uuid</to_checkpoint_id>
//     <disks>
//         <disk id="disk-uuid" />
//         ...
//         ...
//     </disks>
//     <status>initializing</status>
//     <creation_date>
// </backup>
// ----
//
func (p *VmBackupsService) Add() *VmBackupsServiceAddRequest {
	return &VmBackupsServiceAddRequest{VmBackupsService: p}
}

//
// The list of virtual machine backups.
//
type VmBackupsServiceListRequest struct {
	VmBackupsService *VmBackupsService
	header           map[string]string
	query            map[string]string
	follow           *string
	max              *int64
}

func (p *VmBackupsServiceListRequest) Header(key, value string) *VmBackupsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmBackupsServiceListRequest) Query(key, value string) *VmBackupsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmBackupsServiceListRequest) Follow(follow string) *VmBackupsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmBackupsServiceListRequest) Max(max int64) *VmBackupsServiceListRequest {
	p.max = &max
	return p
}

func (p *VmBackupsServiceListRequest) Send() (*VmBackupsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmBackupsService.connection.URL(), p.VmBackupsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmBackupsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmBackupsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmBackupsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmBackupsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmBackupsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBackupReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmBackupsServiceListResponse{backups: result}, nil
}

func (p *VmBackupsServiceListRequest) MustSend() *VmBackupsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// The list of virtual machine backups.
//
type VmBackupsServiceListResponse struct {
	backups *BackupSlice
}

func (p *VmBackupsServiceListResponse) Backups() (*BackupSlice, bool) {
	if p.backups != nil {
		return p.backups, true
	}
	return nil, false
}

func (p *VmBackupsServiceListResponse) MustBackups() *BackupSlice {
	if p.backups == nil {
		panic("backups in response does not exist")
	}
	return p.backups
}

//
// The list of virtual machine backups.
//
func (p *VmBackupsService) List() *VmBackupsServiceListRequest {
	return &VmBackupsServiceListRequest{VmBackupsService: p}
}

//
// Returns a reference to the service that manages a specific VM backup.
//
func (op *VmBackupsService) BackupService(id string) *VmBackupService {
	return NewVmBackupService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmBackupsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.BackupService(path), nil
	}
	return op.BackupService(path[:index]).Service(path[index+1:])
}

func (op *VmBackupsService) String() string {
	return fmt.Sprintf("VmBackupsService:%s", op.path)
}

//
// A service to manage a specific data center network.
//
type DataCenterNetworkService struct {
	BaseService
}

func NewDataCenterNetworkService(connection *Connection, path string) *DataCenterNetworkService {
	var result DataCenterNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the data center network details.
//
type DataCenterNetworkServiceGetRequest struct {
	DataCenterNetworkService *DataCenterNetworkService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *DataCenterNetworkServiceGetRequest) Header(key, value string) *DataCenterNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterNetworkServiceGetRequest) Query(key, value string) *DataCenterNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterNetworkServiceGetRequest) Follow(follow string) *DataCenterNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DataCenterNetworkServiceGetRequest) Send() (*DataCenterNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCenterNetworkService.connection.URL(), p.DataCenterNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCenterNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCenterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCenterNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCenterNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DataCenterNetworkServiceGetResponse{network: result}, nil
}

func (p *DataCenterNetworkServiceGetRequest) MustSend() *DataCenterNetworkServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the data center network details.
//
type DataCenterNetworkServiceGetResponse struct {
	network *Network
}

func (p *DataCenterNetworkServiceGetResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *DataCenterNetworkServiceGetResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Retrieves the data center network details.
//
func (p *DataCenterNetworkService) Get() *DataCenterNetworkServiceGetRequest {
	return &DataCenterNetworkServiceGetRequest{DataCenterNetworkService: p}
}

//
// Removes the network.
//
type DataCenterNetworkServiceRemoveRequest struct {
	DataCenterNetworkService *DataCenterNetworkService
	header                   map[string]string
	query                    map[string]string
}

func (p *DataCenterNetworkServiceRemoveRequest) Header(key, value string) *DataCenterNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterNetworkServiceRemoveRequest) Query(key, value string) *DataCenterNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterNetworkServiceRemoveRequest) Send() (*DataCenterNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCenterNetworkService.connection.URL(), p.DataCenterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCenterNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCenterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCenterNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCenterNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DataCenterNetworkServiceRemoveResponse), nil
}

func (p *DataCenterNetworkServiceRemoveRequest) MustSend() *DataCenterNetworkServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the network.
//
type DataCenterNetworkServiceRemoveResponse struct {
}

//
// Removes the network.
//
func (p *DataCenterNetworkService) Remove() *DataCenterNetworkServiceRemoveRequest {
	return &DataCenterNetworkServiceRemoveRequest{DataCenterNetworkService: p}
}

//
// Updates the network in the data center.
//
type DataCenterNetworkServiceUpdateRequest struct {
	DataCenterNetworkService *DataCenterNetworkService
	header                   map[string]string
	query                    map[string]string
	network                  *Network
}

func (p *DataCenterNetworkServiceUpdateRequest) Header(key, value string) *DataCenterNetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCenterNetworkServiceUpdateRequest) Query(key, value string) *DataCenterNetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCenterNetworkServiceUpdateRequest) Network(network *Network) *DataCenterNetworkServiceUpdateRequest {
	p.network = network
	return p
}

func (p *DataCenterNetworkServiceUpdateRequest) Send() (*DataCenterNetworkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCenterNetworkService.connection.URL(), p.DataCenterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCenterNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCenterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCenterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCenterNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCenterNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DataCenterNetworkServiceUpdateResponse{network: result}, nil
}

func (p *DataCenterNetworkServiceUpdateRequest) MustSend() *DataCenterNetworkServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the network in the data center.
//
type DataCenterNetworkServiceUpdateResponse struct {
	network *Network
}

func (p *DataCenterNetworkServiceUpdateResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *DataCenterNetworkServiceUpdateResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Updates the network in the data center.
//
func (p *DataCenterNetworkService) Update() *DataCenterNetworkServiceUpdateRequest {
	return &DataCenterNetworkServiceUpdateRequest{DataCenterNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DataCenterNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DataCenterNetworkService) String() string {
	return fmt.Sprintf("DataCenterNetworkService:%s", op.path)
}

//
// Represents a feature enabled for the cluster level
//
type ClusterFeatureService struct {
	BaseService
}

func NewClusterFeatureService(connection *Connection, path string) *ClusterFeatureService {
	var result ClusterFeatureService
	result.connection = connection
	result.path = path
	return &result
}

//
// Provides the information about the a cluster feature supported by a cluster level.
// For example, to find details of the cluster feature `456` for cluster level 4.1, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
type ClusterFeatureServiceGetRequest struct {
	ClusterFeatureService *ClusterFeatureService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *ClusterFeatureServiceGetRequest) Header(key, value string) *ClusterFeatureServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterFeatureServiceGetRequest) Query(key, value string) *ClusterFeatureServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterFeatureServiceGetRequest) Follow(follow string) *ClusterFeatureServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ClusterFeatureServiceGetRequest) Send() (*ClusterFeatureServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterFeatureService.connection.URL(), p.ClusterFeatureService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterFeatureService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterFeatureService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterFeatureService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterFeatureService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterFeatureService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterFeatureServiceGetResponse{feature: result}, nil
}

func (p *ClusterFeatureServiceGetRequest) MustSend() *ClusterFeatureServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Provides the information about the a cluster feature supported by a cluster level.
// For example, to find details of the cluster feature `456` for cluster level 4.1, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
type ClusterFeatureServiceGetResponse struct {
	feature *ClusterFeature
}

func (p *ClusterFeatureServiceGetResponse) Feature() (*ClusterFeature, bool) {
	if p.feature != nil {
		return p.feature, true
	}
	return nil, false
}

func (p *ClusterFeatureServiceGetResponse) MustFeature() *ClusterFeature {
	if p.feature == nil {
		panic("feature in response does not exist")
	}
	return p.feature
}

//
// Provides the information about the a cluster feature supported by a cluster level.
// For example, to find details of the cluster feature `456` for cluster level 4.1, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/4.1/clusterfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
func (p *ClusterFeatureService) Get() *ClusterFeatureServiceGetRequest {
	return &ClusterFeatureServiceGetRequest{ClusterFeatureService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterFeatureService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterFeatureService) String() string {
	return fmt.Sprintf("ClusterFeatureService:%s", op.path)
}

//
//
type StatisticService struct {
	BaseService
}

func NewStatisticService(connection *Connection, path string) *StatisticService {
	var result StatisticService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StatisticServiceGetRequest struct {
	StatisticService *StatisticService
	header           map[string]string
	query            map[string]string
	follow           *string
}

func (p *StatisticServiceGetRequest) Header(key, value string) *StatisticServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StatisticServiceGetRequest) Query(key, value string) *StatisticServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StatisticServiceGetRequest) Follow(follow string) *StatisticServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StatisticServiceGetRequest) Send() (*StatisticServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StatisticService.connection.URL(), p.StatisticService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StatisticService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StatisticService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StatisticService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StatisticService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StatisticService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStatisticReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StatisticServiceGetResponse{statistic: result}, nil
}

func (p *StatisticServiceGetRequest) MustSend() *StatisticServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StatisticServiceGetResponse struct {
	statistic *Statistic
}

func (p *StatisticServiceGetResponse) Statistic() (*Statistic, bool) {
	if p.statistic != nil {
		return p.statistic, true
	}
	return nil, false
}

func (p *StatisticServiceGetResponse) MustStatistic() *Statistic {
	if p.statistic == nil {
		panic("statistic in response does not exist")
	}
	return p.statistic
}

//
//
func (p *StatisticService) Get() *StatisticServiceGetRequest {
	return &StatisticServiceGetRequest{StatisticService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StatisticService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StatisticService) String() string {
	return fmt.Sprintf("StatisticService:%s", op.path)
}

//
//
type StorageDomainTemplateService struct {
	BaseService
}

func NewStorageDomainTemplateService(connection *Connection, path string) *StorageDomainTemplateService {
	var result StorageDomainTemplateService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StorageDomainTemplateServiceGetRequest struct {
	StorageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
}

func (p *StorageDomainTemplateServiceGetRequest) Header(key, value string) *StorageDomainTemplateServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceGetRequest) Query(key, value string) *StorageDomainTemplateServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceGetRequest) Follow(follow string) *StorageDomainTemplateServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainTemplateServiceGetRequest) Send() (*StorageDomainTemplateServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainTemplateService.connection.URL(), p.StorageDomainTemplateService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainTemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainTemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainTemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainTemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTemplateReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainTemplateServiceGetResponse{template: result}, nil
}

func (p *StorageDomainTemplateServiceGetRequest) MustSend() *StorageDomainTemplateServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageDomainTemplateServiceGetResponse struct {
	template *Template
}

func (p *StorageDomainTemplateServiceGetResponse) Template() (*Template, bool) {
	if p.template != nil {
		return p.template, true
	}
	return nil, false
}

func (p *StorageDomainTemplateServiceGetResponse) MustTemplate() *Template {
	if p.template == nil {
		panic("template in response does not exist")
	}
	return p.template
}

//
//
func (p *StorageDomainTemplateService) Get() *StorageDomainTemplateServiceGetRequest {
	return &StorageDomainTemplateServiceGetRequest{StorageDomainTemplateService: p}
}

//
// Action to import a template from an export storage domain.
// For example, to import the template `456` from the storage domain `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/templates/456/import
// ----
// With the following request body:
// [source, xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
type StorageDomainTemplateServiceImportRequest struct {
	StorageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
	clone                        *bool
	cluster                      *Cluster
	exclusive                    *bool
	storageDomain                *StorageDomain
	template                     *Template
	vm                           *Vm
}

func (p *StorageDomainTemplateServiceImportRequest) Header(key, value string) *StorageDomainTemplateServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Query(key, value string) *StorageDomainTemplateServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Async(async bool) *StorageDomainTemplateServiceImportRequest {
	p.async = &async
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Clone(clone bool) *StorageDomainTemplateServiceImportRequest {
	p.clone = &clone
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Cluster(cluster *Cluster) *StorageDomainTemplateServiceImportRequest {
	p.cluster = cluster
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Exclusive(exclusive bool) *StorageDomainTemplateServiceImportRequest {
	p.exclusive = &exclusive
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainTemplateServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Template(template *Template) *StorageDomainTemplateServiceImportRequest {
	p.template = template
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Vm(vm *Vm) *StorageDomainTemplateServiceImportRequest {
	p.vm = vm
	return p
}

func (p *StorageDomainTemplateServiceImportRequest) Send() (*StorageDomainTemplateServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.StorageDomainTemplateService.connection.URL(), p.StorageDomainTemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainTemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainTemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainTemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainTemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainTemplateServiceImportResponse), nil
}

func (p *StorageDomainTemplateServiceImportRequest) MustSend() *StorageDomainTemplateServiceImportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Action to import a template from an export storage domain.
// For example, to import the template `456` from the storage domain `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/templates/456/import
// ----
// With the following request body:
// [source, xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
type StorageDomainTemplateServiceImportResponse struct {
}

//
// Action to import a template from an export storage domain.
// For example, to import the template `456` from the storage domain `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/templates/456/import
// ----
// With the following request body:
// [source, xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
func (p *StorageDomainTemplateService) Import() *StorageDomainTemplateServiceImportRequest {
	return &StorageDomainTemplateServiceImportRequest{StorageDomainTemplateService: p}
}

//
// Register the Template means importing the Template from the data domain by inserting the configuration of the
// Template and disks into the database without the copy process.
//
type StorageDomainTemplateServiceRegisterRequest struct {
	StorageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	allowPartialImport           *bool
	async                        *bool
	clone                        *bool
	cluster                      *Cluster
	exclusive                    *bool
	registrationConfiguration    *RegistrationConfiguration
	template                     *Template
	vnicProfileMappings          *VnicProfileMappingSlice
}

func (p *StorageDomainTemplateServiceRegisterRequest) Header(key, value string) *StorageDomainTemplateServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Query(key, value string) *StorageDomainTemplateServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) AllowPartialImport(allowPartialImport bool) *StorageDomainTemplateServiceRegisterRequest {
	p.allowPartialImport = &allowPartialImport
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Async(async bool) *StorageDomainTemplateServiceRegisterRequest {
	p.async = &async
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Clone(clone bool) *StorageDomainTemplateServiceRegisterRequest {
	p.clone = &clone
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Cluster(cluster *Cluster) *StorageDomainTemplateServiceRegisterRequest {
	p.cluster = cluster
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Exclusive(exclusive bool) *StorageDomainTemplateServiceRegisterRequest {
	p.exclusive = &exclusive
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) RegistrationConfiguration(registrationConfiguration *RegistrationConfiguration) *StorageDomainTemplateServiceRegisterRequest {
	p.registrationConfiguration = registrationConfiguration
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Template(template *Template) *StorageDomainTemplateServiceRegisterRequest {
	p.template = template
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) VnicProfileMappings(vnicProfileMappings *VnicProfileMappingSlice) *StorageDomainTemplateServiceRegisterRequest {
	p.vnicProfileMappings = vnicProfileMappings
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) VnicProfileMappingsOfAny(anys ...*VnicProfileMapping) *StorageDomainTemplateServiceRegisterRequest {
	if p.vnicProfileMappings == nil {
		p.vnicProfileMappings = new(VnicProfileMappingSlice)
	}
	p.vnicProfileMappings.slice = append(p.vnicProfileMappings.slice, anys...)
	return p
}

func (p *StorageDomainTemplateServiceRegisterRequest) Send() (*StorageDomainTemplateServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.StorageDomainTemplateService.connection.URL(), p.StorageDomainTemplateService.path)
	actionBuilder := NewActionBuilder()
	if p.allowPartialImport != nil {
		actionBuilder.AllowPartialImport(*p.allowPartialImport)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.RegistrationConfiguration(p.registrationConfiguration)
	actionBuilder.Template(p.template)
	actionBuilder.VnicProfileMappings(p.vnicProfileMappings)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainTemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainTemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainTemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainTemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainTemplateServiceRegisterResponse), nil
}

func (p *StorageDomainTemplateServiceRegisterRequest) MustSend() *StorageDomainTemplateServiceRegisterResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Register the Template means importing the Template from the data domain by inserting the configuration of the
// Template and disks into the database without the copy process.
//
type StorageDomainTemplateServiceRegisterResponse struct {
}

//
// Register the Template means importing the Template from the data domain by inserting the configuration of the
// Template and disks into the database without the copy process.
//
func (p *StorageDomainTemplateService) Register() *StorageDomainTemplateServiceRegisterRequest {
	return &StorageDomainTemplateServiceRegisterRequest{StorageDomainTemplateService: p}
}

//
//
type StorageDomainTemplateServiceRemoveRequest struct {
	StorageDomainTemplateService *StorageDomainTemplateService
	header                       map[string]string
	query                        map[string]string
	async                        *bool
}

func (p *StorageDomainTemplateServiceRemoveRequest) Header(key, value string) *StorageDomainTemplateServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRemoveRequest) Query(key, value string) *StorageDomainTemplateServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainTemplateServiceRemoveRequest) Async(async bool) *StorageDomainTemplateServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *StorageDomainTemplateServiceRemoveRequest) Send() (*StorageDomainTemplateServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainTemplateService.connection.URL(), p.StorageDomainTemplateService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainTemplateService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainTemplateService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainTemplateService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainTemplateService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainTemplateService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainTemplateServiceRemoveResponse), nil
}

func (p *StorageDomainTemplateServiceRemoveRequest) MustSend() *StorageDomainTemplateServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageDomainTemplateServiceRemoveResponse struct {
}

//
//
func (p *StorageDomainTemplateService) Remove() *StorageDomainTemplateServiceRemoveRequest {
	return &StorageDomainTemplateServiceRemoveRequest{StorageDomainTemplateService: p}
}

//
//
func (op *StorageDomainTemplateService) DisksService() *StorageDomainContentDisksService {
	return NewStorageDomainContentDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainTemplateService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainTemplateService) String() string {
	return fmt.Sprintf("StorageDomainTemplateService:%s", op.path)
}

//
//
type MacPoolsService struct {
	BaseService
}

func NewMacPoolsService(connection *Connection, path string) *MacPoolsService {
	var result MacPoolsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new MAC address pool.
// Creation of a MAC address pool requires values for the `name` and `ranges` attributes.
// For example, to create MAC address pool send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/macpools
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>MACPool</name>
//   <description>A MAC address pool</description>
//   <allow_duplicates>true</allow_duplicates>
//   <default_pool>false</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
type MacPoolsServiceAddRequest struct {
	MacPoolsService *MacPoolsService
	header          map[string]string
	query           map[string]string
	pool            *MacPool
}

func (p *MacPoolsServiceAddRequest) Header(key, value string) *MacPoolsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolsServiceAddRequest) Query(key, value string) *MacPoolsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolsServiceAddRequest) Pool(pool *MacPool) *MacPoolsServiceAddRequest {
	p.pool = pool
	return p
}

func (p *MacPoolsServiceAddRequest) Send() (*MacPoolsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.MacPoolsService.connection.URL(), p.MacPoolsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLMacPoolWriteOne(writer, p.pool, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.MacPoolsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.MacPoolsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.MacPoolsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.MacPoolsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.MacPoolsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &MacPoolsServiceAddResponse{pool: result}, nil
}

func (p *MacPoolsServiceAddRequest) MustSend() *MacPoolsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new MAC address pool.
// Creation of a MAC address pool requires values for the `name` and `ranges` attributes.
// For example, to create MAC address pool send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/macpools
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>MACPool</name>
//   <description>A MAC address pool</description>
//   <allow_duplicates>true</allow_duplicates>
//   <default_pool>false</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
type MacPoolsServiceAddResponse struct {
	pool *MacPool
}

func (p *MacPoolsServiceAddResponse) Pool() (*MacPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *MacPoolsServiceAddResponse) MustPool() *MacPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Creates a new MAC address pool.
// Creation of a MAC address pool requires values for the `name` and `ranges` attributes.
// For example, to create MAC address pool send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/macpools
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>MACPool</name>
//   <description>A MAC address pool</description>
//   <allow_duplicates>true</allow_duplicates>
//   <default_pool>false</default_pool>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
func (p *MacPoolsService) Add() *MacPoolsServiceAddRequest {
	return &MacPoolsServiceAddRequest{MacPoolsService: p}
}

//
// Return the list of MAC address pools of the system.
// The returned list of MAC address pools isn't guaranteed.
//
type MacPoolsServiceListRequest struct {
	MacPoolsService *MacPoolsService
	header          map[string]string
	query           map[string]string
	follow          *string
	max             *int64
}

func (p *MacPoolsServiceListRequest) Header(key, value string) *MacPoolsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolsServiceListRequest) Query(key, value string) *MacPoolsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolsServiceListRequest) Follow(follow string) *MacPoolsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *MacPoolsServiceListRequest) Max(max int64) *MacPoolsServiceListRequest {
	p.max = &max
	return p
}

func (p *MacPoolsServiceListRequest) Send() (*MacPoolsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.MacPoolsService.connection.URL(), p.MacPoolsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.MacPoolsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.MacPoolsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.MacPoolsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.MacPoolsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.MacPoolsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &MacPoolsServiceListResponse{pools: result}, nil
}

func (p *MacPoolsServiceListRequest) MustSend() *MacPoolsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Return the list of MAC address pools of the system.
// The returned list of MAC address pools isn't guaranteed.
//
type MacPoolsServiceListResponse struct {
	pools *MacPoolSlice
}

func (p *MacPoolsServiceListResponse) Pools() (*MacPoolSlice, bool) {
	if p.pools != nil {
		return p.pools, true
	}
	return nil, false
}

func (p *MacPoolsServiceListResponse) MustPools() *MacPoolSlice {
	if p.pools == nil {
		panic("pools in response does not exist")
	}
	return p.pools
}

//
// Return the list of MAC address pools of the system.
// The returned list of MAC address pools isn't guaranteed.
//
func (p *MacPoolsService) List() *MacPoolsServiceListRequest {
	return &MacPoolsServiceListRequest{MacPoolsService: p}
}

//
//
func (op *MacPoolsService) MacPoolService(id string) *MacPoolService {
	return NewMacPoolService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MacPoolsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.MacPoolService(path), nil
	}
	return op.MacPoolService(path[:index]).Service(path[index+1:])
}

func (op *MacPoolsService) String() string {
	return fmt.Sprintf("MacPoolsService:%s", op.path)
}

//
// The details of a single affinity label.
//
type AffinityLabelService struct {
	BaseService
}

func NewAffinityLabelService(connection *Connection, path string) *AffinityLabelService {
	var result AffinityLabelService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the details of a label.
//
type AffinityLabelServiceGetRequest struct {
	AffinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *AffinityLabelServiceGetRequest) Header(key, value string) *AffinityLabelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceGetRequest) Query(key, value string) *AffinityLabelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceGetRequest) Follow(follow string) *AffinityLabelServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AffinityLabelServiceGetRequest) Send() (*AffinityLabelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelService.connection.URL(), p.AffinityLabelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityLabelServiceGetResponse{label: result}, nil
}

func (p *AffinityLabelServiceGetRequest) MustSend() *AffinityLabelServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the details of a label.
//
type AffinityLabelServiceGetResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelServiceGetResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *AffinityLabelServiceGetResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Retrieves the details of a label.
//
func (p *AffinityLabelService) Get() *AffinityLabelServiceGetRequest {
	return &AffinityLabelServiceGetRequest{AffinityLabelService: p}
}

//
// Removes a label from the system and clears all assignments
// of the removed label.
//
type AffinityLabelServiceRemoveRequest struct {
	AffinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
}

func (p *AffinityLabelServiceRemoveRequest) Header(key, value string) *AffinityLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceRemoveRequest) Query(key, value string) *AffinityLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceRemoveRequest) Send() (*AffinityLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelService.connection.URL(), p.AffinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityLabelServiceRemoveResponse), nil
}

func (p *AffinityLabelServiceRemoveRequest) MustSend() *AffinityLabelServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a label from the system and clears all assignments
// of the removed label.
//
type AffinityLabelServiceRemoveResponse struct {
}

//
// Removes a label from the system and clears all assignments
// of the removed label.
//
func (p *AffinityLabelService) Remove() *AffinityLabelServiceRemoveRequest {
	return &AffinityLabelServiceRemoveRequest{AffinityLabelService: p}
}

//
// Updates a label. This call will update all metadata, such as the name
// or description.
//
type AffinityLabelServiceUpdateRequest struct {
	AffinityLabelService *AffinityLabelService
	header               map[string]string
	query                map[string]string
	label                *AffinityLabel
}

func (p *AffinityLabelServiceUpdateRequest) Header(key, value string) *AffinityLabelServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelServiceUpdateRequest) Query(key, value string) *AffinityLabelServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelServiceUpdateRequest) Label(label *AffinityLabel) *AffinityLabelServiceUpdateRequest {
	p.label = label
	return p
}

func (p *AffinityLabelServiceUpdateRequest) Send() (*AffinityLabelServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelService.connection.URL(), p.AffinityLabelService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityLabelServiceUpdateResponse{label: result}, nil
}

func (p *AffinityLabelServiceUpdateRequest) MustSend() *AffinityLabelServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates a label. This call will update all metadata, such as the name
// or description.
//
type AffinityLabelServiceUpdateResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelServiceUpdateResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *AffinityLabelServiceUpdateResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Updates a label. This call will update all metadata, such as the name
// or description.
//
func (p *AffinityLabelService) Update() *AffinityLabelServiceUpdateRequest {
	return &AffinityLabelServiceUpdateRequest{AffinityLabelService: p}
}

//
// List all hosts with this label.
//
func (op *AffinityLabelService) HostsService() *AffinityLabelHostsService {
	return NewAffinityLabelHostsService(op.connection, fmt.Sprintf("%s/hosts", op.path))
}

//
// List all virtual machines with this label.
//
func (op *AffinityLabelService) VmsService() *AffinityLabelVmsService {
	return NewAffinityLabelVmsService(op.connection, fmt.Sprintf("%s/vms", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelService) String() string {
	return fmt.Sprintf("AffinityLabelService:%s", op.path)
}

//
//
type TemplateGraphicsConsolesService struct {
	BaseService
}

func NewTemplateGraphicsConsolesService(connection *Connection, path string) *TemplateGraphicsConsolesService {
	var result TemplateGraphicsConsolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new graphics console to the template.
//
type TemplateGraphicsConsolesServiceAddRequest struct {
	TemplateGraphicsConsolesService *TemplateGraphicsConsolesService
	header                          map[string]string
	query                           map[string]string
	console                         *GraphicsConsole
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Header(key, value string) *TemplateGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Query(key, value string) *TemplateGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *TemplateGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}

func (p *TemplateGraphicsConsolesServiceAddRequest) Send() (*TemplateGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateGraphicsConsolesService.connection.URL(), p.TemplateGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateGraphicsConsolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateGraphicsConsolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateGraphicsConsolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateGraphicsConsolesServiceAddResponse{console: result}, nil
}

func (p *TemplateGraphicsConsolesServiceAddRequest) MustSend() *TemplateGraphicsConsolesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add new graphics console to the template.
//
type TemplateGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *TemplateGraphicsConsolesServiceAddResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *TemplateGraphicsConsolesServiceAddResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Add new graphics console to the template.
//
func (p *TemplateGraphicsConsolesService) Add() *TemplateGraphicsConsolesServiceAddRequest {
	return &TemplateGraphicsConsolesServiceAddRequest{TemplateGraphicsConsolesService: p}
}

//
// Lists all the configured graphics consoles of the template.
// The order of the returned list of graphics consoles isn't guaranteed.
//
type TemplateGraphicsConsolesServiceListRequest struct {
	TemplateGraphicsConsolesService *TemplateGraphicsConsolesService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
	max                             *int64
}

func (p *TemplateGraphicsConsolesServiceListRequest) Header(key, value string) *TemplateGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceListRequest) Query(key, value string) *TemplateGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateGraphicsConsolesServiceListRequest) Follow(follow string) *TemplateGraphicsConsolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *TemplateGraphicsConsolesServiceListRequest) Max(max int64) *TemplateGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}

func (p *TemplateGraphicsConsolesServiceListRequest) Send() (*TemplateGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateGraphicsConsolesService.connection.URL(), p.TemplateGraphicsConsolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateGraphicsConsolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateGraphicsConsolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateGraphicsConsolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &TemplateGraphicsConsolesServiceListResponse{consoles: result}, nil
}

func (p *TemplateGraphicsConsolesServiceListRequest) MustSend() *TemplateGraphicsConsolesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all the configured graphics consoles of the template.
// The order of the returned list of graphics consoles isn't guaranteed.
//
type TemplateGraphicsConsolesServiceListResponse struct {
	consoles *GraphicsConsoleSlice
}

func (p *TemplateGraphicsConsolesServiceListResponse) Consoles() (*GraphicsConsoleSlice, bool) {
	if p.consoles != nil {
		return p.consoles, true
	}
	return nil, false
}

func (p *TemplateGraphicsConsolesServiceListResponse) MustConsoles() *GraphicsConsoleSlice {
	if p.consoles == nil {
		panic("consoles in response does not exist")
	}
	return p.consoles
}

//
// Lists all the configured graphics consoles of the template.
// The order of the returned list of graphics consoles isn't guaranteed.
//
func (p *TemplateGraphicsConsolesService) List() *TemplateGraphicsConsolesServiceListRequest {
	return &TemplateGraphicsConsolesServiceListRequest{TemplateGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific template graphics console.
//
func (op *TemplateGraphicsConsolesService) ConsoleService(id string) *TemplateGraphicsConsoleService {
	return NewTemplateGraphicsConsoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateGraphicsConsolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConsoleService(path), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *TemplateGraphicsConsolesService) String() string {
	return fmt.Sprintf("TemplateGraphicsConsolesService:%s", op.path)
}

//
//
type StorageDomainVmService struct {
	BaseService
}

func NewStorageDomainVmService(connection *Connection, path string) *StorageDomainVmService {
	var result StorageDomainVmService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StorageDomainVmServiceGetRequest struct {
	StorageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *StorageDomainVmServiceGetRequest) Header(key, value string) *StorageDomainVmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceGetRequest) Query(key, value string) *StorageDomainVmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceGetRequest) Follow(follow string) *StorageDomainVmServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainVmServiceGetRequest) Send() (*StorageDomainVmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainVmService.connection.URL(), p.StorageDomainVmService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainVmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainVmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainVmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainVmServiceGetResponse{vm: result}, nil
}

func (p *StorageDomainVmServiceGetRequest) MustSend() *StorageDomainVmServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageDomainVmServiceGetResponse struct {
	vm *Vm
}

func (p *StorageDomainVmServiceGetResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *StorageDomainVmServiceGetResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
//
func (p *StorageDomainVmService) Get() *StorageDomainVmServiceGetRequest {
	return &StorageDomainVmServiceGetRequest{StorageDomainVmService: p}
}

//
// Imports a virtual machine from an export storage domain.
// For example, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/vms/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// To import a virtual machine as a new entity add the `clone` parameter:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <clone>true</clone>
//   <vm>
//     <name>myvm</name>
//   </vm>
// </action>
// ----
// Include an optional `disks` parameter to choose which disks to import. For example, to import the disks
// of the template that have the identifiers `123` and `456` send the following request body:
// [source,xml]
// ----
// <action>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <vm>
//     <name>myvm</name>
//   </vm>
//   <disks>
//     <disk id="123"/>
//     <disk id="456"/>
//   </disks>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
type StorageDomainVmServiceImportRequest struct {
	StorageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
	clone                  *bool
	cluster                *Cluster
	collapseSnapshots      *bool
	exclusive              *bool
	storageDomain          *StorageDomain
	vm                     *Vm
}

func (p *StorageDomainVmServiceImportRequest) Header(key, value string) *StorageDomainVmServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceImportRequest) Query(key, value string) *StorageDomainVmServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceImportRequest) Async(async bool) *StorageDomainVmServiceImportRequest {
	p.async = &async
	return p
}

func (p *StorageDomainVmServiceImportRequest) Clone(clone bool) *StorageDomainVmServiceImportRequest {
	p.clone = &clone
	return p
}

func (p *StorageDomainVmServiceImportRequest) Cluster(cluster *Cluster) *StorageDomainVmServiceImportRequest {
	p.cluster = cluster
	return p
}

func (p *StorageDomainVmServiceImportRequest) CollapseSnapshots(collapseSnapshots bool) *StorageDomainVmServiceImportRequest {
	p.collapseSnapshots = &collapseSnapshots
	return p
}

func (p *StorageDomainVmServiceImportRequest) Exclusive(exclusive bool) *StorageDomainVmServiceImportRequest {
	p.exclusive = &exclusive
	return p
}

func (p *StorageDomainVmServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainVmServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainVmServiceImportRequest) Vm(vm *Vm) *StorageDomainVmServiceImportRequest {
	p.vm = vm
	return p
}

func (p *StorageDomainVmServiceImportRequest) Send() (*StorageDomainVmServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.StorageDomainVmService.connection.URL(), p.StorageDomainVmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.collapseSnapshots != nil {
		actionBuilder.CollapseSnapshots(*p.collapseSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainVmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainVmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainVmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainVmServiceImportResponse), nil
}

func (p *StorageDomainVmServiceImportRequest) MustSend() *StorageDomainVmServiceImportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Imports a virtual machine from an export storage domain.
// For example, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/vms/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// To import a virtual machine as a new entity add the `clone` parameter:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <clone>true</clone>
//   <vm>
//     <name>myvm</name>
//   </vm>
// </action>
// ----
// Include an optional `disks` parameter to choose which disks to import. For example, to import the disks
// of the template that have the identifiers `123` and `456` send the following request body:
// [source,xml]
// ----
// <action>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <vm>
//     <name>myvm</name>
//   </vm>
//   <disks>
//     <disk id="123"/>
//     <disk id="456"/>
//   </disks>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
type StorageDomainVmServiceImportResponse struct {
}

//
// Imports a virtual machine from an export storage domain.
// For example, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storagedomains/123/vms/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
// </action>
// ----
// To import a virtual machine as a new entity add the `clone` parameter:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>mydata</name>
//   </storage_domain>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <clone>true</clone>
//   <vm>
//     <name>myvm</name>
//   </vm>
// </action>
// ----
// Include an optional `disks` parameter to choose which disks to import. For example, to import the disks
// of the template that have the identifiers `123` and `456` send the following request body:
// [source,xml]
// ----
// <action>
//   <cluster>
//     <name>mycluster</name>
//   </cluster>
//   <vm>
//     <name>myvm</name>
//   </vm>
//   <disks>
//     <disk id="123"/>
//     <disk id="456"/>
//   </disks>
// </action>
// ----
// If you register an entity without specifying the cluster ID or name,
// the cluster name from the entity's OVF will be used (unless the register request also includes the
// cluster mapping).
//
func (p *StorageDomainVmService) Import() *StorageDomainVmServiceImportRequest {
	return &StorageDomainVmServiceImportRequest{StorageDomainVmService: p}
}

//
//
type StorageDomainVmServiceRegisterRequest struct {
	StorageDomainVmService    *StorageDomainVmService
	header                    map[string]string
	query                     map[string]string
	allowPartialImport        *bool
	async                     *bool
	clone                     *bool
	cluster                   *Cluster
	reassignBadMacs           *bool
	registrationConfiguration *RegistrationConfiguration
	vm                        *Vm
	vnicProfileMappings       *VnicProfileMappingSlice
}

func (p *StorageDomainVmServiceRegisterRequest) Header(key, value string) *StorageDomainVmServiceRegisterRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) Query(key, value string) *StorageDomainVmServiceRegisterRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) AllowPartialImport(allowPartialImport bool) *StorageDomainVmServiceRegisterRequest {
	p.allowPartialImport = &allowPartialImport
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) Async(async bool) *StorageDomainVmServiceRegisterRequest {
	p.async = &async
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) Clone(clone bool) *StorageDomainVmServiceRegisterRequest {
	p.clone = &clone
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) Cluster(cluster *Cluster) *StorageDomainVmServiceRegisterRequest {
	p.cluster = cluster
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) ReassignBadMacs(reassignBadMacs bool) *StorageDomainVmServiceRegisterRequest {
	p.reassignBadMacs = &reassignBadMacs
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) RegistrationConfiguration(registrationConfiguration *RegistrationConfiguration) *StorageDomainVmServiceRegisterRequest {
	p.registrationConfiguration = registrationConfiguration
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) Vm(vm *Vm) *StorageDomainVmServiceRegisterRequest {
	p.vm = vm
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) VnicProfileMappings(vnicProfileMappings *VnicProfileMappingSlice) *StorageDomainVmServiceRegisterRequest {
	p.vnicProfileMappings = vnicProfileMappings
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) VnicProfileMappingsOfAny(anys ...*VnicProfileMapping) *StorageDomainVmServiceRegisterRequest {
	if p.vnicProfileMappings == nil {
		p.vnicProfileMappings = new(VnicProfileMappingSlice)
	}
	p.vnicProfileMappings.slice = append(p.vnicProfileMappings.slice, anys...)
	return p
}

func (p *StorageDomainVmServiceRegisterRequest) Send() (*StorageDomainVmServiceRegisterResponse, error) {
	rawURL := fmt.Sprintf("%s%s/register", p.StorageDomainVmService.connection.URL(), p.StorageDomainVmService.path)
	actionBuilder := NewActionBuilder()
	if p.allowPartialImport != nil {
		actionBuilder.AllowPartialImport(*p.allowPartialImport)
	}
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.clone != nil {
		actionBuilder.Clone(*p.clone)
	}
	actionBuilder.Cluster(p.cluster)
	if p.reassignBadMacs != nil {
		actionBuilder.ReassignBadMacs(*p.reassignBadMacs)
	}
	actionBuilder.RegistrationConfiguration(p.registrationConfiguration)
	actionBuilder.Vm(p.vm)
	actionBuilder.VnicProfileMappings(p.vnicProfileMappings)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainVmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainVmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainVmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainVmServiceRegisterResponse), nil
}

func (p *StorageDomainVmServiceRegisterRequest) MustSend() *StorageDomainVmServiceRegisterResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageDomainVmServiceRegisterResponse struct {
}

//
//
func (p *StorageDomainVmService) Register() *StorageDomainVmServiceRegisterRequest {
	return &StorageDomainVmServiceRegisterRequest{StorageDomainVmService: p}
}

//
// Deletes a virtual machine from an export storage domain.
// For example, to delete the virtual machine `456` from the storage domain `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123/vms/456
// ----
//
type StorageDomainVmServiceRemoveRequest struct {
	StorageDomainVmService *StorageDomainVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *StorageDomainVmServiceRemoveRequest) Header(key, value string) *StorageDomainVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmServiceRemoveRequest) Query(key, value string) *StorageDomainVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmServiceRemoveRequest) Async(async bool) *StorageDomainVmServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *StorageDomainVmServiceRemoveRequest) Send() (*StorageDomainVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainVmService.connection.URL(), p.StorageDomainVmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainVmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainVmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainVmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainVmServiceRemoveResponse), nil
}

func (p *StorageDomainVmServiceRemoveRequest) MustSend() *StorageDomainVmServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Deletes a virtual machine from an export storage domain.
// For example, to delete the virtual machine `456` from the storage domain `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123/vms/456
// ----
//
type StorageDomainVmServiceRemoveResponse struct {
}

//
// Deletes a virtual machine from an export storage domain.
// For example, to delete the virtual machine `456` from the storage domain `123`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/storagedomains/123/vms/456
// ----
//
func (p *StorageDomainVmService) Remove() *StorageDomainVmServiceRemoveRequest {
	return &StorageDomainVmServiceRemoveRequest{StorageDomainVmService: p}
}

//
// Returns a reference to the service that manages the disk attachments of the virtual machine.
//
func (op *StorageDomainVmService) DiskAttachmentsService() *StorageDomainVmDiskAttachmentsService {
	return NewStorageDomainVmDiskAttachmentsService(op.connection, fmt.Sprintf("%s/diskattachments", op.path))
}

//
//
func (op *StorageDomainVmService) DisksService() *StorageDomainContentDisksService {
	return NewStorageDomainContentDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainVmService) String() string {
	return fmt.Sprintf("StorageDomainVmService:%s", op.path)
}

//
//
type QuotaClusterLimitService struct {
	BaseService
}

func NewQuotaClusterLimitService(connection *Connection, path string) *QuotaClusterLimitService {
	var result QuotaClusterLimitService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type QuotaClusterLimitServiceGetRequest struct {
	QuotaClusterLimitService *QuotaClusterLimitService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *QuotaClusterLimitServiceGetRequest) Header(key, value string) *QuotaClusterLimitServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitServiceGetRequest) Query(key, value string) *QuotaClusterLimitServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitServiceGetRequest) Follow(follow string) *QuotaClusterLimitServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *QuotaClusterLimitServiceGetRequest) Send() (*QuotaClusterLimitServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaClusterLimitService.connection.URL(), p.QuotaClusterLimitService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaClusterLimitService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaClusterLimitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaClusterLimitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaClusterLimitService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaClusterLimitService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaClusterLimitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QuotaClusterLimitServiceGetResponse{limit: result}, nil
}

func (p *QuotaClusterLimitServiceGetRequest) MustSend() *QuotaClusterLimitServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type QuotaClusterLimitServiceGetResponse struct {
	limit *QuotaClusterLimit
}

func (p *QuotaClusterLimitServiceGetResponse) Limit() (*QuotaClusterLimit, bool) {
	if p.limit != nil {
		return p.limit, true
	}
	return nil, false
}

func (p *QuotaClusterLimitServiceGetResponse) MustLimit() *QuotaClusterLimit {
	if p.limit == nil {
		panic("limit in response does not exist")
	}
	return p.limit
}

//
//
func (p *QuotaClusterLimitService) Get() *QuotaClusterLimitServiceGetRequest {
	return &QuotaClusterLimitServiceGetRequest{QuotaClusterLimitService: p}
}

//
//
type QuotaClusterLimitServiceRemoveRequest struct {
	QuotaClusterLimitService *QuotaClusterLimitService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *QuotaClusterLimitServiceRemoveRequest) Header(key, value string) *QuotaClusterLimitServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaClusterLimitServiceRemoveRequest) Query(key, value string) *QuotaClusterLimitServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaClusterLimitServiceRemoveRequest) Async(async bool) *QuotaClusterLimitServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *QuotaClusterLimitServiceRemoveRequest) Send() (*QuotaClusterLimitServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaClusterLimitService.connection.URL(), p.QuotaClusterLimitService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaClusterLimitService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaClusterLimitService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaClusterLimitService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaClusterLimitService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaClusterLimitService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(QuotaClusterLimitServiceRemoveResponse), nil
}

func (p *QuotaClusterLimitServiceRemoveRequest) MustSend() *QuotaClusterLimitServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type QuotaClusterLimitServiceRemoveResponse struct {
}

//
//
func (p *QuotaClusterLimitService) Remove() *QuotaClusterLimitServiceRemoveRequest {
	return &QuotaClusterLimitServiceRemoveRequest{QuotaClusterLimitService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaClusterLimitService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *QuotaClusterLimitService) String() string {
	return fmt.Sprintf("QuotaClusterLimitService:%s", op.path)
}

//
// This service manages a single affinity group.
//
type AffinityGroupService struct {
	BaseService
}

func NewAffinityGroupService(connection *Connection, path string) *AffinityGroupService {
	var result AffinityGroupService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieve the affinity group details.
// [source,xml]
// ----
// <affinity_group id="00000000-0000-0000-0000-000000000000">
//   <name>AF_GROUP_001</name>
//   <cluster id="00000000-0000-0000-0000-000000000000"/>
//   <positive>true</positive>
//   <enforcing>true</enforcing>
// </affinity_group>
// ----
//
type AffinityGroupServiceGetRequest struct {
	AffinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *AffinityGroupServiceGetRequest) Header(key, value string) *AffinityGroupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceGetRequest) Query(key, value string) *AffinityGroupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceGetRequest) Follow(follow string) *AffinityGroupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AffinityGroupServiceGetRequest) Send() (*AffinityGroupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupService.connection.URL(), p.AffinityGroupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityGroupServiceGetResponse{group: result}, nil
}

func (p *AffinityGroupServiceGetRequest) MustSend() *AffinityGroupServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieve the affinity group details.
// [source,xml]
// ----
// <affinity_group id="00000000-0000-0000-0000-000000000000">
//   <name>AF_GROUP_001</name>
//   <cluster id="00000000-0000-0000-0000-000000000000"/>
//   <positive>true</positive>
//   <enforcing>true</enforcing>
// </affinity_group>
// ----
//
type AffinityGroupServiceGetResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupServiceGetResponse) Group() (*AffinityGroup, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *AffinityGroupServiceGetResponse) MustGroup() *AffinityGroup {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Retrieve the affinity group details.
// [source,xml]
// ----
// <affinity_group id="00000000-0000-0000-0000-000000000000">
//   <name>AF_GROUP_001</name>
//   <cluster id="00000000-0000-0000-0000-000000000000"/>
//   <positive>true</positive>
//   <enforcing>true</enforcing>
// </affinity_group>
// ----
//
func (p *AffinityGroupService) Get() *AffinityGroupServiceGetRequest {
	return &AffinityGroupServiceGetRequest{AffinityGroupService: p}
}

//
// Remove the affinity group.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/000-000/affinitygroups/123-456
// ----
//
type AffinityGroupServiceRemoveRequest struct {
	AffinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *AffinityGroupServiceRemoveRequest) Header(key, value string) *AffinityGroupServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceRemoveRequest) Query(key, value string) *AffinityGroupServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceRemoveRequest) Async(async bool) *AffinityGroupServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AffinityGroupServiceRemoveRequest) Send() (*AffinityGroupServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupService.connection.URL(), p.AffinityGroupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityGroupServiceRemoveResponse), nil
}

func (p *AffinityGroupServiceRemoveRequest) MustSend() *AffinityGroupServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove the affinity group.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/000-000/affinitygroups/123-456
// ----
//
type AffinityGroupServiceRemoveResponse struct {
}

//
// Remove the affinity group.
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/000-000/affinitygroups/123-456
// ----
//
func (p *AffinityGroupService) Remove() *AffinityGroupServiceRemoveRequest {
	return &AffinityGroupServiceRemoveRequest{AffinityGroupService: p}
}

//
// Update the affinity group.
//
type AffinityGroupServiceUpdateRequest struct {
	AffinityGroupService *AffinityGroupService
	header               map[string]string
	query                map[string]string
	async                *bool
	group                *AffinityGroup
}

func (p *AffinityGroupServiceUpdateRequest) Header(key, value string) *AffinityGroupServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupServiceUpdateRequest) Query(key, value string) *AffinityGroupServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupServiceUpdateRequest) Async(async bool) *AffinityGroupServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *AffinityGroupServiceUpdateRequest) Group(group *AffinityGroup) *AffinityGroupServiceUpdateRequest {
	p.group = group
	return p
}

func (p *AffinityGroupServiceUpdateRequest) Send() (*AffinityGroupServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupService.connection.URL(), p.AffinityGroupService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityGroupWriteOne(writer, p.group, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityGroupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityGroupServiceUpdateResponse{group: result}, nil
}

func (p *AffinityGroupServiceUpdateRequest) MustSend() *AffinityGroupServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the affinity group.
//
type AffinityGroupServiceUpdateResponse struct {
	group *AffinityGroup
}

func (p *AffinityGroupServiceUpdateResponse) Group() (*AffinityGroup, bool) {
	if p.group != nil {
		return p.group, true
	}
	return nil, false
}

func (p *AffinityGroupServiceUpdateResponse) MustGroup() *AffinityGroup {
	if p.group == nil {
		panic("group in response does not exist")
	}
	return p.group
}

//
// Update the affinity group.
//
func (p *AffinityGroupService) Update() *AffinityGroupServiceUpdateRequest {
	return &AffinityGroupServiceUpdateRequest{AffinityGroupService: p}
}

//
// Returns a reference to the service that manages the
// list of all host labels attached to this affinity
// group.
//
func (op *AffinityGroupService) HostLabelsService() *AffinityGroupHostLabelsService {
	return NewAffinityGroupHostLabelsService(op.connection, fmt.Sprintf("%s/hostlabels", op.path))
}

//
// Returns a reference to the service that manages the
// list of all hosts attached to this affinity
// group.
//
func (op *AffinityGroupService) HostsService() *AffinityGroupHostsService {
	return NewAffinityGroupHostsService(op.connection, fmt.Sprintf("%s/hosts", op.path))
}

//
// Returns a reference to the service that manages the
// list of all virtual machine labels attached to this affinity
// group.
//
func (op *AffinityGroupService) VmLabelsService() *AffinityGroupVmLabelsService {
	return NewAffinityGroupVmLabelsService(op.connection, fmt.Sprintf("%s/vmlabels", op.path))
}

//
// Returns a reference to the service that manages the
// list of all virtual machines attached to this affinity
// group.
//
func (op *AffinityGroupService) VmsService() *AffinityGroupVmsService {
	return NewAffinityGroupVmsService(op.connection, fmt.Sprintf("%s/vms", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "hostlabels" {
		return op.HostLabelsService(), nil
	}
	if strings.HasPrefix(path, "hostlabels/") {
		return op.HostLabelsService().Service(path[11:])
	}
	if path == "hosts" {
		return op.HostsService(), nil
	}
	if strings.HasPrefix(path, "hosts/") {
		return op.HostsService().Service(path[6:])
	}
	if path == "vmlabels" {
		return op.VmLabelsService(), nil
	}
	if strings.HasPrefix(path, "vmlabels/") {
		return op.VmLabelsService().Service(path[9:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupService) String() string {
	return fmt.Sprintf("AffinityGroupService:%s", op.path)
}

//
// A service to manage an event in the system.
//
type EventService struct {
	BaseService
}

func NewEventService(connection *Connection, path string) *EventService {
	var result EventService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get an event.
// An example of getting an event:
// [source]
// ----
// GET /ovirt-engine/api/events/123
// ----
// [source,xml]
// ----
// <event href="/ovirt-engine/api/events/123" id="123">
//   <description>Host example.com was added by admin@internal-authz.</description>
//   <code>42</code>
//   <correlation_id>135</correlation_id>
//   <custom_id>-1</custom_id>
//   <flood_rate>30</flood_rate>
//   <origin>oVirt</origin>
//   <severity>normal</severity>
//   <time>2016-12-11T11:13:44.654+02:00</time>
//   <cluster href="/ovirt-engine/api/clusters/456" id="456"/>
//   <host href="/ovirt-engine/api/hosts/789" id="789"/>
//   <user href="/ovirt-engine/api/users/987" id="987"/>
// </event>
// ----
// Note that the number of fields changes according to the information that resides on the event.
// For example, for storage domain related events you will get the storage domain reference,
// as well as the reference for the data center this storage domain resides in.
//
type EventServiceGetRequest struct {
	EventService *EventService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *EventServiceGetRequest) Header(key, value string) *EventServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventServiceGetRequest) Query(key, value string) *EventServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventServiceGetRequest) Follow(follow string) *EventServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *EventServiceGetRequest) Send() (*EventServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EventService.connection.URL(), p.EventService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &EventServiceGetResponse{event: result}, nil
}

func (p *EventServiceGetRequest) MustSend() *EventServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get an event.
// An example of getting an event:
// [source]
// ----
// GET /ovirt-engine/api/events/123
// ----
// [source,xml]
// ----
// <event href="/ovirt-engine/api/events/123" id="123">
//   <description>Host example.com was added by admin@internal-authz.</description>
//   <code>42</code>
//   <correlation_id>135</correlation_id>
//   <custom_id>-1</custom_id>
//   <flood_rate>30</flood_rate>
//   <origin>oVirt</origin>
//   <severity>normal</severity>
//   <time>2016-12-11T11:13:44.654+02:00</time>
//   <cluster href="/ovirt-engine/api/clusters/456" id="456"/>
//   <host href="/ovirt-engine/api/hosts/789" id="789"/>
//   <user href="/ovirt-engine/api/users/987" id="987"/>
// </event>
// ----
// Note that the number of fields changes according to the information that resides on the event.
// For example, for storage domain related events you will get the storage domain reference,
// as well as the reference for the data center this storage domain resides in.
//
type EventServiceGetResponse struct {
	event *Event
}

func (p *EventServiceGetResponse) Event() (*Event, bool) {
	if p.event != nil {
		return p.event, true
	}
	return nil, false
}

func (p *EventServiceGetResponse) MustEvent() *Event {
	if p.event == nil {
		panic("event in response does not exist")
	}
	return p.event
}

//
// Get an event.
// An example of getting an event:
// [source]
// ----
// GET /ovirt-engine/api/events/123
// ----
// [source,xml]
// ----
// <event href="/ovirt-engine/api/events/123" id="123">
//   <description>Host example.com was added by admin@internal-authz.</description>
//   <code>42</code>
//   <correlation_id>135</correlation_id>
//   <custom_id>-1</custom_id>
//   <flood_rate>30</flood_rate>
//   <origin>oVirt</origin>
//   <severity>normal</severity>
//   <time>2016-12-11T11:13:44.654+02:00</time>
//   <cluster href="/ovirt-engine/api/clusters/456" id="456"/>
//   <host href="/ovirt-engine/api/hosts/789" id="789"/>
//   <user href="/ovirt-engine/api/users/987" id="987"/>
// </event>
// ----
// Note that the number of fields changes according to the information that resides on the event.
// For example, for storage domain related events you will get the storage domain reference,
// as well as the reference for the data center this storage domain resides in.
//
func (p *EventService) Get() *EventServiceGetRequest {
	return &EventServiceGetRequest{EventService: p}
}

//
// Removes an event from internal audit log.
// An event can be removed by sending following request
// [source]
// ----
// DELETE /ovirt-engine/api/events/123
// ----
//
type EventServiceRemoveRequest struct {
	EventService *EventService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *EventServiceRemoveRequest) Header(key, value string) *EventServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventServiceRemoveRequest) Query(key, value string) *EventServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventServiceRemoveRequest) Async(async bool) *EventServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *EventServiceRemoveRequest) Send() (*EventServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EventService.connection.URL(), p.EventService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(EventServiceRemoveResponse), nil
}

func (p *EventServiceRemoveRequest) MustSend() *EventServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes an event from internal audit log.
// An event can be removed by sending following request
// [source]
// ----
// DELETE /ovirt-engine/api/events/123
// ----
//
type EventServiceRemoveResponse struct {
}

//
// Removes an event from internal audit log.
// An event can be removed by sending following request
// [source]
// ----
// DELETE /ovirt-engine/api/events/123
// ----
//
func (p *EventService) Remove() *EventServiceRemoveRequest {
	return &EventServiceRemoveRequest{EventService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EventService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *EventService) String() string {
	return fmt.Sprintf("EventService:%s", op.path)
}

//
//
type OpenstackVolumeTypesService struct {
	BaseService
}

func NewOpenstackVolumeTypesService(connection *Connection, path string) *OpenstackVolumeTypesService {
	var result OpenstackVolumeTypesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of volume types.
// The order of the returned list of volume types isn't guaranteed.
//
type OpenstackVolumeTypesServiceListRequest struct {
	OpenstackVolumeTypesService *OpenstackVolumeTypesService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
	max                         *int64
}

func (p *OpenstackVolumeTypesServiceListRequest) Header(key, value string) *OpenstackVolumeTypesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeTypesServiceListRequest) Query(key, value string) *OpenstackVolumeTypesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeTypesServiceListRequest) Follow(follow string) *OpenstackVolumeTypesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackVolumeTypesServiceListRequest) Max(max int64) *OpenstackVolumeTypesServiceListRequest {
	p.max = &max
	return p
}

func (p *OpenstackVolumeTypesServiceListRequest) Send() (*OpenstackVolumeTypesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeTypesService.connection.URL(), p.OpenstackVolumeTypesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeTypesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeTypesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeTypesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeTypesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeTypesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeTypeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeTypesServiceListResponse{types: result}, nil
}

func (p *OpenstackVolumeTypesServiceListRequest) MustSend() *OpenstackVolumeTypesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of volume types.
// The order of the returned list of volume types isn't guaranteed.
//
type OpenstackVolumeTypesServiceListResponse struct {
	types *OpenStackVolumeTypeSlice
}

func (p *OpenstackVolumeTypesServiceListResponse) Types() (*OpenStackVolumeTypeSlice, bool) {
	if p.types != nil {
		return p.types, true
	}
	return nil, false
}

func (p *OpenstackVolumeTypesServiceListResponse) MustTypes() *OpenStackVolumeTypeSlice {
	if p.types == nil {
		panic("types in response does not exist")
	}
	return p.types
}

//
// Returns the list of volume types.
// The order of the returned list of volume types isn't guaranteed.
//
func (p *OpenstackVolumeTypesService) List() *OpenstackVolumeTypesServiceListRequest {
	return &OpenstackVolumeTypesServiceListRequest{OpenstackVolumeTypesService: p}
}

//
//
func (op *OpenstackVolumeTypesService) TypeService(id string) *OpenstackVolumeTypeService {
	return NewOpenstackVolumeTypeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeTypesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TypeService(path), nil
	}
	return op.TypeService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeTypesService) String() string {
	return fmt.Sprintf("OpenstackVolumeTypesService:%s", op.path)
}

//
//
type OpenstackVolumeAuthenticationKeyService struct {
	BaseService
}

func NewOpenstackVolumeAuthenticationKeyService(connection *Connection, path string) *OpenstackVolumeAuthenticationKeyService {
	var result OpenstackVolumeAuthenticationKeyService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OpenstackVolumeAuthenticationKeyServiceGetRequest struct {
	OpenstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	follow                                  *string
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Follow(follow string) *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeAuthenticationKeyService.connection.URL(), p.OpenstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeAuthenticationKeyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeAuthenticationKeyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeAuthenticationKeyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeAuthenticationKeyServiceGetResponse{key: result}, nil
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetRequest) MustSend() *OpenstackVolumeAuthenticationKeyServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackVolumeAuthenticationKeyServiceGetResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetResponse) Key() (*OpenstackVolumeAuthenticationKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *OpenstackVolumeAuthenticationKeyServiceGetResponse) MustKey() *OpenstackVolumeAuthenticationKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
//
func (p *OpenstackVolumeAuthenticationKeyService) Get() *OpenstackVolumeAuthenticationKeyServiceGetRequest {
	return &OpenstackVolumeAuthenticationKeyServiceGetRequest{OpenstackVolumeAuthenticationKeyService: p}
}

//
//
type OpenstackVolumeAuthenticationKeyServiceRemoveRequest struct {
	OpenstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	async                                   *bool
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Async(async bool) *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeAuthenticationKeyService.connection.URL(), p.OpenstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeAuthenticationKeyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeAuthenticationKeyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeAuthenticationKeyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackVolumeAuthenticationKeyServiceRemoveResponse), nil
}

func (p *OpenstackVolumeAuthenticationKeyServiceRemoveRequest) MustSend() *OpenstackVolumeAuthenticationKeyServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackVolumeAuthenticationKeyServiceRemoveResponse struct {
}

//
//
func (p *OpenstackVolumeAuthenticationKeyService) Remove() *OpenstackVolumeAuthenticationKeyServiceRemoveRequest {
	return &OpenstackVolumeAuthenticationKeyServiceRemoveRequest{OpenstackVolumeAuthenticationKeyService: p}
}

//
// Update the specified authentication key.
//
type OpenstackVolumeAuthenticationKeyServiceUpdateRequest struct {
	OpenstackVolumeAuthenticationKeyService *OpenstackVolumeAuthenticationKeyService
	header                                  map[string]string
	query                                   map[string]string
	key                                     *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Key(key *OpenstackVolumeAuthenticationKey) *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	p.key = key
	return p
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) Send() (*OpenstackVolumeAuthenticationKeyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeAuthenticationKeyService.connection.URL(), p.OpenstackVolumeAuthenticationKeyService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenstackVolumeAuthenticationKeyWriteOne(writer, p.key, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeAuthenticationKeyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeAuthenticationKeyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeAuthenticationKeyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeAuthenticationKeyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeAuthenticationKeyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeAuthenticationKeyServiceUpdateResponse{key: result}, nil
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateRequest) MustSend() *OpenstackVolumeAuthenticationKeyServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified authentication key.
//
type OpenstackVolumeAuthenticationKeyServiceUpdateResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateResponse) Key() (*OpenstackVolumeAuthenticationKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *OpenstackVolumeAuthenticationKeyServiceUpdateResponse) MustKey() *OpenstackVolumeAuthenticationKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
// Update the specified authentication key.
//
func (p *OpenstackVolumeAuthenticationKeyService) Update() *OpenstackVolumeAuthenticationKeyServiceUpdateRequest {
	return &OpenstackVolumeAuthenticationKeyServiceUpdateRequest{OpenstackVolumeAuthenticationKeyService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeAuthenticationKeyService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeAuthenticationKeyService) String() string {
	return fmt.Sprintf("OpenstackVolumeAuthenticationKeyService:%s", op.path)
}

//
//
type OpenstackNetworkService struct {
	BaseService
}

func NewOpenstackNetworkService(connection *Connection, path string) *OpenstackNetworkService {
	var result OpenstackNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OpenstackNetworkServiceGetRequest struct {
	OpenstackNetworkService *OpenstackNetworkService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *OpenstackNetworkServiceGetRequest) Header(key, value string) *OpenstackNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkServiceGetRequest) Query(key, value string) *OpenstackNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkServiceGetRequest) Follow(follow string) *OpenstackNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackNetworkServiceGetRequest) Send() (*OpenstackNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackNetworkService.connection.URL(), p.OpenstackNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackNetworkServiceGetResponse{network: result}, nil
}

func (p *OpenstackNetworkServiceGetRequest) MustSend() *OpenstackNetworkServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackNetworkServiceGetResponse struct {
	network *OpenStackNetwork
}

func (p *OpenstackNetworkServiceGetResponse) Network() (*OpenStackNetwork, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *OpenstackNetworkServiceGetResponse) MustNetwork() *OpenStackNetwork {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
//
func (p *OpenstackNetworkService) Get() *OpenstackNetworkServiceGetRequest {
	return &OpenstackNetworkServiceGetRequest{OpenstackNetworkService: p}
}

//
// This operation imports an external network into {product-name}.
// The network will be added to the specified data center.
//
type OpenstackNetworkServiceImportRequest struct {
	OpenstackNetworkService *OpenstackNetworkService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	dataCenter              *DataCenter
}

func (p *OpenstackNetworkServiceImportRequest) Header(key, value string) *OpenstackNetworkServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkServiceImportRequest) Query(key, value string) *OpenstackNetworkServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkServiceImportRequest) Async(async bool) *OpenstackNetworkServiceImportRequest {
	p.async = &async
	return p
}

func (p *OpenstackNetworkServiceImportRequest) DataCenter(dataCenter *DataCenter) *OpenstackNetworkServiceImportRequest {
	p.dataCenter = dataCenter
	return p
}

func (p *OpenstackNetworkServiceImportRequest) Send() (*OpenstackNetworkServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.OpenstackNetworkService.connection.URL(), p.OpenstackNetworkService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.DataCenter(p.dataCenter)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackNetworkServiceImportResponse), nil
}

func (p *OpenstackNetworkServiceImportRequest) MustSend() *OpenstackNetworkServiceImportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation imports an external network into {product-name}.
// The network will be added to the specified data center.
//
type OpenstackNetworkServiceImportResponse struct {
}

//
// This operation imports an external network into {product-name}.
// The network will be added to the specified data center.
//
func (p *OpenstackNetworkService) Import() *OpenstackNetworkServiceImportRequest {
	return &OpenstackNetworkServiceImportRequest{OpenstackNetworkService: p}
}

//
//
func (op *OpenstackNetworkService) SubnetsService() *OpenstackSubnetsService {
	return NewOpenstackSubnetsService(op.connection, fmt.Sprintf("%s/subnets", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "subnets" {
		return op.SubnetsService(), nil
	}
	if strings.HasPrefix(path, "subnets/") {
		return op.SubnetsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackNetworkService) String() string {
	return fmt.Sprintf("OpenstackNetworkService:%s", op.path)
}

//
//
type OpenstackVolumeProvidersService struct {
	BaseService
}

func NewOpenstackVolumeProvidersService(connection *Connection, path string) *OpenstackVolumeProvidersService {
	var result OpenstackVolumeProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a new volume provider.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/openstackvolumeproviders
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_volume_provider>
//   <name>mycinder</name>
//   <url>https://mycinder.example.com:8776</url>
//   <data_center>
//     <name>mydc</name>
//   </data_center>
//   <requires_authentication>true</requires_authentication>
//   <username>admin</username>
//   <password>mypassword</password>
//   <tenant_name>mytenant</tenant_name>
// </openstack_volume_provider>
// ----
//
type OpenstackVolumeProvidersServiceAddRequest struct {
	OpenstackVolumeProvidersService *OpenstackVolumeProvidersService
	header                          map[string]string
	query                           map[string]string
	provider                        *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Header(key, value string) *OpenstackVolumeProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Query(key, value string) *OpenstackVolumeProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Provider(provider *OpenStackVolumeProvider) *OpenstackVolumeProvidersServiceAddRequest {
	p.provider = provider
	return p
}

func (p *OpenstackVolumeProvidersServiceAddRequest) Send() (*OpenstackVolumeProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeProvidersService.connection.URL(), p.OpenstackVolumeProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackVolumeProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeProvidersServiceAddResponse{provider: result}, nil
}

func (p *OpenstackVolumeProvidersServiceAddRequest) MustSend() *OpenstackVolumeProvidersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a new volume provider.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/openstackvolumeproviders
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_volume_provider>
//   <name>mycinder</name>
//   <url>https://mycinder.example.com:8776</url>
//   <data_center>
//     <name>mydc</name>
//   </data_center>
//   <requires_authentication>true</requires_authentication>
//   <username>admin</username>
//   <password>mypassword</password>
//   <tenant_name>mytenant</tenant_name>
// </openstack_volume_provider>
// ----
//
type OpenstackVolumeProvidersServiceAddResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProvidersServiceAddResponse) Provider() (*OpenStackVolumeProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackVolumeProvidersServiceAddResponse) MustProvider() *OpenStackVolumeProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Adds a new volume provider.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/openstackvolumeproviders
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_volume_provider>
//   <name>mycinder</name>
//   <url>https://mycinder.example.com:8776</url>
//   <data_center>
//     <name>mydc</name>
//   </data_center>
//   <requires_authentication>true</requires_authentication>
//   <username>admin</username>
//   <password>mypassword</password>
//   <tenant_name>mytenant</tenant_name>
// </openstack_volume_provider>
// ----
//
func (p *OpenstackVolumeProvidersService) Add() *OpenstackVolumeProvidersServiceAddRequest {
	return &OpenstackVolumeProvidersServiceAddRequest{OpenstackVolumeProvidersService: p}
}

//
// Retrieves the list of volume providers.
// The order of the returned list of volume providers isn't guaranteed.
//
type OpenstackVolumeProvidersServiceListRequest struct {
	OpenstackVolumeProvidersService *OpenstackVolumeProvidersService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
	max                             *int64
	search                          *string
}

func (p *OpenstackVolumeProvidersServiceListRequest) Header(key, value string) *OpenstackVolumeProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Query(key, value string) *OpenstackVolumeProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Follow(follow string) *OpenstackVolumeProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Max(max int64) *OpenstackVolumeProvidersServiceListRequest {
	p.max = &max
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Search(search string) *OpenstackVolumeProvidersServiceListRequest {
	p.search = &search
	return p
}

func (p *OpenstackVolumeProvidersServiceListRequest) Send() (*OpenstackVolumeProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeProvidersService.connection.URL(), p.OpenstackVolumeProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeProvidersServiceListResponse{providers: result}, nil
}

func (p *OpenstackVolumeProvidersServiceListRequest) MustSend() *OpenstackVolumeProvidersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the list of volume providers.
// The order of the returned list of volume providers isn't guaranteed.
//
type OpenstackVolumeProvidersServiceListResponse struct {
	providers *OpenStackVolumeProviderSlice
}

func (p *OpenstackVolumeProvidersServiceListResponse) Providers() (*OpenStackVolumeProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *OpenstackVolumeProvidersServiceListResponse) MustProviders() *OpenStackVolumeProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Retrieves the list of volume providers.
// The order of the returned list of volume providers isn't guaranteed.
//
func (p *OpenstackVolumeProvidersService) List() *OpenstackVolumeProvidersServiceListRequest {
	return &OpenstackVolumeProvidersServiceListRequest{OpenstackVolumeProvidersService: p}
}

//
//
func (op *OpenstackVolumeProvidersService) ProviderService(id string) *OpenstackVolumeProviderService {
	return NewOpenstackVolumeProviderService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProviderService(path), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeProvidersService) String() string {
	return fmt.Sprintf("OpenstackVolumeProvidersService:%s", op.path)
}

//
//
type OpenstackSubnetService struct {
	BaseService
}

func NewOpenstackSubnetService(connection *Connection, path string) *OpenstackSubnetService {
	var result OpenstackSubnetService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OpenstackSubnetServiceGetRequest struct {
	OpenstackSubnetService *OpenstackSubnetService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
}

func (p *OpenstackSubnetServiceGetRequest) Header(key, value string) *OpenstackSubnetServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetServiceGetRequest) Query(key, value string) *OpenstackSubnetServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetServiceGetRequest) Follow(follow string) *OpenstackSubnetServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackSubnetServiceGetRequest) Send() (*OpenstackSubnetServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackSubnetService.connection.URL(), p.OpenstackSubnetService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackSubnetService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackSubnetService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackSubnetService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackSubnetService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackSubnetService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackSubnetServiceGetResponse{subnet: result}, nil
}

func (p *OpenstackSubnetServiceGetRequest) MustSend() *OpenstackSubnetServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackSubnetServiceGetResponse struct {
	subnet *OpenStackSubnet
}

func (p *OpenstackSubnetServiceGetResponse) Subnet() (*OpenStackSubnet, bool) {
	if p.subnet != nil {
		return p.subnet, true
	}
	return nil, false
}

func (p *OpenstackSubnetServiceGetResponse) MustSubnet() *OpenStackSubnet {
	if p.subnet == nil {
		panic("subnet in response does not exist")
	}
	return p.subnet
}

//
//
func (p *OpenstackSubnetService) Get() *OpenstackSubnetServiceGetRequest {
	return &OpenstackSubnetServiceGetRequest{OpenstackSubnetService: p}
}

//
//
type OpenstackSubnetServiceRemoveRequest struct {
	OpenstackSubnetService *OpenstackSubnetService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *OpenstackSubnetServiceRemoveRequest) Header(key, value string) *OpenstackSubnetServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetServiceRemoveRequest) Query(key, value string) *OpenstackSubnetServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetServiceRemoveRequest) Async(async bool) *OpenstackSubnetServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *OpenstackSubnetServiceRemoveRequest) Send() (*OpenstackSubnetServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackSubnetService.connection.URL(), p.OpenstackSubnetService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackSubnetService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackSubnetService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackSubnetService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackSubnetService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackSubnetService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackSubnetServiceRemoveResponse), nil
}

func (p *OpenstackSubnetServiceRemoveRequest) MustSend() *OpenstackSubnetServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackSubnetServiceRemoveResponse struct {
}

//
//
func (p *OpenstackSubnetService) Remove() *OpenstackSubnetServiceRemoveRequest {
	return &OpenstackSubnetServiceRemoveRequest{OpenstackSubnetService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackSubnetService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackSubnetService) String() string {
	return fmt.Sprintf("OpenstackSubnetService:%s", op.path)
}

//
//
type OpenstackImageProviderService struct {
	BaseService
}

func NewOpenstackImageProviderService(connection *Connection, path string) *OpenstackImageProviderService {
	var result OpenstackImageProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OpenstackImageProviderServiceGetRequest struct {
	OpenstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *OpenstackImageProviderServiceGetRequest) Header(key, value string) *OpenstackImageProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceGetRequest) Query(key, value string) *OpenstackImageProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceGetRequest) Follow(follow string) *OpenstackImageProviderServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackImageProviderServiceGetRequest) Send() (*OpenstackImageProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackImageProviderService.connection.URL(), p.OpenstackImageProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackImageProviderServiceGetResponse{provider: result}, nil
}

func (p *OpenstackImageProviderServiceGetRequest) MustSend() *OpenstackImageProviderServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackImageProviderServiceGetResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceGetResponse) Provider() (*OpenStackImageProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackImageProviderServiceGetResponse) MustProvider() *OpenStackImageProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
//
func (p *OpenstackImageProviderService) Get() *OpenstackImageProviderServiceGetRequest {
	return &OpenstackImageProviderServiceGetRequest{OpenstackImageProviderService: p}
}

//
// Import the SSL certificates of the external host provider.
//
type OpenstackImageProviderServiceImportCertificatesRequest struct {
	OpenstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	certificates                  *CertificateSlice
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackImageProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackImageProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *OpenstackImageProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *OpenstackImageProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) Send() (*OpenstackImageProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.OpenstackImageProviderService.connection.URL(), p.OpenstackImageProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackImageProviderServiceImportCertificatesResponse), nil
}

func (p *OpenstackImageProviderServiceImportCertificatesRequest) MustSend() *OpenstackImageProviderServiceImportCertificatesResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Import the SSL certificates of the external host provider.
//
type OpenstackImageProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *OpenstackImageProviderService) ImportCertificates() *OpenstackImageProviderServiceImportCertificatesRequest {
	return &OpenstackImageProviderServiceImportCertificatesRequest{OpenstackImageProviderService: p}
}

//
//
type OpenstackImageProviderServiceRemoveRequest struct {
	OpenstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *OpenstackImageProviderServiceRemoveRequest) Header(key, value string) *OpenstackImageProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceRemoveRequest) Query(key, value string) *OpenstackImageProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceRemoveRequest) Async(async bool) *OpenstackImageProviderServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *OpenstackImageProviderServiceRemoveRequest) Send() (*OpenstackImageProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackImageProviderService.connection.URL(), p.OpenstackImageProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackImageProviderServiceRemoveResponse), nil
}

func (p *OpenstackImageProviderServiceRemoveRequest) MustSend() *OpenstackImageProviderServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackImageProviderServiceRemoveResponse struct {
}

//
//
func (p *OpenstackImageProviderService) Remove() *OpenstackImageProviderServiceRemoveRequest {
	return &OpenstackImageProviderServiceRemoveRequest{OpenstackImageProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type OpenstackImageProviderServiceTestConnectivityRequest struct {
	OpenstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackImageProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackImageProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackImageProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) Send() (*OpenstackImageProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.OpenstackImageProviderService.connection.URL(), p.OpenstackImageProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackImageProviderServiceTestConnectivityResponse), nil
}

func (p *OpenstackImageProviderServiceTestConnectivityRequest) MustSend() *OpenstackImageProviderServiceTestConnectivityResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type OpenstackImageProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *OpenstackImageProviderService) TestConnectivity() *OpenstackImageProviderServiceTestConnectivityRequest {
	return &OpenstackImageProviderServiceTestConnectivityRequest{OpenstackImageProviderService: p}
}

//
// Update the specified OpenStack image provider in the system.
//
type OpenstackImageProviderServiceUpdateRequest struct {
	OpenstackImageProviderService *OpenstackImageProviderService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
	provider                      *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceUpdateRequest) Header(key, value string) *OpenstackImageProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProviderServiceUpdateRequest) Query(key, value string) *OpenstackImageProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProviderServiceUpdateRequest) Async(async bool) *OpenstackImageProviderServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *OpenstackImageProviderServiceUpdateRequest) Provider(provider *OpenStackImageProvider) *OpenstackImageProviderServiceUpdateRequest {
	p.provider = provider
	return p
}

func (p *OpenstackImageProviderServiceUpdateRequest) Send() (*OpenstackImageProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackImageProviderService.connection.URL(), p.OpenstackImageProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackImageProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackImageProviderServiceUpdateResponse{provider: result}, nil
}

func (p *OpenstackImageProviderServiceUpdateRequest) MustSend() *OpenstackImageProviderServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified OpenStack image provider in the system.
//
type OpenstackImageProviderServiceUpdateResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProviderServiceUpdateResponse) Provider() (*OpenStackImageProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackImageProviderServiceUpdateResponse) MustProvider() *OpenStackImageProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Update the specified OpenStack image provider in the system.
//
func (p *OpenstackImageProviderService) Update() *OpenstackImageProviderServiceUpdateRequest {
	return &OpenstackImageProviderServiceUpdateRequest{OpenstackImageProviderService: p}
}

//
// A service to view certificates for this external provider.
//
func (op *OpenstackImageProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
//
func (op *OpenstackImageProviderService) ImagesService() *OpenstackImagesService {
	return NewOpenstackImagesService(op.connection, fmt.Sprintf("%s/images", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "images" {
		return op.ImagesService(), nil
	}
	if strings.HasPrefix(path, "images/") {
		return op.ImagesService().Service(path[7:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackImageProviderService) String() string {
	return fmt.Sprintf("OpenstackImageProviderService:%s", op.path)
}

//
//
type OpenstackVolumeProviderService struct {
	BaseService
}

func NewOpenstackVolumeProviderService(connection *Connection, path string) *OpenstackVolumeProviderService {
	var result OpenstackVolumeProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OpenstackVolumeProviderServiceGetRequest struct {
	OpenstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *OpenstackVolumeProviderServiceGetRequest) Header(key, value string) *OpenstackVolumeProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceGetRequest) Query(key, value string) *OpenstackVolumeProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceGetRequest) Follow(follow string) *OpenstackVolumeProviderServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackVolumeProviderServiceGetRequest) Send() (*OpenstackVolumeProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeProviderService.connection.URL(), p.OpenstackVolumeProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeProviderServiceGetResponse{provider: result}, nil
}

func (p *OpenstackVolumeProviderServiceGetRequest) MustSend() *OpenstackVolumeProviderServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackVolumeProviderServiceGetResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceGetResponse) Provider() (*OpenStackVolumeProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackVolumeProviderServiceGetResponse) MustProvider() *OpenStackVolumeProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
//
func (p *OpenstackVolumeProviderService) Get() *OpenstackVolumeProviderServiceGetRequest {
	return &OpenstackVolumeProviderServiceGetRequest{OpenstackVolumeProviderService: p}
}

//
// Import the SSL certificates of the external host provider.
//
type OpenstackVolumeProviderServiceImportCertificatesRequest struct {
	OpenstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	certificates                   *CertificateSlice
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *OpenstackVolumeProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) Send() (*OpenstackVolumeProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.OpenstackVolumeProviderService.connection.URL(), p.OpenstackVolumeProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackVolumeProviderServiceImportCertificatesResponse), nil
}

func (p *OpenstackVolumeProviderServiceImportCertificatesRequest) MustSend() *OpenstackVolumeProviderServiceImportCertificatesResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Import the SSL certificates of the external host provider.
//
type OpenstackVolumeProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *OpenstackVolumeProviderService) ImportCertificates() *OpenstackVolumeProviderServiceImportCertificatesRequest {
	return &OpenstackVolumeProviderServiceImportCertificatesRequest{OpenstackVolumeProviderService: p}
}

//
//
type OpenstackVolumeProviderServiceRemoveRequest struct {
	OpenstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	force                          *bool
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Header(key, value string) *OpenstackVolumeProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Query(key, value string) *OpenstackVolumeProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Async(async bool) *OpenstackVolumeProviderServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Force(force bool) *OpenstackVolumeProviderServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) Send() (*OpenstackVolumeProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeProviderService.connection.URL(), p.OpenstackVolumeProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackVolumeProviderServiceRemoveResponse), nil
}

func (p *OpenstackVolumeProviderServiceRemoveRequest) MustSend() *OpenstackVolumeProviderServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackVolumeProviderServiceRemoveResponse struct {
}

//
//
func (p *OpenstackVolumeProviderService) Remove() *OpenstackVolumeProviderServiceRemoveRequest {
	return &OpenstackVolumeProviderServiceRemoveRequest{OpenstackVolumeProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type OpenstackVolumeProviderServiceTestConnectivityRequest struct {
	OpenstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackVolumeProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) Send() (*OpenstackVolumeProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.OpenstackVolumeProviderService.connection.URL(), p.OpenstackVolumeProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackVolumeProviderServiceTestConnectivityResponse), nil
}

func (p *OpenstackVolumeProviderServiceTestConnectivityRequest) MustSend() *OpenstackVolumeProviderServiceTestConnectivityResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type OpenstackVolumeProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *OpenstackVolumeProviderService) TestConnectivity() *OpenstackVolumeProviderServiceTestConnectivityRequest {
	return &OpenstackVolumeProviderServiceTestConnectivityRequest{OpenstackVolumeProviderService: p}
}

//
// Update the specified OpenStack volume provider in the system.
//
type OpenstackVolumeProviderServiceUpdateRequest struct {
	OpenstackVolumeProviderService *OpenstackVolumeProviderService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	provider                       *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Header(key, value string) *OpenstackVolumeProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Query(key, value string) *OpenstackVolumeProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Async(async bool) *OpenstackVolumeProviderServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Provider(provider *OpenStackVolumeProvider) *OpenstackVolumeProviderServiceUpdateRequest {
	p.provider = provider
	return p
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) Send() (*OpenstackVolumeProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeProviderService.connection.URL(), p.OpenstackVolumeProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackVolumeProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeProviderServiceUpdateResponse{provider: result}, nil
}

func (p *OpenstackVolumeProviderServiceUpdateRequest) MustSend() *OpenstackVolumeProviderServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified OpenStack volume provider in the system.
//
type OpenstackVolumeProviderServiceUpdateResponse struct {
	provider *OpenStackVolumeProvider
}

func (p *OpenstackVolumeProviderServiceUpdateResponse) Provider() (*OpenStackVolumeProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackVolumeProviderServiceUpdateResponse) MustProvider() *OpenStackVolumeProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Update the specified OpenStack volume provider in the system.
//
func (p *OpenstackVolumeProviderService) Update() *OpenstackVolumeProviderServiceUpdateRequest {
	return &OpenstackVolumeProviderServiceUpdateRequest{OpenstackVolumeProviderService: p}
}

//
//
func (op *OpenstackVolumeProviderService) AuthenticationKeysService() *OpenstackVolumeAuthenticationKeysService {
	return NewOpenstackVolumeAuthenticationKeysService(op.connection, fmt.Sprintf("%s/authenticationkeys", op.path))
}

//
// A service to view certificates for this external provider.
//
func (op *OpenstackVolumeProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
//
func (op *OpenstackVolumeProviderService) VolumeTypesService() *OpenstackVolumeTypesService {
	return NewOpenstackVolumeTypesService(op.connection, fmt.Sprintf("%s/volumetypes", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "authenticationkeys" {
		return op.AuthenticationKeysService(), nil
	}
	if strings.HasPrefix(path, "authenticationkeys/") {
		return op.AuthenticationKeysService().Service(path[19:])
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "volumetypes" {
		return op.VolumeTypesService(), nil
	}
	if strings.HasPrefix(path, "volumetypes/") {
		return op.VolumeTypesService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeProviderService) String() string {
	return fmt.Sprintf("OpenstackVolumeProviderService:%s", op.path)
}

//
// This service manages OpenStack network providers.
//
type OpenstackNetworkProvidersService struct {
	BaseService
}

func NewOpenstackNetworkProvidersService(connection *Connection, path string) *OpenstackNetworkProvidersService {
	var result OpenstackNetworkProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// The operation adds a new network provider to the system.
// If the `type` property is not present, a default value of `NEUTRON` will be used.
//
type OpenstackNetworkProvidersServiceAddRequest struct {
	OpenstackNetworkProvidersService *OpenstackNetworkProvidersService
	header                           map[string]string
	query                            map[string]string
	provider                         *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Header(key, value string) *OpenstackNetworkProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Query(key, value string) *OpenstackNetworkProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Provider(provider *OpenStackNetworkProvider) *OpenstackNetworkProvidersServiceAddRequest {
	p.provider = provider
	return p
}

func (p *OpenstackNetworkProvidersServiceAddRequest) Send() (*OpenstackNetworkProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackNetworkProvidersService.connection.URL(), p.OpenstackNetworkProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackNetworkProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackNetworkProvidersServiceAddResponse{provider: result}, nil
}

func (p *OpenstackNetworkProvidersServiceAddRequest) MustSend() *OpenstackNetworkProvidersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// The operation adds a new network provider to the system.
// If the `type` property is not present, a default value of `NEUTRON` will be used.
//
type OpenstackNetworkProvidersServiceAddResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProvidersServiceAddResponse) Provider() (*OpenStackNetworkProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackNetworkProvidersServiceAddResponse) MustProvider() *OpenStackNetworkProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// The operation adds a new network provider to the system.
// If the `type` property is not present, a default value of `NEUTRON` will be used.
//
func (p *OpenstackNetworkProvidersService) Add() *OpenstackNetworkProvidersServiceAddRequest {
	return &OpenstackNetworkProvidersServiceAddRequest{OpenstackNetworkProvidersService: p}
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
type OpenstackNetworkProvidersServiceListRequest struct {
	OpenstackNetworkProvidersService *OpenstackNetworkProvidersService
	header                           map[string]string
	query                            map[string]string
	follow                           *string
	max                              *int64
	search                           *string
}

func (p *OpenstackNetworkProvidersServiceListRequest) Header(key, value string) *OpenstackNetworkProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Query(key, value string) *OpenstackNetworkProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Follow(follow string) *OpenstackNetworkProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Max(max int64) *OpenstackNetworkProvidersServiceListRequest {
	p.max = &max
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Search(search string) *OpenstackNetworkProvidersServiceListRequest {
	p.search = &search
	return p
}

func (p *OpenstackNetworkProvidersServiceListRequest) Send() (*OpenstackNetworkProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackNetworkProvidersService.connection.URL(), p.OpenstackNetworkProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OpenstackNetworkProvidersServiceListResponse{providers: result}, nil
}

func (p *OpenstackNetworkProvidersServiceListRequest) MustSend() *OpenstackNetworkProvidersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
type OpenstackNetworkProvidersServiceListResponse struct {
	providers *OpenStackNetworkProviderSlice
}

func (p *OpenstackNetworkProvidersServiceListResponse) Providers() (*OpenStackNetworkProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *OpenstackNetworkProvidersServiceListResponse) MustProviders() *OpenStackNetworkProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
func (p *OpenstackNetworkProvidersService) List() *OpenstackNetworkProvidersServiceListRequest {
	return &OpenstackNetworkProvidersServiceListRequest{OpenstackNetworkProvidersService: p}
}

//
// Reference to OpenStack network provider service.
//
func (op *OpenstackNetworkProvidersService) ProviderService(id string) *OpenstackNetworkProviderService {
	return NewOpenstackNetworkProviderService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProviderService(path), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackNetworkProvidersService) String() string {
	return fmt.Sprintf("OpenstackNetworkProvidersService:%s", op.path)
}

//
// This service manages the OpenStack network provider.
//
type OpenstackNetworkProviderService struct {
	BaseService
}

func NewOpenstackNetworkProviderService(connection *Connection, path string) *OpenstackNetworkProviderService {
	var result OpenstackNetworkProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the representation of the object managed by this service.
// For example, to get the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
type OpenstackNetworkProviderServiceGetRequest struct {
	OpenstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	follow                          *string
}

func (p *OpenstackNetworkProviderServiceGetRequest) Header(key, value string) *OpenstackNetworkProviderServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceGetRequest) Query(key, value string) *OpenstackNetworkProviderServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceGetRequest) Follow(follow string) *OpenstackNetworkProviderServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackNetworkProviderServiceGetRequest) Send() (*OpenstackNetworkProviderServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackNetworkProviderService.connection.URL(), p.OpenstackNetworkProviderService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackNetworkProviderServiceGetResponse{provider: result}, nil
}

func (p *OpenstackNetworkProviderServiceGetRequest) MustSend() *OpenstackNetworkProviderServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the representation of the object managed by this service.
// For example, to get the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
type OpenstackNetworkProviderServiceGetResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceGetResponse) Provider() (*OpenStackNetworkProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackNetworkProviderServiceGetResponse) MustProvider() *OpenStackNetworkProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Returns the representation of the object managed by this service.
// For example, to get the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
func (p *OpenstackNetworkProviderService) Get() *OpenstackNetworkProviderServiceGetRequest {
	return &OpenstackNetworkProviderServiceGetRequest{OpenstackNetworkProviderService: p}
}

//
// Import the SSL certificates of the external host provider.
//
type OpenstackNetworkProviderServiceImportCertificatesRequest struct {
	OpenstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	certificates                    *CertificateSlice
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Header(key, value string) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Query(key, value string) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *OpenstackNetworkProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) Send() (*OpenstackNetworkProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.OpenstackNetworkProviderService.connection.URL(), p.OpenstackNetworkProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackNetworkProviderServiceImportCertificatesResponse), nil
}

func (p *OpenstackNetworkProviderServiceImportCertificatesRequest) MustSend() *OpenstackNetworkProviderServiceImportCertificatesResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Import the SSL certificates of the external host provider.
//
type OpenstackNetworkProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *OpenstackNetworkProviderService) ImportCertificates() *OpenstackNetworkProviderServiceImportCertificatesRequest {
	return &OpenstackNetworkProviderServiceImportCertificatesRequest{OpenstackNetworkProviderService: p}
}

//
// Removes the provider.
// For example, to remove the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
type OpenstackNetworkProviderServiceRemoveRequest struct {
	OpenstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Header(key, value string) *OpenstackNetworkProviderServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Query(key, value string) *OpenstackNetworkProviderServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Async(async bool) *OpenstackNetworkProviderServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) Send() (*OpenstackNetworkProviderServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackNetworkProviderService.connection.URL(), p.OpenstackNetworkProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(OpenstackNetworkProviderServiceRemoveResponse), nil
}

func (p *OpenstackNetworkProviderServiceRemoveRequest) MustSend() *OpenstackNetworkProviderServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the provider.
// For example, to remove the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
type OpenstackNetworkProviderServiceRemoveResponse struct {
}

//
// Removes the provider.
// For example, to remove the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/openstacknetworkproviders/1234
// ----
//
func (p *OpenstackNetworkProviderService) Remove() *OpenstackNetworkProviderServiceRemoveRequest {
	return &OpenstackNetworkProviderServiceRemoveRequest{OpenstackNetworkProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type OpenstackNetworkProviderServiceTestConnectivityRequest struct {
	OpenstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Header(key, value string) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Query(key, value string) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Async(async bool) *OpenstackNetworkProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) Send() (*OpenstackNetworkProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.OpenstackNetworkProviderService.connection.URL(), p.OpenstackNetworkProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackNetworkProviderServiceTestConnectivityResponse), nil
}

func (p *OpenstackNetworkProviderServiceTestConnectivityRequest) MustSend() *OpenstackNetworkProviderServiceTestConnectivityResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type OpenstackNetworkProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *OpenstackNetworkProviderService) TestConnectivity() *OpenstackNetworkProviderServiceTestConnectivityRequest {
	return &OpenstackNetworkProviderServiceTestConnectivityRequest{OpenstackNetworkProviderService: p}
}

//
// Updates the provider.
// For example, to update `provider_name`, `requires_authentication`, `url`, `tenant_name` and `type` properties,
// for the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/openstacknetworkproviders/1234
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_network_provider>
//   <name>ovn-network-provider</name>
//   <requires_authentication>false</requires_authentication>
//   <url>http://some_server_url.domain.com:9696</url>
//   <tenant_name>oVirt</tenant_name>
//   <type>external</type>
// </openstack_network_provider>
// ----
//
type OpenstackNetworkProviderServiceUpdateRequest struct {
	OpenstackNetworkProviderService *OpenstackNetworkProviderService
	header                          map[string]string
	query                           map[string]string
	async                           *bool
	provider                        *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Header(key, value string) *OpenstackNetworkProviderServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Query(key, value string) *OpenstackNetworkProviderServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Async(async bool) *OpenstackNetworkProviderServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Provider(provider *OpenStackNetworkProvider) *OpenstackNetworkProviderServiceUpdateRequest {
	p.provider = provider
	return p
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) Send() (*OpenstackNetworkProviderServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackNetworkProviderService.connection.URL(), p.OpenstackNetworkProviderService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackNetworkProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworkProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworkProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworkProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworkProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworkProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackNetworkProviderServiceUpdateResponse{provider: result}, nil
}

func (p *OpenstackNetworkProviderServiceUpdateRequest) MustSend() *OpenstackNetworkProviderServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the provider.
// For example, to update `provider_name`, `requires_authentication`, `url`, `tenant_name` and `type` properties,
// for the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/openstacknetworkproviders/1234
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_network_provider>
//   <name>ovn-network-provider</name>
//   <requires_authentication>false</requires_authentication>
//   <url>http://some_server_url.domain.com:9696</url>
//   <tenant_name>oVirt</tenant_name>
//   <type>external</type>
// </openstack_network_provider>
// ----
//
type OpenstackNetworkProviderServiceUpdateResponse struct {
	provider *OpenStackNetworkProvider
}

func (p *OpenstackNetworkProviderServiceUpdateResponse) Provider() (*OpenStackNetworkProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackNetworkProviderServiceUpdateResponse) MustProvider() *OpenStackNetworkProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Updates the provider.
// For example, to update `provider_name`, `requires_authentication`, `url`, `tenant_name` and `type` properties,
// for the OpenStack network provider with identifier `1234`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/openstacknetworkproviders/1234
// ----
// With a request body like this:
// [source,xml]
// ----
// <openstack_network_provider>
//   <name>ovn-network-provider</name>
//   <requires_authentication>false</requires_authentication>
//   <url>http://some_server_url.domain.com:9696</url>
//   <tenant_name>oVirt</tenant_name>
//   <type>external</type>
// </openstack_network_provider>
// ----
//
func (p *OpenstackNetworkProviderService) Update() *OpenstackNetworkProviderServiceUpdateRequest {
	return &OpenstackNetworkProviderServiceUpdateRequest{OpenstackNetworkProviderService: p}
}

//
// A service to view certificates for this external provider.
//
func (op *OpenstackNetworkProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
// Reference to OpenStack networks service.
//
func (op *OpenstackNetworkProviderService) NetworksService() *OpenstackNetworksService {
	return NewOpenstackNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworkProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackNetworkProviderService) String() string {
	return fmt.Sprintf("OpenstackNetworkProviderService:%s", op.path)
}

//
//
type OpenstackImageService struct {
	BaseService
}

func NewOpenstackImageService(connection *Connection, path string) *OpenstackImageService {
	var result OpenstackImageService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OpenstackImageServiceGetRequest struct {
	OpenstackImageService *OpenstackImageService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *OpenstackImageServiceGetRequest) Header(key, value string) *OpenstackImageServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageServiceGetRequest) Query(key, value string) *OpenstackImageServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageServiceGetRequest) Follow(follow string) *OpenstackImageServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackImageServiceGetRequest) Send() (*OpenstackImageServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackImageService.connection.URL(), p.OpenstackImageService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackImageServiceGetResponse{image: result}, nil
}

func (p *OpenstackImageServiceGetRequest) MustSend() *OpenstackImageServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackImageServiceGetResponse struct {
	image *OpenStackImage
}

func (p *OpenstackImageServiceGetResponse) Image() (*OpenStackImage, bool) {
	if p.image != nil {
		return p.image, true
	}
	return nil, false
}

func (p *OpenstackImageServiceGetResponse) MustImage() *OpenStackImage {
	if p.image == nil {
		panic("image in response does not exist")
	}
	return p.image
}

//
//
func (p *OpenstackImageService) Get() *OpenstackImageServiceGetRequest {
	return &OpenstackImageServiceGetRequest{OpenstackImageService: p}
}

//
// Imports a virtual machine from a Glance image storage domain.
// For example, to import the image with identifier `456` from the
// storage domain with identifier `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/openstackimageproviders/123/images/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>images0</name>
//   </storage_domain>
//   <cluster>
//     <name>images0</name>
//   </cluster>
// </action>
// ----
//
type OpenstackImageServiceImportRequest struct {
	OpenstackImageService *OpenstackImageService
	header                map[string]string
	query                 map[string]string
	async                 *bool
	cluster               *Cluster
	disk                  *Disk
	importAsTemplate      *bool
	storageDomain         *StorageDomain
	template              *Template
}

func (p *OpenstackImageServiceImportRequest) Header(key, value string) *OpenstackImageServiceImportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageServiceImportRequest) Query(key, value string) *OpenstackImageServiceImportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageServiceImportRequest) Async(async bool) *OpenstackImageServiceImportRequest {
	p.async = &async
	return p
}

func (p *OpenstackImageServiceImportRequest) Cluster(cluster *Cluster) *OpenstackImageServiceImportRequest {
	p.cluster = cluster
	return p
}

func (p *OpenstackImageServiceImportRequest) Disk(disk *Disk) *OpenstackImageServiceImportRequest {
	p.disk = disk
	return p
}

func (p *OpenstackImageServiceImportRequest) ImportAsTemplate(importAsTemplate bool) *OpenstackImageServiceImportRequest {
	p.importAsTemplate = &importAsTemplate
	return p
}

func (p *OpenstackImageServiceImportRequest) StorageDomain(storageDomain *StorageDomain) *OpenstackImageServiceImportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *OpenstackImageServiceImportRequest) Template(template *Template) *OpenstackImageServiceImportRequest {
	p.template = template
	return p
}

func (p *OpenstackImageServiceImportRequest) Send() (*OpenstackImageServiceImportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/import", p.OpenstackImageService.connection.URL(), p.OpenstackImageService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	actionBuilder.Disk(p.disk)
	if p.importAsTemplate != nil {
		actionBuilder.ImportAsTemplate(*p.importAsTemplate)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Template(p.template)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(OpenstackImageServiceImportResponse), nil
}

func (p *OpenstackImageServiceImportRequest) MustSend() *OpenstackImageServiceImportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Imports a virtual machine from a Glance image storage domain.
// For example, to import the image with identifier `456` from the
// storage domain with identifier `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/openstackimageproviders/123/images/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>images0</name>
//   </storage_domain>
//   <cluster>
//     <name>images0</name>
//   </cluster>
// </action>
// ----
//
type OpenstackImageServiceImportResponse struct {
}

//
// Imports a virtual machine from a Glance image storage domain.
// For example, to import the image with identifier `456` from the
// storage domain with identifier `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/openstackimageproviders/123/images/456/import
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>images0</name>
//   </storage_domain>
//   <cluster>
//     <name>images0</name>
//   </cluster>
// </action>
// ----
//
func (p *OpenstackImageService) Import() *OpenstackImageServiceImportRequest {
	return &OpenstackImageServiceImportRequest{OpenstackImageService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackImageService) String() string {
	return fmt.Sprintf("OpenstackImageService:%s", op.path)
}

//
//
type OpenstackNetworksService struct {
	BaseService
}

func NewOpenstackNetworksService(connection *Connection, path string) *OpenstackNetworksService {
	var result OpenstackNetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
type OpenstackNetworksServiceListRequest struct {
	OpenstackNetworksService *OpenstackNetworksService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
	max                      *int64
}

func (p *OpenstackNetworksServiceListRequest) Header(key, value string) *OpenstackNetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackNetworksServiceListRequest) Query(key, value string) *OpenstackNetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackNetworksServiceListRequest) Follow(follow string) *OpenstackNetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackNetworksServiceListRequest) Max(max int64) *OpenstackNetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *OpenstackNetworksServiceListRequest) Send() (*OpenstackNetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackNetworksService.connection.URL(), p.OpenstackNetworksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackNetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackNetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackNetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackNetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackNetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OpenstackNetworksServiceListResponse{networks: result}, nil
}

func (p *OpenstackNetworksServiceListRequest) MustSend() *OpenstackNetworksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
type OpenstackNetworksServiceListResponse struct {
	networks *OpenStackNetworkSlice
}

func (p *OpenstackNetworksServiceListResponse) Networks() (*OpenStackNetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *OpenstackNetworksServiceListResponse) MustNetworks() *OpenStackNetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// Returns the list of networks.
// The order of the returned list of networks isn't guaranteed.
//
func (p *OpenstackNetworksService) List() *OpenstackNetworksServiceListRequest {
	return &OpenstackNetworksServiceListRequest{OpenstackNetworksService: p}
}

//
//
func (op *OpenstackNetworksService) NetworkService(id string) *OpenstackNetworkService {
	return NewOpenstackNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackNetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackNetworksService) String() string {
	return fmt.Sprintf("OpenstackNetworksService:%s", op.path)
}

//
//
type OpenstackVolumeTypeService struct {
	BaseService
}

func NewOpenstackVolumeTypeService(connection *Connection, path string) *OpenstackVolumeTypeService {
	var result OpenstackVolumeTypeService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OpenstackVolumeTypeServiceGetRequest struct {
	OpenstackVolumeTypeService *OpenstackVolumeTypeService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
}

func (p *OpenstackVolumeTypeServiceGetRequest) Header(key, value string) *OpenstackVolumeTypeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeTypeServiceGetRequest) Query(key, value string) *OpenstackVolumeTypeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeTypeServiceGetRequest) Follow(follow string) *OpenstackVolumeTypeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackVolumeTypeServiceGetRequest) Send() (*OpenstackVolumeTypeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeTypeService.connection.URL(), p.OpenstackVolumeTypeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeTypeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeTypeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeTypeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeTypeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeTypeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackVolumeTypeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeTypeServiceGetResponse{type_: result}, nil
}

func (p *OpenstackVolumeTypeServiceGetRequest) MustSend() *OpenstackVolumeTypeServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackVolumeTypeServiceGetResponse struct {
	type_ *OpenStackVolumeType
}

func (p *OpenstackVolumeTypeServiceGetResponse) Type() (*OpenStackVolumeType, bool) {
	if p.type_ != nil {
		return p.type_, true
	}
	return nil, false
}

func (p *OpenstackVolumeTypeServiceGetResponse) MustType() *OpenStackVolumeType {
	if p.type_ == nil {
		panic("type_ in response does not exist")
	}
	return p.type_
}

//
//
func (p *OpenstackVolumeTypeService) Get() *OpenstackVolumeTypeServiceGetRequest {
	return &OpenstackVolumeTypeServiceGetRequest{OpenstackVolumeTypeService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeTypeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *OpenstackVolumeTypeService) String() string {
	return fmt.Sprintf("OpenstackVolumeTypeService:%s", op.path)
}

//
//
type OpenstackSubnetsService struct {
	BaseService
}

func NewOpenstackSubnetsService(connection *Connection, path string) *OpenstackSubnetsService {
	var result OpenstackSubnetsService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type OpenstackSubnetsServiceAddRequest struct {
	OpenstackSubnetsService *OpenstackSubnetsService
	header                  map[string]string
	query                   map[string]string
	subnet                  *OpenStackSubnet
}

func (p *OpenstackSubnetsServiceAddRequest) Header(key, value string) *OpenstackSubnetsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetsServiceAddRequest) Query(key, value string) *OpenstackSubnetsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetsServiceAddRequest) Subnet(subnet *OpenStackSubnet) *OpenstackSubnetsServiceAddRequest {
	p.subnet = subnet
	return p
}

func (p *OpenstackSubnetsServiceAddRequest) Send() (*OpenstackSubnetsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackSubnetsService.connection.URL(), p.OpenstackSubnetsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackSubnetWriteOne(writer, p.subnet, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackSubnetsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackSubnetsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackSubnetsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackSubnetsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackSubnetsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackSubnetsServiceAddResponse{subnet: result}, nil
}

func (p *OpenstackSubnetsServiceAddRequest) MustSend() *OpenstackSubnetsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type OpenstackSubnetsServiceAddResponse struct {
	subnet *OpenStackSubnet
}

func (p *OpenstackSubnetsServiceAddResponse) Subnet() (*OpenStackSubnet, bool) {
	if p.subnet != nil {
		return p.subnet, true
	}
	return nil, false
}

func (p *OpenstackSubnetsServiceAddResponse) MustSubnet() *OpenStackSubnet {
	if p.subnet == nil {
		panic("subnet in response does not exist")
	}
	return p.subnet
}

//
//
func (p *OpenstackSubnetsService) Add() *OpenstackSubnetsServiceAddRequest {
	return &OpenstackSubnetsServiceAddRequest{OpenstackSubnetsService: p}
}

//
// Returns the list of sub-networks.
// The order of the returned list of sub-networks isn't guaranteed.
//
type OpenstackSubnetsServiceListRequest struct {
	OpenstackSubnetsService *OpenstackSubnetsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
}

func (p *OpenstackSubnetsServiceListRequest) Header(key, value string) *OpenstackSubnetsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackSubnetsServiceListRequest) Query(key, value string) *OpenstackSubnetsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackSubnetsServiceListRequest) Follow(follow string) *OpenstackSubnetsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackSubnetsServiceListRequest) Max(max int64) *OpenstackSubnetsServiceListRequest {
	p.max = &max
	return p
}

func (p *OpenstackSubnetsServiceListRequest) Send() (*OpenstackSubnetsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackSubnetsService.connection.URL(), p.OpenstackSubnetsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackSubnetsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackSubnetsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackSubnetsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackSubnetsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackSubnetsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackSubnetReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OpenstackSubnetsServiceListResponse{subnets: result}, nil
}

func (p *OpenstackSubnetsServiceListRequest) MustSend() *OpenstackSubnetsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of sub-networks.
// The order of the returned list of sub-networks isn't guaranteed.
//
type OpenstackSubnetsServiceListResponse struct {
	subnets *OpenStackSubnetSlice
}

func (p *OpenstackSubnetsServiceListResponse) Subnets() (*OpenStackSubnetSlice, bool) {
	if p.subnets != nil {
		return p.subnets, true
	}
	return nil, false
}

func (p *OpenstackSubnetsServiceListResponse) MustSubnets() *OpenStackSubnetSlice {
	if p.subnets == nil {
		panic("subnets in response does not exist")
	}
	return p.subnets
}

//
// Returns the list of sub-networks.
// The order of the returned list of sub-networks isn't guaranteed.
//
func (p *OpenstackSubnetsService) List() *OpenstackSubnetsServiceListRequest {
	return &OpenstackSubnetsServiceListRequest{OpenstackSubnetsService: p}
}

//
//
func (op *OpenstackSubnetsService) SubnetService(id string) *OpenstackSubnetService {
	return NewOpenstackSubnetService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackSubnetsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.SubnetService(path), nil
	}
	return op.SubnetService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackSubnetsService) String() string {
	return fmt.Sprintf("OpenstackSubnetsService:%s", op.path)
}

//
//
type OpenstackVolumeAuthenticationKeysService struct {
	BaseService
}

func NewOpenstackVolumeAuthenticationKeysService(connection *Connection, path string) *OpenstackVolumeAuthenticationKeysService {
	var result OpenstackVolumeAuthenticationKeysService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new authentication key to the OpenStack volume provider.
//
type OpenstackVolumeAuthenticationKeysServiceAddRequest struct {
	OpenstackVolumeAuthenticationKeysService *OpenstackVolumeAuthenticationKeysService
	header                                   map[string]string
	query                                    map[string]string
	key                                      *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Key(key *OpenstackVolumeAuthenticationKey) *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	p.key = key
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) Send() (*OpenstackVolumeAuthenticationKeysServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeAuthenticationKeysService.connection.URL(), p.OpenstackVolumeAuthenticationKeysService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenstackVolumeAuthenticationKeyWriteOne(writer, p.key, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeAuthenticationKeysService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeAuthenticationKeysService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeAuthenticationKeysService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeAuthenticationKeysService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeAuthenticationKeysService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeAuthenticationKeysServiceAddResponse{key: result}, nil
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddRequest) MustSend() *OpenstackVolumeAuthenticationKeysServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new authentication key to the OpenStack volume provider.
//
type OpenstackVolumeAuthenticationKeysServiceAddResponse struct {
	key *OpenstackVolumeAuthenticationKey
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddResponse) Key() (*OpenstackVolumeAuthenticationKey, bool) {
	if p.key != nil {
		return p.key, true
	}
	return nil, false
}

func (p *OpenstackVolumeAuthenticationKeysServiceAddResponse) MustKey() *OpenstackVolumeAuthenticationKey {
	if p.key == nil {
		panic("key in response does not exist")
	}
	return p.key
}

//
// Add a new authentication key to the OpenStack volume provider.
//
func (p *OpenstackVolumeAuthenticationKeysService) Add() *OpenstackVolumeAuthenticationKeysServiceAddRequest {
	return &OpenstackVolumeAuthenticationKeysServiceAddRequest{OpenstackVolumeAuthenticationKeysService: p}
}

//
// Returns the list of authentication keys.
// The order of the returned list of authentication keys isn't guaranteed.
//
type OpenstackVolumeAuthenticationKeysServiceListRequest struct {
	OpenstackVolumeAuthenticationKeysService *OpenstackVolumeAuthenticationKeysService
	header                                   map[string]string
	query                                    map[string]string
	follow                                   *string
	max                                      *int64
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Header(key, value string) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Query(key, value string) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Follow(follow string) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Max(max int64) *OpenstackVolumeAuthenticationKeysServiceListRequest {
	p.max = &max
	return p
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) Send() (*OpenstackVolumeAuthenticationKeysServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackVolumeAuthenticationKeysService.connection.URL(), p.OpenstackVolumeAuthenticationKeysService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackVolumeAuthenticationKeysService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackVolumeAuthenticationKeysService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackVolumeAuthenticationKeysService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackVolumeAuthenticationKeysService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackVolumeAuthenticationKeysService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenstackVolumeAuthenticationKeyReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OpenstackVolumeAuthenticationKeysServiceListResponse{keys: result}, nil
}

func (p *OpenstackVolumeAuthenticationKeysServiceListRequest) MustSend() *OpenstackVolumeAuthenticationKeysServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of authentication keys.
// The order of the returned list of authentication keys isn't guaranteed.
//
type OpenstackVolumeAuthenticationKeysServiceListResponse struct {
	keys *OpenstackVolumeAuthenticationKeySlice
}

func (p *OpenstackVolumeAuthenticationKeysServiceListResponse) Keys() (*OpenstackVolumeAuthenticationKeySlice, bool) {
	if p.keys != nil {
		return p.keys, true
	}
	return nil, false
}

func (p *OpenstackVolumeAuthenticationKeysServiceListResponse) MustKeys() *OpenstackVolumeAuthenticationKeySlice {
	if p.keys == nil {
		panic("keys in response does not exist")
	}
	return p.keys
}

//
// Returns the list of authentication keys.
// The order of the returned list of authentication keys isn't guaranteed.
//
func (p *OpenstackVolumeAuthenticationKeysService) List() *OpenstackVolumeAuthenticationKeysServiceListRequest {
	return &OpenstackVolumeAuthenticationKeysServiceListRequest{OpenstackVolumeAuthenticationKeysService: p}
}

//
//
func (op *OpenstackVolumeAuthenticationKeysService) KeyService(id string) *OpenstackVolumeAuthenticationKeyService {
	return NewOpenstackVolumeAuthenticationKeyService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackVolumeAuthenticationKeysService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.KeyService(path), nil
	}
	return op.KeyService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackVolumeAuthenticationKeysService) String() string {
	return fmt.Sprintf("OpenstackVolumeAuthenticationKeysService:%s", op.path)
}

//
//
type OpenstackImageProvidersService struct {
	BaseService
}

func NewOpenstackImageProvidersService(connection *Connection, path string) *OpenstackImageProvidersService {
	var result OpenstackImageProvidersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new OpenStack image provider to the system.
//
type OpenstackImageProvidersServiceAddRequest struct {
	OpenstackImageProvidersService *OpenstackImageProvidersService
	header                         map[string]string
	query                          map[string]string
	provider                       *OpenStackImageProvider
}

func (p *OpenstackImageProvidersServiceAddRequest) Header(key, value string) *OpenstackImageProvidersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceAddRequest) Query(key, value string) *OpenstackImageProvidersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceAddRequest) Provider(provider *OpenStackImageProvider) *OpenstackImageProvidersServiceAddRequest {
	p.provider = provider
	return p
}

func (p *OpenstackImageProvidersServiceAddRequest) Send() (*OpenstackImageProvidersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackImageProvidersService.connection.URL(), p.OpenstackImageProvidersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLOpenStackImageProviderWriteOne(writer, p.provider, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &OpenstackImageProvidersServiceAddResponse{provider: result}, nil
}

func (p *OpenstackImageProvidersServiceAddRequest) MustSend() *OpenstackImageProvidersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new OpenStack image provider to the system.
//
type OpenstackImageProvidersServiceAddResponse struct {
	provider *OpenStackImageProvider
}

func (p *OpenstackImageProvidersServiceAddResponse) Provider() (*OpenStackImageProvider, bool) {
	if p.provider != nil {
		return p.provider, true
	}
	return nil, false
}

func (p *OpenstackImageProvidersServiceAddResponse) MustProvider() *OpenStackImageProvider {
	if p.provider == nil {
		panic("provider in response does not exist")
	}
	return p.provider
}

//
// Add a new OpenStack image provider to the system.
//
func (p *OpenstackImageProvidersService) Add() *OpenstackImageProvidersServiceAddRequest {
	return &OpenstackImageProvidersServiceAddRequest{OpenstackImageProvidersService: p}
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
type OpenstackImageProvidersServiceListRequest struct {
	OpenstackImageProvidersService *OpenstackImageProvidersService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
	max                            *int64
	search                         *string
}

func (p *OpenstackImageProvidersServiceListRequest) Header(key, value string) *OpenstackImageProvidersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Query(key, value string) *OpenstackImageProvidersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Follow(follow string) *OpenstackImageProvidersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Max(max int64) *OpenstackImageProvidersServiceListRequest {
	p.max = &max
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Search(search string) *OpenstackImageProvidersServiceListRequest {
	p.search = &search
	return p
}

func (p *OpenstackImageProvidersServiceListRequest) Send() (*OpenstackImageProvidersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackImageProvidersService.connection.URL(), p.OpenstackImageProvidersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImageProvidersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImageProvidersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImageProvidersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImageProvidersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImageProvidersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageProviderReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OpenstackImageProvidersServiceListResponse{providers: result}, nil
}

func (p *OpenstackImageProvidersServiceListRequest) MustSend() *OpenstackImageProvidersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
type OpenstackImageProvidersServiceListResponse struct {
	providers *OpenStackImageProviderSlice
}

func (p *OpenstackImageProvidersServiceListResponse) Providers() (*OpenStackImageProviderSlice, bool) {
	if p.providers != nil {
		return p.providers, true
	}
	return nil, false
}

func (p *OpenstackImageProvidersServiceListResponse) MustProviders() *OpenStackImageProviderSlice {
	if p.providers == nil {
		panic("providers in response does not exist")
	}
	return p.providers
}

//
// Returns the list of providers.
// The order of the returned list of providers isn't guaranteed.
//
func (p *OpenstackImageProvidersService) List() *OpenstackImageProvidersServiceListRequest {
	return &OpenstackImageProvidersServiceListRequest{OpenstackImageProvidersService: p}
}

//
//
func (op *OpenstackImageProvidersService) ProviderService(id string) *OpenstackImageProviderService {
	return NewOpenstackImageProviderService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImageProvidersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProviderService(path), nil
	}
	return op.ProviderService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackImageProvidersService) String() string {
	return fmt.Sprintf("OpenstackImageProvidersService:%s", op.path)
}

//
//
type OpenstackImagesService struct {
	BaseService
}

func NewOpenstackImagesService(connection *Connection, path string) *OpenstackImagesService {
	var result OpenstackImagesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Lists the images of a Glance image storage domain.
// The order of the returned list of images isn't guaranteed.
//
type OpenstackImagesServiceListRequest struct {
	OpenstackImagesService *OpenstackImagesService
	header                 map[string]string
	query                  map[string]string
	follow                 *string
	max                    *int64
}

func (p *OpenstackImagesServiceListRequest) Header(key, value string) *OpenstackImagesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OpenstackImagesServiceListRequest) Query(key, value string) *OpenstackImagesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OpenstackImagesServiceListRequest) Follow(follow string) *OpenstackImagesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OpenstackImagesServiceListRequest) Max(max int64) *OpenstackImagesServiceListRequest {
	p.max = &max
	return p
}

func (p *OpenstackImagesServiceListRequest) Send() (*OpenstackImagesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OpenstackImagesService.connection.URL(), p.OpenstackImagesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OpenstackImagesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OpenstackImagesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OpenstackImagesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OpenstackImagesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OpenstackImagesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOpenStackImageReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OpenstackImagesServiceListResponse{images: result}, nil
}

func (p *OpenstackImagesServiceListRequest) MustSend() *OpenstackImagesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists the images of a Glance image storage domain.
// The order of the returned list of images isn't guaranteed.
//
type OpenstackImagesServiceListResponse struct {
	images *OpenStackImageSlice
}

func (p *OpenstackImagesServiceListResponse) Images() (*OpenStackImageSlice, bool) {
	if p.images != nil {
		return p.images, true
	}
	return nil, false
}

func (p *OpenstackImagesServiceListResponse) MustImages() *OpenStackImageSlice {
	if p.images == nil {
		panic("images in response does not exist")
	}
	return p.images
}

//
// Lists the images of a Glance image storage domain.
// The order of the returned list of images isn't guaranteed.
//
func (p *OpenstackImagesService) List() *OpenstackImagesServiceListRequest {
	return &OpenstackImagesServiceListRequest{OpenstackImagesService: p}
}

//
// Returns a reference to the service that manages a specific image.
//
func (op *OpenstackImagesService) ImageService(id string) *OpenstackImageService {
	return NewOpenstackImageService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OpenstackImagesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ImageService(path), nil
	}
	return op.ImageService(path[:index]).Service(path[index+1:])
}

func (op *OpenstackImagesService) String() string {
	return fmt.Sprintf("OpenstackImagesService:%s", op.path)
}

//
// Returns the details of the disks attached to a virtual machine in the export domain.
//
type StorageDomainVmDiskAttachmentService struct {
	BaseService
}

func NewStorageDomainVmDiskAttachmentService(connection *Connection, path string) *StorageDomainVmDiskAttachmentService {
	var result StorageDomainVmDiskAttachmentService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the details of the attachment with all its properties and a link to the disk.
//
type StorageDomainVmDiskAttachmentServiceGetRequest struct {
	StorageDomainVmDiskAttachmentService *StorageDomainVmDiskAttachmentService
	header                               map[string]string
	query                                map[string]string
	follow                               *string
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Header(key, value string) *StorageDomainVmDiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Query(key, value string) *StorageDomainVmDiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Follow(follow string) *StorageDomainVmDiskAttachmentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) Send() (*StorageDomainVmDiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainVmDiskAttachmentService.connection.URL(), p.StorageDomainVmDiskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainVmDiskAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainVmDiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainVmDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainVmDiskAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainVmDiskAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainVmDiskAttachmentServiceGetResponse{attachment: result}, nil
}

func (p *StorageDomainVmDiskAttachmentServiceGetRequest) MustSend() *StorageDomainVmDiskAttachmentServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the details of the attachment with all its properties and a link to the disk.
//
type StorageDomainVmDiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *StorageDomainVmDiskAttachmentServiceGetResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *StorageDomainVmDiskAttachmentServiceGetResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Returns the details of the attachment with all its properties and a link to the disk.
//
func (p *StorageDomainVmDiskAttachmentService) Get() *StorageDomainVmDiskAttachmentServiceGetRequest {
	return &StorageDomainVmDiskAttachmentServiceGetRequest{StorageDomainVmDiskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmDiskAttachmentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainVmDiskAttachmentService) String() string {
	return fmt.Sprintf("StorageDomainVmDiskAttachmentService:%s", op.path)
}

//
//
type InstanceTypeWatchdogService struct {
	BaseService
}

func NewInstanceTypeWatchdogService(connection *Connection, path string) *InstanceTypeWatchdogService {
	var result InstanceTypeWatchdogService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets watchdog configuration of the instance type.
//
type InstanceTypeWatchdogServiceGetRequest struct {
	InstanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	follow                      *string
}

func (p *InstanceTypeWatchdogServiceGetRequest) Header(key, value string) *InstanceTypeWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceGetRequest) Query(key, value string) *InstanceTypeWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceGetRequest) Follow(follow string) *InstanceTypeWatchdogServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *InstanceTypeWatchdogServiceGetRequest) Send() (*InstanceTypeWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeWatchdogService.connection.URL(), p.InstanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeWatchdogServiceGetResponse{watchdog: result}, nil
}

func (p *InstanceTypeWatchdogServiceGetRequest) MustSend() *InstanceTypeWatchdogServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets watchdog configuration of the instance type.
//
type InstanceTypeWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogServiceGetResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *InstanceTypeWatchdogServiceGetResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Gets watchdog configuration of the instance type.
//
func (p *InstanceTypeWatchdogService) Get() *InstanceTypeWatchdogServiceGetRequest {
	return &InstanceTypeWatchdogServiceGetRequest{InstanceTypeWatchdogService: p}
}

//
// Remove a watchdog from the instance type.
//
type InstanceTypeWatchdogServiceRemoveRequest struct {
	InstanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Header(key, value string) *InstanceTypeWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Query(key, value string) *InstanceTypeWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Async(async bool) *InstanceTypeWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) Send() (*InstanceTypeWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeWatchdogService.connection.URL(), p.InstanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(InstanceTypeWatchdogServiceRemoveResponse), nil
}

func (p *InstanceTypeWatchdogServiceRemoveRequest) MustSend() *InstanceTypeWatchdogServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove a watchdog from the instance type.
//
type InstanceTypeWatchdogServiceRemoveResponse struct {
}

//
// Remove a watchdog from the instance type.
//
func (p *InstanceTypeWatchdogService) Remove() *InstanceTypeWatchdogServiceRemoveRequest {
	return &InstanceTypeWatchdogServiceRemoveRequest{InstanceTypeWatchdogService: p}
}

//
// Updates the watchdog configuration of the instance type.
//
type InstanceTypeWatchdogServiceUpdateRequest struct {
	InstanceTypeWatchdogService *InstanceTypeWatchdogService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	watchdog                    *Watchdog
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Header(key, value string) *InstanceTypeWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Query(key, value string) *InstanceTypeWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Async(async bool) *InstanceTypeWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *InstanceTypeWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) Send() (*InstanceTypeWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeWatchdogService.connection.URL(), p.InstanceTypeWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeWatchdogServiceUpdateResponse{watchdog: result}, nil
}

func (p *InstanceTypeWatchdogServiceUpdateRequest) MustSend() *InstanceTypeWatchdogServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the watchdog configuration of the instance type.
//
type InstanceTypeWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *InstanceTypeWatchdogServiceUpdateResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *InstanceTypeWatchdogServiceUpdateResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Updates the watchdog configuration of the instance type.
//
func (p *InstanceTypeWatchdogService) Update() *InstanceTypeWatchdogServiceUpdateRequest {
	return &InstanceTypeWatchdogServiceUpdateRequest{InstanceTypeWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeWatchdogService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *InstanceTypeWatchdogService) String() string {
	return fmt.Sprintf("InstanceTypeWatchdogService:%s", op.path)
}

//
// A service managing a watchdog on virtual machines.
//
type VmWatchdogService struct {
	BaseService
}

func NewVmWatchdogService(connection *Connection, path string) *VmWatchdogService {
	var result VmWatchdogService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about the watchdog.
//
type VmWatchdogServiceGetRequest struct {
	VmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *VmWatchdogServiceGetRequest) Header(key, value string) *VmWatchdogServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceGetRequest) Query(key, value string) *VmWatchdogServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceGetRequest) Follow(follow string) *VmWatchdogServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmWatchdogServiceGetRequest) Send() (*VmWatchdogServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmWatchdogService.connection.URL(), p.VmWatchdogService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmWatchdogServiceGetResponse{watchdog: result}, nil
}

func (p *VmWatchdogServiceGetRequest) MustSend() *VmWatchdogServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the information about the watchdog.
//
type VmWatchdogServiceGetResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogServiceGetResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *VmWatchdogServiceGetResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Returns the information about the watchdog.
//
func (p *VmWatchdogService) Get() *VmWatchdogServiceGetRequest {
	return &VmWatchdogServiceGetRequest{VmWatchdogService: p}
}

//
// Removes the watchdog from the virtual machine.
// For example, to remove a watchdog from a virtual machine, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000
// ----
//
type VmWatchdogServiceRemoveRequest struct {
	VmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *VmWatchdogServiceRemoveRequest) Header(key, value string) *VmWatchdogServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceRemoveRequest) Query(key, value string) *VmWatchdogServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceRemoveRequest) Async(async bool) *VmWatchdogServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VmWatchdogServiceRemoveRequest) Send() (*VmWatchdogServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmWatchdogService.connection.URL(), p.VmWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmWatchdogServiceRemoveResponse), nil
}

func (p *VmWatchdogServiceRemoveRequest) MustSend() *VmWatchdogServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the watchdog from the virtual machine.
// For example, to remove a watchdog from a virtual machine, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000
// ----
//
type VmWatchdogServiceRemoveResponse struct {
}

//
// Removes the watchdog from the virtual machine.
// For example, to remove a watchdog from a virtual machine, send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000
// ----
//
func (p *VmWatchdogService) Remove() *VmWatchdogServiceRemoveRequest {
	return &VmWatchdogServiceRemoveRequest{VmWatchdogService: p}
}

//
// Updates the information about the watchdog.
// You can update the information using `action` and `model` elements.
// For example, to update a watchdog, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>reset</action>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>reset</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
type VmWatchdogServiceUpdateRequest struct {
	VmWatchdogService *VmWatchdogService
	header            map[string]string
	query             map[string]string
	async             *bool
	watchdog          *Watchdog
}

func (p *VmWatchdogServiceUpdateRequest) Header(key, value string) *VmWatchdogServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogServiceUpdateRequest) Query(key, value string) *VmWatchdogServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogServiceUpdateRequest) Async(async bool) *VmWatchdogServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *VmWatchdogServiceUpdateRequest) Watchdog(watchdog *Watchdog) *VmWatchdogServiceUpdateRequest {
	p.watchdog = watchdog
	return p
}

func (p *VmWatchdogServiceUpdateRequest) Send() (*VmWatchdogServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmWatchdogService.connection.URL(), p.VmWatchdogService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmWatchdogService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmWatchdogService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmWatchdogService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmWatchdogService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmWatchdogService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmWatchdogServiceUpdateResponse{watchdog: result}, nil
}

func (p *VmWatchdogServiceUpdateRequest) MustSend() *VmWatchdogServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the information about the watchdog.
// You can update the information using `action` and `model` elements.
// For example, to update a watchdog, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>reset</action>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>reset</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
type VmWatchdogServiceUpdateResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogServiceUpdateResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *VmWatchdogServiceUpdateResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Updates the information about the watchdog.
// You can update the information using `action` and `model` elements.
// For example, to update a watchdog, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>reset</action>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>reset</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
func (p *VmWatchdogService) Update() *VmWatchdogServiceUpdateRequest {
	return &VmWatchdogServiceUpdateRequest{VmWatchdogService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmWatchdogService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmWatchdogService) String() string {
	return fmt.Sprintf("VmWatchdogService:%s", op.path)
}

//
// A service to manage fence agent for a specific host.
//
type FenceAgentService struct {
	BaseService
}

func NewFenceAgentService(connection *Connection, path string) *FenceAgentService {
	var result FenceAgentService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets details of this fence agent.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <agent id="0">
//   <type>apc</type>
//   <order>1</order>
//   <ip>192.168.1.101</ip>
//   <user>user</user>
//   <password>xxx</password>
//   <port>9</port>
//   <options>name1=value1, name2=value2</options>
// </agent>
// ----
//
type FenceAgentServiceGetRequest struct {
	FenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *FenceAgentServiceGetRequest) Header(key, value string) *FenceAgentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceGetRequest) Query(key, value string) *FenceAgentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceGetRequest) Follow(follow string) *FenceAgentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *FenceAgentServiceGetRequest) Send() (*FenceAgentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FenceAgentService.connection.URL(), p.FenceAgentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FenceAgentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FenceAgentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FenceAgentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FenceAgentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FenceAgentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &FenceAgentServiceGetResponse{agent: result}, nil
}

func (p *FenceAgentServiceGetRequest) MustSend() *FenceAgentServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets details of this fence agent.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <agent id="0">
//   <type>apc</type>
//   <order>1</order>
//   <ip>192.168.1.101</ip>
//   <user>user</user>
//   <password>xxx</password>
//   <port>9</port>
//   <options>name1=value1, name2=value2</options>
// </agent>
// ----
//
type FenceAgentServiceGetResponse struct {
	agent *Agent
}

func (p *FenceAgentServiceGetResponse) Agent() (*Agent, bool) {
	if p.agent != nil {
		return p.agent, true
	}
	return nil, false
}

func (p *FenceAgentServiceGetResponse) MustAgent() *Agent {
	if p.agent == nil {
		panic("agent in response does not exist")
	}
	return p.agent
}

//
// Gets details of this fence agent.
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/fenceagents/0
// ----
// And here is sample response:
// [source,xml]
// ----
// <agent id="0">
//   <type>apc</type>
//   <order>1</order>
//   <ip>192.168.1.101</ip>
//   <user>user</user>
//   <password>xxx</password>
//   <port>9</port>
//   <options>name1=value1, name2=value2</options>
// </agent>
// ----
//
func (p *FenceAgentService) Get() *FenceAgentServiceGetRequest {
	return &FenceAgentServiceGetRequest{FenceAgentService: p}
}

//
// Removes a fence agent for a specific host.
// [source]
// ----
// DELETE /ovirt-engine/api/hosts/123/fenceagents/0
// ----
//
type FenceAgentServiceRemoveRequest struct {
	FenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
	async             *bool
}

func (p *FenceAgentServiceRemoveRequest) Header(key, value string) *FenceAgentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceRemoveRequest) Query(key, value string) *FenceAgentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceRemoveRequest) Async(async bool) *FenceAgentServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *FenceAgentServiceRemoveRequest) Send() (*FenceAgentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FenceAgentService.connection.URL(), p.FenceAgentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FenceAgentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FenceAgentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FenceAgentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FenceAgentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FenceAgentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(FenceAgentServiceRemoveResponse), nil
}

func (p *FenceAgentServiceRemoveRequest) MustSend() *FenceAgentServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a fence agent for a specific host.
// [source]
// ----
// DELETE /ovirt-engine/api/hosts/123/fenceagents/0
// ----
//
type FenceAgentServiceRemoveResponse struct {
}

//
// Removes a fence agent for a specific host.
// [source]
// ----
// DELETE /ovirt-engine/api/hosts/123/fenceagents/0
// ----
//
func (p *FenceAgentService) Remove() *FenceAgentServiceRemoveRequest {
	return &FenceAgentServiceRemoveRequest{FenceAgentService: p}
}

//
// Update a fencing-agent.
//
type FenceAgentServiceUpdateRequest struct {
	FenceAgentService *FenceAgentService
	header            map[string]string
	query             map[string]string
	agent             *Agent
	async             *bool
}

func (p *FenceAgentServiceUpdateRequest) Header(key, value string) *FenceAgentServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FenceAgentServiceUpdateRequest) Query(key, value string) *FenceAgentServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FenceAgentServiceUpdateRequest) Agent(agent *Agent) *FenceAgentServiceUpdateRequest {
	p.agent = agent
	return p
}

func (p *FenceAgentServiceUpdateRequest) Async(async bool) *FenceAgentServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *FenceAgentServiceUpdateRequest) Send() (*FenceAgentServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FenceAgentService.connection.URL(), p.FenceAgentService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAgentWriteOne(writer, p.agent, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FenceAgentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FenceAgentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FenceAgentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FenceAgentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FenceAgentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAgentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &FenceAgentServiceUpdateResponse{agent: result}, nil
}

func (p *FenceAgentServiceUpdateRequest) MustSend() *FenceAgentServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update a fencing-agent.
//
type FenceAgentServiceUpdateResponse struct {
	agent *Agent
}

func (p *FenceAgentServiceUpdateResponse) Agent() (*Agent, bool) {
	if p.agent != nil {
		return p.agent, true
	}
	return nil, false
}

func (p *FenceAgentServiceUpdateResponse) MustAgent() *Agent {
	if p.agent == nil {
		panic("agent in response does not exist")
	}
	return p.agent
}

//
// Update a fencing-agent.
//
func (p *FenceAgentService) Update() *FenceAgentServiceUpdateRequest {
	return &FenceAgentServiceUpdateRequest{FenceAgentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FenceAgentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FenceAgentService) String() string {
	return fmt.Sprintf("FenceAgentService:%s", op.path)
}

//
// This service represents a host that has a specific
// label when accessed through the affinitylabels/hosts
// subcollection.
//
type AffinityLabelHostService struct {
	BaseService
}

func NewAffinityLabelHostService(connection *Connection, path string) *AffinityLabelHostService {
	var result AffinityLabelHostService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves details about a host that has this label assigned.
//
type AffinityLabelHostServiceGetRequest struct {
	AffinityLabelHostService *AffinityLabelHostService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *AffinityLabelHostServiceGetRequest) Header(key, value string) *AffinityLabelHostServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostServiceGetRequest) Query(key, value string) *AffinityLabelHostServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostServiceGetRequest) Follow(follow string) *AffinityLabelHostServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AffinityLabelHostServiceGetRequest) Send() (*AffinityLabelHostServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelHostService.connection.URL(), p.AffinityLabelHostService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelHostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelHostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelHostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityLabelHostServiceGetResponse{host: result}, nil
}

func (p *AffinityLabelHostServiceGetRequest) MustSend() *AffinityLabelHostServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves details about a host that has this label assigned.
//
type AffinityLabelHostServiceGetResponse struct {
	host *Host
}

func (p *AffinityLabelHostServiceGetResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *AffinityLabelHostServiceGetResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Retrieves details about a host that has this label assigned.
//
func (p *AffinityLabelHostService) Get() *AffinityLabelHostServiceGetRequest {
	return &AffinityLabelHostServiceGetRequest{AffinityLabelHostService: p}
}

//
// Remove a label from a host.
//
type AffinityLabelHostServiceRemoveRequest struct {
	AffinityLabelHostService *AffinityLabelHostService
	header                   map[string]string
	query                    map[string]string
}

func (p *AffinityLabelHostServiceRemoveRequest) Header(key, value string) *AffinityLabelHostServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostServiceRemoveRequest) Query(key, value string) *AffinityLabelHostServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostServiceRemoveRequest) Send() (*AffinityLabelHostServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelHostService.connection.URL(), p.AffinityLabelHostService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelHostService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelHostService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelHostService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelHostService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelHostService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityLabelHostServiceRemoveResponse), nil
}

func (p *AffinityLabelHostServiceRemoveRequest) MustSend() *AffinityLabelHostServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove a label from a host.
//
type AffinityLabelHostServiceRemoveResponse struct {
}

//
// Remove a label from a host.
//
func (p *AffinityLabelHostService) Remove() *AffinityLabelHostServiceRemoveRequest {
	return &AffinityLabelHostServiceRemoveRequest{AffinityLabelHostService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelHostService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityLabelHostService) String() string {
	return fmt.Sprintf("AffinityLabelHostService:%s", op.path)
}

//
// This service manages a collection of parameters for network filters.
//
type NicNetworkFilterParametersService struct {
	BaseService
}

func NewNicNetworkFilterParametersService(connection *Connection, path string) *NicNetworkFilterParametersService {
	var result NicNetworkFilterParametersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a network filter parameter.
// For example, to add the parameter for the network filter on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/789/nics/456/networkfilterparameters
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>IP</name>
//   <value>10.0.1.2</value>
// </network_filter_parameter>
// ----
//
type NicNetworkFilterParametersServiceAddRequest struct {
	NicNetworkFilterParametersService *NicNetworkFilterParametersService
	header                            map[string]string
	query                             map[string]string
	parameter                         *NetworkFilterParameter
}

func (p *NicNetworkFilterParametersServiceAddRequest) Header(key, value string) *NicNetworkFilterParametersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NicNetworkFilterParametersServiceAddRequest) Query(key, value string) *NicNetworkFilterParametersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NicNetworkFilterParametersServiceAddRequest) Parameter(parameter *NetworkFilterParameter) *NicNetworkFilterParametersServiceAddRequest {
	p.parameter = parameter
	return p
}

func (p *NicNetworkFilterParametersServiceAddRequest) Send() (*NicNetworkFilterParametersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NicNetworkFilterParametersService.connection.URL(), p.NicNetworkFilterParametersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkFilterParameterWriteOne(writer, p.parameter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NicNetworkFilterParametersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NicNetworkFilterParametersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NicNetworkFilterParametersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NicNetworkFilterParametersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NicNetworkFilterParametersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NicNetworkFilterParametersServiceAddResponse{parameter: result}, nil
}

func (p *NicNetworkFilterParametersServiceAddRequest) MustSend() *NicNetworkFilterParametersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a network filter parameter.
// For example, to add the parameter for the network filter on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/789/nics/456/networkfilterparameters
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>IP</name>
//   <value>10.0.1.2</value>
// </network_filter_parameter>
// ----
//
type NicNetworkFilterParametersServiceAddResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NicNetworkFilterParametersServiceAddResponse) Parameter() (*NetworkFilterParameter, bool) {
	if p.parameter != nil {
		return p.parameter, true
	}
	return nil, false
}

func (p *NicNetworkFilterParametersServiceAddResponse) MustParameter() *NetworkFilterParameter {
	if p.parameter == nil {
		panic("parameter in response does not exist")
	}
	return p.parameter
}

//
// Add a network filter parameter.
// For example, to add the parameter for the network filter on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/789/nics/456/networkfilterparameters
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>IP</name>
//   <value>10.0.1.2</value>
// </network_filter_parameter>
// ----
//
func (p *NicNetworkFilterParametersService) Add() *NicNetworkFilterParametersServiceAddRequest {
	return &NicNetworkFilterParametersServiceAddRequest{NicNetworkFilterParametersService: p}
}

//
// Retrieves the representations of the network filter parameters.
// The order of the returned list of network filters isn't guaranteed.
//
type NicNetworkFilterParametersServiceListRequest struct {
	NicNetworkFilterParametersService *NicNetworkFilterParametersService
	header                            map[string]string
	query                             map[string]string
	follow                            *string
}

func (p *NicNetworkFilterParametersServiceListRequest) Header(key, value string) *NicNetworkFilterParametersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NicNetworkFilterParametersServiceListRequest) Query(key, value string) *NicNetworkFilterParametersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NicNetworkFilterParametersServiceListRequest) Follow(follow string) *NicNetworkFilterParametersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *NicNetworkFilterParametersServiceListRequest) Send() (*NicNetworkFilterParametersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NicNetworkFilterParametersService.connection.URL(), p.NicNetworkFilterParametersService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NicNetworkFilterParametersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NicNetworkFilterParametersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NicNetworkFilterParametersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NicNetworkFilterParametersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NicNetworkFilterParametersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &NicNetworkFilterParametersServiceListResponse{parameters: result}, nil
}

func (p *NicNetworkFilterParametersServiceListRequest) MustSend() *NicNetworkFilterParametersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the representations of the network filter parameters.
// The order of the returned list of network filters isn't guaranteed.
//
type NicNetworkFilterParametersServiceListResponse struct {
	parameters *NetworkFilterParameterSlice
}

func (p *NicNetworkFilterParametersServiceListResponse) Parameters() (*NetworkFilterParameterSlice, bool) {
	if p.parameters != nil {
		return p.parameters, true
	}
	return nil, false
}

func (p *NicNetworkFilterParametersServiceListResponse) MustParameters() *NetworkFilterParameterSlice {
	if p.parameters == nil {
		panic("parameters in response does not exist")
	}
	return p.parameters
}

//
// Retrieves the representations of the network filter parameters.
// The order of the returned list of network filters isn't guaranteed.
//
func (p *NicNetworkFilterParametersService) List() *NicNetworkFilterParametersServiceListRequest {
	return &NicNetworkFilterParametersServiceListRequest{NicNetworkFilterParametersService: p}
}

//
// Reference to the service that manages a specific network filter parameter.
//
func (op *NicNetworkFilterParametersService) ParameterService(id string) *NicNetworkFilterParameterService {
	return NewNicNetworkFilterParameterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NicNetworkFilterParametersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ParameterService(path), nil
	}
	return op.ParameterService(path[:index]).Service(path[index+1:])
}

func (op *NicNetworkFilterParametersService) String() string {
	return fmt.Sprintf("NicNetworkFilterParametersService:%s", op.path)
}

//
// This service manages a single virtual machine to affinity group assignment.
//
type AffinityGroupVmService struct {
	BaseService
}

func NewAffinityGroupVmService(connection *Connection, path string) *AffinityGroupVmService {
	var result AffinityGroupVmService
	result.connection = connection
	result.path = path
	return &result
}

//
// Remove this virtual machine from the affinity group.
//
type AffinityGroupVmServiceRemoveRequest struct {
	AffinityGroupVmService *AffinityGroupVmService
	header                 map[string]string
	query                  map[string]string
	async                  *bool
}

func (p *AffinityGroupVmServiceRemoveRequest) Header(key, value string) *AffinityGroupVmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmServiceRemoveRequest) Query(key, value string) *AffinityGroupVmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmServiceRemoveRequest) Async(async bool) *AffinityGroupVmServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AffinityGroupVmServiceRemoveRequest) Send() (*AffinityGroupVmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupVmService.connection.URL(), p.AffinityGroupVmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupVmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupVmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupVmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupVmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupVmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityGroupVmServiceRemoveResponse), nil
}

func (p *AffinityGroupVmServiceRemoveRequest) MustSend() *AffinityGroupVmServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove this virtual machine from the affinity group.
//
type AffinityGroupVmServiceRemoveResponse struct {
}

//
// Remove this virtual machine from the affinity group.
//
func (p *AffinityGroupVmService) Remove() *AffinityGroupVmServiceRemoveRequest {
	return &AffinityGroupVmServiceRemoveRequest{AffinityGroupVmService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupVmService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupVmService) String() string {
	return fmt.Sprintf("AffinityGroupVmService:%s", op.path)
}

//
//
type InstanceTypeGraphicsConsolesService struct {
	BaseService
}

func NewInstanceTypeGraphicsConsolesService(connection *Connection, path string) *InstanceTypeGraphicsConsolesService {
	var result InstanceTypeGraphicsConsolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new graphics console to the instance type.
//
type InstanceTypeGraphicsConsolesServiceAddRequest struct {
	InstanceTypeGraphicsConsolesService *InstanceTypeGraphicsConsolesService
	header                              map[string]string
	query                               map[string]string
	console                             *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Header(key, value string) *InstanceTypeGraphicsConsolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Query(key, value string) *InstanceTypeGraphicsConsolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Console(console *GraphicsConsole) *InstanceTypeGraphicsConsolesServiceAddRequest {
	p.console = console
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) Send() (*InstanceTypeGraphicsConsolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeGraphicsConsolesService.connection.URL(), p.InstanceTypeGraphicsConsolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLGraphicsConsoleWriteOne(writer, p.console, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeGraphicsConsolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeGraphicsConsolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeGraphicsConsolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeGraphicsConsolesServiceAddResponse{console: result}, nil
}

func (p *InstanceTypeGraphicsConsolesServiceAddRequest) MustSend() *InstanceTypeGraphicsConsolesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add new graphics console to the instance type.
//
type InstanceTypeGraphicsConsolesServiceAddResponse struct {
	console *GraphicsConsole
}

func (p *InstanceTypeGraphicsConsolesServiceAddResponse) Console() (*GraphicsConsole, bool) {
	if p.console != nil {
		return p.console, true
	}
	return nil, false
}

func (p *InstanceTypeGraphicsConsolesServiceAddResponse) MustConsole() *GraphicsConsole {
	if p.console == nil {
		panic("console in response does not exist")
	}
	return p.console
}

//
// Add new graphics console to the instance type.
//
func (p *InstanceTypeGraphicsConsolesService) Add() *InstanceTypeGraphicsConsolesServiceAddRequest {
	return &InstanceTypeGraphicsConsolesServiceAddRequest{InstanceTypeGraphicsConsolesService: p}
}

//
// Lists all the configured graphics consoles of the instance type.
// The order of the returned list of graphics consoles isn't guaranteed.
//
type InstanceTypeGraphicsConsolesServiceListRequest struct {
	InstanceTypeGraphicsConsolesService *InstanceTypeGraphicsConsolesService
	header                              map[string]string
	query                               map[string]string
	follow                              *string
	max                                 *int64
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Header(key, value string) *InstanceTypeGraphicsConsolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Query(key, value string) *InstanceTypeGraphicsConsolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Follow(follow string) *InstanceTypeGraphicsConsolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Max(max int64) *InstanceTypeGraphicsConsolesServiceListRequest {
	p.max = &max
	return p
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) Send() (*InstanceTypeGraphicsConsolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeGraphicsConsolesService.connection.URL(), p.InstanceTypeGraphicsConsolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeGraphicsConsolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeGraphicsConsolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeGraphicsConsolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeGraphicsConsolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeGraphicsConsolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLGraphicsConsoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &InstanceTypeGraphicsConsolesServiceListResponse{consoles: result}, nil
}

func (p *InstanceTypeGraphicsConsolesServiceListRequest) MustSend() *InstanceTypeGraphicsConsolesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all the configured graphics consoles of the instance type.
// The order of the returned list of graphics consoles isn't guaranteed.
//
type InstanceTypeGraphicsConsolesServiceListResponse struct {
	consoles *GraphicsConsoleSlice
}

func (p *InstanceTypeGraphicsConsolesServiceListResponse) Consoles() (*GraphicsConsoleSlice, bool) {
	if p.consoles != nil {
		return p.consoles, true
	}
	return nil, false
}

func (p *InstanceTypeGraphicsConsolesServiceListResponse) MustConsoles() *GraphicsConsoleSlice {
	if p.consoles == nil {
		panic("consoles in response does not exist")
	}
	return p.consoles
}

//
// Lists all the configured graphics consoles of the instance type.
// The order of the returned list of graphics consoles isn't guaranteed.
//
func (p *InstanceTypeGraphicsConsolesService) List() *InstanceTypeGraphicsConsolesServiceListRequest {
	return &InstanceTypeGraphicsConsolesServiceListRequest{InstanceTypeGraphicsConsolesService: p}
}

//
// Returns a reference to the service that manages a specific instance type graphics console.
//
func (op *InstanceTypeGraphicsConsolesService) ConsoleService(id string) *InstanceTypeGraphicsConsoleService {
	return NewInstanceTypeGraphicsConsoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeGraphicsConsolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConsoleService(path), nil
	}
	return op.ConsoleService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeGraphicsConsolesService) String() string {
	return fmt.Sprintf("InstanceTypeGraphicsConsolesService:%s", op.path)
}

//
//
type StorageServerConnectionService struct {
	BaseService
}

func NewStorageServerConnectionService(connection *Connection, path string) *StorageServerConnectionService {
	var result StorageServerConnectionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type StorageServerConnectionServiceGetRequest struct {
	StorageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
}

func (p *StorageServerConnectionServiceGetRequest) Header(key, value string) *StorageServerConnectionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceGetRequest) Query(key, value string) *StorageServerConnectionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceGetRequest) Follow(follow string) *StorageServerConnectionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageServerConnectionServiceGetRequest) Send() (*StorageServerConnectionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionService.connection.URL(), p.StorageServerConnectionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageServerConnectionServiceGetResponse{conection: result}, nil
}

func (p *StorageServerConnectionServiceGetRequest) MustSend() *StorageServerConnectionServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type StorageServerConnectionServiceGetResponse struct {
	conection *StorageConnection
}

func (p *StorageServerConnectionServiceGetResponse) Conection() (*StorageConnection, bool) {
	if p.conection != nil {
		return p.conection, true
	}
	return nil, false
}

func (p *StorageServerConnectionServiceGetResponse) MustConection() *StorageConnection {
	if p.conection == nil {
		panic("conection in response does not exist")
	}
	return p.conection
}

//
//
func (p *StorageServerConnectionService) Get() *StorageServerConnectionServiceGetRequest {
	return &StorageServerConnectionServiceGetRequest{StorageServerConnectionService: p}
}

//
// Update the specified Glusterfs storage connection in the system.
//
type StorageServerConnectionServiceUpdateGlusterfsRequest struct {
	StorageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *StorageServerConnectionServiceUpdateGlusterfsRequest) Header(key, value string) *StorageServerConnectionServiceUpdateGlusterfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateGlusterfsRequest) Query(key, value string) *StorageServerConnectionServiceUpdateGlusterfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateGlusterfsRequest) Async(async bool) *StorageServerConnectionServiceUpdateGlusterfsRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionServiceUpdateGlusterfsRequest) Connection(connection *StorageConnection) *StorageServerConnectionServiceUpdateGlusterfsRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionServiceUpdateGlusterfsRequest) Force(force bool) *StorageServerConnectionServiceUpdateGlusterfsRequest {
	p.force = &force
	return p
}

func (p *StorageServerConnectionServiceUpdateGlusterfsRequest) Send() (*StorageServerConnectionServiceUpdateGlusterfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/glusterfs", p.StorageServerConnectionService.connection.URL(), p.StorageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionServiceUpdateGlusterfsResponse{connection: result}, nil
}

func (p *StorageServerConnectionServiceUpdateGlusterfsRequest) MustSend() *StorageServerConnectionServiceUpdateGlusterfsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified Glusterfs storage connection in the system.
//
type StorageServerConnectionServiceUpdateGlusterfsResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionServiceUpdateGlusterfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionServiceUpdateGlusterfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified Glusterfs storage connection in the system.
//
func (p *StorageServerConnectionService) UpdateGlusterfs() *StorageServerConnectionServiceUpdateGlusterfsRequest {
	return &StorageServerConnectionServiceUpdateGlusterfsRequest{StorageServerConnectionService: p}
}

//
// Update the specified iSCSI storage connection in the system.
//
type StorageServerConnectionServiceUpdateIscsiRequest struct {
	StorageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *StorageServerConnectionServiceUpdateIscsiRequest) Header(key, value string) *StorageServerConnectionServiceUpdateIscsiRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateIscsiRequest) Query(key, value string) *StorageServerConnectionServiceUpdateIscsiRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateIscsiRequest) Async(async bool) *StorageServerConnectionServiceUpdateIscsiRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionServiceUpdateIscsiRequest) Connection(connection *StorageConnection) *StorageServerConnectionServiceUpdateIscsiRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionServiceUpdateIscsiRequest) Force(force bool) *StorageServerConnectionServiceUpdateIscsiRequest {
	p.force = &force
	return p
}

func (p *StorageServerConnectionServiceUpdateIscsiRequest) Send() (*StorageServerConnectionServiceUpdateIscsiResponse, error) {
	rawURL := fmt.Sprintf("%s%s/iscsi", p.StorageServerConnectionService.connection.URL(), p.StorageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionServiceUpdateIscsiResponse{connection: result}, nil
}

func (p *StorageServerConnectionServiceUpdateIscsiRequest) MustSend() *StorageServerConnectionServiceUpdateIscsiResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified iSCSI storage connection in the system.
//
type StorageServerConnectionServiceUpdateIscsiResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionServiceUpdateIscsiResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionServiceUpdateIscsiResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified iSCSI storage connection in the system.
//
func (p *StorageServerConnectionService) UpdateIscsi() *StorageServerConnectionServiceUpdateIscsiRequest {
	return &StorageServerConnectionServiceUpdateIscsiRequest{StorageServerConnectionService: p}
}

//
// Update the specified local storage connection in the system.
//
type StorageServerConnectionServiceUpdateLocalRequest struct {
	StorageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *StorageServerConnectionServiceUpdateLocalRequest) Header(key, value string) *StorageServerConnectionServiceUpdateLocalRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateLocalRequest) Query(key, value string) *StorageServerConnectionServiceUpdateLocalRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateLocalRequest) Async(async bool) *StorageServerConnectionServiceUpdateLocalRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionServiceUpdateLocalRequest) Connection(connection *StorageConnection) *StorageServerConnectionServiceUpdateLocalRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionServiceUpdateLocalRequest) Force(force bool) *StorageServerConnectionServiceUpdateLocalRequest {
	p.force = &force
	return p
}

func (p *StorageServerConnectionServiceUpdateLocalRequest) Send() (*StorageServerConnectionServiceUpdateLocalResponse, error) {
	rawURL := fmt.Sprintf("%s%s/local", p.StorageServerConnectionService.connection.URL(), p.StorageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionServiceUpdateLocalResponse{connection: result}, nil
}

func (p *StorageServerConnectionServiceUpdateLocalRequest) MustSend() *StorageServerConnectionServiceUpdateLocalResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified local storage connection in the system.
//
type StorageServerConnectionServiceUpdateLocalResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionServiceUpdateLocalResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionServiceUpdateLocalResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified local storage connection in the system.
//
func (p *StorageServerConnectionService) UpdateLocal() *StorageServerConnectionServiceUpdateLocalRequest {
	return &StorageServerConnectionServiceUpdateLocalRequest{StorageServerConnectionService: p}
}

//
// Update the specified NFS storage connection in the system.
//
type StorageServerConnectionServiceUpdateNfsRequest struct {
	StorageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *StorageServerConnectionServiceUpdateNfsRequest) Header(key, value string) *StorageServerConnectionServiceUpdateNfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateNfsRequest) Query(key, value string) *StorageServerConnectionServiceUpdateNfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateNfsRequest) Async(async bool) *StorageServerConnectionServiceUpdateNfsRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionServiceUpdateNfsRequest) Connection(connection *StorageConnection) *StorageServerConnectionServiceUpdateNfsRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionServiceUpdateNfsRequest) Force(force bool) *StorageServerConnectionServiceUpdateNfsRequest {
	p.force = &force
	return p
}

func (p *StorageServerConnectionServiceUpdateNfsRequest) Send() (*StorageServerConnectionServiceUpdateNfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/nfs", p.StorageServerConnectionService.connection.URL(), p.StorageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionServiceUpdateNfsResponse{connection: result}, nil
}

func (p *StorageServerConnectionServiceUpdateNfsRequest) MustSend() *StorageServerConnectionServiceUpdateNfsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified NFS storage connection in the system.
//
type StorageServerConnectionServiceUpdateNfsResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionServiceUpdateNfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionServiceUpdateNfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified NFS storage connection in the system.
//
func (p *StorageServerConnectionService) UpdateNfs() *StorageServerConnectionServiceUpdateNfsRequest {
	return &StorageServerConnectionServiceUpdateNfsRequest{StorageServerConnectionService: p}
}

//
// Removes a storage connection.
// A storage connection can only be deleted if neither storage domain nor LUN disks reference it. The host name or
// id is optional; providing it disconnects (unmounts) the connection from that host.
//
type StorageServerConnectionServiceRemoveRequest struct {
	StorageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	host                           *string
}

func (p *StorageServerConnectionServiceRemoveRequest) Header(key, value string) *StorageServerConnectionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceRemoveRequest) Query(key, value string) *StorageServerConnectionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceRemoveRequest) Async(async bool) *StorageServerConnectionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionServiceRemoveRequest) Host(host string) *StorageServerConnectionServiceRemoveRequest {
	p.host = &host
	return p
}

func (p *StorageServerConnectionServiceRemoveRequest) Send() (*StorageServerConnectionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionService.connection.URL(), p.StorageServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.host != nil {
		values["host"] = []string{fmt.Sprintf("%v", *p.host)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageServerConnectionServiceRemoveResponse), nil
}

func (p *StorageServerConnectionServiceRemoveRequest) MustSend() *StorageServerConnectionServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a storage connection.
// A storage connection can only be deleted if neither storage domain nor LUN disks reference it. The host name or
// id is optional; providing it disconnects (unmounts) the connection from that host.
//
type StorageServerConnectionServiceRemoveResponse struct {
}

//
// Removes a storage connection.
// A storage connection can only be deleted if neither storage domain nor LUN disks reference it. The host name or
// id is optional; providing it disconnects (unmounts) the connection from that host.
//
func (p *StorageServerConnectionService) Remove() *StorageServerConnectionServiceRemoveRequest {
	return &StorageServerConnectionServiceRemoveRequest{StorageServerConnectionService: p}
}

//
// Updates the storage connection.
// For example, to change the address of an NFS storage server, send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <address>mynewnfs.example.com</address>
// </storage_connection>
// ----
// To change the connection of an iSCSI storage server, send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <port>3260</port>
//   <target>iqn.2017-01.com.myhost:444</target>
// </storage_connection>
// ----
//
type StorageServerConnectionServiceUpdateRequest struct {
	StorageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *StorageServerConnectionServiceUpdateRequest) Header(key, value string) *StorageServerConnectionServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Query(key, value string) *StorageServerConnectionServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Async(async bool) *StorageServerConnectionServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Connection(connection *StorageConnection) *StorageServerConnectionServiceUpdateRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Force(force bool) *StorageServerConnectionServiceUpdateRequest {
	p.force = &force
	return p
}

func (p *StorageServerConnectionServiceUpdateRequest) Send() (*StorageServerConnectionServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionService.connection.URL(), p.StorageServerConnectionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionWriteOne(writer, p.connection, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageServerConnectionServiceUpdateResponse{connection: result}, nil
}

func (p *StorageServerConnectionServiceUpdateRequest) MustSend() *StorageServerConnectionServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the storage connection.
// For example, to change the address of an NFS storage server, send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <address>mynewnfs.example.com</address>
// </storage_connection>
// ----
// To change the connection of an iSCSI storage server, send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <port>3260</port>
//   <target>iqn.2017-01.com.myhost:444</target>
// </storage_connection>
// ----
//
type StorageServerConnectionServiceUpdateResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionServiceUpdateResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionServiceUpdateResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Updates the storage connection.
// For example, to change the address of an NFS storage server, send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <address>mynewnfs.example.com</address>
// </storage_connection>
// ----
// To change the connection of an iSCSI storage server, send a request like this:
// [source,xml]
// ----
// PUT /ovirt-engine/api/storageconnections/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection>
//   <port>3260</port>
//   <target>iqn.2017-01.com.myhost:444</target>
// </storage_connection>
// ----
//
func (p *StorageServerConnectionService) Update() *StorageServerConnectionServiceUpdateRequest {
	return &StorageServerConnectionServiceUpdateRequest{StorageServerConnectionService: p}
}

//
// Update the specified VFS storage connection in the system.
//
type StorageServerConnectionServiceUpdateVfsRequest struct {
	StorageServerConnectionService *StorageServerConnectionService
	header                         map[string]string
	query                          map[string]string
	async                          *bool
	connection                     *StorageConnection
	force                          *bool
}

func (p *StorageServerConnectionServiceUpdateVfsRequest) Header(key, value string) *StorageServerConnectionServiceUpdateVfsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateVfsRequest) Query(key, value string) *StorageServerConnectionServiceUpdateVfsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionServiceUpdateVfsRequest) Async(async bool) *StorageServerConnectionServiceUpdateVfsRequest {
	p.async = &async
	return p
}

func (p *StorageServerConnectionServiceUpdateVfsRequest) Connection(connection *StorageConnection) *StorageServerConnectionServiceUpdateVfsRequest {
	p.connection = connection
	return p
}

func (p *StorageServerConnectionServiceUpdateVfsRequest) Force(force bool) *StorageServerConnectionServiceUpdateVfsRequest {
	p.force = &force
	return p
}

func (p *StorageServerConnectionServiceUpdateVfsRequest) Send() (*StorageServerConnectionServiceUpdateVfsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/vfs", p.StorageServerConnectionService.connection.URL(), p.StorageServerConnectionService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Connection(p.connection)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustConnection()
	return &StorageServerConnectionServiceUpdateVfsResponse{connection: result}, nil
}

func (p *StorageServerConnectionServiceUpdateVfsRequest) MustSend() *StorageServerConnectionServiceUpdateVfsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified VFS storage connection in the system.
//
type StorageServerConnectionServiceUpdateVfsResponse struct {
	connection *StorageConnection
}

func (p *StorageServerConnectionServiceUpdateVfsResponse) Connection() (*StorageConnection, bool) {
	if p.connection != nil {
		return p.connection, true
	}
	return nil, false
}

func (p *StorageServerConnectionServiceUpdateVfsResponse) MustConnection() *StorageConnection {
	if p.connection == nil {
		panic("connection in response does not exist")
	}
	return p.connection
}

//
// Update the specified VFS storage connection in the system.
//
func (p *StorageServerConnectionService) UpdateVfs() *StorageServerConnectionServiceUpdateVfsRequest {
	return &StorageServerConnectionServiceUpdateVfsRequest{StorageServerConnectionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageServerConnectionService) String() string {
	return fmt.Sprintf("StorageServerConnectionService:%s", op.path)
}

//
// A service managing a network
//
type NetworkService struct {
	BaseService
}

func NewNetworkService(connection *Connection, path string) *NetworkService {
	var result NetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets a logical network.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks/123
// ----
// Will respond:
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/123" id="123">
//   <name>ovirtmgmt</name>
//   <description>Default Management Network</description>
//   <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//   <mtu>0</mtu>
//   <stp>false</stp>
//   <usages>
//     <usage>vm</usage>
//   </usages>
//   <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
// </network>
// ----
//
type NetworkServiceGetRequest struct {
	NetworkService *NetworkService
	header         map[string]string
	query          map[string]string
	follow         *string
}

func (p *NetworkServiceGetRequest) Header(key, value string) *NetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceGetRequest) Query(key, value string) *NetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceGetRequest) Follow(follow string) *NetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *NetworkServiceGetRequest) Send() (*NetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkService.connection.URL(), p.NetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworkServiceGetResponse{network: result}, nil
}

func (p *NetworkServiceGetRequest) MustSend() *NetworkServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets a logical network.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks/123
// ----
// Will respond:
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/123" id="123">
//   <name>ovirtmgmt</name>
//   <description>Default Management Network</description>
//   <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//   <mtu>0</mtu>
//   <stp>false</stp>
//   <usages>
//     <usage>vm</usage>
//   </usages>
//   <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
// </network>
// ----
//
type NetworkServiceGetResponse struct {
	network *Network
}

func (p *NetworkServiceGetResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *NetworkServiceGetResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Gets a logical network.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks/123
// ----
// Will respond:
// [source,xml]
// ----
// <network href="/ovirt-engine/api/networks/123" id="123">
//   <name>ovirtmgmt</name>
//   <description>Default Management Network</description>
//   <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//   <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//   <mtu>0</mtu>
//   <stp>false</stp>
//   <usages>
//     <usage>vm</usage>
//   </usages>
//   <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
// </network>
// ----
//
func (p *NetworkService) Get() *NetworkServiceGetRequest {
	return &NetworkServiceGetRequest{NetworkService: p}
}

//
// Removes a logical network, or the association of a logical network to a data center.
// For example, to remove the logical network `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123
// ----
// Each network is bound exactly to one data center. So if we disassociate network with data center it has the same
// result as if we would just remove that network. However it might be more specific to say we're removing network
// `456` of data center `123`.
// For example, to remove the association of network `456` to data center `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/networks/456
// ----
// NOTE: To remove an external logical network, the network has to be removed directly from its provider by
// https://developer.openstack.org/api-ref/network[OpenStack Networking API].
// The entity representing the external network inside {product-name} is removed automatically,
// if <<types/open_stack_network_provider/attributes/auto_sync,`auto_sync`>> is enabled for the provider,
// otherwise the entity has to be removed using this method.
//
type NetworkServiceRemoveRequest struct {
	NetworkService *NetworkService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *NetworkServiceRemoveRequest) Header(key, value string) *NetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceRemoveRequest) Query(key, value string) *NetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceRemoveRequest) Async(async bool) *NetworkServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *NetworkServiceRemoveRequest) Send() (*NetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkService.connection.URL(), p.NetworkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(NetworkServiceRemoveResponse), nil
}

func (p *NetworkServiceRemoveRequest) MustSend() *NetworkServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a logical network, or the association of a logical network to a data center.
// For example, to remove the logical network `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123
// ----
// Each network is bound exactly to one data center. So if we disassociate network with data center it has the same
// result as if we would just remove that network. However it might be more specific to say we're removing network
// `456` of data center `123`.
// For example, to remove the association of network `456` to data center `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/networks/456
// ----
// NOTE: To remove an external logical network, the network has to be removed directly from its provider by
// https://developer.openstack.org/api-ref/network[OpenStack Networking API].
// The entity representing the external network inside {product-name} is removed automatically,
// if <<types/open_stack_network_provider/attributes/auto_sync,`auto_sync`>> is enabled for the provider,
// otherwise the entity has to be removed using this method.
//
type NetworkServiceRemoveResponse struct {
}

//
// Removes a logical network, or the association of a logical network to a data center.
// For example, to remove the logical network `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/networks/123
// ----
// Each network is bound exactly to one data center. So if we disassociate network with data center it has the same
// result as if we would just remove that network. However it might be more specific to say we're removing network
// `456` of data center `123`.
// For example, to remove the association of network `456` to data center `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/networks/456
// ----
// NOTE: To remove an external logical network, the network has to be removed directly from its provider by
// https://developer.openstack.org/api-ref/network[OpenStack Networking API].
// The entity representing the external network inside {product-name} is removed automatically,
// if <<types/open_stack_network_provider/attributes/auto_sync,`auto_sync`>> is enabled for the provider,
// otherwise the entity has to be removed using this method.
//
func (p *NetworkService) Remove() *NetworkServiceRemoveRequest {
	return &NetworkServiceRemoveRequest{NetworkService: p}
}

//
// Updates a logical network.
// The `name`, `description`, `ip`, `vlan`, `stp` and `display` attributes can be updated.
// For example, to update the description of the logical network `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/networks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <description>My updated description</description>
// </network>
// ----
// The maximum transmission unit of a network is set using a PUT request to
// specify the integer value of the `mtu` attribute.
// For example, to set the maximum transmission unit send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/networks/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <mtu>1500</mtu>
// </network>
// ----
// NOTE: Updating external networks is not propagated to the provider.
//
type NetworkServiceUpdateRequest struct {
	NetworkService *NetworkService
	header         map[string]string
	query          map[string]string
	async          *bool
	network        *Network
}

func (p *NetworkServiceUpdateRequest) Header(key, value string) *NetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkServiceUpdateRequest) Query(key, value string) *NetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkServiceUpdateRequest) Async(async bool) *NetworkServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *NetworkServiceUpdateRequest) Network(network *Network) *NetworkServiceUpdateRequest {
	p.network = network
	return p
}

func (p *NetworkServiceUpdateRequest) Send() (*NetworkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkService.connection.URL(), p.NetworkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworkServiceUpdateResponse{network: result}, nil
}

func (p *NetworkServiceUpdateRequest) MustSend() *NetworkServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates a logical network.
// The `name`, `description`, `ip`, `vlan`, `stp` and `display` attributes can be updated.
// For example, to update the description of the logical network `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/networks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <description>My updated description</description>
// </network>
// ----
// The maximum transmission unit of a network is set using a PUT request to
// specify the integer value of the `mtu` attribute.
// For example, to set the maximum transmission unit send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/networks/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <mtu>1500</mtu>
// </network>
// ----
// NOTE: Updating external networks is not propagated to the provider.
//
type NetworkServiceUpdateResponse struct {
	network *Network
}

func (p *NetworkServiceUpdateResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *NetworkServiceUpdateResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Updates a logical network.
// The `name`, `description`, `ip`, `vlan`, `stp` and `display` attributes can be updated.
// For example, to update the description of the logical network `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/networks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <description>My updated description</description>
// </network>
// ----
// The maximum transmission unit of a network is set using a PUT request to
// specify the integer value of the `mtu` attribute.
// For example, to set the maximum transmission unit send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/networks/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <mtu>1500</mtu>
// </network>
// ----
// NOTE: Updating external networks is not propagated to the provider.
//
func (p *NetworkService) Update() *NetworkServiceUpdateRequest {
	return &NetworkServiceUpdateRequest{NetworkService: p}
}

//
// Reference to the service that manages the network labels assigned to this network.
//
func (op *NetworkService) NetworkLabelsService() *NetworkLabelsService {
	return NewNetworkLabelsService(op.connection, fmt.Sprintf("%s/networklabels", op.path))
}

//
// Reference to the service that manages the permissions assigned to this network.
//
func (op *NetworkService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Reference to the service that manages the vNIC profiles assigned to this network.
//
func (op *NetworkService) VnicProfilesService() *AssignedVnicProfilesService {
	return NewAssignedVnicProfilesService(op.connection, fmt.Sprintf("%s/vnicprofiles", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "networklabels" {
		return op.NetworkLabelsService(), nil
	}
	if strings.HasPrefix(path, "networklabels/") {
		return op.NetworkLabelsService().Service(path[14:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "vnicprofiles" {
		return op.VnicProfilesService(), nil
	}
	if strings.HasPrefix(path, "vnicprofiles/") {
		return op.VnicProfilesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NetworkService) String() string {
	return fmt.Sprintf("NetworkService:%s", op.path)
}

//
//
type TemplateWatchdogsService struct {
	BaseService
}

func NewTemplateWatchdogsService(connection *Connection, path string) *TemplateWatchdogsService {
	var result TemplateWatchdogsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a watchdog to the template identified by the given id.
//
type TemplateWatchdogsServiceAddRequest struct {
	TemplateWatchdogsService *TemplateWatchdogsService
	header                   map[string]string
	query                    map[string]string
	watchdog                 *Watchdog
}

func (p *TemplateWatchdogsServiceAddRequest) Header(key, value string) *TemplateWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogsServiceAddRequest) Query(key, value string) *TemplateWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *TemplateWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}

func (p *TemplateWatchdogsServiceAddRequest) Send() (*TemplateWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateWatchdogsService.connection.URL(), p.TemplateWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateWatchdogsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateWatchdogsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateWatchdogsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateWatchdogsServiceAddResponse{watchdog: result}, nil
}

func (p *TemplateWatchdogsServiceAddRequest) MustSend() *TemplateWatchdogsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a watchdog to the template identified by the given id.
//
type TemplateWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *TemplateWatchdogsServiceAddResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *TemplateWatchdogsServiceAddResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Add a watchdog to the template identified by the given id.
//
func (p *TemplateWatchdogsService) Add() *TemplateWatchdogsServiceAddRequest {
	return &TemplateWatchdogsServiceAddRequest{TemplateWatchdogsService: p}
}

//
// Returns the list of watchdogs.
// The order of the returned list of watchdogs isn't guaranteed.
//
type TemplateWatchdogsServiceListRequest struct {
	TemplateWatchdogsService *TemplateWatchdogsService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
	max                      *int64
}

func (p *TemplateWatchdogsServiceListRequest) Header(key, value string) *TemplateWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateWatchdogsServiceListRequest) Query(key, value string) *TemplateWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateWatchdogsServiceListRequest) Follow(follow string) *TemplateWatchdogsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *TemplateWatchdogsServiceListRequest) Max(max int64) *TemplateWatchdogsServiceListRequest {
	p.max = &max
	return p
}

func (p *TemplateWatchdogsServiceListRequest) Send() (*TemplateWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateWatchdogsService.connection.URL(), p.TemplateWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateWatchdogsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateWatchdogsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateWatchdogsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &TemplateWatchdogsServiceListResponse{watchdogs: result}, nil
}

func (p *TemplateWatchdogsServiceListRequest) MustSend() *TemplateWatchdogsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of watchdogs.
// The order of the returned list of watchdogs isn't guaranteed.
//
type TemplateWatchdogsServiceListResponse struct {
	watchdogs *WatchdogSlice
}

func (p *TemplateWatchdogsServiceListResponse) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *TemplateWatchdogsServiceListResponse) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("watchdogs in response does not exist")
	}
	return p.watchdogs
}

//
// Returns the list of watchdogs.
// The order of the returned list of watchdogs isn't guaranteed.
//
func (p *TemplateWatchdogsService) List() *TemplateWatchdogsServiceListRequest {
	return &TemplateWatchdogsServiceListRequest{TemplateWatchdogsService: p}
}

//
//
func (op *TemplateWatchdogsService) WatchdogService(id string) *TemplateWatchdogService {
	return NewTemplateWatchdogService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateWatchdogsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.WatchdogService(path), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *TemplateWatchdogsService) String() string {
	return fmt.Sprintf("TemplateWatchdogsService:%s", op.path)
}

//
//
type AssignedDiskProfileService struct {
	BaseService
}

func NewAssignedDiskProfileService(connection *Connection, path string) *AssignedDiskProfileService {
	var result AssignedDiskProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type AssignedDiskProfileServiceGetRequest struct {
	AssignedDiskProfileService *AssignedDiskProfileService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
}

func (p *AssignedDiskProfileServiceGetRequest) Header(key, value string) *AssignedDiskProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfileServiceGetRequest) Query(key, value string) *AssignedDiskProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfileServiceGetRequest) Follow(follow string) *AssignedDiskProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AssignedDiskProfileServiceGetRequest) Send() (*AssignedDiskProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedDiskProfileService.connection.URL(), p.AssignedDiskProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedDiskProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedDiskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedDiskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedDiskProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedDiskProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedDiskProfileServiceGetResponse{diskProfile: result}, nil
}

func (p *AssignedDiskProfileServiceGetRequest) MustSend() *AssignedDiskProfileServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type AssignedDiskProfileServiceGetResponse struct {
	diskProfile *DiskProfile
}

func (p *AssignedDiskProfileServiceGetResponse) DiskProfile() (*DiskProfile, bool) {
	if p.diskProfile != nil {
		return p.diskProfile, true
	}
	return nil, false
}

func (p *AssignedDiskProfileServiceGetResponse) MustDiskProfile() *DiskProfile {
	if p.diskProfile == nil {
		panic("diskProfile in response does not exist")
	}
	return p.diskProfile
}

//
//
func (p *AssignedDiskProfileService) Get() *AssignedDiskProfileServiceGetRequest {
	return &AssignedDiskProfileServiceGetRequest{AssignedDiskProfileService: p}
}

//
//
type AssignedDiskProfileServiceRemoveRequest struct {
	AssignedDiskProfileService *AssignedDiskProfileService
	header                     map[string]string
	query                      map[string]string
	async                      *bool
}

func (p *AssignedDiskProfileServiceRemoveRequest) Header(key, value string) *AssignedDiskProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedDiskProfileServiceRemoveRequest) Query(key, value string) *AssignedDiskProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedDiskProfileServiceRemoveRequest) Async(async bool) *AssignedDiskProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AssignedDiskProfileServiceRemoveRequest) Send() (*AssignedDiskProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedDiskProfileService.connection.URL(), p.AssignedDiskProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedDiskProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedDiskProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedDiskProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedDiskProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedDiskProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedDiskProfileServiceRemoveResponse), nil
}

func (p *AssignedDiskProfileServiceRemoveRequest) MustSend() *AssignedDiskProfileServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type AssignedDiskProfileServiceRemoveResponse struct {
}

//
//
func (p *AssignedDiskProfileService) Remove() *AssignedDiskProfileServiceRemoveRequest {
	return &AssignedDiskProfileServiceRemoveRequest{AssignedDiskProfileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedDiskProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedDiskProfileService) String() string {
	return fmt.Sprintf("AssignedDiskProfileService:%s", op.path)
}

//
//
type VmNicService struct {
	BaseService
}

func NewVmNicService(connection *Connection, path string) *VmNicService {
	var result VmNicService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type VmNicServiceActivateRequest struct {
	VmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceActivateRequest) Header(key, value string) *VmNicServiceActivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceActivateRequest) Query(key, value string) *VmNicServiceActivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceActivateRequest) Async(async bool) *VmNicServiceActivateRequest {
	p.async = &async
	return p
}

func (p *VmNicServiceActivateRequest) Send() (*VmNicServiceActivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/activate", p.VmNicService.connection.URL(), p.VmNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmNicServiceActivateResponse), nil
}

func (p *VmNicServiceActivateRequest) MustSend() *VmNicServiceActivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmNicServiceActivateResponse struct {
}

//
//
func (p *VmNicService) Activate() *VmNicServiceActivateRequest {
	return &VmNicServiceActivateRequest{VmNicService: p}
}

//
//
type VmNicServiceDeactivateRequest struct {
	VmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceDeactivateRequest) Header(key, value string) *VmNicServiceDeactivateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceDeactivateRequest) Query(key, value string) *VmNicServiceDeactivateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceDeactivateRequest) Async(async bool) *VmNicServiceDeactivateRequest {
	p.async = &async
	return p
}

func (p *VmNicServiceDeactivateRequest) Send() (*VmNicServiceDeactivateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/deactivate", p.VmNicService.connection.URL(), p.VmNicService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmNicServiceDeactivateResponse), nil
}

func (p *VmNicServiceDeactivateRequest) MustSend() *VmNicServiceDeactivateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmNicServiceDeactivateResponse struct {
}

//
//
func (p *VmNicService) Deactivate() *VmNicServiceDeactivateRequest {
	return &VmNicServiceDeactivateRequest{VmNicService: p}
}

//
//
type VmNicServiceGetRequest struct {
	VmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	follow       *string
}

func (p *VmNicServiceGetRequest) Header(key, value string) *VmNicServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceGetRequest) Query(key, value string) *VmNicServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceGetRequest) Follow(follow string) *VmNicServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmNicServiceGetRequest) Send() (*VmNicServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNicService.connection.URL(), p.VmNicService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmNicServiceGetResponse{nic: result}, nil
}

func (p *VmNicServiceGetRequest) MustSend() *VmNicServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmNicServiceGetResponse struct {
	nic *Nic
}

func (p *VmNicServiceGetResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *VmNicServiceGetResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
//
func (p *VmNicService) Get() *VmNicServiceGetRequest {
	return &VmNicServiceGetRequest{VmNicService: p}
}

//
// Removes the NIC.
// For example, to remove the NIC with id `456` from the virtual machine with id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/nics/456
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type VmNicServiceRemoveRequest struct {
	VmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
}

func (p *VmNicServiceRemoveRequest) Header(key, value string) *VmNicServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceRemoveRequest) Query(key, value string) *VmNicServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceRemoveRequest) Async(async bool) *VmNicServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VmNicServiceRemoveRequest) Send() (*VmNicServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNicService.connection.URL(), p.VmNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmNicServiceRemoveResponse), nil
}

func (p *VmNicServiceRemoveRequest) MustSend() *VmNicServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the NIC.
// For example, to remove the NIC with id `456` from the virtual machine with id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/nics/456
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type VmNicServiceRemoveResponse struct {
}

//
// Removes the NIC.
// For example, to remove the NIC with id `456` from the virtual machine with id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123/nics/456
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
func (p *VmNicService) Remove() *VmNicServiceRemoveRequest {
	return &VmNicServiceRemoveRequest{VmNicService: p}
}

//
// Updates the NIC.
// For example, to update the NIC having with `456` belonging to virtual the machine with id `123` send a request
// like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/nics/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>e1000</interface>
//   <vnic_profile id='789'/>
// </nic>
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type VmNicServiceUpdateRequest struct {
	VmNicService *VmNicService
	header       map[string]string
	query        map[string]string
	async        *bool
	nic          *Nic
}

func (p *VmNicServiceUpdateRequest) Header(key, value string) *VmNicServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmNicServiceUpdateRequest) Query(key, value string) *VmNicServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmNicServiceUpdateRequest) Async(async bool) *VmNicServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *VmNicServiceUpdateRequest) Nic(nic *Nic) *VmNicServiceUpdateRequest {
	p.nic = nic
	return p
}

func (p *VmNicServiceUpdateRequest) Send() (*VmNicServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmNicService.connection.URL(), p.VmNicService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmNicService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmNicService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmNicService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmNicService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmNicService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmNicServiceUpdateResponse{nic: result}, nil
}

func (p *VmNicServiceUpdateRequest) MustSend() *VmNicServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the NIC.
// For example, to update the NIC having with `456` belonging to virtual the machine with id `123` send a request
// like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/nics/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>e1000</interface>
//   <vnic_profile id='789'/>
// </nic>
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
type VmNicServiceUpdateResponse struct {
	nic *Nic
}

func (p *VmNicServiceUpdateResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *VmNicServiceUpdateResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Updates the NIC.
// For example, to update the NIC having with `456` belonging to virtual the machine with id `123` send a request
// like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/nics/456
// ----
// With a request body like this:
// [source,xml]
// ----
// <nic>
//   <name>mynic</name>
//   <interface>e1000</interface>
//   <vnic_profile id='789'/>
// </nic>
// ----
// [IMPORTANT]
// ====
// The hotplugging feature only supports virtual machine operating systems with hotplugging operations.
// Example operating systems include:
// - Red Hat Enterprise Linux 6
// - Red Hat Enterprise Linux 5
// - Windows Server 2008 and
// - Windows Server 2003
// ====
//
func (p *VmNicService) Update() *VmNicServiceUpdateRequest {
	return &VmNicServiceUpdateRequest{VmNicService: p}
}

//
// Reference to the service that manages the network filter parameters of the NIC.
// A single top-level network filter may assigned to the NIC by the NIC's <<types/vnic_profile,vNIC Profile>>.
//
func (op *VmNicService) NetworkFilterParametersService() *NicNetworkFilterParametersService {
	return NewNicNetworkFilterParametersService(op.connection, fmt.Sprintf("%s/networkfilterparameters", op.path))
}

//
//
func (op *VmNicService) ReportedDevicesService() *VmReportedDevicesService {
	return NewVmReportedDevicesService(op.connection, fmt.Sprintf("%s/reporteddevices", op.path))
}

//
//
func (op *VmNicService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmNicService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "networkfilterparameters" {
		return op.NetworkFilterParametersService(), nil
	}
	if strings.HasPrefix(path, "networkfilterparameters/") {
		return op.NetworkFilterParametersService().Service(path[24:])
	}
	if path == "reporteddevices" {
		return op.ReportedDevicesService(), nil
	}
	if strings.HasPrefix(path, "reporteddevices/") {
		return op.ReportedDevicesService().Service(path[16:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmNicService) String() string {
	return fmt.Sprintf("VmNicService:%s", op.path)
}

//
// This service represents list of hosts that have a specific
// label when accessed through the affinitylabels/hosts
// subcollection.
//
type AffinityLabelHostsService struct {
	BaseService
}

func NewAffinityLabelHostsService(connection *Connection, path string) *AffinityLabelHostsService {
	var result AffinityLabelHostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a label to a host.
//
type AffinityLabelHostsServiceAddRequest struct {
	AffinityLabelHostsService *AffinityLabelHostsService
	header                    map[string]string
	query                     map[string]string
	host                      *Host
}

func (p *AffinityLabelHostsServiceAddRequest) Header(key, value string) *AffinityLabelHostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostsServiceAddRequest) Query(key, value string) *AffinityLabelHostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostsServiceAddRequest) Host(host *Host) *AffinityLabelHostsServiceAddRequest {
	p.host = host
	return p
}

func (p *AffinityLabelHostsServiceAddRequest) Send() (*AffinityLabelHostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelHostsService.connection.URL(), p.AffinityLabelHostsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelHostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelHostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelHostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityLabelHostsServiceAddResponse{host: result}, nil
}

func (p *AffinityLabelHostsServiceAddRequest) MustSend() *AffinityLabelHostsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a label to a host.
//
type AffinityLabelHostsServiceAddResponse struct {
	host *Host
}

func (p *AffinityLabelHostsServiceAddResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *AffinityLabelHostsServiceAddResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Add a label to a host.
//
func (p *AffinityLabelHostsService) Add() *AffinityLabelHostsServiceAddRequest {
	return &AffinityLabelHostsServiceAddRequest{AffinityLabelHostsService: p}
}

//
// List all hosts with the label.
// The order of the returned hosts isn't guaranteed.
//
type AffinityLabelHostsServiceListRequest struct {
	AffinityLabelHostsService *AffinityLabelHostsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
}

func (p *AffinityLabelHostsServiceListRequest) Header(key, value string) *AffinityLabelHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelHostsServiceListRequest) Query(key, value string) *AffinityLabelHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelHostsServiceListRequest) Follow(follow string) *AffinityLabelHostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AffinityLabelHostsServiceListRequest) Send() (*AffinityLabelHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelHostsService.connection.URL(), p.AffinityLabelHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelHostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelHostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelHostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AffinityLabelHostsServiceListResponse{hosts: result}, nil
}

func (p *AffinityLabelHostsServiceListRequest) MustSend() *AffinityLabelHostsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all hosts with the label.
// The order of the returned hosts isn't guaranteed.
//
type AffinityLabelHostsServiceListResponse struct {
	hosts *HostSlice
}

func (p *AffinityLabelHostsServiceListResponse) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *AffinityLabelHostsServiceListResponse) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// List all hosts with the label.
// The order of the returned hosts isn't guaranteed.
//
func (p *AffinityLabelHostsService) List() *AffinityLabelHostsServiceListRequest {
	return &AffinityLabelHostsServiceListRequest{AffinityLabelHostsService: p}
}

//
// A link to the specific label-host assignment to
// allow label removal.
//
func (op *AffinityLabelHostsService) HostService(id string) *AffinityLabelHostService {
	return NewAffinityLabelHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelHostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelHostsService) String() string {
	return fmt.Sprintf("AffinityLabelHostsService:%s", op.path)
}

//
// Lists the watchdogs of a virtual machine.
//
type VmWatchdogsService struct {
	BaseService
}

func NewVmWatchdogsService(connection *Connection, path string) *VmWatchdogsService {
	var result VmWatchdogsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds new watchdog to the virtual machine.
// For example, to add a watchdog to a virtual machine, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
type VmWatchdogsServiceAddRequest struct {
	VmWatchdogsService *VmWatchdogsService
	header             map[string]string
	query              map[string]string
	watchdog           *Watchdog
}

func (p *VmWatchdogsServiceAddRequest) Header(key, value string) *VmWatchdogsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogsServiceAddRequest) Query(key, value string) *VmWatchdogsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogsServiceAddRequest) Watchdog(watchdog *Watchdog) *VmWatchdogsServiceAddRequest {
	p.watchdog = watchdog
	return p
}

func (p *VmWatchdogsServiceAddRequest) Send() (*VmWatchdogsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmWatchdogsService.connection.URL(), p.VmWatchdogsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLWatchdogWriteOne(writer, p.watchdog, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmWatchdogsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmWatchdogsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmWatchdogsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmWatchdogsServiceAddResponse{watchdog: result}, nil
}

func (p *VmWatchdogsServiceAddRequest) MustSend() *VmWatchdogsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds new watchdog to the virtual machine.
// For example, to add a watchdog to a virtual machine, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
type VmWatchdogsServiceAddResponse struct {
	watchdog *Watchdog
}

func (p *VmWatchdogsServiceAddResponse) Watchdog() (*Watchdog, bool) {
	if p.watchdog != nil {
		return p.watchdog, true
	}
	return nil, false
}

func (p *VmWatchdogsServiceAddResponse) MustWatchdog() *Watchdog {
	if p.watchdog == nil {
		panic("watchdog in response does not exist")
	}
	return p.watchdog
}

//
// Adds new watchdog to the virtual machine.
// For example, to add a watchdog to a virtual machine, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/watchdogs
// <watchdog>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
// with response body:
// [source,xml]
// ----
// <watchdog href="/ovirt-engine/api/vms/123/watchdogs/00000000-0000-0000-0000-000000000000" id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   <action>poweroff</action>
//   <model>i6300esb</model>
// </watchdog>
// ----
//
func (p *VmWatchdogsService) Add() *VmWatchdogsServiceAddRequest {
	return &VmWatchdogsServiceAddRequest{VmWatchdogsService: p}
}

//
// The list of watchdogs of the virtual machine.
// The order of the returned list of watchdogs isn't guaranteed.
//
type VmWatchdogsServiceListRequest struct {
	VmWatchdogsService *VmWatchdogsService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *VmWatchdogsServiceListRequest) Header(key, value string) *VmWatchdogsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmWatchdogsServiceListRequest) Query(key, value string) *VmWatchdogsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmWatchdogsServiceListRequest) Follow(follow string) *VmWatchdogsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmWatchdogsServiceListRequest) Max(max int64) *VmWatchdogsServiceListRequest {
	p.max = &max
	return p
}

func (p *VmWatchdogsServiceListRequest) Send() (*VmWatchdogsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmWatchdogsService.connection.URL(), p.VmWatchdogsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmWatchdogsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmWatchdogsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmWatchdogsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmWatchdogsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmWatchdogsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWatchdogReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmWatchdogsServiceListResponse{watchdogs: result}, nil
}

func (p *VmWatchdogsServiceListRequest) MustSend() *VmWatchdogsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// The list of watchdogs of the virtual machine.
// The order of the returned list of watchdogs isn't guaranteed.
//
type VmWatchdogsServiceListResponse struct {
	watchdogs *WatchdogSlice
}

func (p *VmWatchdogsServiceListResponse) Watchdogs() (*WatchdogSlice, bool) {
	if p.watchdogs != nil {
		return p.watchdogs, true
	}
	return nil, false
}

func (p *VmWatchdogsServiceListResponse) MustWatchdogs() *WatchdogSlice {
	if p.watchdogs == nil {
		panic("watchdogs in response does not exist")
	}
	return p.watchdogs
}

//
// The list of watchdogs of the virtual machine.
// The order of the returned list of watchdogs isn't guaranteed.
//
func (p *VmWatchdogsService) List() *VmWatchdogsServiceListRequest {
	return &VmWatchdogsServiceListRequest{VmWatchdogsService: p}
}

//
// Returns a reference to the service that manages a specific watchdog.
//
func (op *VmWatchdogsService) WatchdogService(id string) *VmWatchdogService {
	return NewVmWatchdogService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmWatchdogsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.WatchdogService(path), nil
	}
	return op.WatchdogService(path[:index]).Service(path[index+1:])
}

func (op *VmWatchdogsService) String() string {
	return fmt.Sprintf("VmWatchdogsService:%s", op.path)
}

//
// This service manages a single host label assigned to an affinity group.
//
type AffinityGroupHostLabelService struct {
	BaseService
}

func NewAffinityGroupHostLabelService(connection *Connection, path string) *AffinityGroupHostLabelService {
	var result AffinityGroupHostLabelService
	result.connection = connection
	result.path = path
	return &result
}

//
// Remove this label from the affinity group.
//
type AffinityGroupHostLabelServiceRemoveRequest struct {
	AffinityGroupHostLabelService *AffinityGroupHostLabelService
	header                        map[string]string
	query                         map[string]string
	async                         *bool
}

func (p *AffinityGroupHostLabelServiceRemoveRequest) Header(key, value string) *AffinityGroupHostLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupHostLabelServiceRemoveRequest) Query(key, value string) *AffinityGroupHostLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupHostLabelServiceRemoveRequest) Async(async bool) *AffinityGroupHostLabelServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AffinityGroupHostLabelServiceRemoveRequest) Send() (*AffinityGroupHostLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupHostLabelService.connection.URL(), p.AffinityGroupHostLabelService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupHostLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupHostLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupHostLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupHostLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupHostLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityGroupHostLabelServiceRemoveResponse), nil
}

func (p *AffinityGroupHostLabelServiceRemoveRequest) MustSend() *AffinityGroupHostLabelServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove this label from the affinity group.
//
type AffinityGroupHostLabelServiceRemoveResponse struct {
}

//
// Remove this label from the affinity group.
//
func (p *AffinityGroupHostLabelService) Remove() *AffinityGroupHostLabelServiceRemoveRequest {
	return &AffinityGroupHostLabelServiceRemoveRequest{AffinityGroupHostLabelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupHostLabelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupHostLabelService) String() string {
	return fmt.Sprintf("AffinityGroupHostLabelService:%s", op.path)
}

//
// A service to access a particular device of a host.
//
type HostDeviceService struct {
	BaseService
}

func NewHostDeviceService(connection *Connection, path string) *HostDeviceService {
	var result HostDeviceService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieve information about a particular host's device.
// An example of getting a host device:
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/devices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/123/devices/456" id="456">
//   <name>usb_1_9_1_1_0</name>
//   <capability>usb</capability>
//   <host href="/ovirt-engine/api/hosts/123" id="123"/>
//   <parent_device href="/ovirt-engine/api/hosts/123/devices/789" id="789">
//     <name>usb_1_9_1</name>
//   </parent_device>
// </host_device>
// ----
//
type HostDeviceServiceGetRequest struct {
	HostDeviceService *HostDeviceService
	header            map[string]string
	query             map[string]string
	follow            *string
}

func (p *HostDeviceServiceGetRequest) Header(key, value string) *HostDeviceServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostDeviceServiceGetRequest) Query(key, value string) *HostDeviceServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostDeviceServiceGetRequest) Follow(follow string) *HostDeviceServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *HostDeviceServiceGetRequest) Send() (*HostDeviceServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostDeviceService.connection.URL(), p.HostDeviceService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostDeviceService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostDeviceService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostDeviceService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostDeviceService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostDeviceService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &HostDeviceServiceGetResponse{device: result}, nil
}

func (p *HostDeviceServiceGetRequest) MustSend() *HostDeviceServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieve information about a particular host's device.
// An example of getting a host device:
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/devices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/123/devices/456" id="456">
//   <name>usb_1_9_1_1_0</name>
//   <capability>usb</capability>
//   <host href="/ovirt-engine/api/hosts/123" id="123"/>
//   <parent_device href="/ovirt-engine/api/hosts/123/devices/789" id="789">
//     <name>usb_1_9_1</name>
//   </parent_device>
// </host_device>
// ----
//
type HostDeviceServiceGetResponse struct {
	device *HostDevice
}

func (p *HostDeviceServiceGetResponse) Device() (*HostDevice, bool) {
	if p.device != nil {
		return p.device, true
	}
	return nil, false
}

func (p *HostDeviceServiceGetResponse) MustDevice() *HostDevice {
	if p.device == nil {
		panic("device in response does not exist")
	}
	return p.device
}

//
// Retrieve information about a particular host's device.
// An example of getting a host device:
// [source]
// ----
// GET /ovirt-engine/api/hosts/123/devices/456
// ----
// [source,xml]
// ----
// <host_device href="/ovirt-engine/api/hosts/123/devices/456" id="456">
//   <name>usb_1_9_1_1_0</name>
//   <capability>usb</capability>
//   <host href="/ovirt-engine/api/hosts/123" id="123"/>
//   <parent_device href="/ovirt-engine/api/hosts/123/devices/789" id="789">
//     <name>usb_1_9_1</name>
//   </parent_device>
// </host_device>
// ----
//
func (p *HostDeviceService) Get() *HostDeviceServiceGetRequest {
	return &HostDeviceServiceGetRequest{HostDeviceService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostDeviceService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostDeviceService) String() string {
	return fmt.Sprintf("HostDeviceService:%s", op.path)
}

//
//
type MeasurableService struct {
	BaseService
}

func NewMeasurableService(connection *Connection, path string) *MeasurableService {
	var result MeasurableService
	result.connection = connection
	result.path = path
	return &result
}

//
//
func (op *MeasurableService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MeasurableService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MeasurableService) String() string {
	return fmt.Sprintf("MeasurableService:%s", op.path)
}

//
// Manages logical networks.
// The engine creates a default `ovirtmgmt` network on installation. This network acts as the management network for
// access to hypervisor hosts. This network is associated with the `Default` cluster and is a member of the `Default`
// data center.
//
type NetworksService struct {
	BaseService
}

func NewNetworksService(connection *Connection, path string) *NetworksService {
	var result NetworksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new logical network, or associates an existing network with a data center.
// Creation of a new network requires the `name` and `data_center` elements.
// For example, to create a network named `mynetwork` for data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
//   <data_center id="123"/>
// </network>
// ----
// To associate the existing network `456` with the data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>ovirtmgmt</name>
// </network>
// ----
// To create a network named `exnetwork` on top of an external _OpenStack_ network provider `456` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// [source,xml]
// ----
// <network>
//   <name>exnetwork</name>
//   <external_provider id="456"/>
//   <data_center id="123"/>
// </network>
// ----
//
type NetworksServiceAddRequest struct {
	NetworksService *NetworksService
	header          map[string]string
	query           map[string]string
	network         *Network
}

func (p *NetworksServiceAddRequest) Header(key, value string) *NetworksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworksServiceAddRequest) Query(key, value string) *NetworksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworksServiceAddRequest) Network(network *Network) *NetworksServiceAddRequest {
	p.network = network
	return p
}

func (p *NetworksServiceAddRequest) Send() (*NetworksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworksService.connection.URL(), p.NetworksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworksServiceAddResponse{network: result}, nil
}

func (p *NetworksServiceAddRequest) MustSend() *NetworksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new logical network, or associates an existing network with a data center.
// Creation of a new network requires the `name` and `data_center` elements.
// For example, to create a network named `mynetwork` for data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
//   <data_center id="123"/>
// </network>
// ----
// To associate the existing network `456` with the data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>ovirtmgmt</name>
// </network>
// ----
// To create a network named `exnetwork` on top of an external _OpenStack_ network provider `456` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// [source,xml]
// ----
// <network>
//   <name>exnetwork</name>
//   <external_provider id="456"/>
//   <data_center id="123"/>
// </network>
// ----
//
type NetworksServiceAddResponse struct {
	network *Network
}

func (p *NetworksServiceAddResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *NetworksServiceAddResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Creates a new logical network, or associates an existing network with a data center.
// Creation of a new network requires the `name` and `data_center` elements.
// For example, to create a network named `mynetwork` for data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>mynetwork</name>
//   <data_center id="123"/>
// </network>
// ----
// To associate the existing network `456` with the data center `123` send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/networks
// ----
// With a request body like this:
// [source,xml]
// ----
// <network>
//   <name>ovirtmgmt</name>
// </network>
// ----
// To create a network named `exnetwork` on top of an external _OpenStack_ network provider `456` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/networks
// ----
// [source,xml]
// ----
// <network>
//   <name>exnetwork</name>
//   <external_provider id="456"/>
//   <data_center id="123"/>
// </network>
// ----
//
func (p *NetworksService) Add() *NetworksServiceAddRequest {
	return &NetworksServiceAddRequest{NetworksService: p}
}

//
// List logical networks.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks
// ----
// Will respond:
// [source,xml]
// ----
// <networks>
//   <network href="/ovirt-engine/api/networks/123" id="123">
//     <name>ovirtmgmt</name>
//     <description>Default Management Network</description>
//     <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//     <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//     <mtu>0</mtu>
//     <stp>false</stp>
//     <usages>
//       <usage>vm</usage>
//     </usages>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </network>
//   ...
// </networks>
// ----
// The order of the returned list of networks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type NetworksServiceListRequest struct {
	NetworksService *NetworksService
	header          map[string]string
	query           map[string]string
	caseSensitive   *bool
	follow          *string
	max             *int64
	search          *string
}

func (p *NetworksServiceListRequest) Header(key, value string) *NetworksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworksServiceListRequest) Query(key, value string) *NetworksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworksServiceListRequest) CaseSensitive(caseSensitive bool) *NetworksServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *NetworksServiceListRequest) Follow(follow string) *NetworksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *NetworksServiceListRequest) Max(max int64) *NetworksServiceListRequest {
	p.max = &max
	return p
}

func (p *NetworksServiceListRequest) Search(search string) *NetworksServiceListRequest {
	p.search = &search
	return p
}

func (p *NetworksServiceListRequest) Send() (*NetworksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworksService.connection.URL(), p.NetworksService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &NetworksServiceListResponse{networks: result}, nil
}

func (p *NetworksServiceListRequest) MustSend() *NetworksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List logical networks.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks
// ----
// Will respond:
// [source,xml]
// ----
// <networks>
//   <network href="/ovirt-engine/api/networks/123" id="123">
//     <name>ovirtmgmt</name>
//     <description>Default Management Network</description>
//     <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//     <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//     <mtu>0</mtu>
//     <stp>false</stp>
//     <usages>
//       <usage>vm</usage>
//     </usages>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </network>
//   ...
// </networks>
// ----
// The order of the returned list of networks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type NetworksServiceListResponse struct {
	networks *NetworkSlice
}

func (p *NetworksServiceListResponse) Networks() (*NetworkSlice, bool) {
	if p.networks != nil {
		return p.networks, true
	}
	return nil, false
}

func (p *NetworksServiceListResponse) MustNetworks() *NetworkSlice {
	if p.networks == nil {
		panic("networks in response does not exist")
	}
	return p.networks
}

//
// List logical networks.
// For example:
// [source]
// ----
// GET /ovirt-engine/api/networks
// ----
// Will respond:
// [source,xml]
// ----
// <networks>
//   <network href="/ovirt-engine/api/networks/123" id="123">
//     <name>ovirtmgmt</name>
//     <description>Default Management Network</description>
//     <link href="/ovirt-engine/api/networks/123/permissions" rel="permissions"/>
//     <link href="/ovirt-engine/api/networks/123/vnicprofiles" rel="vnicprofiles"/>
//     <link href="/ovirt-engine/api/networks/123/networklabels" rel="networklabels"/>
//     <mtu>0</mtu>
//     <stp>false</stp>
//     <usages>
//       <usage>vm</usage>
//     </usages>
//     <data_center href="/ovirt-engine/api/datacenters/456" id="456"/>
//   </network>
//   ...
// </networks>
// ----
// The order of the returned list of networks is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *NetworksService) List() *NetworksServiceListRequest {
	return &NetworksServiceListRequest{NetworksService: p}
}

//
// Reference to the service that manages a specific network.
//
func (op *NetworksService) NetworkService(id string) *NetworkService {
	return NewNetworkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NetworkService(path), nil
	}
	return op.NetworkService(path[:index]).Service(path[index+1:])
}

func (op *NetworksService) String() string {
	return fmt.Sprintf("NetworksService:%s", op.path)
}

//
// A service to manage data centers.
//
type DataCentersService struct {
	BaseService
}

func NewDataCentersService(connection *Connection, path string) *DataCentersService {
	var result DataCentersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new data center.
// Creation of a new data center requires the `name` and `local` elements. For example, to create a data center
// named `mydc` that uses shared storage (NFS, iSCSI or fibre channel) send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>mydc</name>
//   <local>false</local>
// </data_center>
// ----
//
type DataCentersServiceAddRequest struct {
	DataCentersService *DataCentersService
	header             map[string]string
	query              map[string]string
	dataCenter         *DataCenter
}

func (p *DataCentersServiceAddRequest) Header(key, value string) *DataCentersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCentersServiceAddRequest) Query(key, value string) *DataCentersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCentersServiceAddRequest) DataCenter(dataCenter *DataCenter) *DataCentersServiceAddRequest {
	p.dataCenter = dataCenter
	return p
}

func (p *DataCentersServiceAddRequest) Send() (*DataCentersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCentersService.connection.URL(), p.DataCentersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDataCenterWriteOne(writer, p.dataCenter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCentersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCentersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCentersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCentersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCentersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DataCentersServiceAddResponse{dataCenter: result}, nil
}

func (p *DataCentersServiceAddRequest) MustSend() *DataCentersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new data center.
// Creation of a new data center requires the `name` and `local` elements. For example, to create a data center
// named `mydc` that uses shared storage (NFS, iSCSI or fibre channel) send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>mydc</name>
//   <local>false</local>
// </data_center>
// ----
//
type DataCentersServiceAddResponse struct {
	dataCenter *DataCenter
}

func (p *DataCentersServiceAddResponse) DataCenter() (*DataCenter, bool) {
	if p.dataCenter != nil {
		return p.dataCenter, true
	}
	return nil, false
}

func (p *DataCentersServiceAddResponse) MustDataCenter() *DataCenter {
	if p.dataCenter == nil {
		panic("dataCenter in response does not exist")
	}
	return p.dataCenter
}

//
// Creates a new data center.
// Creation of a new data center requires the `name` and `local` elements. For example, to create a data center
// named `mydc` that uses shared storage (NFS, iSCSI or fibre channel) send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters
// ----
// With a request body like this:
// [source,xml]
// ----
// <data_center>
//   <name>mydc</name>
//   <local>false</local>
// </data_center>
// ----
//
func (p *DataCentersService) Add() *DataCentersServiceAddRequest {
	return &DataCentersServiceAddRequest{DataCentersService: p}
}

//
// Lists the data centers.
// The following request retrieves a representation of the data centers:
// [source]
// ----
// GET /ovirt-engine/api/datacenters
// ----
// The above request performed with `curl`:
// [source,bash]
// ----
// curl \
// --request GET \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --header "Version: 4" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// https://myengine.example.com/ovirt-engine/api/datacenters
// ----
// This is what an example response could look like:
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//     </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
// </data_center>
// ----
// Note the `id` code of your `Default` data center. This code identifies this data center in relation to other
// resources of your virtual environment.
// The data center also contains a link to the storage domains collection. The data center uses this collection to
// attach storage domains from the storage domains main collection.
// The order of the returned list of data centers is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type DataCentersServiceListRequest struct {
	DataCentersService *DataCentersService
	header             map[string]string
	query              map[string]string
	caseSensitive      *bool
	filter             *bool
	follow             *string
	max                *int64
	search             *string
}

func (p *DataCentersServiceListRequest) Header(key, value string) *DataCentersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DataCentersServiceListRequest) Query(key, value string) *DataCentersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DataCentersServiceListRequest) CaseSensitive(caseSensitive bool) *DataCentersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *DataCentersServiceListRequest) Filter(filter bool) *DataCentersServiceListRequest {
	p.filter = &filter
	return p
}

func (p *DataCentersServiceListRequest) Follow(follow string) *DataCentersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DataCentersServiceListRequest) Max(max int64) *DataCentersServiceListRequest {
	p.max = &max
	return p
}

func (p *DataCentersServiceListRequest) Search(search string) *DataCentersServiceListRequest {
	p.search = &search
	return p
}

func (p *DataCentersServiceListRequest) Send() (*DataCentersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DataCentersService.connection.URL(), p.DataCentersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DataCentersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DataCentersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DataCentersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DataCentersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DataCentersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDataCenterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DataCentersServiceListResponse{dataCenters: result}, nil
}

func (p *DataCentersServiceListRequest) MustSend() *DataCentersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists the data centers.
// The following request retrieves a representation of the data centers:
// [source]
// ----
// GET /ovirt-engine/api/datacenters
// ----
// The above request performed with `curl`:
// [source,bash]
// ----
// curl \
// --request GET \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --header "Version: 4" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// https://myengine.example.com/ovirt-engine/api/datacenters
// ----
// This is what an example response could look like:
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//     </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
// </data_center>
// ----
// Note the `id` code of your `Default` data center. This code identifies this data center in relation to other
// resources of your virtual environment.
// The data center also contains a link to the storage domains collection. The data center uses this collection to
// attach storage domains from the storage domains main collection.
// The order of the returned list of data centers is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type DataCentersServiceListResponse struct {
	dataCenters *DataCenterSlice
}

func (p *DataCentersServiceListResponse) DataCenters() (*DataCenterSlice, bool) {
	if p.dataCenters != nil {
		return p.dataCenters, true
	}
	return nil, false
}

func (p *DataCentersServiceListResponse) MustDataCenters() *DataCenterSlice {
	if p.dataCenters == nil {
		panic("dataCenters in response does not exist")
	}
	return p.dataCenters
}

//
// Lists the data centers.
// The following request retrieves a representation of the data centers:
// [source]
// ----
// GET /ovirt-engine/api/datacenters
// ----
// The above request performed with `curl`:
// [source,bash]
// ----
// curl \
// --request GET \
// --cacert /etc/pki/ovirt-engine/ca.pem \
// --header "Version: 4" \
// --header "Accept: application/xml" \
// --user "admin@internal:mypassword" \
// https://myengine.example.com/ovirt-engine/api/datacenters
// ----
// This is what an example response could look like:
// [source,xml]
// ----
// <data_center href="/ovirt-engine/api/datacenters/123" id="123">
//   <name>Default</name>
//   <description>The default Data Center</description>
//   <link href="/ovirt-engine/api/datacenters/123/networks" rel="networks"/>
//   <link href="/ovirt-engine/api/datacenters/123/storagedomains" rel="storagedomains"/>
//   <link href="/ovirt-engine/api/datacenters/123/permissions" rel="permissions"/>
//   <link href="/ovirt-engine/api/datacenters/123/clusters" rel="clusters"/>
//   <link href="/ovirt-engine/api/datacenters/123/qoss" rel="qoss"/>
//   <link href="/ovirt-engine/api/datacenters/123/iscsibonds" rel="iscsibonds"/>
//   <link href="/ovirt-engine/api/datacenters/123/quotas" rel="quotas"/>
//   <local>false</local>
//   <quota_mode>disabled</quota_mode>
//   <status>up</status>
//   <supported_versions>
//     <version>
//       <major>4</major>
//       <minor>0</minor>
//     </version>
//   </supported_versions>
//   <version>
//     <major>4</major>
//     <minor>0</minor>
//   </version>
// </data_center>
// ----
// Note the `id` code of your `Default` data center. This code identifies this data center in relation to other
// resources of your virtual environment.
// The data center also contains a link to the storage domains collection. The data center uses this collection to
// attach storage domains from the storage domains main collection.
// The order of the returned list of data centers is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *DataCentersService) List() *DataCentersServiceListRequest {
	return &DataCentersServiceListRequest{DataCentersService: p}
}

//
// Reference to the service that manages a specific data center.
//
func (op *DataCentersService) DataCenterService(id string) *DataCenterService {
	return NewDataCenterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DataCentersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DataCenterService(path), nil
	}
	return op.DataCenterService(path[:index]).Service(path[index+1:])
}

func (op *DataCentersService) String() string {
	return fmt.Sprintf("DataCentersService:%s", op.path)
}

//
// Represents a feature enabled for the cluster.
//
type ClusterEnabledFeatureService struct {
	BaseService
}

func NewClusterEnabledFeatureService(connection *Connection, path string) *ClusterEnabledFeatureService {
	var result ClusterEnabledFeatureService
	result.connection = connection
	result.path = path
	return &result
}

//
// Provides the information about the cluster feature enabled.
// For example, to find details of the enabled feature `456` for cluster `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
type ClusterEnabledFeatureServiceGetRequest struct {
	ClusterEnabledFeatureService *ClusterEnabledFeatureService
	header                       map[string]string
	query                        map[string]string
	follow                       *string
}

func (p *ClusterEnabledFeatureServiceGetRequest) Header(key, value string) *ClusterEnabledFeatureServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterEnabledFeatureServiceGetRequest) Query(key, value string) *ClusterEnabledFeatureServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterEnabledFeatureServiceGetRequest) Follow(follow string) *ClusterEnabledFeatureServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ClusterEnabledFeatureServiceGetRequest) Send() (*ClusterEnabledFeatureServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterEnabledFeatureService.connection.URL(), p.ClusterEnabledFeatureService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterEnabledFeatureService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterEnabledFeatureService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterEnabledFeatureService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterEnabledFeatureService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterEnabledFeatureService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterFeatureReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterEnabledFeatureServiceGetResponse{feature: result}, nil
}

func (p *ClusterEnabledFeatureServiceGetRequest) MustSend() *ClusterEnabledFeatureServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Provides the information about the cluster feature enabled.
// For example, to find details of the enabled feature `456` for cluster `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
type ClusterEnabledFeatureServiceGetResponse struct {
	feature *ClusterFeature
}

func (p *ClusterEnabledFeatureServiceGetResponse) Feature() (*ClusterFeature, bool) {
	if p.feature != nil {
		return p.feature, true
	}
	return nil, false
}

func (p *ClusterEnabledFeatureServiceGetResponse) MustFeature() *ClusterFeature {
	if p.feature == nil {
		panic("feature in response does not exist")
	}
	return p.feature
}

//
// Provides the information about the cluster feature enabled.
// For example, to find details of the enabled feature `456` for cluster `123`, send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
// That will return a <<types/cluster_feature, ClusterFeature>> object containing the name:
// [source,xml]
// ----
// <cluster_feature id="456">
//   <name>libgfapi_supported</name>
// </cluster_feature>
// ----
//
func (p *ClusterEnabledFeatureService) Get() *ClusterEnabledFeatureServiceGetRequest {
	return &ClusterEnabledFeatureServiceGetRequest{ClusterEnabledFeatureService: p}
}

//
// Disables a cluster feature.
// For example, to disable the feature `456` of cluster `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
//
type ClusterEnabledFeatureServiceRemoveRequest struct {
	ClusterEnabledFeatureService *ClusterEnabledFeatureService
	header                       map[string]string
	query                        map[string]string
}

func (p *ClusterEnabledFeatureServiceRemoveRequest) Header(key, value string) *ClusterEnabledFeatureServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterEnabledFeatureServiceRemoveRequest) Query(key, value string) *ClusterEnabledFeatureServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterEnabledFeatureServiceRemoveRequest) Send() (*ClusterEnabledFeatureServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterEnabledFeatureService.connection.URL(), p.ClusterEnabledFeatureService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterEnabledFeatureService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterEnabledFeatureService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterEnabledFeatureService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterEnabledFeatureService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterEnabledFeatureService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(ClusterEnabledFeatureServiceRemoveResponse), nil
}

func (p *ClusterEnabledFeatureServiceRemoveRequest) MustSend() *ClusterEnabledFeatureServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Disables a cluster feature.
// For example, to disable the feature `456` of cluster `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
//
type ClusterEnabledFeatureServiceRemoveResponse struct {
}

//
// Disables a cluster feature.
// For example, to disable the feature `456` of cluster `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/clusters/123/enabledfeatures/456
// ----
//
func (p *ClusterEnabledFeatureService) Remove() *ClusterEnabledFeatureServiceRemoveRequest {
	return &ClusterEnabledFeatureServiceRemoveRequest{ClusterEnabledFeatureService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterEnabledFeatureService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterEnabledFeatureService) String() string {
	return fmt.Sprintf("ClusterEnabledFeatureService:%s", op.path)
}

//
// Provides information about the capabilities of different cluster levels supported by the engine. Version 4.0 of the
// engine supports levels 4.0 and 3.6. Each of these levels support different sets of CPU types, for example. This
// service provides that information.
//
type ClusterLevelsService struct {
	BaseService
}

func NewClusterLevelsService(connection *Connection, path string) *ClusterLevelsService {
	var result ClusterLevelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Lists the cluster levels supported by the system.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels
// ----
// This will return a list of available cluster levels.
// [source,xml]
// ----
// <cluster_levels>
//   <cluster_level id="4.0">
//      ...
//   </cluster_level>
//   ...
// </cluster_levels>
// ----
// The order of the returned cluster levels isn't guaranteed.
//
type ClusterLevelsServiceListRequest struct {
	ClusterLevelsService *ClusterLevelsService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *ClusterLevelsServiceListRequest) Header(key, value string) *ClusterLevelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterLevelsServiceListRequest) Query(key, value string) *ClusterLevelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterLevelsServiceListRequest) Follow(follow string) *ClusterLevelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ClusterLevelsServiceListRequest) Send() (*ClusterLevelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterLevelsService.connection.URL(), p.ClusterLevelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterLevelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterLevelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterLevelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterLevelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterLevelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterLevelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ClusterLevelsServiceListResponse{levels: result}, nil
}

func (p *ClusterLevelsServiceListRequest) MustSend() *ClusterLevelsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists the cluster levels supported by the system.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels
// ----
// This will return a list of available cluster levels.
// [source,xml]
// ----
// <cluster_levels>
//   <cluster_level id="4.0">
//      ...
//   </cluster_level>
//   ...
// </cluster_levels>
// ----
// The order of the returned cluster levels isn't guaranteed.
//
type ClusterLevelsServiceListResponse struct {
	levels *ClusterLevelSlice
}

func (p *ClusterLevelsServiceListResponse) Levels() (*ClusterLevelSlice, bool) {
	if p.levels != nil {
		return p.levels, true
	}
	return nil, false
}

func (p *ClusterLevelsServiceListResponse) MustLevels() *ClusterLevelSlice {
	if p.levels == nil {
		panic("levels in response does not exist")
	}
	return p.levels
}

//
// Lists the cluster levels supported by the system.
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels
// ----
// This will return a list of available cluster levels.
// [source,xml]
// ----
// <cluster_levels>
//   <cluster_level id="4.0">
//      ...
//   </cluster_level>
//   ...
// </cluster_levels>
// ----
// The order of the returned cluster levels isn't guaranteed.
//
func (p *ClusterLevelsService) List() *ClusterLevelsServiceListRequest {
	return &ClusterLevelsServiceListRequest{ClusterLevelsService: p}
}

//
// Reference to the service that provides information about an specific cluster level.
//
func (op *ClusterLevelsService) LevelService(id string) *ClusterLevelService {
	return NewClusterLevelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterLevelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LevelService(path), nil
	}
	return op.LevelService(path[:index]).Service(path[index+1:])
}

func (op *ClusterLevelsService) String() string {
	return fmt.Sprintf("ClusterLevelsService:%s", op.path)
}

//
// Manages the set of NICs of an snapshot.
//
type SnapshotNicsService struct {
	BaseService
}

func NewSnapshotNicsService(connection *Connection, path string) *SnapshotNicsService {
	var result SnapshotNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of NICs of the snapshot.
// The order of the returned list of NICs isn't guaranteed.
//
type SnapshotNicsServiceListRequest struct {
	SnapshotNicsService *SnapshotNicsService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *SnapshotNicsServiceListRequest) Header(key, value string) *SnapshotNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotNicsServiceListRequest) Query(key, value string) *SnapshotNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotNicsServiceListRequest) Follow(follow string) *SnapshotNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *SnapshotNicsServiceListRequest) Max(max int64) *SnapshotNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *SnapshotNicsServiceListRequest) Send() (*SnapshotNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotNicsService.connection.URL(), p.SnapshotNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotNicsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotNicsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotNicsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotNicsServiceListResponse{nics: result}, nil
}

func (p *SnapshotNicsServiceListRequest) MustSend() *SnapshotNicsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of NICs of the snapshot.
// The order of the returned list of NICs isn't guaranteed.
//
type SnapshotNicsServiceListResponse struct {
	nics *NicSlice
}

func (p *SnapshotNicsServiceListResponse) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *SnapshotNicsServiceListResponse) MustNics() *NicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Returns the list of NICs of the snapshot.
// The order of the returned list of NICs isn't guaranteed.
//
func (p *SnapshotNicsService) List() *SnapshotNicsServiceListRequest {
	return &SnapshotNicsServiceListRequest{SnapshotNicsService: p}
}

//
//
func (op *SnapshotNicsService) NicService(id string) *SnapshotNicService {
	return NewSnapshotNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *SnapshotNicsService) String() string {
	return fmt.Sprintf("SnapshotNicsService:%s", op.path)
}

//
//
type IscsiBondService struct {
	BaseService
}

func NewIscsiBondService(connection *Connection, path string) *IscsiBondService {
	var result IscsiBondService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type IscsiBondServiceGetRequest struct {
	IscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
	follow           *string
}

func (p *IscsiBondServiceGetRequest) Header(key, value string) *IscsiBondServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceGetRequest) Query(key, value string) *IscsiBondServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceGetRequest) Follow(follow string) *IscsiBondServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *IscsiBondServiceGetRequest) Send() (*IscsiBondServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.IscsiBondService.connection.URL(), p.IscsiBondService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.IscsiBondService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.IscsiBondService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.IscsiBondService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.IscsiBondService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.IscsiBondService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &IscsiBondServiceGetResponse{bond: result}, nil
}

func (p *IscsiBondServiceGetRequest) MustSend() *IscsiBondServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type IscsiBondServiceGetResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondServiceGetResponse) Bond() (*IscsiBond, bool) {
	if p.bond != nil {
		return p.bond, true
	}
	return nil, false
}

func (p *IscsiBondServiceGetResponse) MustBond() *IscsiBond {
	if p.bond == nil {
		panic("bond in response does not exist")
	}
	return p.bond
}

//
//
func (p *IscsiBondService) Get() *IscsiBondServiceGetRequest {
	return &IscsiBondServiceGetRequest{IscsiBondService: p}
}

//
// Removes of an existing iSCSI bond.
// For example, to remove the iSCSI bond `456` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/iscsibonds/456
// ----
//
type IscsiBondServiceRemoveRequest struct {
	IscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
	async            *bool
}

func (p *IscsiBondServiceRemoveRequest) Header(key, value string) *IscsiBondServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceRemoveRequest) Query(key, value string) *IscsiBondServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceRemoveRequest) Async(async bool) *IscsiBondServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *IscsiBondServiceRemoveRequest) Send() (*IscsiBondServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.IscsiBondService.connection.URL(), p.IscsiBondService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.IscsiBondService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.IscsiBondService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.IscsiBondService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.IscsiBondService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.IscsiBondService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(IscsiBondServiceRemoveResponse), nil
}

func (p *IscsiBondServiceRemoveRequest) MustSend() *IscsiBondServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes of an existing iSCSI bond.
// For example, to remove the iSCSI bond `456` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/iscsibonds/456
// ----
//
type IscsiBondServiceRemoveResponse struct {
}

//
// Removes of an existing iSCSI bond.
// For example, to remove the iSCSI bond `456` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/datacenters/123/iscsibonds/456
// ----
//
func (p *IscsiBondService) Remove() *IscsiBondServiceRemoveRequest {
	return &IscsiBondServiceRemoveRequest{IscsiBondService: p}
}

//
// Updates an iSCSI bond.
// Updating of an iSCSI bond can be done on the `name` and the `description` attributes only. For example, to
// update the iSCSI bond `456` of data center `123`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/iscsibonds/1234
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//    <name>mybond</name>
//    <description>My iSCSI bond</description>
// </iscsi_bond>
// ----
//
type IscsiBondServiceUpdateRequest struct {
	IscsiBondService *IscsiBondService
	header           map[string]string
	query            map[string]string
	async            *bool
	bond             *IscsiBond
}

func (p *IscsiBondServiceUpdateRequest) Header(key, value string) *IscsiBondServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondServiceUpdateRequest) Query(key, value string) *IscsiBondServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondServiceUpdateRequest) Async(async bool) *IscsiBondServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *IscsiBondServiceUpdateRequest) Bond(bond *IscsiBond) *IscsiBondServiceUpdateRequest {
	p.bond = bond
	return p
}

func (p *IscsiBondServiceUpdateRequest) Send() (*IscsiBondServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.IscsiBondService.connection.URL(), p.IscsiBondService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLIscsiBondWriteOne(writer, p.bond, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.IscsiBondService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.IscsiBondService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.IscsiBondService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.IscsiBondService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.IscsiBondService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &IscsiBondServiceUpdateResponse{bond: result}, nil
}

func (p *IscsiBondServiceUpdateRequest) MustSend() *IscsiBondServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates an iSCSI bond.
// Updating of an iSCSI bond can be done on the `name` and the `description` attributes only. For example, to
// update the iSCSI bond `456` of data center `123`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/iscsibonds/1234
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//    <name>mybond</name>
//    <description>My iSCSI bond</description>
// </iscsi_bond>
// ----
//
type IscsiBondServiceUpdateResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondServiceUpdateResponse) Bond() (*IscsiBond, bool) {
	if p.bond != nil {
		return p.bond, true
	}
	return nil, false
}

func (p *IscsiBondServiceUpdateResponse) MustBond() *IscsiBond {
	if p.bond == nil {
		panic("bond in response does not exist")
	}
	return p.bond
}

//
// Updates an iSCSI bond.
// Updating of an iSCSI bond can be done on the `name` and the `description` attributes only. For example, to
// update the iSCSI bond `456` of data center `123`, send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/datacenters/123/iscsibonds/1234
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//    <name>mybond</name>
//    <description>My iSCSI bond</description>
// </iscsi_bond>
// ----
//
func (p *IscsiBondService) Update() *IscsiBondServiceUpdateRequest {
	return &IscsiBondServiceUpdateRequest{IscsiBondService: p}
}

//
//
func (op *IscsiBondService) NetworksService() *NetworksService {
	return NewNetworksService(op.connection, fmt.Sprintf("%s/networks", op.path))
}

//
//
func (op *IscsiBondService) StorageServerConnectionsService() *StorageServerConnectionsService {
	return NewStorageServerConnectionsService(op.connection, fmt.Sprintf("%s/storageserverconnections", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IscsiBondService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "networks" {
		return op.NetworksService(), nil
	}
	if strings.HasPrefix(path, "networks/") {
		return op.NetworksService().Service(path[9:])
	}
	if path == "storageserverconnections" {
		return op.StorageServerConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageserverconnections/") {
		return op.StorageServerConnectionsService().Service(path[25:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *IscsiBondService) String() string {
	return fmt.Sprintf("IscsiBondService:%s", op.path)
}

//
//
type AssignedCpuProfileService struct {
	BaseService
}

func NewAssignedCpuProfileService(connection *Connection, path string) *AssignedCpuProfileService {
	var result AssignedCpuProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type AssignedCpuProfileServiceGetRequest struct {
	AssignedCpuProfileService *AssignedCpuProfileService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
}

func (p *AssignedCpuProfileServiceGetRequest) Header(key, value string) *AssignedCpuProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfileServiceGetRequest) Query(key, value string) *AssignedCpuProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfileServiceGetRequest) Follow(follow string) *AssignedCpuProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AssignedCpuProfileServiceGetRequest) Send() (*AssignedCpuProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedCpuProfileService.connection.URL(), p.AssignedCpuProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedCpuProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedCpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedCpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedCpuProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedCpuProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedCpuProfileServiceGetResponse{profile: result}, nil
}

func (p *AssignedCpuProfileServiceGetRequest) MustSend() *AssignedCpuProfileServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type AssignedCpuProfileServiceGetResponse struct {
	profile *CpuProfile
}

func (p *AssignedCpuProfileServiceGetResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *AssignedCpuProfileServiceGetResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
//
func (p *AssignedCpuProfileService) Get() *AssignedCpuProfileServiceGetRequest {
	return &AssignedCpuProfileServiceGetRequest{AssignedCpuProfileService: p}
}

//
//
type AssignedCpuProfileServiceRemoveRequest struct {
	AssignedCpuProfileService *AssignedCpuProfileService
	header                    map[string]string
	query                     map[string]string
	async                     *bool
}

func (p *AssignedCpuProfileServiceRemoveRequest) Header(key, value string) *AssignedCpuProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfileServiceRemoveRequest) Query(key, value string) *AssignedCpuProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfileServiceRemoveRequest) Async(async bool) *AssignedCpuProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AssignedCpuProfileServiceRemoveRequest) Send() (*AssignedCpuProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedCpuProfileService.connection.URL(), p.AssignedCpuProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedCpuProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedCpuProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedCpuProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedCpuProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedCpuProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedCpuProfileServiceRemoveResponse), nil
}

func (p *AssignedCpuProfileServiceRemoveRequest) MustSend() *AssignedCpuProfileServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type AssignedCpuProfileServiceRemoveResponse struct {
}

//
//
func (p *AssignedCpuProfileService) Remove() *AssignedCpuProfileServiceRemoveRequest {
	return &AssignedCpuProfileServiceRemoveRequest{AssignedCpuProfileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedCpuProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedCpuProfileService) String() string {
	return fmt.Sprintf("AssignedCpuProfileService:%s", op.path)
}

//
// A service to manage assignment of specific tag to specific entities in system.
//
type AssignedTagService struct {
	BaseService
}

func NewAssignedTagService(connection *Connection, path string) *AssignedTagService {
	var result AssignedTagService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the information about the assigned tag.
// For example to retrieve the information about the tag with the id `456` which is assigned to virtual machine
// with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags/456
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/456" id="456">
//   <name>root</name>
//   <description>root</description>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </tag>
// ----
//
type AssignedTagServiceGetRequest struct {
	AssignedTagService *AssignedTagService
	header             map[string]string
	query              map[string]string
	follow             *string
}

func (p *AssignedTagServiceGetRequest) Header(key, value string) *AssignedTagServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagServiceGetRequest) Query(key, value string) *AssignedTagServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagServiceGetRequest) Follow(follow string) *AssignedTagServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AssignedTagServiceGetRequest) Send() (*AssignedTagServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedTagService.connection.URL(), p.AssignedTagService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedTagService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedTagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedTagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedTagService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedTagService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedTagServiceGetResponse{tag: result}, nil
}

func (p *AssignedTagServiceGetRequest) MustSend() *AssignedTagServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the information about the assigned tag.
// For example to retrieve the information about the tag with the id `456` which is assigned to virtual machine
// with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags/456
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/456" id="456">
//   <name>root</name>
//   <description>root</description>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </tag>
// ----
//
type AssignedTagServiceGetResponse struct {
	tag *Tag
}

func (p *AssignedTagServiceGetResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *AssignedTagServiceGetResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Gets the information about the assigned tag.
// For example to retrieve the information about the tag with the id `456` which is assigned to virtual machine
// with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags/456
// ....
// [source,xml]
// ----
// <tag href="/ovirt-engine/api/tags/456" id="456">
//   <name>root</name>
//   <description>root</description>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </tag>
// ----
//
func (p *AssignedTagService) Get() *AssignedTagServiceGetRequest {
	return &AssignedTagServiceGetRequest{AssignedTagService: p}
}

//
// Unassign tag from specific entity in the system.
// For example to unassign the tag with id `456` from virtual machine with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/vms/123/tags/456
// ....
//
type AssignedTagServiceRemoveRequest struct {
	AssignedTagService *AssignedTagService
	header             map[string]string
	query              map[string]string
	async              *bool
}

func (p *AssignedTagServiceRemoveRequest) Header(key, value string) *AssignedTagServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagServiceRemoveRequest) Query(key, value string) *AssignedTagServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagServiceRemoveRequest) Async(async bool) *AssignedTagServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AssignedTagServiceRemoveRequest) Send() (*AssignedTagServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedTagService.connection.URL(), p.AssignedTagService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedTagService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedTagService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedTagService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedTagService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedTagService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedTagServiceRemoveResponse), nil
}

func (p *AssignedTagServiceRemoveRequest) MustSend() *AssignedTagServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Unassign tag from specific entity in the system.
// For example to unassign the tag with id `456` from virtual machine with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/vms/123/tags/456
// ....
//
type AssignedTagServiceRemoveResponse struct {
}

//
// Unassign tag from specific entity in the system.
// For example to unassign the tag with id `456` from virtual machine with id `123` send a request like this:
// ....
// DELETE /ovirt-engine/api/vms/123/tags/456
// ....
//
func (p *AssignedTagService) Remove() *AssignedTagServiceRemoveRequest {
	return &AssignedTagServiceRemoveRequest{AssignedTagService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedTagService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedTagService) String() string {
	return fmt.Sprintf("AssignedTagService:%s", op.path)
}

//
// This service manages a parameter for a network filter.
//
type NicNetworkFilterParameterService struct {
	BaseService
}

func NewNicNetworkFilterParameterService(connection *Connection, path string) *NicNetworkFilterParameterService {
	var result NicNetworkFilterParameterService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a representation of the network filter parameter.
//
type NicNetworkFilterParameterServiceGetRequest struct {
	NicNetworkFilterParameterService *NicNetworkFilterParameterService
	header                           map[string]string
	query                            map[string]string
	follow                           *string
}

func (p *NicNetworkFilterParameterServiceGetRequest) Header(key, value string) *NicNetworkFilterParameterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NicNetworkFilterParameterServiceGetRequest) Query(key, value string) *NicNetworkFilterParameterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NicNetworkFilterParameterServiceGetRequest) Follow(follow string) *NicNetworkFilterParameterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *NicNetworkFilterParameterServiceGetRequest) Send() (*NicNetworkFilterParameterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NicNetworkFilterParameterService.connection.URL(), p.NicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NicNetworkFilterParameterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NicNetworkFilterParameterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NicNetworkFilterParameterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NicNetworkFilterParameterServiceGetResponse{parameter: result}, nil
}

func (p *NicNetworkFilterParameterServiceGetRequest) MustSend() *NicNetworkFilterParameterServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves a representation of the network filter parameter.
//
type NicNetworkFilterParameterServiceGetResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NicNetworkFilterParameterServiceGetResponse) Parameter() (*NetworkFilterParameter, bool) {
	if p.parameter != nil {
		return p.parameter, true
	}
	return nil, false
}

func (p *NicNetworkFilterParameterServiceGetResponse) MustParameter() *NetworkFilterParameter {
	if p.parameter == nil {
		panic("parameter in response does not exist")
	}
	return p.parameter
}

//
// Retrieves a representation of the network filter parameter.
//
func (p *NicNetworkFilterParameterService) Get() *NicNetworkFilterParameterServiceGetRequest {
	return &NicNetworkFilterParameterServiceGetRequest{NicNetworkFilterParameterService: p}
}

//
// Removes the filter parameter.
// For example, to remove the filter parameter with id `123` on NIC `456` of virtual machine `789`
// send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
//
type NicNetworkFilterParameterServiceRemoveRequest struct {
	NicNetworkFilterParameterService *NicNetworkFilterParameterService
	header                           map[string]string
	query                            map[string]string
}

func (p *NicNetworkFilterParameterServiceRemoveRequest) Header(key, value string) *NicNetworkFilterParameterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NicNetworkFilterParameterServiceRemoveRequest) Query(key, value string) *NicNetworkFilterParameterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NicNetworkFilterParameterServiceRemoveRequest) Send() (*NicNetworkFilterParameterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NicNetworkFilterParameterService.connection.URL(), p.NicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NicNetworkFilterParameterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NicNetworkFilterParameterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NicNetworkFilterParameterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(NicNetworkFilterParameterServiceRemoveResponse), nil
}

func (p *NicNetworkFilterParameterServiceRemoveRequest) MustSend() *NicNetworkFilterParameterServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the filter parameter.
// For example, to remove the filter parameter with id `123` on NIC `456` of virtual machine `789`
// send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
//
type NicNetworkFilterParameterServiceRemoveResponse struct {
}

//
// Removes the filter parameter.
// For example, to remove the filter parameter with id `123` on NIC `456` of virtual machine `789`
// send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
//
func (p *NicNetworkFilterParameterService) Remove() *NicNetworkFilterParameterServiceRemoveRequest {
	return &NicNetworkFilterParameterServiceRemoveRequest{NicNetworkFilterParameterService: p}
}

//
// Updates the network filter parameter.
// For example, to update the network filter parameter having with with id `123` on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>updatedName</name>
//   <value>updatedValue</value>
// </network_filter_parameter>
// ----
//
type NicNetworkFilterParameterServiceUpdateRequest struct {
	NicNetworkFilterParameterService *NicNetworkFilterParameterService
	header                           map[string]string
	query                            map[string]string
	parameter                        *NetworkFilterParameter
}

func (p *NicNetworkFilterParameterServiceUpdateRequest) Header(key, value string) *NicNetworkFilterParameterServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NicNetworkFilterParameterServiceUpdateRequest) Query(key, value string) *NicNetworkFilterParameterServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NicNetworkFilterParameterServiceUpdateRequest) Parameter(parameter *NetworkFilterParameter) *NicNetworkFilterParameterServiceUpdateRequest {
	p.parameter = parameter
	return p
}

func (p *NicNetworkFilterParameterServiceUpdateRequest) Send() (*NicNetworkFilterParameterServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NicNetworkFilterParameterService.connection.URL(), p.NicNetworkFilterParameterService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkFilterParameterWriteOne(writer, p.parameter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NicNetworkFilterParameterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NicNetworkFilterParameterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NicNetworkFilterParameterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NicNetworkFilterParameterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NicNetworkFilterParameterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkFilterParameterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NicNetworkFilterParameterServiceUpdateResponse{parameter: result}, nil
}

func (p *NicNetworkFilterParameterServiceUpdateRequest) MustSend() *NicNetworkFilterParameterServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the network filter parameter.
// For example, to update the network filter parameter having with with id `123` on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>updatedName</name>
//   <value>updatedValue</value>
// </network_filter_parameter>
// ----
//
type NicNetworkFilterParameterServiceUpdateResponse struct {
	parameter *NetworkFilterParameter
}

func (p *NicNetworkFilterParameterServiceUpdateResponse) Parameter() (*NetworkFilterParameter, bool) {
	if p.parameter != nil {
		return p.parameter, true
	}
	return nil, false
}

func (p *NicNetworkFilterParameterServiceUpdateResponse) MustParameter() *NetworkFilterParameter {
	if p.parameter == nil {
		panic("parameter in response does not exist")
	}
	return p.parameter
}

//
// Updates the network filter parameter.
// For example, to update the network filter parameter having with with id `123` on NIC `456` of
// virtual machine `789` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/789/nics/456/networkfilterparameters/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <network_filter_parameter>
//   <name>updatedName</name>
//   <value>updatedValue</value>
// </network_filter_parameter>
// ----
//
func (p *NicNetworkFilterParameterService) Update() *NicNetworkFilterParameterServiceUpdateRequest {
	return &NicNetworkFilterParameterServiceUpdateRequest{NicNetworkFilterParameterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NicNetworkFilterParameterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *NicNetworkFilterParameterService) String() string {
	return fmt.Sprintf("NicNetworkFilterParameterService:%s", op.path)
}

//
// Manages the affinity labels available in the system.
//
type AffinityLabelsService struct {
	BaseService
}

func NewAffinityLabelsService(connection *Connection, path string) *AffinityLabelsService {
	var result AffinityLabelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new label. The label is automatically attached
// to all entities mentioned in the vms or hosts lists.
//
type AffinityLabelsServiceAddRequest struct {
	AffinityLabelsService *AffinityLabelsService
	header                map[string]string
	query                 map[string]string
	label                 *AffinityLabel
}

func (p *AffinityLabelsServiceAddRequest) Header(key, value string) *AffinityLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelsServiceAddRequest) Query(key, value string) *AffinityLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelsServiceAddRequest) Label(label *AffinityLabel) *AffinityLabelsServiceAddRequest {
	p.label = label
	return p
}

func (p *AffinityLabelsServiceAddRequest) Send() (*AffinityLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelsService.connection.URL(), p.AffinityLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityLabelsServiceAddResponse{label: result}, nil
}

func (p *AffinityLabelsServiceAddRequest) MustSend() *AffinityLabelsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new label. The label is automatically attached
// to all entities mentioned in the vms or hosts lists.
//
type AffinityLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *AffinityLabelsServiceAddResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *AffinityLabelsServiceAddResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Creates a new label. The label is automatically attached
// to all entities mentioned in the vms or hosts lists.
//
func (p *AffinityLabelsService) Add() *AffinityLabelsServiceAddRequest {
	return &AffinityLabelsServiceAddRequest{AffinityLabelsService: p}
}

//
// Lists all labels present in the system.
// The order of the returned labels isn't guaranteed.
//
type AffinityLabelsServiceListRequest struct {
	AffinityLabelsService *AffinityLabelsService
	header                map[string]string
	query                 map[string]string
	follow                *string
	max                   *int64
}

func (p *AffinityLabelsServiceListRequest) Header(key, value string) *AffinityLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelsServiceListRequest) Query(key, value string) *AffinityLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelsServiceListRequest) Follow(follow string) *AffinityLabelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AffinityLabelsServiceListRequest) Max(max int64) *AffinityLabelsServiceListRequest {
	p.max = &max
	return p
}

func (p *AffinityLabelsServiceListRequest) Send() (*AffinityLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelsService.connection.URL(), p.AffinityLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AffinityLabelsServiceListResponse{labels: result}, nil
}

func (p *AffinityLabelsServiceListRequest) MustSend() *AffinityLabelsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all labels present in the system.
// The order of the returned labels isn't guaranteed.
//
type AffinityLabelsServiceListResponse struct {
	labels *AffinityLabelSlice
}

func (p *AffinityLabelsServiceListResponse) Labels() (*AffinityLabelSlice, bool) {
	if p.labels != nil {
		return p.labels, true
	}
	return nil, false
}

func (p *AffinityLabelsServiceListResponse) MustLabels() *AffinityLabelSlice {
	if p.labels == nil {
		panic("labels in response does not exist")
	}
	return p.labels
}

//
// Lists all labels present in the system.
// The order of the returned labels isn't guaranteed.
//
func (p *AffinityLabelsService) List() *AffinityLabelsServiceListRequest {
	return &AffinityLabelsServiceListRequest{AffinityLabelsService: p}
}

//
// Link to a single label details.
//
func (op *AffinityLabelsService) LabelService(id string) *AffinityLabelService {
	return NewAffinityLabelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LabelService(path), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelsService) String() string {
	return fmt.Sprintf("AffinityLabelsService:%s", op.path)
}

//
// Manages a single disk available in a storage domain.
// IMPORTANT: Since version 4.2 of the engine this service is intended only to list disks available in the storage
// domain, and to register unregistered disks. All the other operations, like copying a disk, moving a disk, etc, have
// been deprecated and will be removed in the future. To perform those operations use the <<services/disks, service
// that manages all the disks of the system>>, or the <<services/disk, service that manages an specific disk>>.
//
type StorageDomainDiskService struct {
	BaseService
}

func NewStorageDomainDiskService(connection *Connection, path string) *StorageDomainDiskService {
	var result StorageDomainDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceCopyRequest struct {
	StorageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	disk                     *Disk
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceCopyRequest) Header(key, value string) *StorageDomainDiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceCopyRequest) Query(key, value string) *StorageDomainDiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceCopyRequest) Disk(disk *Disk) *StorageDomainDiskServiceCopyRequest {
	p.disk = disk
	return p
}

func (p *StorageDomainDiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainDiskServiceCopyRequest) Send() (*StorageDomainDiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.StorageDomainDiskService.connection.URL(), p.StorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Disk(p.disk)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceCopyResponse), nil
}

func (p *StorageDomainDiskServiceCopyRequest) MustSend() *StorageDomainDiskServiceCopyResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceCopyResponse struct {
}

//
// Copies a disk to the specified storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To copy a disk use the <<services/disk/methods/copy, copy>>
// operation of the service that manages that disk.
//
func (p *StorageDomainDiskService) Copy() *StorageDomainDiskServiceCopyRequest {
	return &StorageDomainDiskServiceCopyRequest{StorageDomainDiskService: p}
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceExportRequest struct {
	StorageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceExportRequest) Header(key, value string) *StorageDomainDiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceExportRequest) Query(key, value string) *StorageDomainDiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainDiskServiceExportRequest) Send() (*StorageDomainDiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.StorageDomainDiskService.connection.URL(), p.StorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceExportResponse), nil
}

func (p *StorageDomainDiskServiceExportRequest) MustSend() *StorageDomainDiskServiceExportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To export a disk use the <<services/disk/methods/export, export>>
// operation of the service that manages that disk.
//
func (p *StorageDomainDiskService) Export() *StorageDomainDiskServiceExportRequest {
	return &StorageDomainDiskServiceExportRequest{StorageDomainDiskService: p}
}

//
// Retrieves the description of the disk.
//
type StorageDomainDiskServiceGetRequest struct {
	StorageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
}

func (p *StorageDomainDiskServiceGetRequest) Header(key, value string) *StorageDomainDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceGetRequest) Query(key, value string) *StorageDomainDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceGetRequest) Follow(follow string) *StorageDomainDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainDiskServiceGetRequest) Send() (*StorageDomainDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainDiskService.connection.URL(), p.StorageDomainDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainDiskServiceGetResponse{disk: result}, nil
}

func (p *StorageDomainDiskServiceGetRequest) MustSend() *StorageDomainDiskServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the description of the disk.
//
type StorageDomainDiskServiceGetResponse struct {
	disk *Disk
}

func (p *StorageDomainDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *StorageDomainDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (p *StorageDomainDiskService) Get() *StorageDomainDiskServiceGetRequest {
	return &StorageDomainDiskServiceGetRequest{StorageDomainDiskService: p}
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceMoveRequest struct {
	StorageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
	filter                   *bool
	storageDomain            *StorageDomain
}

func (p *StorageDomainDiskServiceMoveRequest) Header(key, value string) *StorageDomainDiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) Query(key, value string) *StorageDomainDiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) Async(async bool) *StorageDomainDiskServiceMoveRequest {
	p.async = &async
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) Filter(filter bool) *StorageDomainDiskServiceMoveRequest {
	p.filter = &filter
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainDiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainDiskServiceMoveRequest) Send() (*StorageDomainDiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.StorageDomainDiskService.connection.URL(), p.StorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceMoveResponse), nil
}

func (p *StorageDomainDiskServiceMoveRequest) MustSend() *StorageDomainDiskServiceMoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To move a disk use the <<services/disk/methods/move, move>>
// operation of the service that manages that disk.
//
func (p *StorageDomainDiskService) Move() *StorageDomainDiskServiceMoveRequest {
	return &StorageDomainDiskServiceMoveRequest{StorageDomainDiskService: p}
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
type StorageDomainDiskServiceReduceRequest struct {
	StorageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *StorageDomainDiskServiceReduceRequest) Header(key, value string) *StorageDomainDiskServiceReduceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceReduceRequest) Query(key, value string) *StorageDomainDiskServiceReduceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceReduceRequest) Async(async bool) *StorageDomainDiskServiceReduceRequest {
	p.async = &async
	return p
}

func (p *StorageDomainDiskServiceReduceRequest) Send() (*StorageDomainDiskServiceReduceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reduce", p.StorageDomainDiskService.connection.URL(), p.StorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceReduceResponse), nil
}

func (p *StorageDomainDiskServiceReduceRequest) MustSend() *StorageDomainDiskServiceReduceResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
type StorageDomainDiskServiceReduceResponse struct {
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
func (p *StorageDomainDiskService) Reduce() *StorageDomainDiskServiceReduceRequest {
	return &StorageDomainDiskServiceReduceRequest{StorageDomainDiskService: p}
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceRemoveRequest struct {
	StorageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *StorageDomainDiskServiceRemoveRequest) Header(key, value string) *StorageDomainDiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceRemoveRequest) Query(key, value string) *StorageDomainDiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceRemoveRequest) Send() (*StorageDomainDiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainDiskService.connection.URL(), p.StorageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainDiskServiceRemoveResponse), nil
}

func (p *StorageDomainDiskServiceRemoveRequest) MustSend() *StorageDomainDiskServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceRemoveResponse struct {
}

//
// Removes a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (p *StorageDomainDiskService) Remove() *StorageDomainDiskServiceRemoveRequest {
	return &StorageDomainDiskServiceRemoveRequest{StorageDomainDiskService: p}
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceSparsifyRequest struct {
	StorageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
}

func (p *StorageDomainDiskServiceSparsifyRequest) Header(key, value string) *StorageDomainDiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceSparsifyRequest) Query(key, value string) *StorageDomainDiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceSparsifyRequest) Send() (*StorageDomainDiskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.StorageDomainDiskService.connection.URL(), p.StorageDomainDiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainDiskServiceSparsifyResponse), nil
}

func (p *StorageDomainDiskServiceSparsifyRequest) MustSend() *StorageDomainDiskServiceSparsifyResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
type StorageDomainDiskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To remove a disk use the <<services/disk/methods/remove, remove>>
// operation of the service that manages that disk.
//
func (p *StorageDomainDiskService) Sparsify() *StorageDomainDiskServiceSparsifyRequest {
	return &StorageDomainDiskServiceSparsifyRequest{StorageDomainDiskService: p}
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
type StorageDomainDiskServiceUpdateRequest struct {
	StorageDomainDiskService *StorageDomainDiskService
	header                   map[string]string
	query                    map[string]string
	disk                     *Disk
}

func (p *StorageDomainDiskServiceUpdateRequest) Header(key, value string) *StorageDomainDiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainDiskServiceUpdateRequest) Query(key, value string) *StorageDomainDiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainDiskServiceUpdateRequest) Disk(disk *Disk) *StorageDomainDiskServiceUpdateRequest {
	p.disk = disk
	return p
}

func (p *StorageDomainDiskServiceUpdateRequest) Send() (*StorageDomainDiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainDiskService.connection.URL(), p.StorageDomainDiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainDiskServiceUpdateResponse{disk: result}, nil
}

func (p *StorageDomainDiskServiceUpdateRequest) MustSend() *StorageDomainDiskServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
type StorageDomainDiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *StorageDomainDiskServiceUpdateResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *StorageDomainDiskServiceUpdateResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Updates the disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To update a disk use the
// <<services/disk/methods/update, update>> operation of the service that manages that disk.
//
func (p *StorageDomainDiskService) Update() *StorageDomainDiskServiceUpdateRequest {
	return &StorageDomainDiskServiceUpdateRequest{StorageDomainDiskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *StorageDomainDiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *StorageDomainDiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainDiskService) String() string {
	return fmt.Sprintf("StorageDomainDiskService:%s", op.path)
}

//
// This service manages a collection of all the virtual machines assigned to an affinity group.
//
type AffinityGroupVmsService struct {
	BaseService
}

func NewAffinityGroupVmsService(connection *Connection, path string) *AffinityGroupVmsService {
	var result AffinityGroupVmsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a virtual machine to the affinity group.
// For example, to add the virtual machine `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vms
// ....
// With the following body:
// [source,xml]
// ----
// <vm id="789"/>
// ----
//
type AffinityGroupVmsServiceAddRequest struct {
	AffinityGroupVmsService *AffinityGroupVmsService
	header                  map[string]string
	query                   map[string]string
	vm                      *Vm
}

func (p *AffinityGroupVmsServiceAddRequest) Header(key, value string) *AffinityGroupVmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmsServiceAddRequest) Query(key, value string) *AffinityGroupVmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmsServiceAddRequest) Vm(vm *Vm) *AffinityGroupVmsServiceAddRequest {
	p.vm = vm
	return p
}

func (p *AffinityGroupVmsServiceAddRequest) Send() (*AffinityGroupVmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupVmsService.connection.URL(), p.AffinityGroupVmsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupVmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupVmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupVmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityGroupVmsServiceAddResponse{vm: result}, nil
}

func (p *AffinityGroupVmsServiceAddRequest) MustSend() *AffinityGroupVmsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a virtual machine to the affinity group.
// For example, to add the virtual machine `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vms
// ....
// With the following body:
// [source,xml]
// ----
// <vm id="789"/>
// ----
//
type AffinityGroupVmsServiceAddResponse struct {
	vm *Vm
}

func (p *AffinityGroupVmsServiceAddResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *AffinityGroupVmsServiceAddResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Adds a virtual machine to the affinity group.
// For example, to add the virtual machine `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/vms
// ....
// With the following body:
// [source,xml]
// ----
// <vm id="789"/>
// ----
//
func (p *AffinityGroupVmsService) Add() *AffinityGroupVmsServiceAddRequest {
	return &AffinityGroupVmsServiceAddRequest{AffinityGroupVmsService: p}
}

//
// List all virtual machines assigned to this affinity group.
// The order of the returned virtual machines isn't guaranteed.
//
type AffinityGroupVmsServiceListRequest struct {
	AffinityGroupVmsService *AffinityGroupVmsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
}

func (p *AffinityGroupVmsServiceListRequest) Header(key, value string) *AffinityGroupVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmsServiceListRequest) Query(key, value string) *AffinityGroupVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmsServiceListRequest) Follow(follow string) *AffinityGroupVmsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AffinityGroupVmsServiceListRequest) Max(max int64) *AffinityGroupVmsServiceListRequest {
	p.max = &max
	return p
}

func (p *AffinityGroupVmsServiceListRequest) Send() (*AffinityGroupVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupVmsService.connection.URL(), p.AffinityGroupVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupVmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupVmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupVmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AffinityGroupVmsServiceListResponse{vms: result}, nil
}

func (p *AffinityGroupVmsServiceListRequest) MustSend() *AffinityGroupVmsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all virtual machines assigned to this affinity group.
// The order of the returned virtual machines isn't guaranteed.
//
type AffinityGroupVmsServiceListResponse struct {
	vms *VmSlice
}

func (p *AffinityGroupVmsServiceListResponse) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *AffinityGroupVmsServiceListResponse) MustVms() *VmSlice {
	if p.vms == nil {
		panic("vms in response does not exist")
	}
	return p.vms
}

//
// List all virtual machines assigned to this affinity group.
// The order of the returned virtual machines isn't guaranteed.
//
func (p *AffinityGroupVmsService) List() *AffinityGroupVmsServiceListRequest {
	return &AffinityGroupVmsServiceListRequest{AffinityGroupVmsService: p}
}

//
// Access the service that manages the virtual machine assignment to this affinity group.
//
func (op *AffinityGroupVmsService) VmService(id string) *AffinityGroupVmService {
	return NewAffinityGroupVmService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupVmsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VmService(path), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupVmsService) String() string {
	return fmt.Sprintf("AffinityGroupVmsService:%s", op.path)
}

//
// This service represents list of vms that have a specific
// label when accessed through the affinitylabels/vms
// subcollection.
//
type AffinityLabelVmsService struct {
	BaseService
}

func NewAffinityLabelVmsService(connection *Connection, path string) *AffinityLabelVmsService {
	var result AffinityLabelVmsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a label to a vm.
//
type AffinityLabelVmsServiceAddRequest struct {
	AffinityLabelVmsService *AffinityLabelVmsService
	header                  map[string]string
	query                   map[string]string
	vm                      *Vm
}

func (p *AffinityLabelVmsServiceAddRequest) Header(key, value string) *AffinityLabelVmsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmsServiceAddRequest) Query(key, value string) *AffinityLabelVmsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmsServiceAddRequest) Vm(vm *Vm) *AffinityLabelVmsServiceAddRequest {
	p.vm = vm
	return p
}

func (p *AffinityLabelVmsServiceAddRequest) Send() (*AffinityLabelVmsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelVmsService.connection.URL(), p.AffinityLabelVmsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelVmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelVmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelVmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityLabelVmsServiceAddResponse{vm: result}, nil
}

func (p *AffinityLabelVmsServiceAddRequest) MustSend() *AffinityLabelVmsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a label to a vm.
//
type AffinityLabelVmsServiceAddResponse struct {
	vm *Vm
}

func (p *AffinityLabelVmsServiceAddResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *AffinityLabelVmsServiceAddResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Add a label to a vm.
//
func (p *AffinityLabelVmsService) Add() *AffinityLabelVmsServiceAddRequest {
	return &AffinityLabelVmsServiceAddRequest{AffinityLabelVmsService: p}
}

//
// List all virtual machines with the label.
// The order of the returned virtual machines isn't guaranteed.
//
type AffinityLabelVmsServiceListRequest struct {
	AffinityLabelVmsService *AffinityLabelVmsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
}

func (p *AffinityLabelVmsServiceListRequest) Header(key, value string) *AffinityLabelVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityLabelVmsServiceListRequest) Query(key, value string) *AffinityLabelVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityLabelVmsServiceListRequest) Follow(follow string) *AffinityLabelVmsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AffinityLabelVmsServiceListRequest) Send() (*AffinityLabelVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityLabelVmsService.connection.URL(), p.AffinityLabelVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityLabelVmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityLabelVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityLabelVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityLabelVmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityLabelVmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AffinityLabelVmsServiceListResponse{vms: result}, nil
}

func (p *AffinityLabelVmsServiceListRequest) MustSend() *AffinityLabelVmsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all virtual machines with the label.
// The order of the returned virtual machines isn't guaranteed.
//
type AffinityLabelVmsServiceListResponse struct {
	vms *VmSlice
}

func (p *AffinityLabelVmsServiceListResponse) Vms() (*VmSlice, bool) {
	if p.vms != nil {
		return p.vms, true
	}
	return nil, false
}

func (p *AffinityLabelVmsServiceListResponse) MustVms() *VmSlice {
	if p.vms == nil {
		panic("vms in response does not exist")
	}
	return p.vms
}

//
// List all virtual machines with the label.
// The order of the returned virtual machines isn't guaranteed.
//
func (p *AffinityLabelVmsService) List() *AffinityLabelVmsServiceListRequest {
	return &AffinityLabelVmsServiceListRequest{AffinityLabelVmsService: p}
}

//
// A link to the specific label-vm assignment to
// allow label removal.
//
func (op *AffinityLabelVmsService) VmService(id string) *AffinityLabelVmService {
	return NewAffinityLabelVmService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityLabelVmsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VmService(path), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *AffinityLabelVmsService) String() string {
	return fmt.Sprintf("AffinityLabelVmsService:%s", op.path)
}

//
// Lists the virtual machines of an export storage domain.
// For example, to retrieve the virtual machines that are available in the storage domain with identifier `123` send the
// following request:
// [source]
// ----
// GET /ovirt-engine/api/storagedomains/123/vms
// ----
// This will return the following response body:
// [source,xml]
// ----
// <vms>
//   <vm id="456" href="/api/storagedomains/123/vms/456">
//     <name>vm1</name>
//     ...
//     <storage_domain id="123" href="/api/storagedomains/123"/>
//     <actions>
//       <link rel="import" href="/api/storagedomains/123/vms/456/import"/>
//     </actions>
//   </vm>
// </vms>
// ----
// Virtual machines and templates in these collections have a similar representation to their counterparts in the
// top-level <<types/vm, Vm>> and <<types/template, Template>> collections, except they also contain a
// <<types/storage_domain, StorageDomain>> reference and an <<services/storage_domain_vm/methods/import, import>>
// action.
//
type StorageDomainVmsService struct {
	BaseService
}

func NewStorageDomainVmsService(connection *Connection, path string) *StorageDomainVmsService {
	var result StorageDomainVmsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of virtual machines of the export storage domain.
// The order of the returned list of virtual machines isn't guaranteed.
//
type StorageDomainVmsServiceListRequest struct {
	StorageDomainVmsService *StorageDomainVmsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
	unregistered            *bool
}

func (p *StorageDomainVmsServiceListRequest) Header(key, value string) *StorageDomainVmsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainVmsServiceListRequest) Query(key, value string) *StorageDomainVmsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainVmsServiceListRequest) Follow(follow string) *StorageDomainVmsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainVmsServiceListRequest) Max(max int64) *StorageDomainVmsServiceListRequest {
	p.max = &max
	return p
}

func (p *StorageDomainVmsServiceListRequest) Unregistered(unregistered bool) *StorageDomainVmsServiceListRequest {
	p.unregistered = &unregistered
	return p
}

func (p *StorageDomainVmsServiceListRequest) Send() (*StorageDomainVmsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainVmsService.connection.URL(), p.StorageDomainVmsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainVmsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainVmsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainVmsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainVmsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainVmsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageDomainVmsServiceListResponse{vm: result}, nil
}

func (p *StorageDomainVmsServiceListRequest) MustSend() *StorageDomainVmsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of virtual machines of the export storage domain.
// The order of the returned list of virtual machines isn't guaranteed.
//
type StorageDomainVmsServiceListResponse struct {
	vm *VmSlice
}

func (p *StorageDomainVmsServiceListResponse) Vm() (*VmSlice, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *StorageDomainVmsServiceListResponse) MustVm() *VmSlice {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Returns the list of virtual machines of the export storage domain.
// The order of the returned list of virtual machines isn't guaranteed.
//
func (p *StorageDomainVmsService) List() *StorageDomainVmsServiceListRequest {
	return &StorageDomainVmsServiceListRequest{StorageDomainVmsService: p}
}

//
//
func (op *StorageDomainVmsService) VmService(id string) *StorageDomainVmService {
	return NewStorageDomainVmService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainVmsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.VmService(path), nil
	}
	return op.VmService(path[:index]).Service(path[index+1:])
}

func (op *StorageDomainVmsService) String() string {
	return fmt.Sprintf("StorageDomainVmsService:%s", op.path)
}

//
//
type StorageServerConnectionExtensionsService struct {
	BaseService
}

func NewStorageServerConnectionExtensionsService(connection *Connection, path string) *StorageServerConnectionExtensionsService {
	var result StorageServerConnectionExtensionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new storage server connection extension for the given host.
// The extension lets the user define credentials for an iSCSI target for a specific host. For example to use
// `myuser` and `mypassword` as the credentials when connecting to the iSCSI target from host `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/storageconnectionextensions
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
type StorageServerConnectionExtensionsServiceAddRequest struct {
	StorageServerConnectionExtensionsService *StorageServerConnectionExtensionsService
	header                                   map[string]string
	query                                    map[string]string
	extension                                *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Header(key, value string) *StorageServerConnectionExtensionsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Query(key, value string) *StorageServerConnectionExtensionsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Extension(extension *StorageConnectionExtension) *StorageServerConnectionExtensionsServiceAddRequest {
	p.extension = extension
	return p
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) Send() (*StorageServerConnectionExtensionsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionExtensionsService.connection.URL(), p.StorageServerConnectionExtensionsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageConnectionExtensionWriteOne(writer, p.extension, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionExtensionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionExtensionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionExtensionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionExtensionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionExtensionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageServerConnectionExtensionsServiceAddResponse{extension: result}, nil
}

func (p *StorageServerConnectionExtensionsServiceAddRequest) MustSend() *StorageServerConnectionExtensionsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new storage server connection extension for the given host.
// The extension lets the user define credentials for an iSCSI target for a specific host. For example to use
// `myuser` and `mypassword` as the credentials when connecting to the iSCSI target from host `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/storageconnectionextensions
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
type StorageServerConnectionExtensionsServiceAddResponse struct {
	extension *StorageConnectionExtension
}

func (p *StorageServerConnectionExtensionsServiceAddResponse) Extension() (*StorageConnectionExtension, bool) {
	if p.extension != nil {
		return p.extension, true
	}
	return nil, false
}

func (p *StorageServerConnectionExtensionsServiceAddResponse) MustExtension() *StorageConnectionExtension {
	if p.extension == nil {
		panic("extension in response does not exist")
	}
	return p.extension
}

//
// Creates a new storage server connection extension for the given host.
// The extension lets the user define credentials for an iSCSI target for a specific host. For example to use
// `myuser` and `mypassword` as the credentials when connecting to the iSCSI target from host `123` send a request
// like this:
// [source]
// ----
// POST /ovirt-engine/api/hosts/123/storageconnectionextensions
// ----
// With a request body like this:
// [source,xml]
// ----
// <storage_connection_extension>
//   <target>iqn.2016-01.com.example:mytarget</target>
//   <username>myuser</username>
//   <password>mypassword</password>
// </storage_connection_extension>
// ----
//
func (p *StorageServerConnectionExtensionsService) Add() *StorageServerConnectionExtensionsServiceAddRequest {
	return &StorageServerConnectionExtensionsServiceAddRequest{StorageServerConnectionExtensionsService: p}
}

//
// Returns the list os storage connection extensions.
// The order of the returned list of storage connections isn't guaranteed.
//
type StorageServerConnectionExtensionsServiceListRequest struct {
	StorageServerConnectionExtensionsService *StorageServerConnectionExtensionsService
	header                                   map[string]string
	query                                    map[string]string
	follow                                   *string
	max                                      *int64
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Header(key, value string) *StorageServerConnectionExtensionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Query(key, value string) *StorageServerConnectionExtensionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Follow(follow string) *StorageServerConnectionExtensionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Max(max int64) *StorageServerConnectionExtensionsServiceListRequest {
	p.max = &max
	return p
}

func (p *StorageServerConnectionExtensionsServiceListRequest) Send() (*StorageServerConnectionExtensionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageServerConnectionExtensionsService.connection.URL(), p.StorageServerConnectionExtensionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageServerConnectionExtensionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageServerConnectionExtensionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageServerConnectionExtensionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageServerConnectionExtensionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageServerConnectionExtensionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageConnectionExtensionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StorageServerConnectionExtensionsServiceListResponse{extensions: result}, nil
}

func (p *StorageServerConnectionExtensionsServiceListRequest) MustSend() *StorageServerConnectionExtensionsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list os storage connection extensions.
// The order of the returned list of storage connections isn't guaranteed.
//
type StorageServerConnectionExtensionsServiceListResponse struct {
	extensions *StorageConnectionExtensionSlice
}

func (p *StorageServerConnectionExtensionsServiceListResponse) Extensions() (*StorageConnectionExtensionSlice, bool) {
	if p.extensions != nil {
		return p.extensions, true
	}
	return nil, false
}

func (p *StorageServerConnectionExtensionsServiceListResponse) MustExtensions() *StorageConnectionExtensionSlice {
	if p.extensions == nil {
		panic("extensions in response does not exist")
	}
	return p.extensions
}

//
// Returns the list os storage connection extensions.
// The order of the returned list of storage connections isn't guaranteed.
//
func (p *StorageServerConnectionExtensionsService) List() *StorageServerConnectionExtensionsServiceListRequest {
	return &StorageServerConnectionExtensionsServiceListRequest{StorageServerConnectionExtensionsService: p}
}

//
//
func (op *StorageServerConnectionExtensionsService) StorageConnectionExtensionService(id string) *StorageServerConnectionExtensionService {
	return NewStorageServerConnectionExtensionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageServerConnectionExtensionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StorageConnectionExtensionService(path), nil
	}
	return op.StorageConnectionExtensionService(path[:index]).Service(path[index+1:])
}

func (op *StorageServerConnectionExtensionsService) String() string {
	return fmt.Sprintf("StorageServerConnectionExtensionsService:%s", op.path)
}

//
// A service to manage host devices attached to a virtual machine.
//
type VmHostDevicesService struct {
	BaseService
}

func NewVmHostDevicesService(connection *Connection, path string) *VmHostDevicesService {
	var result VmHostDevicesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Attach target device to given virtual machine.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/hostdevices
// ----
// With request body of type <<types/host_device,HostDevice>>, for example
// [source,xml]
// ----
// <host_device id="123" />
// ----
// NOTE: A necessary precondition for a successful host device attachment is that the virtual machine must be pinned
// to *exactly* one host. The device ID is then taken relative to this host.
// NOTE: Attachment of a PCI device that is part of a bigger IOMMU group will result in attachment of the remaining
// devices from that IOMMU group as "placeholders". These devices are then identified using the `placeholder`
// attribute of the <<types/host_device,HostDevice>> type set to `true`.
// In case you want attach a device that already serves as an IOMMU placeholder, simply issue an explicit Add operation
// for it, and its `placeholder` flag will be cleared, and the device will be accessible to the virtual machine.
//
type VmHostDevicesServiceAddRequest struct {
	VmHostDevicesService *VmHostDevicesService
	header               map[string]string
	query                map[string]string
	device               *HostDevice
}

func (p *VmHostDevicesServiceAddRequest) Header(key, value string) *VmHostDevicesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDevicesServiceAddRequest) Query(key, value string) *VmHostDevicesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDevicesServiceAddRequest) Device(device *HostDevice) *VmHostDevicesServiceAddRequest {
	p.device = device
	return p
}

func (p *VmHostDevicesServiceAddRequest) Send() (*VmHostDevicesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmHostDevicesService.connection.URL(), p.VmHostDevicesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostDeviceWriteOne(writer, p.device, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmHostDevicesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmHostDevicesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmHostDevicesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmHostDevicesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmHostDevicesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmHostDevicesServiceAddResponse{device: result}, nil
}

func (p *VmHostDevicesServiceAddRequest) MustSend() *VmHostDevicesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Attach target device to given virtual machine.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/hostdevices
// ----
// With request body of type <<types/host_device,HostDevice>>, for example
// [source,xml]
// ----
// <host_device id="123" />
// ----
// NOTE: A necessary precondition for a successful host device attachment is that the virtual machine must be pinned
// to *exactly* one host. The device ID is then taken relative to this host.
// NOTE: Attachment of a PCI device that is part of a bigger IOMMU group will result in attachment of the remaining
// devices from that IOMMU group as "placeholders". These devices are then identified using the `placeholder`
// attribute of the <<types/host_device,HostDevice>> type set to `true`.
// In case you want attach a device that already serves as an IOMMU placeholder, simply issue an explicit Add operation
// for it, and its `placeholder` flag will be cleared, and the device will be accessible to the virtual machine.
//
type VmHostDevicesServiceAddResponse struct {
	device *HostDevice
}

func (p *VmHostDevicesServiceAddResponse) Device() (*HostDevice, bool) {
	if p.device != nil {
		return p.device, true
	}
	return nil, false
}

func (p *VmHostDevicesServiceAddResponse) MustDevice() *HostDevice {
	if p.device == nil {
		panic("device in response does not exist")
	}
	return p.device
}

//
// Attach target device to given virtual machine.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/hostdevices
// ----
// With request body of type <<types/host_device,HostDevice>>, for example
// [source,xml]
// ----
// <host_device id="123" />
// ----
// NOTE: A necessary precondition for a successful host device attachment is that the virtual machine must be pinned
// to *exactly* one host. The device ID is then taken relative to this host.
// NOTE: Attachment of a PCI device that is part of a bigger IOMMU group will result in attachment of the remaining
// devices from that IOMMU group as "placeholders". These devices are then identified using the `placeholder`
// attribute of the <<types/host_device,HostDevice>> type set to `true`.
// In case you want attach a device that already serves as an IOMMU placeholder, simply issue an explicit Add operation
// for it, and its `placeholder` flag will be cleared, and the device will be accessible to the virtual machine.
//
func (p *VmHostDevicesService) Add() *VmHostDevicesServiceAddRequest {
	return &VmHostDevicesServiceAddRequest{VmHostDevicesService: p}
}

//
// List the host devices assigned to given virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
type VmHostDevicesServiceListRequest struct {
	VmHostDevicesService *VmHostDevicesService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *VmHostDevicesServiceListRequest) Header(key, value string) *VmHostDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmHostDevicesServiceListRequest) Query(key, value string) *VmHostDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmHostDevicesServiceListRequest) Follow(follow string) *VmHostDevicesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmHostDevicesServiceListRequest) Max(max int64) *VmHostDevicesServiceListRequest {
	p.max = &max
	return p
}

func (p *VmHostDevicesServiceListRequest) Send() (*VmHostDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmHostDevicesService.connection.URL(), p.VmHostDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmHostDevicesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmHostDevicesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmHostDevicesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmHostDevicesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmHostDevicesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostDeviceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmHostDevicesServiceListResponse{device: result}, nil
}

func (p *VmHostDevicesServiceListRequest) MustSend() *VmHostDevicesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the host devices assigned to given virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
type VmHostDevicesServiceListResponse struct {
	device *HostDeviceSlice
}

func (p *VmHostDevicesServiceListResponse) Device() (*HostDeviceSlice, bool) {
	if p.device != nil {
		return p.device, true
	}
	return nil, false
}

func (p *VmHostDevicesServiceListResponse) MustDevice() *HostDeviceSlice {
	if p.device == nil {
		panic("device in response does not exist")
	}
	return p.device
}

//
// List the host devices assigned to given virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
func (p *VmHostDevicesService) List() *VmHostDevicesServiceListRequest {
	return &VmHostDevicesServiceListRequest{VmHostDevicesService: p}
}

//
// Returns a reference to the service that manages a specific host device attached to given virtual machine.
//
func (op *VmHostDevicesService) DeviceService(id string) *VmHostDeviceService {
	return NewVmHostDeviceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmHostDevicesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DeviceService(path), nil
	}
	return op.DeviceService(path[:index]).Service(path[index+1:])
}

func (op *VmHostDevicesService) String() string {
	return fmt.Sprintf("VmHostDevicesService:%s", op.path)
}

//
// Manages the set of types of operating systems available in the system.
//
type OperatingSystemsService struct {
	BaseService
}

func NewOperatingSystemsService(connection *Connection, path string) *OperatingSystemsService {
	var result OperatingSystemsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of types of operating system available in the system.
// The order of the returned list of operating systems isn't guaranteed.
//
type OperatingSystemsServiceListRequest struct {
	OperatingSystemsService *OperatingSystemsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
}

func (p *OperatingSystemsServiceListRequest) Header(key, value string) *OperatingSystemsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *OperatingSystemsServiceListRequest) Query(key, value string) *OperatingSystemsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *OperatingSystemsServiceListRequest) Follow(follow string) *OperatingSystemsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *OperatingSystemsServiceListRequest) Max(max int64) *OperatingSystemsServiceListRequest {
	p.max = &max
	return p
}

func (p *OperatingSystemsServiceListRequest) Send() (*OperatingSystemsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.OperatingSystemsService.connection.URL(), p.OperatingSystemsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.OperatingSystemsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.OperatingSystemsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.OperatingSystemsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.OperatingSystemsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.OperatingSystemsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLOperatingSystemInfoReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &OperatingSystemsServiceListResponse{operatingSystem: result}, nil
}

func (p *OperatingSystemsServiceListRequest) MustSend() *OperatingSystemsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of types of operating system available in the system.
// The order of the returned list of operating systems isn't guaranteed.
//
type OperatingSystemsServiceListResponse struct {
	operatingSystem *OperatingSystemInfoSlice
}

func (p *OperatingSystemsServiceListResponse) OperatingSystem() (*OperatingSystemInfoSlice, bool) {
	if p.operatingSystem != nil {
		return p.operatingSystem, true
	}
	return nil, false
}

func (p *OperatingSystemsServiceListResponse) MustOperatingSystem() *OperatingSystemInfoSlice {
	if p.operatingSystem == nil {
		panic("operatingSystem in response does not exist")
	}
	return p.operatingSystem
}

//
// Returns the list of types of operating system available in the system.
// The order of the returned list of operating systems isn't guaranteed.
//
func (p *OperatingSystemsService) List() *OperatingSystemsServiceListRequest {
	return &OperatingSystemsServiceListRequest{OperatingSystemsService: p}
}

//
//
func (op *OperatingSystemsService) OperatingSystemService(id string) *OperatingSystemService {
	return NewOperatingSystemService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *OperatingSystemsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.OperatingSystemService(path), nil
	}
	return op.OperatingSystemService(path[:index]).Service(path[index+1:])
}

func (op *OperatingSystemsService) String() string {
	return fmt.Sprintf("OperatingSystemsService:%s", op.path)
}

//
//
type DiskProfilesService struct {
	BaseService
}

func NewDiskProfilesService(connection *Connection, path string) *DiskProfilesService {
	var result DiskProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new disk profile to the system.
//
type DiskProfilesServiceAddRequest struct {
	DiskProfilesService *DiskProfilesService
	header              map[string]string
	query               map[string]string
	profile             *DiskProfile
}

func (p *DiskProfilesServiceAddRequest) Header(key, value string) *DiskProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfilesServiceAddRequest) Query(key, value string) *DiskProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfilesServiceAddRequest) Profile(profile *DiskProfile) *DiskProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *DiskProfilesServiceAddRequest) Send() (*DiskProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskProfilesService.connection.URL(), p.DiskProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskProfilesServiceAddResponse{profile: result}, nil
}

func (p *DiskProfilesServiceAddRequest) MustSend() *DiskProfilesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new disk profile to the system.
//
type DiskProfilesServiceAddResponse struct {
	profile *DiskProfile
}

func (p *DiskProfilesServiceAddResponse) Profile() (*DiskProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *DiskProfilesServiceAddResponse) MustProfile() *DiskProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new disk profile to the system.
//
func (p *DiskProfilesService) Add() *DiskProfilesServiceAddRequest {
	return &DiskProfilesServiceAddRequest{DiskProfilesService: p}
}

//
// Returns the list of disk profiles of the system.
// The order of the returned list of disk profiles isn't guaranteed.
//
type DiskProfilesServiceListRequest struct {
	DiskProfilesService *DiskProfilesService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *DiskProfilesServiceListRequest) Header(key, value string) *DiskProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskProfilesServiceListRequest) Query(key, value string) *DiskProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskProfilesServiceListRequest) Follow(follow string) *DiskProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *DiskProfilesServiceListRequest) Max(max int64) *DiskProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *DiskProfilesServiceListRequest) Send() (*DiskProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskProfilesService.connection.URL(), p.DiskProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &DiskProfilesServiceListResponse{profile: result}, nil
}

func (p *DiskProfilesServiceListRequest) MustSend() *DiskProfilesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of disk profiles of the system.
// The order of the returned list of disk profiles isn't guaranteed.
//
type DiskProfilesServiceListResponse struct {
	profile *DiskProfileSlice
}

func (p *DiskProfilesServiceListResponse) Profile() (*DiskProfileSlice, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *DiskProfilesServiceListResponse) MustProfile() *DiskProfileSlice {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Returns the list of disk profiles of the system.
// The order of the returned list of disk profiles isn't guaranteed.
//
func (p *DiskProfilesService) List() *DiskProfilesServiceListRequest {
	return &DiskProfilesServiceListRequest{DiskProfilesService: p}
}

//
//
func (op *DiskProfilesService) DiskProfileService(id string) *DiskProfileService {
	return NewDiskProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskProfileService(path), nil
	}
	return op.DiskProfileService(path[:index]).Service(path[index+1:])
}

func (op *DiskProfilesService) String() string {
	return fmt.Sprintf("DiskProfilesService:%s", op.path)
}

//
//
type VmBackupDiskService struct {
	BaseService
}

func NewVmBackupDiskService(connection *Connection, path string) *VmBackupDiskService {
	var result VmBackupDiskService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the description of the disk.
//
type VmBackupDiskServiceGetRequest struct {
	VmBackupDiskService *VmBackupDiskService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *VmBackupDiskServiceGetRequest) Header(key, value string) *VmBackupDiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmBackupDiskServiceGetRequest) Query(key, value string) *VmBackupDiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmBackupDiskServiceGetRequest) Follow(follow string) *VmBackupDiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmBackupDiskServiceGetRequest) Send() (*VmBackupDiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmBackupDiskService.connection.URL(), p.VmBackupDiskService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmBackupDiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmBackupDiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmBackupDiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmBackupDiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmBackupDiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmBackupDiskServiceGetResponse{disk: result}, nil
}

func (p *VmBackupDiskServiceGetRequest) MustSend() *VmBackupDiskServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the description of the disk.
//
type VmBackupDiskServiceGetResponse struct {
	disk *Disk
}

func (p *VmBackupDiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *VmBackupDiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (p *VmBackupDiskService) Get() *VmBackupDiskServiceGetRequest {
	return &VmBackupDiskServiceGetRequest{VmBackupDiskService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmBackupDiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmBackupDiskService) String() string {
	return fmt.Sprintf("VmBackupDiskService:%s", op.path)
}

//
//
type AssignedVnicProfileService struct {
	BaseService
}

func NewAssignedVnicProfileService(connection *Connection, path string) *AssignedVnicProfileService {
	var result AssignedVnicProfileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type AssignedVnicProfileServiceGetRequest struct {
	AssignedVnicProfileService *AssignedVnicProfileService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
}

func (p *AssignedVnicProfileServiceGetRequest) Header(key, value string) *AssignedVnicProfileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfileServiceGetRequest) Query(key, value string) *AssignedVnicProfileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfileServiceGetRequest) Follow(follow string) *AssignedVnicProfileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *AssignedVnicProfileServiceGetRequest) Send() (*AssignedVnicProfileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedVnicProfileService.connection.URL(), p.AssignedVnicProfileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedVnicProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedVnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedVnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedVnicProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedVnicProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedVnicProfileServiceGetResponse{profile: result}, nil
}

func (p *AssignedVnicProfileServiceGetRequest) MustSend() *AssignedVnicProfileServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type AssignedVnicProfileServiceGetResponse struct {
	profile *VnicProfile
}

func (p *AssignedVnicProfileServiceGetResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *AssignedVnicProfileServiceGetResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
//
func (p *AssignedVnicProfileService) Get() *AssignedVnicProfileServiceGetRequest {
	return &AssignedVnicProfileServiceGetRequest{AssignedVnicProfileService: p}
}

//
//
type AssignedVnicProfileServiceRemoveRequest struct {
	AssignedVnicProfileService *AssignedVnicProfileService
	header                     map[string]string
	query                      map[string]string
	async                      *bool
}

func (p *AssignedVnicProfileServiceRemoveRequest) Header(key, value string) *AssignedVnicProfileServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedVnicProfileServiceRemoveRequest) Query(key, value string) *AssignedVnicProfileServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedVnicProfileServiceRemoveRequest) Async(async bool) *AssignedVnicProfileServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AssignedVnicProfileServiceRemoveRequest) Send() (*AssignedVnicProfileServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedVnicProfileService.connection.URL(), p.AssignedVnicProfileService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedVnicProfileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedVnicProfileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedVnicProfileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedVnicProfileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedVnicProfileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AssignedVnicProfileServiceRemoveResponse), nil
}

func (p *AssignedVnicProfileServiceRemoveRequest) MustSend() *AssignedVnicProfileServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type AssignedVnicProfileServiceRemoveResponse struct {
}

//
//
func (p *AssignedVnicProfileService) Remove() *AssignedVnicProfileServiceRemoveRequest {
	return &AssignedVnicProfileServiceRemoveRequest{AssignedVnicProfileService: p}
}

//
//
func (op *AssignedVnicProfileService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedVnicProfileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AssignedVnicProfileService) String() string {
	return fmt.Sprintf("AssignedVnicProfileService:%s", op.path)
}

//
//
type FileService struct {
	BaseService
}

func NewFileService(connection *Connection, path string) *FileService {
	var result FileService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type FileServiceGetRequest struct {
	FileService *FileService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *FileServiceGetRequest) Header(key, value string) *FileServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FileServiceGetRequest) Query(key, value string) *FileServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FileServiceGetRequest) Follow(follow string) *FileServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *FileServiceGetRequest) Send() (*FileServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FileService.connection.URL(), p.FileService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FileService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FileService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FileService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FileService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FileService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &FileServiceGetResponse{file: result}, nil
}

func (p *FileServiceGetRequest) MustSend() *FileServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type FileServiceGetResponse struct {
	file *File
}

func (p *FileServiceGetResponse) File() (*File, bool) {
	if p.file != nil {
		return p.file, true
	}
	return nil, false
}

func (p *FileServiceGetResponse) MustFile() *File {
	if p.file == nil {
		panic("file in response does not exist")
	}
	return p.file
}

//
//
func (p *FileService) Get() *FileServiceGetRequest {
	return &FileServiceGetRequest{FileService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FileService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FileService) String() string {
	return fmt.Sprintf("FileService:%s", op.path)
}

//
//
type BalancesService struct {
	BaseService
}

func NewBalancesService(connection *Connection, path string) *BalancesService {
	var result BalancesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a balance module to a specified user defined scheduling policy.
//
type BalancesServiceAddRequest struct {
	BalancesService *BalancesService
	header          map[string]string
	query           map[string]string
	balance         *Balance
}

func (p *BalancesServiceAddRequest) Header(key, value string) *BalancesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalancesServiceAddRequest) Query(key, value string) *BalancesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalancesServiceAddRequest) Balance(balance *Balance) *BalancesServiceAddRequest {
	p.balance = balance
	return p
}

func (p *BalancesServiceAddRequest) Send() (*BalancesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BalancesService.connection.URL(), p.BalancesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBalanceWriteOne(writer, p.balance, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BalancesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BalancesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BalancesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BalancesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BalancesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &BalancesServiceAddResponse{balance: result}, nil
}

func (p *BalancesServiceAddRequest) MustSend() *BalancesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a balance module to a specified user defined scheduling policy.
//
type BalancesServiceAddResponse struct {
	balance *Balance
}

func (p *BalancesServiceAddResponse) Balance() (*Balance, bool) {
	if p.balance != nil {
		return p.balance, true
	}
	return nil, false
}

func (p *BalancesServiceAddResponse) MustBalance() *Balance {
	if p.balance == nil {
		panic("balance in response does not exist")
	}
	return p.balance
}

//
// Add a balance module to a specified user defined scheduling policy.
//
func (p *BalancesService) Add() *BalancesServiceAddRequest {
	return &BalancesServiceAddRequest{BalancesService: p}
}

//
// Returns the list of balance modules used by the scheduling policy.
// The order of the returned balance modules isn't guaranteed.
//
type BalancesServiceListRequest struct {
	BalancesService *BalancesService
	header          map[string]string
	query           map[string]string
	filter          *bool
	follow          *string
	max             *int64
}

func (p *BalancesServiceListRequest) Header(key, value string) *BalancesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BalancesServiceListRequest) Query(key, value string) *BalancesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BalancesServiceListRequest) Filter(filter bool) *BalancesServiceListRequest {
	p.filter = &filter
	return p
}

func (p *BalancesServiceListRequest) Follow(follow string) *BalancesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *BalancesServiceListRequest) Max(max int64) *BalancesServiceListRequest {
	p.max = &max
	return p
}

func (p *BalancesServiceListRequest) Send() (*BalancesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BalancesService.connection.URL(), p.BalancesService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BalancesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BalancesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BalancesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BalancesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BalancesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBalanceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &BalancesServiceListResponse{balances: result}, nil
}

func (p *BalancesServiceListRequest) MustSend() *BalancesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of balance modules used by the scheduling policy.
// The order of the returned balance modules isn't guaranteed.
//
type BalancesServiceListResponse struct {
	balances *BalanceSlice
}

func (p *BalancesServiceListResponse) Balances() (*BalanceSlice, bool) {
	if p.balances != nil {
		return p.balances, true
	}
	return nil, false
}

func (p *BalancesServiceListResponse) MustBalances() *BalanceSlice {
	if p.balances == nil {
		panic("balances in response does not exist")
	}
	return p.balances
}

//
// Returns the list of balance modules used by the scheduling policy.
// The order of the returned balance modules isn't guaranteed.
//
func (p *BalancesService) List() *BalancesServiceListRequest {
	return &BalancesServiceListRequest{BalancesService: p}
}

//
//
func (op *BalancesService) BalanceService(id string) *BalanceService {
	return NewBalanceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BalancesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.BalanceService(path), nil
	}
	return op.BalanceService(path[:index]).Service(path[index+1:])
}

func (op *BalancesService) String() string {
	return fmt.Sprintf("BalancesService:%s", op.path)
}

//
// A service to manage a step.
//
type StepService struct {
	BaseService
}

func NewStepService(connection *Connection, path string) *StepService {
	var result StepService
	result.connection = connection
	result.path = path
	return &result
}

//
// Marks an external step execution as ended.
// For example, to terminate a step with identifier `456` which belongs to a `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps/456/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <succeeded>true</succeeded>
// </action>
// ----
//
type StepServiceEndRequest struct {
	StepService *StepService
	header      map[string]string
	query       map[string]string
	async       *bool
	force       *bool
	succeeded   *bool
}

func (p *StepServiceEndRequest) Header(key, value string) *StepServiceEndRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepServiceEndRequest) Query(key, value string) *StepServiceEndRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepServiceEndRequest) Async(async bool) *StepServiceEndRequest {
	p.async = &async
	return p
}

func (p *StepServiceEndRequest) Force(force bool) *StepServiceEndRequest {
	p.force = &force
	return p
}

func (p *StepServiceEndRequest) Succeeded(succeeded bool) *StepServiceEndRequest {
	p.succeeded = &succeeded
	return p
}

func (p *StepServiceEndRequest) Send() (*StepServiceEndResponse, error) {
	rawURL := fmt.Sprintf("%s%s/end", p.StepService.connection.URL(), p.StepService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	if p.succeeded != nil {
		actionBuilder.Succeeded(*p.succeeded)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StepService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StepService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StepService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StepService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StepService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StepServiceEndResponse), nil
}

func (p *StepServiceEndRequest) MustSend() *StepServiceEndResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Marks an external step execution as ended.
// For example, to terminate a step with identifier `456` which belongs to a `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps/456/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <succeeded>true</succeeded>
// </action>
// ----
//
type StepServiceEndResponse struct {
}

//
// Marks an external step execution as ended.
// For example, to terminate a step with identifier `456` which belongs to a `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps/456/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <succeeded>true</succeeded>
// </action>
// ----
//
func (p *StepService) End() *StepServiceEndRequest {
	return &StepServiceEndRequest{StepService: p}
}

//
// Retrieves a step.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123/steps/456
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <end_time>2016-12-12T23:07:26.627+02:00</end_time>
//   <external>false</external>
//   <number>0</number>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>finished</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
type StepServiceGetRequest struct {
	StepService *StepService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *StepServiceGetRequest) Header(key, value string) *StepServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepServiceGetRequest) Query(key, value string) *StepServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepServiceGetRequest) Follow(follow string) *StepServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StepServiceGetRequest) Send() (*StepServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StepService.connection.URL(), p.StepService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StepService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StepService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StepService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StepService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StepService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StepServiceGetResponse{step: result}, nil
}

func (p *StepServiceGetRequest) MustSend() *StepServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves a step.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123/steps/456
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <end_time>2016-12-12T23:07:26.627+02:00</end_time>
//   <external>false</external>
//   <number>0</number>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>finished</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
type StepServiceGetResponse struct {
	step *Step
}

func (p *StepServiceGetResponse) Step() (*Step, bool) {
	if p.step != nil {
		return p.step, true
	}
	return nil, false
}

func (p *StepServiceGetResponse) MustStep() *Step {
	if p.step == nil {
		panic("step in response does not exist")
	}
	return p.step
}

//
// Retrieves a step.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123/steps/456
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <end_time>2016-12-12T23:07:26.627+02:00</end_time>
//   <external>false</external>
//   <number>0</number>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>finished</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
func (p *StepService) Get() *StepServiceGetRequest {
	return &StepServiceGetRequest{StepService: p}
}

//
//
func (op *StepService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StepService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StepService) String() string {
	return fmt.Sprintf("StepService:%s", op.path)
}

//
// A service to manage a bookmark.
//
type BookmarkService struct {
	BaseService
}

func NewBookmarkService(connection *Connection, path string) *BookmarkService {
	var result BookmarkService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get a bookmark.
// An example for getting a bookmark:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks/123
// ----
// [source,xml]
// ----
// <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//   <name>example_vm</name>
//   <value>vm: name=example*</value>
// </bookmark>
// ----
//
type BookmarkServiceGetRequest struct {
	BookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
	follow          *string
}

func (p *BookmarkServiceGetRequest) Header(key, value string) *BookmarkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceGetRequest) Query(key, value string) *BookmarkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceGetRequest) Follow(follow string) *BookmarkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *BookmarkServiceGetRequest) Send() (*BookmarkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BookmarkService.connection.URL(), p.BookmarkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BookmarkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BookmarkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BookmarkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BookmarkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BookmarkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &BookmarkServiceGetResponse{bookmark: result}, nil
}

func (p *BookmarkServiceGetRequest) MustSend() *BookmarkServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get a bookmark.
// An example for getting a bookmark:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks/123
// ----
// [source,xml]
// ----
// <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//   <name>example_vm</name>
//   <value>vm: name=example*</value>
// </bookmark>
// ----
//
type BookmarkServiceGetResponse struct {
	bookmark *Bookmark
}

func (p *BookmarkServiceGetResponse) Bookmark() (*Bookmark, bool) {
	if p.bookmark != nil {
		return p.bookmark, true
	}
	return nil, false
}

func (p *BookmarkServiceGetResponse) MustBookmark() *Bookmark {
	if p.bookmark == nil {
		panic("bookmark in response does not exist")
	}
	return p.bookmark
}

//
// Get a bookmark.
// An example for getting a bookmark:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks/123
// ----
// [source,xml]
// ----
// <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//   <name>example_vm</name>
//   <value>vm: name=example*</value>
// </bookmark>
// ----
//
func (p *BookmarkService) Get() *BookmarkServiceGetRequest {
	return &BookmarkServiceGetRequest{BookmarkService: p}
}

//
// Remove a bookmark.
// An example for removing a bookmark:
// [source]
// ----
// DELETE /ovirt-engine/api/bookmarks/123
// ----
//
type BookmarkServiceRemoveRequest struct {
	BookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
	async           *bool
}

func (p *BookmarkServiceRemoveRequest) Header(key, value string) *BookmarkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceRemoveRequest) Query(key, value string) *BookmarkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceRemoveRequest) Async(async bool) *BookmarkServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *BookmarkServiceRemoveRequest) Send() (*BookmarkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BookmarkService.connection.URL(), p.BookmarkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BookmarkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BookmarkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BookmarkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BookmarkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BookmarkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(BookmarkServiceRemoveResponse), nil
}

func (p *BookmarkServiceRemoveRequest) MustSend() *BookmarkServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove a bookmark.
// An example for removing a bookmark:
// [source]
// ----
// DELETE /ovirt-engine/api/bookmarks/123
// ----
//
type BookmarkServiceRemoveResponse struct {
}

//
// Remove a bookmark.
// An example for removing a bookmark:
// [source]
// ----
// DELETE /ovirt-engine/api/bookmarks/123
// ----
//
func (p *BookmarkService) Remove() *BookmarkServiceRemoveRequest {
	return &BookmarkServiceRemoveRequest{BookmarkService: p}
}

//
// Update a bookmark.
// An example for updating a bookmark:
// [source]
// ----
// PUT /ovirt-engine/api/bookmarks/123
// ----
// With the request body:
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
type BookmarkServiceUpdateRequest struct {
	BookmarkService *BookmarkService
	header          map[string]string
	query           map[string]string
	async           *bool
	bookmark        *Bookmark
}

func (p *BookmarkServiceUpdateRequest) Header(key, value string) *BookmarkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarkServiceUpdateRequest) Query(key, value string) *BookmarkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarkServiceUpdateRequest) Async(async bool) *BookmarkServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *BookmarkServiceUpdateRequest) Bookmark(bookmark *Bookmark) *BookmarkServiceUpdateRequest {
	p.bookmark = bookmark
	return p
}

func (p *BookmarkServiceUpdateRequest) Send() (*BookmarkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BookmarkService.connection.URL(), p.BookmarkService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBookmarkWriteOne(writer, p.bookmark, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BookmarkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BookmarkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BookmarkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BookmarkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BookmarkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &BookmarkServiceUpdateResponse{bookmark: result}, nil
}

func (p *BookmarkServiceUpdateRequest) MustSend() *BookmarkServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update a bookmark.
// An example for updating a bookmark:
// [source]
// ----
// PUT /ovirt-engine/api/bookmarks/123
// ----
// With the request body:
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
type BookmarkServiceUpdateResponse struct {
	bookmark *Bookmark
}

func (p *BookmarkServiceUpdateResponse) Bookmark() (*Bookmark, bool) {
	if p.bookmark != nil {
		return p.bookmark, true
	}
	return nil, false
}

func (p *BookmarkServiceUpdateResponse) MustBookmark() *Bookmark {
	if p.bookmark == nil {
		panic("bookmark in response does not exist")
	}
	return p.bookmark
}

//
// Update a bookmark.
// An example for updating a bookmark:
// [source]
// ----
// PUT /ovirt-engine/api/bookmarks/123
// ----
// With the request body:
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
func (p *BookmarkService) Update() *BookmarkServiceUpdateRequest {
	return &BookmarkServiceUpdateRequest{BookmarkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BookmarkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *BookmarkService) String() string {
	return fmt.Sprintf("BookmarkService:%s", op.path)
}

//
// Represents a roles sub-collection, for example scoped by user.
//
type AssignedRolesService struct {
	BaseService
}

func NewAssignedRolesService(connection *Connection, path string) *AssignedRolesService {
	var result AssignedRolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the roles assigned to the permission.
// The order of the returned roles isn't guaranteed.
//
type AssignedRolesServiceListRequest struct {
	AssignedRolesService *AssignedRolesService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *AssignedRolesServiceListRequest) Header(key, value string) *AssignedRolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedRolesServiceListRequest) Query(key, value string) *AssignedRolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedRolesServiceListRequest) Follow(follow string) *AssignedRolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AssignedRolesServiceListRequest) Max(max int64) *AssignedRolesServiceListRequest {
	p.max = &max
	return p
}

func (p *AssignedRolesServiceListRequest) Send() (*AssignedRolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedRolesService.connection.URL(), p.AssignedRolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedRolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedRolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedRolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedRolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedRolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AssignedRolesServiceListResponse{roles: result}, nil
}

func (p *AssignedRolesServiceListRequest) MustSend() *AssignedRolesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the roles assigned to the permission.
// The order of the returned roles isn't guaranteed.
//
type AssignedRolesServiceListResponse struct {
	roles *RoleSlice
}

func (p *AssignedRolesServiceListResponse) Roles() (*RoleSlice, bool) {
	if p.roles != nil {
		return p.roles, true
	}
	return nil, false
}

func (p *AssignedRolesServiceListResponse) MustRoles() *RoleSlice {
	if p.roles == nil {
		panic("roles in response does not exist")
	}
	return p.roles
}

//
// Returns the roles assigned to the permission.
// The order of the returned roles isn't guaranteed.
//
func (p *AssignedRolesService) List() *AssignedRolesServiceListRequest {
	return &AssignedRolesServiceListRequest{AssignedRolesService: p}
}

//
// Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
//
func (op *AssignedRolesService) RoleService(id string) *RoleService {
	return NewRoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedRolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.RoleService(path), nil
	}
	return op.RoleService(path[:index]).Service(path[index+1:])
}

func (op *AssignedRolesService) String() string {
	return fmt.Sprintf("AssignedRolesService:%s", op.path)
}

//
//
type VmDisksService struct {
	BaseService
}

func NewVmDisksService(connection *Connection, path string) *VmDisksService {
	var result VmDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type VmDisksServiceAddRequest struct {
	VmDisksService *VmDisksService
	header         map[string]string
	query          map[string]string
	disk           *Disk
}

func (p *VmDisksServiceAddRequest) Header(key, value string) *VmDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDisksServiceAddRequest) Query(key, value string) *VmDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDisksServiceAddRequest) Disk(disk *Disk) *VmDisksServiceAddRequest {
	p.disk = disk
	return p
}

func (p *VmDisksServiceAddRequest) Send() (*VmDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmDisksService.connection.URL(), p.VmDisksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmDisksServiceAddResponse{disk: result}, nil
}

func (p *VmDisksServiceAddRequest) MustSend() *VmDisksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmDisksServiceAddResponse struct {
	disk *Disk
}

func (p *VmDisksServiceAddResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *VmDisksServiceAddResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
//
func (p *VmDisksService) Add() *VmDisksServiceAddRequest {
	return &VmDisksServiceAddRequest{VmDisksService: p}
}

//
// Returns the list of disks of the virtual machine.
// The order of the returned list of disks isn't guaranteed.
//
type VmDisksServiceListRequest struct {
	VmDisksService *VmDisksService
	header         map[string]string
	query          map[string]string
	follow         *string
	max            *int64
}

func (p *VmDisksServiceListRequest) Header(key, value string) *VmDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmDisksServiceListRequest) Query(key, value string) *VmDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmDisksServiceListRequest) Follow(follow string) *VmDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmDisksServiceListRequest) Max(max int64) *VmDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *VmDisksServiceListRequest) Send() (*VmDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmDisksService.connection.URL(), p.VmDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmDisksServiceListResponse{disks: result}, nil
}

func (p *VmDisksServiceListRequest) MustSend() *VmDisksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of disks of the virtual machine.
// The order of the returned list of disks isn't guaranteed.
//
type VmDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *VmDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *VmDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks of the virtual machine.
// The order of the returned list of disks isn't guaranteed.
//
func (p *VmDisksService) List() *VmDisksServiceListRequest {
	return &VmDisksServiceListRequest{VmDisksService: p}
}

//
//
func (op *VmDisksService) DiskService(id string) *VmDiskService {
	return NewVmDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *VmDisksService) String() string {
	return fmt.Sprintf("VmDisksService:%s", op.path)
}

//
//
type VmReportedDevicesService struct {
	BaseService
}

func NewVmReportedDevicesService(connection *Connection, path string) *VmReportedDevicesService {
	var result VmReportedDevicesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of reported devices of the virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
type VmReportedDevicesServiceListRequest struct {
	VmReportedDevicesService *VmReportedDevicesService
	header                   map[string]string
	query                    map[string]string
	follow                   *string
	max                      *int64
}

func (p *VmReportedDevicesServiceListRequest) Header(key, value string) *VmReportedDevicesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmReportedDevicesServiceListRequest) Query(key, value string) *VmReportedDevicesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmReportedDevicesServiceListRequest) Follow(follow string) *VmReportedDevicesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmReportedDevicesServiceListRequest) Max(max int64) *VmReportedDevicesServiceListRequest {
	p.max = &max
	return p
}

func (p *VmReportedDevicesServiceListRequest) Send() (*VmReportedDevicesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmReportedDevicesService.connection.URL(), p.VmReportedDevicesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmReportedDevicesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmReportedDevicesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmReportedDevicesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmReportedDevicesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmReportedDevicesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLReportedDeviceReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmReportedDevicesServiceListResponse{reportedDevice: result}, nil
}

func (p *VmReportedDevicesServiceListRequest) MustSend() *VmReportedDevicesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of reported devices of the virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
type VmReportedDevicesServiceListResponse struct {
	reportedDevice *ReportedDeviceSlice
}

func (p *VmReportedDevicesServiceListResponse) ReportedDevice() (*ReportedDeviceSlice, bool) {
	if p.reportedDevice != nil {
		return p.reportedDevice, true
	}
	return nil, false
}

func (p *VmReportedDevicesServiceListResponse) MustReportedDevice() *ReportedDeviceSlice {
	if p.reportedDevice == nil {
		panic("reportedDevice in response does not exist")
	}
	return p.reportedDevice
}

//
// Returns the list of reported devices of the virtual machine.
// The order of the returned list of devices isn't guaranteed.
//
func (p *VmReportedDevicesService) List() *VmReportedDevicesServiceListRequest {
	return &VmReportedDevicesServiceListRequest{VmReportedDevicesService: p}
}

//
//
func (op *VmReportedDevicesService) ReportedDeviceService(id string) *VmReportedDeviceService {
	return NewVmReportedDeviceService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmReportedDevicesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ReportedDeviceService(path), nil
	}
	return op.ReportedDeviceService(path[:index]).Service(path[index+1:])
}

func (op *VmReportedDevicesService) String() string {
	return fmt.Sprintf("VmReportedDevicesService:%s", op.path)
}

//
// Represents a service to manage collection of the tags in the system.
//
type TagsService struct {
	BaseService
}

func NewTagsService(connection *Connection, path string) *TagsService {
	var result TagsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new tag to the system.
// For example, to add new tag with name `mytag` to the system send a request like this:
// ....
// POST /ovirt-engine/api/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
// NOTE: The root tag is a special pseudo-tag assumed as the default parent tag if no parent tag is specified.
// The root tag cannot be deleted nor assigned a parent tag.
// To create new tag with specific parent tag send a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
//   <parent>
//     <name>myparenttag</name>
//   </parent>
// </tag>
// ----
//
type TagsServiceAddRequest struct {
	TagsService *TagsService
	header      map[string]string
	query       map[string]string
	tag         *Tag
}

func (p *TagsServiceAddRequest) Header(key, value string) *TagsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagsServiceAddRequest) Query(key, value string) *TagsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagsServiceAddRequest) Tag(tag *Tag) *TagsServiceAddRequest {
	p.tag = tag
	return p
}

func (p *TagsServiceAddRequest) Send() (*TagsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TagsService.connection.URL(), p.TagsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TagsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TagsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TagsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TagsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TagsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TagsServiceAddResponse{tag: result}, nil
}

func (p *TagsServiceAddRequest) MustSend() *TagsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new tag to the system.
// For example, to add new tag with name `mytag` to the system send a request like this:
// ....
// POST /ovirt-engine/api/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
// NOTE: The root tag is a special pseudo-tag assumed as the default parent tag if no parent tag is specified.
// The root tag cannot be deleted nor assigned a parent tag.
// To create new tag with specific parent tag send a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
//   <parent>
//     <name>myparenttag</name>
//   </parent>
// </tag>
// ----
//
type TagsServiceAddResponse struct {
	tag *Tag
}

func (p *TagsServiceAddResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *TagsServiceAddResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Add a new tag to the system.
// For example, to add new tag with name `mytag` to the system send a request like this:
// ....
// POST /ovirt-engine/api/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
// NOTE: The root tag is a special pseudo-tag assumed as the default parent tag if no parent tag is specified.
// The root tag cannot be deleted nor assigned a parent tag.
// To create new tag with specific parent tag send a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
//   <parent>
//     <name>myparenttag</name>
//   </parent>
// </tag>
// ----
//
func (p *TagsService) Add() *TagsServiceAddRequest {
	return &TagsServiceAddRequest{TagsService: p}
}

//
// List the tags in the system.
// For example to list the full hierarchy of the tags in the system send a request like this:
// ....
// GET /ovirt-engine/api/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>root2</name>
//     <description>root2</description>
//     <parent href="/ovirt-engine/api/tags/111" id="111"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/333" id="333">
//     <name>root3</name>
//     <description>root3</description>
//     <parent href="/ovirt-engine/api/tags/222" id="222"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/111" id="111">
//     <name>root</name>
//     <description>root</description>
//   </tag>
// </tags>
// ----
// In the previous XML output you can see the following hierarchy of the tags:
// ....
// root:        (id: 111)
//   - root2    (id: 222)
//     - root3  (id: 333)
// ....
// The order of the returned list of tags isn't guaranteed.
//
type TagsServiceListRequest struct {
	TagsService *TagsService
	header      map[string]string
	query       map[string]string
	follow      *string
	max         *int64
}

func (p *TagsServiceListRequest) Header(key, value string) *TagsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TagsServiceListRequest) Query(key, value string) *TagsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TagsServiceListRequest) Follow(follow string) *TagsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *TagsServiceListRequest) Max(max int64) *TagsServiceListRequest {
	p.max = &max
	return p
}

func (p *TagsServiceListRequest) Send() (*TagsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TagsService.connection.URL(), p.TagsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TagsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TagsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TagsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TagsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TagsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &TagsServiceListResponse{tags: result}, nil
}

func (p *TagsServiceListRequest) MustSend() *TagsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the tags in the system.
// For example to list the full hierarchy of the tags in the system send a request like this:
// ....
// GET /ovirt-engine/api/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>root2</name>
//     <description>root2</description>
//     <parent href="/ovirt-engine/api/tags/111" id="111"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/333" id="333">
//     <name>root3</name>
//     <description>root3</description>
//     <parent href="/ovirt-engine/api/tags/222" id="222"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/111" id="111">
//     <name>root</name>
//     <description>root</description>
//   </tag>
// </tags>
// ----
// In the previous XML output you can see the following hierarchy of the tags:
// ....
// root:        (id: 111)
//   - root2    (id: 222)
//     - root3  (id: 333)
// ....
// The order of the returned list of tags isn't guaranteed.
//
type TagsServiceListResponse struct {
	tags *TagSlice
}

func (p *TagsServiceListResponse) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *TagsServiceListResponse) MustTags() *TagSlice {
	if p.tags == nil {
		panic("tags in response does not exist")
	}
	return p.tags
}

//
// List the tags in the system.
// For example to list the full hierarchy of the tags in the system send a request like this:
// ....
// GET /ovirt-engine/api/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>root2</name>
//     <description>root2</description>
//     <parent href="/ovirt-engine/api/tags/111" id="111"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/333" id="333">
//     <name>root3</name>
//     <description>root3</description>
//     <parent href="/ovirt-engine/api/tags/222" id="222"/>
//   </tag>
//   <tag href="/ovirt-engine/api/tags/111" id="111">
//     <name>root</name>
//     <description>root</description>
//   </tag>
// </tags>
// ----
// In the previous XML output you can see the following hierarchy of the tags:
// ....
// root:        (id: 111)
//   - root2    (id: 222)
//     - root3  (id: 333)
// ....
// The order of the returned list of tags isn't guaranteed.
//
func (p *TagsService) List() *TagsServiceListRequest {
	return &TagsServiceListRequest{TagsService: p}
}

//
// Reference to the service that manages a specific tag.
//
func (op *TagsService) TagService(id string) *TagService {
	return NewTagService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TagsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TagService(path), nil
	}
	return op.TagService(path[:index]).Service(path[index+1:])
}

func (op *TagsService) String() string {
	return fmt.Sprintf("TagsService:%s", op.path)
}

//
// This service manages the collection of all vNIC profiles.
//
type VnicProfilesService struct {
	BaseService
}

func NewVnicProfilesService(connection *Connection, path string) *VnicProfilesService {
	var result VnicProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a vNIC profile.
// For example to add vNIC profile `123` to network `456` send a request to:
// [source]
// ----
// POST /ovirt-engine/api/networks/456/vnicprofiles
// ----
// With the following body:
// [source,xml]
// ----
// <vnic_profile id="123">
//   <name>new_vNIC_name</name>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
// </vnic_profile>
// ----
// Please note that there is a default network filter to each VNIC profile.
// For more details of how the default network filter is calculated please refer to
// the documentation in <<services/network_filters,NetworkFilters>>.
// NOTE: The automatically created vNIC profile for the external network will be without network filter.
// The output of creating a new VNIC profile depends in the  body  arguments that were given.
// In case no network filter was given, the default network filter will be configured. For example:
// [source,xml]
// ----
// <vnic_profile href="/ovirt-engine/api/vnicprofiles/123" id="123">
//   <name>new_vNIC_name</name>
//   <link href="/ovirt-engine/api/vnicprofiles/123/permissions" rel="permissions"/>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
//   <network href="/ovirt-engine/api/networks/456" id="456"/>
//   <network_filter href="/ovirt-engine/api/networkfilters/789" id="789"/>
// </vnic_profile>
// ----
// In case an empty network filter was given, no network filter will be configured for the specific VNIC profile
// regardless of the VNIC profile's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>no_network_filter</name>
//   <network_filter/>
// </vnic_profile>
// ----
// In case that a specific valid network filter id was given, the VNIC profile will be configured with the given
// network filter regardless of the VNIC profiles's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>user_choice_network_filter</name>
//   <network_filter id= "0000001b-001b-001b-001b-0000000001d5"/>
// </vnic_profile>
// ----
//
type VnicProfilesServiceAddRequest struct {
	VnicProfilesService *VnicProfilesService
	header              map[string]string
	query               map[string]string
	profile             *VnicProfile
}

func (p *VnicProfilesServiceAddRequest) Header(key, value string) *VnicProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfilesServiceAddRequest) Query(key, value string) *VnicProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfilesServiceAddRequest) Profile(profile *VnicProfile) *VnicProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *VnicProfilesServiceAddRequest) Send() (*VnicProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VnicProfilesService.connection.URL(), p.VnicProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVnicProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VnicProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VnicProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VnicProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VnicProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VnicProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VnicProfilesServiceAddResponse{profile: result}, nil
}

func (p *VnicProfilesServiceAddRequest) MustSend() *VnicProfilesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a vNIC profile.
// For example to add vNIC profile `123` to network `456` send a request to:
// [source]
// ----
// POST /ovirt-engine/api/networks/456/vnicprofiles
// ----
// With the following body:
// [source,xml]
// ----
// <vnic_profile id="123">
//   <name>new_vNIC_name</name>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
// </vnic_profile>
// ----
// Please note that there is a default network filter to each VNIC profile.
// For more details of how the default network filter is calculated please refer to
// the documentation in <<services/network_filters,NetworkFilters>>.
// NOTE: The automatically created vNIC profile for the external network will be without network filter.
// The output of creating a new VNIC profile depends in the  body  arguments that were given.
// In case no network filter was given, the default network filter will be configured. For example:
// [source,xml]
// ----
// <vnic_profile href="/ovirt-engine/api/vnicprofiles/123" id="123">
//   <name>new_vNIC_name</name>
//   <link href="/ovirt-engine/api/vnicprofiles/123/permissions" rel="permissions"/>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
//   <network href="/ovirt-engine/api/networks/456" id="456"/>
//   <network_filter href="/ovirt-engine/api/networkfilters/789" id="789"/>
// </vnic_profile>
// ----
// In case an empty network filter was given, no network filter will be configured for the specific VNIC profile
// regardless of the VNIC profile's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>no_network_filter</name>
//   <network_filter/>
// </vnic_profile>
// ----
// In case that a specific valid network filter id was given, the VNIC profile will be configured with the given
// network filter regardless of the VNIC profiles's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>user_choice_network_filter</name>
//   <network_filter id= "0000001b-001b-001b-001b-0000000001d5"/>
// </vnic_profile>
// ----
//
type VnicProfilesServiceAddResponse struct {
	profile *VnicProfile
}

func (p *VnicProfilesServiceAddResponse) Profile() (*VnicProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *VnicProfilesServiceAddResponse) MustProfile() *VnicProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a vNIC profile.
// For example to add vNIC profile `123` to network `456` send a request to:
// [source]
// ----
// POST /ovirt-engine/api/networks/456/vnicprofiles
// ----
// With the following body:
// [source,xml]
// ----
// <vnic_profile id="123">
//   <name>new_vNIC_name</name>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
// </vnic_profile>
// ----
// Please note that there is a default network filter to each VNIC profile.
// For more details of how the default network filter is calculated please refer to
// the documentation in <<services/network_filters,NetworkFilters>>.
// NOTE: The automatically created vNIC profile for the external network will be without network filter.
// The output of creating a new VNIC profile depends in the  body  arguments that were given.
// In case no network filter was given, the default network filter will be configured. For example:
// [source,xml]
// ----
// <vnic_profile href="/ovirt-engine/api/vnicprofiles/123" id="123">
//   <name>new_vNIC_name</name>
//   <link href="/ovirt-engine/api/vnicprofiles/123/permissions" rel="permissions"/>
//   <pass_through>
//     <mode>disabled</mode>
//   </pass_through>
//   <port_mirroring>false</port_mirroring>
//   <network href="/ovirt-engine/api/networks/456" id="456"/>
//   <network_filter href="/ovirt-engine/api/networkfilters/789" id="789"/>
// </vnic_profile>
// ----
// In case an empty network filter was given, no network filter will be configured for the specific VNIC profile
// regardless of the VNIC profile's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>no_network_filter</name>
//   <network_filter/>
// </vnic_profile>
// ----
// In case that a specific valid network filter id was given, the VNIC profile will be configured with the given
// network filter regardless of the VNIC profiles's default network filter. For example:
// [source,xml]
// ----
// <vnic_profile>
//   <name>user_choice_network_filter</name>
//   <network_filter id= "0000001b-001b-001b-001b-0000000001d5"/>
// </vnic_profile>
// ----
//
func (p *VnicProfilesService) Add() *VnicProfilesServiceAddRequest {
	return &VnicProfilesServiceAddRequest{VnicProfilesService: p}
}

//
// List all vNIC profiles.
// The order of the returned list of vNIC profiles isn't guaranteed.
//
type VnicProfilesServiceListRequest struct {
	VnicProfilesService *VnicProfilesService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *VnicProfilesServiceListRequest) Header(key, value string) *VnicProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VnicProfilesServiceListRequest) Query(key, value string) *VnicProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VnicProfilesServiceListRequest) Follow(follow string) *VnicProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VnicProfilesServiceListRequest) Max(max int64) *VnicProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *VnicProfilesServiceListRequest) Send() (*VnicProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VnicProfilesService.connection.URL(), p.VnicProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VnicProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VnicProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VnicProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VnicProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VnicProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVnicProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VnicProfilesServiceListResponse{profiles: result}, nil
}

func (p *VnicProfilesServiceListRequest) MustSend() *VnicProfilesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all vNIC profiles.
// The order of the returned list of vNIC profiles isn't guaranteed.
//
type VnicProfilesServiceListResponse struct {
	profiles *VnicProfileSlice
}

func (p *VnicProfilesServiceListResponse) Profiles() (*VnicProfileSlice, bool) {
	if p.profiles != nil {
		return p.profiles, true
	}
	return nil, false
}

func (p *VnicProfilesServiceListResponse) MustProfiles() *VnicProfileSlice {
	if p.profiles == nil {
		panic("profiles in response does not exist")
	}
	return p.profiles
}

//
// List all vNIC profiles.
// The order of the returned list of vNIC profiles isn't guaranteed.
//
func (p *VnicProfilesService) List() *VnicProfilesServiceListRequest {
	return &VnicProfilesServiceListRequest{VnicProfilesService: p}
}

//
//
func (op *VnicProfilesService) ProfileService(id string) *VnicProfileService {
	return NewVnicProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VnicProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *VnicProfilesService) String() string {
	return fmt.Sprintf("VnicProfilesService:%s", op.path)
}

//
//
type DiskSnapshotService struct {
	BaseService
}

func NewDiskSnapshotService(connection *Connection, path string) *DiskSnapshotService {
	var result DiskSnapshotService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type DiskSnapshotServiceGetRequest struct {
	DiskSnapshotService *DiskSnapshotService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *DiskSnapshotServiceGetRequest) Header(key, value string) *DiskSnapshotServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotServiceGetRequest) Query(key, value string) *DiskSnapshotServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotServiceGetRequest) Follow(follow string) *DiskSnapshotServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DiskSnapshotServiceGetRequest) Send() (*DiskSnapshotServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskSnapshotService.connection.URL(), p.DiskSnapshotService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskSnapshotService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskSnapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskSnapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskSnapshotService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskSnapshotService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskSnapshotReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskSnapshotServiceGetResponse{snapshot: result}, nil
}

func (p *DiskSnapshotServiceGetRequest) MustSend() *DiskSnapshotServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type DiskSnapshotServiceGetResponse struct {
	snapshot *DiskSnapshot
}

func (p *DiskSnapshotServiceGetResponse) Snapshot() (*DiskSnapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

func (p *DiskSnapshotServiceGetResponse) MustSnapshot() *DiskSnapshot {
	if p.snapshot == nil {
		panic("snapshot in response does not exist")
	}
	return p.snapshot
}

//
//
func (p *DiskSnapshotService) Get() *DiskSnapshotServiceGetRequest {
	return &DiskSnapshotServiceGetRequest{DiskSnapshotService: p}
}

//
//
type DiskSnapshotServiceRemoveRequest struct {
	DiskSnapshotService *DiskSnapshotService
	header              map[string]string
	query               map[string]string
	async               *bool
}

func (p *DiskSnapshotServiceRemoveRequest) Header(key, value string) *DiskSnapshotServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskSnapshotServiceRemoveRequest) Query(key, value string) *DiskSnapshotServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskSnapshotServiceRemoveRequest) Async(async bool) *DiskSnapshotServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *DiskSnapshotServiceRemoveRequest) Send() (*DiskSnapshotServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskSnapshotService.connection.URL(), p.DiskSnapshotService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskSnapshotService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskSnapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskSnapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskSnapshotService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskSnapshotService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DiskSnapshotServiceRemoveResponse), nil
}

func (p *DiskSnapshotServiceRemoveRequest) MustSend() *DiskSnapshotServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type DiskSnapshotServiceRemoveResponse struct {
}

//
//
func (p *DiskSnapshotService) Remove() *DiskSnapshotServiceRemoveRequest {
	return &DiskSnapshotServiceRemoveRequest{DiskSnapshotService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskSnapshotService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskSnapshotService) String() string {
	return fmt.Sprintf("DiskSnapshotService:%s", op.path)
}

//
// This service manages the attachment of a disk to a template.
//
type TemplateDiskAttachmentService struct {
	BaseService
}

func NewTemplateDiskAttachmentService(connection *Connection, path string) *TemplateDiskAttachmentService {
	var result TemplateDiskAttachmentService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the details of the attachment.
//
type TemplateDiskAttachmentServiceGetRequest struct {
	TemplateDiskAttachmentService *TemplateDiskAttachmentService
	header                        map[string]string
	query                         map[string]string
	follow                        *string
}

func (p *TemplateDiskAttachmentServiceGetRequest) Header(key, value string) *TemplateDiskAttachmentServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceGetRequest) Query(key, value string) *TemplateDiskAttachmentServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceGetRequest) Follow(follow string) *TemplateDiskAttachmentServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *TemplateDiskAttachmentServiceGetRequest) Send() (*TemplateDiskAttachmentServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateDiskAttachmentService.connection.URL(), p.TemplateDiskAttachmentService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateDiskAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateDiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateDiskAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateDiskAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &TemplateDiskAttachmentServiceGetResponse{attachment: result}, nil
}

func (p *TemplateDiskAttachmentServiceGetRequest) MustSend() *TemplateDiskAttachmentServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the details of the attachment.
//
type TemplateDiskAttachmentServiceGetResponse struct {
	attachment *DiskAttachment
}

func (p *TemplateDiskAttachmentServiceGetResponse) Attachment() (*DiskAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *TemplateDiskAttachmentServiceGetResponse) MustAttachment() *DiskAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Returns the details of the attachment.
//
func (p *TemplateDiskAttachmentService) Get() *TemplateDiskAttachmentServiceGetRequest {
	return &TemplateDiskAttachmentServiceGetRequest{TemplateDiskAttachmentService: p}
}

//
// Removes the disk from the template. The disk will only be removed if there are other existing copies of the
// disk on other storage domains.
// A storage domain has to be specified to determine which of the copies should be removed (template disks can
// have copies on multiple storage domains).
// [source]
// ----
// DELETE /ovirt-engine/api/templates/{template:id}/diskattachments/{attachment:id}?storage_domain=072fbaa1-08f3-4a40-9f34-a5ca22dd1d74
// ----
//
type TemplateDiskAttachmentServiceRemoveRequest struct {
	TemplateDiskAttachmentService *TemplateDiskAttachmentService
	header                        map[string]string
	query                         map[string]string
	force                         *bool
	storageDomain                 *string
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Header(key, value string) *TemplateDiskAttachmentServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Query(key, value string) *TemplateDiskAttachmentServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Force(force bool) *TemplateDiskAttachmentServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) StorageDomain(storageDomain string) *TemplateDiskAttachmentServiceRemoveRequest {
	p.storageDomain = &storageDomain
	return p
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) Send() (*TemplateDiskAttachmentServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateDiskAttachmentService.connection.URL(), p.TemplateDiskAttachmentService.path)
	values := make(url.Values)
	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.storageDomain != nil {
		values["storage_domain"] = []string{fmt.Sprintf("%v", *p.storageDomain)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateDiskAttachmentService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateDiskAttachmentService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateDiskAttachmentService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateDiskAttachmentService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateDiskAttachmentService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(TemplateDiskAttachmentServiceRemoveResponse), nil
}

func (p *TemplateDiskAttachmentServiceRemoveRequest) MustSend() *TemplateDiskAttachmentServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the disk from the template. The disk will only be removed if there are other existing copies of the
// disk on other storage domains.
// A storage domain has to be specified to determine which of the copies should be removed (template disks can
// have copies on multiple storage domains).
// [source]
// ----
// DELETE /ovirt-engine/api/templates/{template:id}/diskattachments/{attachment:id}?storage_domain=072fbaa1-08f3-4a40-9f34-a5ca22dd1d74
// ----
//
type TemplateDiskAttachmentServiceRemoveResponse struct {
}

//
// Removes the disk from the template. The disk will only be removed if there are other existing copies of the
// disk on other storage domains.
// A storage domain has to be specified to determine which of the copies should be removed (template disks can
// have copies on multiple storage domains).
// [source]
// ----
// DELETE /ovirt-engine/api/templates/{template:id}/diskattachments/{attachment:id}?storage_domain=072fbaa1-08f3-4a40-9f34-a5ca22dd1d74
// ----
//
func (p *TemplateDiskAttachmentService) Remove() *TemplateDiskAttachmentServiceRemoveRequest {
	return &TemplateDiskAttachmentServiceRemoveRequest{TemplateDiskAttachmentService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDiskAttachmentService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *TemplateDiskAttachmentService) String() string {
	return fmt.Sprintf("TemplateDiskAttachmentService:%s", op.path)
}

//
//
type StorageDomainService struct {
	BaseService
}

func NewStorageDomainService(connection *Connection, path string) *StorageDomainService {
	var result StorageDomainService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the description of the storage domain.
//
type StorageDomainServiceGetRequest struct {
	StorageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	filter               *bool
	follow               *string
}

func (p *StorageDomainServiceGetRequest) Header(key, value string) *StorageDomainServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceGetRequest) Query(key, value string) *StorageDomainServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceGetRequest) Filter(filter bool) *StorageDomainServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *StorageDomainServiceGetRequest) Follow(follow string) *StorageDomainServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *StorageDomainServiceGetRequest) Send() (*StorageDomainServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainService.connection.URL(), p.StorageDomainService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainServiceGetResponse{storageDomain: result}, nil
}

func (p *StorageDomainServiceGetRequest) MustSend() *StorageDomainServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the description of the storage domain.
//
type StorageDomainServiceGetResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainServiceGetResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *StorageDomainServiceGetResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Retrieves the description of the storage domain.
//
func (p *StorageDomainService) Get() *StorageDomainServiceGetRequest {
	return &StorageDomainServiceGetRequest{StorageDomainService: p}
}

//
// Used for querying if the storage domain is already attached to a data center using
// the is_attached boolean field, which is part of the storage server. IMPORTANT:
// Executing this API will cause the host to disconnect from the storage domain.
//
type StorageDomainServiceIsAttachedRequest struct {
	StorageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	host                 *Host
}

func (p *StorageDomainServiceIsAttachedRequest) Header(key, value string) *StorageDomainServiceIsAttachedRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceIsAttachedRequest) Query(key, value string) *StorageDomainServiceIsAttachedRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceIsAttachedRequest) Async(async bool) *StorageDomainServiceIsAttachedRequest {
	p.async = &async
	return p
}

func (p *StorageDomainServiceIsAttachedRequest) Host(host *Host) *StorageDomainServiceIsAttachedRequest {
	p.host = host
	return p
}

func (p *StorageDomainServiceIsAttachedRequest) Send() (*StorageDomainServiceIsAttachedResponse, error) {
	rawURL := fmt.Sprintf("%s%s/isattached", p.StorageDomainService.connection.URL(), p.StorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustIsAttached()
	return &StorageDomainServiceIsAttachedResponse{isAttached: &result}, nil
}

func (p *StorageDomainServiceIsAttachedRequest) MustSend() *StorageDomainServiceIsAttachedResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Used for querying if the storage domain is already attached to a data center using
// the is_attached boolean field, which is part of the storage server. IMPORTANT:
// Executing this API will cause the host to disconnect from the storage domain.
//
type StorageDomainServiceIsAttachedResponse struct {
	isAttached *bool
}

func (p *StorageDomainServiceIsAttachedResponse) IsAttached() (bool, bool) {
	if p.isAttached != nil {
		return *p.isAttached, true
	}
	var zero bool
	return zero, false
}

func (p *StorageDomainServiceIsAttachedResponse) MustIsAttached() bool {
	if p.isAttached == nil {
		panic("isAttached in response does not exist")
	}
	return *p.isAttached
}

//
// Used for querying if the storage domain is already attached to a data center using
// the is_attached boolean field, which is part of the storage server. IMPORTANT:
// Executing this API will cause the host to disconnect from the storage domain.
//
func (p *StorageDomainService) IsAttached() *StorageDomainServiceIsAttachedRequest {
	return &StorageDomainServiceIsAttachedRequest{StorageDomainService: p}
}

//
// This operation reduces logical units from the storage domain.
// In order to do so the data stored on the provided logical units will be moved to other logical units of the
// storage domain and only then they will be reduced from the storage domain.
// For example, in order to reduce two logical units from a storage domain send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/123/reduceluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//  Note that this operation is only applicable to block storage domains (i.e., storage domains with the
//  <<types/storage_type, storage type> of iSCSI or FCP).
//
type StorageDomainServiceReduceLunsRequest struct {
	StorageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	logicalUnits         *LogicalUnitSlice
}

func (p *StorageDomainServiceReduceLunsRequest) Header(key, value string) *StorageDomainServiceReduceLunsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceReduceLunsRequest) Query(key, value string) *StorageDomainServiceReduceLunsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceReduceLunsRequest) LogicalUnits(logicalUnits *LogicalUnitSlice) *StorageDomainServiceReduceLunsRequest {
	p.logicalUnits = logicalUnits
	return p
}

func (p *StorageDomainServiceReduceLunsRequest) LogicalUnitsOfAny(anys ...*LogicalUnit) *StorageDomainServiceReduceLunsRequest {
	if p.logicalUnits == nil {
		p.logicalUnits = new(LogicalUnitSlice)
	}
	p.logicalUnits.slice = append(p.logicalUnits.slice, anys...)
	return p
}

func (p *StorageDomainServiceReduceLunsRequest) Send() (*StorageDomainServiceReduceLunsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reduceluns", p.StorageDomainService.connection.URL(), p.StorageDomainService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.LogicalUnits(p.logicalUnits)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainServiceReduceLunsResponse), nil
}

func (p *StorageDomainServiceReduceLunsRequest) MustSend() *StorageDomainServiceReduceLunsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation reduces logical units from the storage domain.
// In order to do so the data stored on the provided logical units will be moved to other logical units of the
// storage domain and only then they will be reduced from the storage domain.
// For example, in order to reduce two logical units from a storage domain send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/123/reduceluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//  Note that this operation is only applicable to block storage domains (i.e., storage domains with the
//  <<types/storage_type, storage type> of iSCSI or FCP).
//
type StorageDomainServiceReduceLunsResponse struct {
}

//
// This operation reduces logical units from the storage domain.
// In order to do so the data stored on the provided logical units will be moved to other logical units of the
// storage domain and only then they will be reduced from the storage domain.
// For example, in order to reduce two logical units from a storage domain send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/123/reduceluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//  Note that this operation is only applicable to block storage domains (i.e., storage domains with the
//  <<types/storage_type, storage type> of iSCSI or FCP).
//
func (p *StorageDomainService) ReduceLuns() *StorageDomainServiceReduceLunsRequest {
	return &StorageDomainServiceReduceLunsRequest{StorageDomainService: p}
}

//
// This operation refreshes the LUN size.
// After increasing the size of the underlying LUN on the storage server,
// the user can refresh the LUN size.
// This action forces a rescan of the provided LUNs and
// updates the database with the new size, if required.
// For example, in order to refresh the size of two LUNs send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/262b056b-aede-40f1-9666-b883eff59d40/refreshluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//
type StorageDomainServiceRefreshLunsRequest struct {
	StorageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	logicalUnits         *LogicalUnitSlice
}

func (p *StorageDomainServiceRefreshLunsRequest) Header(key, value string) *StorageDomainServiceRefreshLunsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) Query(key, value string) *StorageDomainServiceRefreshLunsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) Async(async bool) *StorageDomainServiceRefreshLunsRequest {
	p.async = &async
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) LogicalUnits(logicalUnits *LogicalUnitSlice) *StorageDomainServiceRefreshLunsRequest {
	p.logicalUnits = logicalUnits
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) LogicalUnitsOfAny(anys ...*LogicalUnit) *StorageDomainServiceRefreshLunsRequest {
	if p.logicalUnits == nil {
		p.logicalUnits = new(LogicalUnitSlice)
	}
	p.logicalUnits.slice = append(p.logicalUnits.slice, anys...)
	return p
}

func (p *StorageDomainServiceRefreshLunsRequest) Send() (*StorageDomainServiceRefreshLunsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refreshluns", p.StorageDomainService.connection.URL(), p.StorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.LogicalUnits(p.logicalUnits)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainServiceRefreshLunsResponse), nil
}

func (p *StorageDomainServiceRefreshLunsRequest) MustSend() *StorageDomainServiceRefreshLunsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation refreshes the LUN size.
// After increasing the size of the underlying LUN on the storage server,
// the user can refresh the LUN size.
// This action forces a rescan of the provided LUNs and
// updates the database with the new size, if required.
// For example, in order to refresh the size of two LUNs send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/262b056b-aede-40f1-9666-b883eff59d40/refreshluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//
type StorageDomainServiceRefreshLunsResponse struct {
}

//
// This operation refreshes the LUN size.
// After increasing the size of the underlying LUN on the storage server,
// the user can refresh the LUN size.
// This action forces a rescan of the provided LUNs and
// updates the database with the new size, if required.
// For example, in order to refresh the size of two LUNs send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/storageDomains/262b056b-aede-40f1-9666-b883eff59d40/refreshluns
// ----
// With a request body like this:
// [source,xml]
// ----
//  <action>
//    <logical_units>
//      <logical_unit id="1IET_00010001"/>
//      <logical_unit id="1IET_00010002"/>
//    </logical_units>
//  </action>
// ----
//
func (p *StorageDomainService) RefreshLuns() *StorageDomainServiceRefreshLunsRequest {
	return &StorageDomainServiceRefreshLunsRequest{StorageDomainService: p}
}

//
// Removes the storage domain.
// Without any special parameters, the storage domain is detached from the system and removed from the database. The
// storage domain can then be imported to the same or to a different setup, with all the data on it. If the storage is
// not accessible the operation will fail.
// If the `destroy` parameter is `true` then the operation will always succeed, even if the storage is not
// accessible, the failure is just ignored and the storage domain is removed from the database anyway.
// If the `format` parameter is `true` then the actual storage is formatted, and the metadata is removed from the
// LUN or directory, so it can no longer be imported to the same or to a different setup.
//
type StorageDomainServiceRemoveRequest struct {
	StorageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	destroy              *bool
	format               *bool
	host                 *string
}

func (p *StorageDomainServiceRemoveRequest) Header(key, value string) *StorageDomainServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceRemoveRequest) Query(key, value string) *StorageDomainServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceRemoveRequest) Async(async bool) *StorageDomainServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *StorageDomainServiceRemoveRequest) Destroy(destroy bool) *StorageDomainServiceRemoveRequest {
	p.destroy = &destroy
	return p
}

func (p *StorageDomainServiceRemoveRequest) Format(format bool) *StorageDomainServiceRemoveRequest {
	p.format = &format
	return p
}

func (p *StorageDomainServiceRemoveRequest) Host(host string) *StorageDomainServiceRemoveRequest {
	p.host = &host
	return p
}

func (p *StorageDomainServiceRemoveRequest) Send() (*StorageDomainServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainService.connection.URL(), p.StorageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.destroy != nil {
		values["destroy"] = []string{fmt.Sprintf("%v", *p.destroy)}
	}

	if p.format != nil {
		values["format"] = []string{fmt.Sprintf("%v", *p.format)}
	}

	if p.host != nil {
		values["host"] = []string{fmt.Sprintf("%v", *p.host)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(StorageDomainServiceRemoveResponse), nil
}

func (p *StorageDomainServiceRemoveRequest) MustSend() *StorageDomainServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the storage domain.
// Without any special parameters, the storage domain is detached from the system and removed from the database. The
// storage domain can then be imported to the same or to a different setup, with all the data on it. If the storage is
// not accessible the operation will fail.
// If the `destroy` parameter is `true` then the operation will always succeed, even if the storage is not
// accessible, the failure is just ignored and the storage domain is removed from the database anyway.
// If the `format` parameter is `true` then the actual storage is formatted, and the metadata is removed from the
// LUN or directory, so it can no longer be imported to the same or to a different setup.
//
type StorageDomainServiceRemoveResponse struct {
}

//
// Removes the storage domain.
// Without any special parameters, the storage domain is detached from the system and removed from the database. The
// storage domain can then be imported to the same or to a different setup, with all the data on it. If the storage is
// not accessible the operation will fail.
// If the `destroy` parameter is `true` then the operation will always succeed, even if the storage is not
// accessible, the failure is just ignored and the storage domain is removed from the database anyway.
// If the `format` parameter is `true` then the actual storage is formatted, and the metadata is removed from the
// LUN or directory, so it can no longer be imported to the same or to a different setup.
//
func (p *StorageDomainService) Remove() *StorageDomainServiceRemoveRequest {
	return &StorageDomainServiceRemoveRequest{StorageDomainService: p}
}

//
// Updates a storage domain.
// Not all of the <<types/storage_domain,StorageDomain>>'s attributes are updatable after creation. Those that can be
// updated are: `name`, `description`, `comment`, `warning_low_space_indicator`, `critical_space_action_blocker` and
// `wipe_after_delete.` (Note that changing the `wipe_after_delete` attribute will not change the wipe after delete
// property of disks that already exist).
// To update the `name` and `wipe_after_delete` attributes of a storage domain with an identifier `123`, send a
// request as follows:
// [source]
// ----
// PUT /ovirt-engine/api/storageDomains/123
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>data2</name>
//   <wipe_after_delete>true</wipe_after_delete>
// </storage_domain>
// ----
//
type StorageDomainServiceUpdateRequest struct {
	StorageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
	storageDomain        *StorageDomain
}

func (p *StorageDomainServiceUpdateRequest) Header(key, value string) *StorageDomainServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceUpdateRequest) Query(key, value string) *StorageDomainServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceUpdateRequest) Async(async bool) *StorageDomainServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *StorageDomainServiceUpdateRequest) StorageDomain(storageDomain *StorageDomain) *StorageDomainServiceUpdateRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *StorageDomainServiceUpdateRequest) Send() (*StorageDomainServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StorageDomainService.connection.URL(), p.StorageDomainService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStorageDomainWriteOne(writer, p.storageDomain, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStorageDomainReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StorageDomainServiceUpdateResponse{storageDomain: result}, nil
}

func (p *StorageDomainServiceUpdateRequest) MustSend() *StorageDomainServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates a storage domain.
// Not all of the <<types/storage_domain,StorageDomain>>'s attributes are updatable after creation. Those that can be
// updated are: `name`, `description`, `comment`, `warning_low_space_indicator`, `critical_space_action_blocker` and
// `wipe_after_delete.` (Note that changing the `wipe_after_delete` attribute will not change the wipe after delete
// property of disks that already exist).
// To update the `name` and `wipe_after_delete` attributes of a storage domain with an identifier `123`, send a
// request as follows:
// [source]
// ----
// PUT /ovirt-engine/api/storageDomains/123
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>data2</name>
//   <wipe_after_delete>true</wipe_after_delete>
// </storage_domain>
// ----
//
type StorageDomainServiceUpdateResponse struct {
	storageDomain *StorageDomain
}

func (p *StorageDomainServiceUpdateResponse) StorageDomain() (*StorageDomain, bool) {
	if p.storageDomain != nil {
		return p.storageDomain, true
	}
	return nil, false
}

func (p *StorageDomainServiceUpdateResponse) MustStorageDomain() *StorageDomain {
	if p.storageDomain == nil {
		panic("storageDomain in response does not exist")
	}
	return p.storageDomain
}

//
// Updates a storage domain.
// Not all of the <<types/storage_domain,StorageDomain>>'s attributes are updatable after creation. Those that can be
// updated are: `name`, `description`, `comment`, `warning_low_space_indicator`, `critical_space_action_blocker` and
// `wipe_after_delete.` (Note that changing the `wipe_after_delete` attribute will not change the wipe after delete
// property of disks that already exist).
// To update the `name` and `wipe_after_delete` attributes of a storage domain with an identifier `123`, send a
// request as follows:
// [source]
// ----
// PUT /ovirt-engine/api/storageDomains/123
// ----
// With a request body as follows:
// [source,xml]
// ----
// <storage_domain>
//   <name>data2</name>
//   <wipe_after_delete>true</wipe_after_delete>
// </storage_domain>
// ----
//
func (p *StorageDomainService) Update() *StorageDomainServiceUpdateRequest {
	return &StorageDomainServiceUpdateRequest{StorageDomainService: p}
}

//
// This operation forces the update of the `OVF_STORE`
// of this storage domain.
// The `OVF_STORE` is a disk image that contains the metadata
// of virtual machines and disks that reside in the
// storage domain. This metadata is used in case the
// domain is imported or exported to or from a different
// data center or a different installation.
// By default the `OVF_STORE` is updated periodically
// (set by default to 60 minutes) but users might want to force an
// update after an important change, or when the they believe the
// `OVF_STORE` is corrupt.
// When initiated by the user, `OVF_STORE` update will be performed whether
// an update is needed or not.
//
type StorageDomainServiceUpdateOvfStoreRequest struct {
	StorageDomainService *StorageDomainService
	header               map[string]string
	query                map[string]string
	async                *bool
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Header(key, value string) *StorageDomainServiceUpdateOvfStoreRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Query(key, value string) *StorageDomainServiceUpdateOvfStoreRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Async(async bool) *StorageDomainServiceUpdateOvfStoreRequest {
	p.async = &async
	return p
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) Send() (*StorageDomainServiceUpdateOvfStoreResponse, error) {
	rawURL := fmt.Sprintf("%s%s/updateovfstore", p.StorageDomainService.connection.URL(), p.StorageDomainService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StorageDomainService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StorageDomainService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StorageDomainService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StorageDomainService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StorageDomainService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(StorageDomainServiceUpdateOvfStoreResponse), nil
}

func (p *StorageDomainServiceUpdateOvfStoreRequest) MustSend() *StorageDomainServiceUpdateOvfStoreResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation forces the update of the `OVF_STORE`
// of this storage domain.
// The `OVF_STORE` is a disk image that contains the metadata
// of virtual machines and disks that reside in the
// storage domain. This metadata is used in case the
// domain is imported or exported to or from a different
// data center or a different installation.
// By default the `OVF_STORE` is updated periodically
// (set by default to 60 minutes) but users might want to force an
// update after an important change, or when the they believe the
// `OVF_STORE` is corrupt.
// When initiated by the user, `OVF_STORE` update will be performed whether
// an update is needed or not.
//
type StorageDomainServiceUpdateOvfStoreResponse struct {
}

//
// This operation forces the update of the `OVF_STORE`
// of this storage domain.
// The `OVF_STORE` is a disk image that contains the metadata
// of virtual machines and disks that reside in the
// storage domain. This metadata is used in case the
// domain is imported or exported to or from a different
// data center or a different installation.
// By default the `OVF_STORE` is updated periodically
// (set by default to 60 minutes) but users might want to force an
// update after an important change, or when the they believe the
// `OVF_STORE` is corrupt.
// When initiated by the user, `OVF_STORE` update will be performed whether
// an update is needed or not.
//
func (p *StorageDomainService) UpdateOvfStore() *StorageDomainServiceUpdateOvfStoreRequest {
	return &StorageDomainServiceUpdateOvfStoreRequest{StorageDomainService: p}
}

//
//
func (op *StorageDomainService) DiskProfilesService() *AssignedDiskProfilesService {
	return NewAssignedDiskProfilesService(op.connection, fmt.Sprintf("%s/diskprofiles", op.path))
}

//
//
func (op *StorageDomainService) DiskSnapshotsService() *DiskSnapshotsService {
	return NewDiskSnapshotsService(op.connection, fmt.Sprintf("%s/disksnapshots", op.path))
}

//
// Reference to the service that manages the disks available in the storage domain.
//
func (op *StorageDomainService) DisksService() *StorageDomainDisksService {
	return NewStorageDomainDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Returns a reference to the service that manages the files available in the storage domain.
//
func (op *StorageDomainService) FilesService() *FilesService {
	return NewFilesService(op.connection, fmt.Sprintf("%s/files", op.path))
}

//
//
func (op *StorageDomainService) ImagesService() *ImagesService {
	return NewImagesService(op.connection, fmt.Sprintf("%s/images", op.path))
}

//
//
func (op *StorageDomainService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
// Returns a reference to the service that manages the storage connections.
//
func (op *StorageDomainService) StorageConnectionsService() *StorageDomainServerConnectionsService {
	return NewStorageDomainServerConnectionsService(op.connection, fmt.Sprintf("%s/storageconnections", op.path))
}

//
//
func (op *StorageDomainService) TemplatesService() *StorageDomainTemplatesService {
	return NewStorageDomainTemplatesService(op.connection, fmt.Sprintf("%s/templates", op.path))
}

//
//
func (op *StorageDomainService) VmsService() *StorageDomainVmsService {
	return NewStorageDomainVmsService(op.connection, fmt.Sprintf("%s/vms", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StorageDomainService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "diskprofiles" {
		return op.DiskProfilesService(), nil
	}
	if strings.HasPrefix(path, "diskprofiles/") {
		return op.DiskProfilesService().Service(path[13:])
	}
	if path == "disksnapshots" {
		return op.DiskSnapshotsService(), nil
	}
	if strings.HasPrefix(path, "disksnapshots/") {
		return op.DiskSnapshotsService().Service(path[14:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "files" {
		return op.FilesService(), nil
	}
	if strings.HasPrefix(path, "files/") {
		return op.FilesService().Service(path[6:])
	}
	if path == "images" {
		return op.ImagesService(), nil
	}
	if strings.HasPrefix(path, "images/") {
		return op.ImagesService().Service(path[7:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "storageconnections" {
		return op.StorageConnectionsService(), nil
	}
	if strings.HasPrefix(path, "storageconnections/") {
		return op.StorageConnectionsService().Service(path[19:])
	}
	if path == "templates" {
		return op.TemplatesService(), nil
	}
	if strings.HasPrefix(path, "templates/") {
		return op.TemplatesService().Service(path[10:])
	}
	if path == "vms" {
		return op.VmsService(), nil
	}
	if strings.HasPrefix(path, "vms/") {
		return op.VmsService().Service(path[4:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *StorageDomainService) String() string {
	return fmt.Sprintf("StorageDomainService:%s", op.path)
}

//
//
type VmService struct {
	BaseService
}

func NewVmService(connection *Connection, path string) *VmService {
	var result VmService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation stops any migration of a virtual machine to another physical host.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/cancelmigration
// ----
// The cancel migration action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceCancelMigrationRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceCancelMigrationRequest) Header(key, value string) *VmServiceCancelMigrationRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCancelMigrationRequest) Query(key, value string) *VmServiceCancelMigrationRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCancelMigrationRequest) Async(async bool) *VmServiceCancelMigrationRequest {
	p.async = &async
	return p
}

func (p *VmServiceCancelMigrationRequest) Send() (*VmServiceCancelMigrationResponse, error) {
	rawURL := fmt.Sprintf("%s%s/cancelmigration", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceCancelMigrationResponse), nil
}

func (p *VmServiceCancelMigrationRequest) MustSend() *VmServiceCancelMigrationResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation stops any migration of a virtual machine to another physical host.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/cancelmigration
// ----
// The cancel migration action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceCancelMigrationResponse struct {
}

//
// This operation stops any migration of a virtual machine to another physical host.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/cancelmigration
// ----
// The cancel migration action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) CancelMigration() *VmServiceCancelMigrationRequest {
	return &VmServiceCancelMigrationRequest{VmService: p}
}

//
//
type VmServiceCloneRequest struct {
	VmService        *VmService
	header           map[string]string
	query            map[string]string
	async            *bool
	discardSnapshots *bool
	storageDomain    *StorageDomain
	vm               *Vm
}

func (p *VmServiceCloneRequest) Header(key, value string) *VmServiceCloneRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCloneRequest) Query(key, value string) *VmServiceCloneRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCloneRequest) Async(async bool) *VmServiceCloneRequest {
	p.async = &async
	return p
}

func (p *VmServiceCloneRequest) DiscardSnapshots(discardSnapshots bool) *VmServiceCloneRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}

func (p *VmServiceCloneRequest) StorageDomain(storageDomain *StorageDomain) *VmServiceCloneRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *VmServiceCloneRequest) Vm(vm *Vm) *VmServiceCloneRequest {
	p.vm = vm
	return p
}

func (p *VmServiceCloneRequest) Send() (*VmServiceCloneResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clone", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceCloneResponse), nil
}

func (p *VmServiceCloneRequest) MustSend() *VmServiceCloneResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmServiceCloneResponse struct {
}

//
//
func (p *VmService) Clone() *VmServiceCloneRequest {
	return &VmServiceCloneRequest{VmService: p}
}

//
// Permanently restores the virtual machine to the state of the previewed snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
type VmServiceCommitSnapshotRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceCommitSnapshotRequest) Header(key, value string) *VmServiceCommitSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceCommitSnapshotRequest) Query(key, value string) *VmServiceCommitSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceCommitSnapshotRequest) Async(async bool) *VmServiceCommitSnapshotRequest {
	p.async = &async
	return p
}

func (p *VmServiceCommitSnapshotRequest) Send() (*VmServiceCommitSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/commitsnapshot", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceCommitSnapshotResponse), nil
}

func (p *VmServiceCommitSnapshotRequest) MustSend() *VmServiceCommitSnapshotResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Permanently restores the virtual machine to the state of the previewed snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
type VmServiceCommitSnapshotResponse struct {
}

//
// Permanently restores the virtual machine to the state of the previewed snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
func (p *VmService) CommitSnapshot() *VmServiceCommitSnapshotRequest {
	return &VmServiceCommitSnapshotRequest{VmService: p}
}

//
// Detaches a virtual machine from a pool.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/detach
// ----
// The detach action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceDetachRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceDetachRequest) Header(key, value string) *VmServiceDetachRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceDetachRequest) Query(key, value string) *VmServiceDetachRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceDetachRequest) Async(async bool) *VmServiceDetachRequest {
	p.async = &async
	return p
}

func (p *VmServiceDetachRequest) Send() (*VmServiceDetachResponse, error) {
	rawURL := fmt.Sprintf("%s%s/detach", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceDetachResponse), nil
}

func (p *VmServiceDetachRequest) MustSend() *VmServiceDetachResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Detaches a virtual machine from a pool.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/detach
// ----
// The detach action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceDetachResponse struct {
}

//
// Detaches a virtual machine from a pool.
// [source]
// ----
// POST /ovirt-engine/api/vms/123/detach
// ----
// The detach action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) Detach() *VmServiceDetachRequest {
	return &VmServiceDetachRequest{VmService: p}
}

//
// Exports the virtual machine.
// A virtual machine can be exported to an export domain.
// For example, to export virtual machine `123` to the export domain `myexport`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <exclusive>true</exclusive>
//   <discard_snapshots>true</discard_snapshots>
// </action>
// ----
// Since version 4.2 of the engine it is also possible to export a virtual machine as a virtual appliance (OVA).
// For example, to export virtual machine `123` as an OVA file named `myvm.ova` that is placed in the directory `/home/ovirt/` on host `myhost`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <host>
//     <name>myhost</name>
//   </host>
//   <directory>/home/ovirt</directory>
//   <filename>myvm.ova</filename>
// </action>
// ----
//
type VmServiceExportRequest struct {
	VmService        *VmService
	header           map[string]string
	query            map[string]string
	async            *bool
	discardSnapshots *bool
	exclusive        *bool
	storageDomain    *StorageDomain
}

func (p *VmServiceExportRequest) Header(key, value string) *VmServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceExportRequest) Query(key, value string) *VmServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceExportRequest) Async(async bool) *VmServiceExportRequest {
	p.async = &async
	return p
}

func (p *VmServiceExportRequest) DiscardSnapshots(discardSnapshots bool) *VmServiceExportRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}

func (p *VmServiceExportRequest) Exclusive(exclusive bool) *VmServiceExportRequest {
	p.exclusive = &exclusive
	return p
}

func (p *VmServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *VmServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *VmServiceExportRequest) Send() (*VmServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceExportResponse), nil
}

func (p *VmServiceExportRequest) MustSend() *VmServiceExportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports the virtual machine.
// A virtual machine can be exported to an export domain.
// For example, to export virtual machine `123` to the export domain `myexport`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <exclusive>true</exclusive>
//   <discard_snapshots>true</discard_snapshots>
// </action>
// ----
// Since version 4.2 of the engine it is also possible to export a virtual machine as a virtual appliance (OVA).
// For example, to export virtual machine `123` as an OVA file named `myvm.ova` that is placed in the directory `/home/ovirt/` on host `myhost`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <host>
//     <name>myhost</name>
//   </host>
//   <directory>/home/ovirt</directory>
//   <filename>myvm.ova</filename>
// </action>
// ----
//
type VmServiceExportResponse struct {
}

//
// Exports the virtual machine.
// A virtual machine can be exported to an export domain.
// For example, to export virtual machine `123` to the export domain `myexport`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain>
//     <name>myexport</name>
//   </storage_domain>
//   <exclusive>true</exclusive>
//   <discard_snapshots>true</discard_snapshots>
// </action>
// ----
// Since version 4.2 of the engine it is also possible to export a virtual machine as a virtual appliance (OVA).
// For example, to export virtual machine `123` as an OVA file named `myvm.ova` that is placed in the directory `/home/ovirt/` on host `myhost`:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/export
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <host>
//     <name>myhost</name>
//   </host>
//   <directory>/home/ovirt</directory>
//   <filename>myvm.ova</filename>
// </action>
// ----
//
func (p *VmService) Export() *VmServiceExportRequest {
	return &VmServiceExportRequest{VmService: p}
}

//
// Freezes virtual machine file systems.
// This operation freezes a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of
// a running virtual machine. Normally, this is done automatically by the manager, but this must be executed
// manually with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/freezefilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceFreezeFilesystemsRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceFreezeFilesystemsRequest) Header(key, value string) *VmServiceFreezeFilesystemsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceFreezeFilesystemsRequest) Query(key, value string) *VmServiceFreezeFilesystemsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceFreezeFilesystemsRequest) Async(async bool) *VmServiceFreezeFilesystemsRequest {
	p.async = &async
	return p
}

func (p *VmServiceFreezeFilesystemsRequest) Send() (*VmServiceFreezeFilesystemsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/freezefilesystems", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceFreezeFilesystemsResponse), nil
}

func (p *VmServiceFreezeFilesystemsRequest) MustSend() *VmServiceFreezeFilesystemsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Freezes virtual machine file systems.
// This operation freezes a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of
// a running virtual machine. Normally, this is done automatically by the manager, but this must be executed
// manually with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/freezefilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceFreezeFilesystemsResponse struct {
}

//
// Freezes virtual machine file systems.
// This operation freezes a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of
// a running virtual machine. Normally, this is done automatically by the manager, but this must be executed
// manually with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/freezefilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) FreezeFilesystems() *VmServiceFreezeFilesystemsRequest {
	return &VmServiceFreezeFilesystemsRequest{VmService: p}
}

//
// Retrieves the description of the virtual machine.
//
type VmServiceGetRequest struct {
	VmService  *VmService
	header     map[string]string
	query      map[string]string
	allContent *bool
	filter     *bool
	follow     *string
	nextRun    *bool
}

func (p *VmServiceGetRequest) Header(key, value string) *VmServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceGetRequest) Query(key, value string) *VmServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceGetRequest) AllContent(allContent bool) *VmServiceGetRequest {
	p.allContent = &allContent
	return p
}

func (p *VmServiceGetRequest) Filter(filter bool) *VmServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *VmServiceGetRequest) Follow(follow string) *VmServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmServiceGetRequest) NextRun(nextRun bool) *VmServiceGetRequest {
	p.nextRun = &nextRun
	return p
}

func (p *VmServiceGetRequest) Send() (*VmServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmService.connection.URL(), p.VmService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.nextRun != nil {
		values["next_run"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmServiceGetResponse{vm: result}, nil
}

func (p *VmServiceGetRequest) MustSend() *VmServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the description of the virtual machine.
//
type VmServiceGetResponse struct {
	vm *Vm
}

func (p *VmServiceGetResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *VmServiceGetResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Retrieves the description of the virtual machine.
//
func (p *VmService) Get() *VmServiceGetRequest {
	return &VmServiceGetRequest{VmService: p}
}

//
// Initiates the automatic user logon to access a virtual machine from an external console.
// This action requires the `ovirt-guest-agent-gdm-plugin` and the `ovirt-guest-agent-pam-module` packages to be
// installed and the `ovirt-guest-agent` service to be running on the virtual machine.
// Users require the appropriate user permissions for the virtual machine in order to access the virtual machine
// from an external console.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/logon
// ----
// Request body:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceLogonRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceLogonRequest) Header(key, value string) *VmServiceLogonRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceLogonRequest) Query(key, value string) *VmServiceLogonRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceLogonRequest) Async(async bool) *VmServiceLogonRequest {
	p.async = &async
	return p
}

func (p *VmServiceLogonRequest) Send() (*VmServiceLogonResponse, error) {
	rawURL := fmt.Sprintf("%s%s/logon", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceLogonResponse), nil
}

func (p *VmServiceLogonRequest) MustSend() *VmServiceLogonResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Initiates the automatic user logon to access a virtual machine from an external console.
// This action requires the `ovirt-guest-agent-gdm-plugin` and the `ovirt-guest-agent-pam-module` packages to be
// installed and the `ovirt-guest-agent` service to be running on the virtual machine.
// Users require the appropriate user permissions for the virtual machine in order to access the virtual machine
// from an external console.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/logon
// ----
// Request body:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceLogonResponse struct {
}

//
// Initiates the automatic user logon to access a virtual machine from an external console.
// This action requires the `ovirt-guest-agent-gdm-plugin` and the `ovirt-guest-agent-pam-module` packages to be
// installed and the `ovirt-guest-agent` service to be running on the virtual machine.
// Users require the appropriate user permissions for the virtual machine in order to access the virtual machine
// from an external console.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/logon
// ----
// Request body:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) Logon() *VmServiceLogonRequest {
	return &VmServiceLogonRequest{VmService: p}
}

//
// Sets the global maintenance mode on the hosted engine virtual machine.
// This action has no effect on other virtual machines.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/maintenance
// ----
// [source,xml]
// ----
// <action>
//   <maintenance_enabled>true<maintenance_enabled/>
// </action>
// ----
//
type VmServiceMaintenanceRequest struct {
	VmService          *VmService
	header             map[string]string
	query              map[string]string
	async              *bool
	maintenanceEnabled *bool
}

func (p *VmServiceMaintenanceRequest) Header(key, value string) *VmServiceMaintenanceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceMaintenanceRequest) Query(key, value string) *VmServiceMaintenanceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceMaintenanceRequest) Async(async bool) *VmServiceMaintenanceRequest {
	p.async = &async
	return p
}

func (p *VmServiceMaintenanceRequest) MaintenanceEnabled(maintenanceEnabled bool) *VmServiceMaintenanceRequest {
	p.maintenanceEnabled = &maintenanceEnabled
	return p
}

func (p *VmServiceMaintenanceRequest) Send() (*VmServiceMaintenanceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/maintenance", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.maintenanceEnabled != nil {
		actionBuilder.MaintenanceEnabled(*p.maintenanceEnabled)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceMaintenanceResponse), nil
}

func (p *VmServiceMaintenanceRequest) MustSend() *VmServiceMaintenanceResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Sets the global maintenance mode on the hosted engine virtual machine.
// This action has no effect on other virtual machines.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/maintenance
// ----
// [source,xml]
// ----
// <action>
//   <maintenance_enabled>true<maintenance_enabled/>
// </action>
// ----
//
type VmServiceMaintenanceResponse struct {
}

//
// Sets the global maintenance mode on the hosted engine virtual machine.
// This action has no effect on other virtual machines.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/maintenance
// ----
// [source,xml]
// ----
// <action>
//   <maintenance_enabled>true<maintenance_enabled/>
// </action>
// ----
//
func (p *VmService) Maintenance() *VmServiceMaintenanceRequest {
	return &VmServiceMaintenanceRequest{VmService: p}
}

//
// Migrates a virtual machine to another physical host.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/migrate
// ----
// To specify a specific host to migrate the virtual machine to:
// [source,xml]
// ----
// <action>
//   <host id="2ab5e1da-b726-4274-bbf7-0a42b16a0fc3"/>
// </action>
// ----
//
type VmServiceMigrateRequest struct {
	VmService                   *VmService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
	cluster                     *Cluster
	force                       *bool
	host                        *Host
	migrateVmsInAffinityClosure *bool
}

func (p *VmServiceMigrateRequest) Header(key, value string) *VmServiceMigrateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceMigrateRequest) Query(key, value string) *VmServiceMigrateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceMigrateRequest) Async(async bool) *VmServiceMigrateRequest {
	p.async = &async
	return p
}

func (p *VmServiceMigrateRequest) Cluster(cluster *Cluster) *VmServiceMigrateRequest {
	p.cluster = cluster
	return p
}

func (p *VmServiceMigrateRequest) Force(force bool) *VmServiceMigrateRequest {
	p.force = &force
	return p
}

func (p *VmServiceMigrateRequest) Host(host *Host) *VmServiceMigrateRequest {
	p.host = host
	return p
}

func (p *VmServiceMigrateRequest) MigrateVmsInAffinityClosure(migrateVmsInAffinityClosure bool) *VmServiceMigrateRequest {
	p.migrateVmsInAffinityClosure = &migrateVmsInAffinityClosure
	return p
}

func (p *VmServiceMigrateRequest) Send() (*VmServiceMigrateResponse, error) {
	rawURL := fmt.Sprintf("%s%s/migrate", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Cluster(p.cluster)
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	actionBuilder.Host(p.host)
	if p.migrateVmsInAffinityClosure != nil {
		actionBuilder.MigrateVmsInAffinityClosure(*p.migrateVmsInAffinityClosure)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceMigrateResponse), nil
}

func (p *VmServiceMigrateRequest) MustSend() *VmServiceMigrateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Migrates a virtual machine to another physical host.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/migrate
// ----
// To specify a specific host to migrate the virtual machine to:
// [source,xml]
// ----
// <action>
//   <host id="2ab5e1da-b726-4274-bbf7-0a42b16a0fc3"/>
// </action>
// ----
//
type VmServiceMigrateResponse struct {
}

//
// Migrates a virtual machine to another physical host.
// Example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/migrate
// ----
// To specify a specific host to migrate the virtual machine to:
// [source,xml]
// ----
// <action>
//   <host id="2ab5e1da-b726-4274-bbf7-0a42b16a0fc3"/>
// </action>
// ----
//
func (p *VmService) Migrate() *VmServiceMigrateRequest {
	return &VmServiceMigrateRequest{VmService: p}
}

//
// Temporarily restores the virtual machine to the state of a snapshot.
// The snapshot is indicated with the `snapshot.id` parameter. It is restored temporarily, so that the content can
// be inspected. Once that inspection is finished, the state of the virtual machine can be made permanent, using the
// <<services/vm/methods/commit_snapshot, commit_snapshot>> method, or discarded using the
// <<services/vm/methods/undo_snapshot, undo_snapshot>> method.
//
type VmServicePreviewSnapshotRequest struct {
	VmService     *VmService
	header        map[string]string
	query         map[string]string
	async         *bool
	disks         *DiskSlice
	lease         *StorageDomainLease
	restoreMemory *bool
	snapshot      *Snapshot
	vm            *Vm
}

func (p *VmServicePreviewSnapshotRequest) Header(key, value string) *VmServicePreviewSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServicePreviewSnapshotRequest) Query(key, value string) *VmServicePreviewSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServicePreviewSnapshotRequest) Async(async bool) *VmServicePreviewSnapshotRequest {
	p.async = &async
	return p
}

func (p *VmServicePreviewSnapshotRequest) Disks(disks *DiskSlice) *VmServicePreviewSnapshotRequest {
	p.disks = disks
	return p
}

func (p *VmServicePreviewSnapshotRequest) DisksOfAny(anys ...*Disk) *VmServicePreviewSnapshotRequest {
	if p.disks == nil {
		p.disks = new(DiskSlice)
	}
	p.disks.slice = append(p.disks.slice, anys...)
	return p
}

func (p *VmServicePreviewSnapshotRequest) Lease(lease *StorageDomainLease) *VmServicePreviewSnapshotRequest {
	p.lease = lease
	return p
}

func (p *VmServicePreviewSnapshotRequest) RestoreMemory(restoreMemory bool) *VmServicePreviewSnapshotRequest {
	p.restoreMemory = &restoreMemory
	return p
}

func (p *VmServicePreviewSnapshotRequest) Snapshot(snapshot *Snapshot) *VmServicePreviewSnapshotRequest {
	p.snapshot = snapshot
	return p
}

func (p *VmServicePreviewSnapshotRequest) Vm(vm *Vm) *VmServicePreviewSnapshotRequest {
	p.vm = vm
	return p
}

func (p *VmServicePreviewSnapshotRequest) Send() (*VmServicePreviewSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/previewsnapshot", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disks(p.disks)
	actionBuilder.Lease(p.lease)
	if p.restoreMemory != nil {
		actionBuilder.RestoreMemory(*p.restoreMemory)
	}
	actionBuilder.Snapshot(p.snapshot)
	actionBuilder.Vm(p.vm)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServicePreviewSnapshotResponse), nil
}

func (p *VmServicePreviewSnapshotRequest) MustSend() *VmServicePreviewSnapshotResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Temporarily restores the virtual machine to the state of a snapshot.
// The snapshot is indicated with the `snapshot.id` parameter. It is restored temporarily, so that the content can
// be inspected. Once that inspection is finished, the state of the virtual machine can be made permanent, using the
// <<services/vm/methods/commit_snapshot, commit_snapshot>> method, or discarded using the
// <<services/vm/methods/undo_snapshot, undo_snapshot>> method.
//
type VmServicePreviewSnapshotResponse struct {
}

//
// Temporarily restores the virtual machine to the state of a snapshot.
// The snapshot is indicated with the `snapshot.id` parameter. It is restored temporarily, so that the content can
// be inspected. Once that inspection is finished, the state of the virtual machine can be made permanent, using the
// <<services/vm/methods/commit_snapshot, commit_snapshot>> method, or discarded using the
// <<services/vm/methods/undo_snapshot, undo_snapshot>> method.
//
func (p *VmService) PreviewSnapshot() *VmServicePreviewSnapshotRequest {
	return &VmServicePreviewSnapshotRequest{VmService: p}
}

//
// Sends a reboot request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/reboot
// ----
// The reboot action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceRebootRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceRebootRequest) Header(key, value string) *VmServiceRebootRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceRebootRequest) Query(key, value string) *VmServiceRebootRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceRebootRequest) Async(async bool) *VmServiceRebootRequest {
	p.async = &async
	return p
}

func (p *VmServiceRebootRequest) Send() (*VmServiceRebootResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reboot", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceRebootResponse), nil
}

func (p *VmServiceRebootRequest) MustSend() *VmServiceRebootResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Sends a reboot request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/reboot
// ----
// The reboot action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceRebootResponse struct {
}

//
// Sends a reboot request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/reboot
// ----
// The reboot action does not take any action specific parameters; therefore, the request body should contain an
// empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) Reboot() *VmServiceRebootRequest {
	return &VmServiceRebootRequest{VmService: p}
}

//
// Removes the virtual machine, including the virtual disks attached to it.
// For example, to remove the virtual machine with identifier `123`:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123
// ----
//
type VmServiceRemoveRequest struct {
	VmService  *VmService
	header     map[string]string
	query      map[string]string
	async      *bool
	detachOnly *bool
	force      *bool
}

func (p *VmServiceRemoveRequest) Header(key, value string) *VmServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceRemoveRequest) Query(key, value string) *VmServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceRemoveRequest) Async(async bool) *VmServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *VmServiceRemoveRequest) DetachOnly(detachOnly bool) *VmServiceRemoveRequest {
	p.detachOnly = &detachOnly
	return p
}

func (p *VmServiceRemoveRequest) Force(force bool) *VmServiceRemoveRequest {
	p.force = &force
	return p
}

func (p *VmServiceRemoveRequest) Send() (*VmServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmService.connection.URL(), p.VmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.detachOnly != nil {
		values["detach_only"] = []string{fmt.Sprintf("%v", *p.detachOnly)}
	}

	if p.force != nil {
		values["force"] = []string{fmt.Sprintf("%v", *p.force)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(VmServiceRemoveResponse), nil
}

func (p *VmServiceRemoveRequest) MustSend() *VmServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the virtual machine, including the virtual disks attached to it.
// For example, to remove the virtual machine with identifier `123`:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123
// ----
//
type VmServiceRemoveResponse struct {
}

//
// Removes the virtual machine, including the virtual disks attached to it.
// For example, to remove the virtual machine with identifier `123`:
// [source]
// ----
// DELETE /ovirt-engine/api/vms/123
// ----
//
func (p *VmService) Remove() *VmServiceRemoveRequest {
	return &VmServiceRemoveRequest{VmService: p}
}

//
//
type VmServiceReorderMacAddressesRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceReorderMacAddressesRequest) Header(key, value string) *VmServiceReorderMacAddressesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceReorderMacAddressesRequest) Query(key, value string) *VmServiceReorderMacAddressesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceReorderMacAddressesRequest) Async(async bool) *VmServiceReorderMacAddressesRequest {
	p.async = &async
	return p
}

func (p *VmServiceReorderMacAddressesRequest) Send() (*VmServiceReorderMacAddressesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reordermacaddresses", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceReorderMacAddressesResponse), nil
}

func (p *VmServiceReorderMacAddressesRequest) MustSend() *VmServiceReorderMacAddressesResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmServiceReorderMacAddressesResponse struct {
}

//
//
func (p *VmService) ReorderMacAddresses() *VmServiceReorderMacAddressesRequest {
	return &VmServiceReorderMacAddressesRequest{VmService: p}
}

//
// This operation sends a shutdown request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/shutdown
// ----
// The shutdown action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceShutdownRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	reason    *string
}

func (p *VmServiceShutdownRequest) Header(key, value string) *VmServiceShutdownRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceShutdownRequest) Query(key, value string) *VmServiceShutdownRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceShutdownRequest) Async(async bool) *VmServiceShutdownRequest {
	p.async = &async
	return p
}

func (p *VmServiceShutdownRequest) Reason(reason string) *VmServiceShutdownRequest {
	p.reason = &reason
	return p
}

func (p *VmServiceShutdownRequest) Send() (*VmServiceShutdownResponse, error) {
	rawURL := fmt.Sprintf("%s%s/shutdown", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.reason != nil {
		actionBuilder.Reason(*p.reason)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceShutdownResponse), nil
}

func (p *VmServiceShutdownRequest) MustSend() *VmServiceShutdownResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation sends a shutdown request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/shutdown
// ----
// The shutdown action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceShutdownResponse struct {
}

//
// This operation sends a shutdown request to a virtual machine.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/shutdown
// ----
// The shutdown action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) Shutdown() *VmServiceShutdownRequest {
	return &VmServiceShutdownRequest{VmService: p}
}

//
// Starts the virtual machine.
// If the virtual environment is complete and the virtual machine contains all necessary components to function,
// it can be started.
// This example starts the virtual machine:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/start
// ----
// With a request body:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceStartRequest struct {
	VmService         *VmService
	header            map[string]string
	query             map[string]string
	async             *bool
	authorizedKey     *AuthorizedKey
	filter            *bool
	pause             *bool
	useCloudInit      *bool
	useIgnition       *bool
	useInitialization *bool
	useSysprep        *bool
	vm                *Vm
	volatile          *bool
}

func (p *VmServiceStartRequest) Header(key, value string) *VmServiceStartRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceStartRequest) Query(key, value string) *VmServiceStartRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceStartRequest) Async(async bool) *VmServiceStartRequest {
	p.async = &async
	return p
}

func (p *VmServiceStartRequest) AuthorizedKey(authorizedKey *AuthorizedKey) *VmServiceStartRequest {
	p.authorizedKey = authorizedKey
	return p
}

func (p *VmServiceStartRequest) Filter(filter bool) *VmServiceStartRequest {
	p.filter = &filter
	return p
}

func (p *VmServiceStartRequest) Pause(pause bool) *VmServiceStartRequest {
	p.pause = &pause
	return p
}

func (p *VmServiceStartRequest) UseCloudInit(useCloudInit bool) *VmServiceStartRequest {
	p.useCloudInit = &useCloudInit
	return p
}

func (p *VmServiceStartRequest) UseIgnition(useIgnition bool) *VmServiceStartRequest {
	p.useIgnition = &useIgnition
	return p
}

func (p *VmServiceStartRequest) UseInitialization(useInitialization bool) *VmServiceStartRequest {
	p.useInitialization = &useInitialization
	return p
}

func (p *VmServiceStartRequest) UseSysprep(useSysprep bool) *VmServiceStartRequest {
	p.useSysprep = &useSysprep
	return p
}

func (p *VmServiceStartRequest) Vm(vm *Vm) *VmServiceStartRequest {
	p.vm = vm
	return p
}

func (p *VmServiceStartRequest) Volatile(volatile bool) *VmServiceStartRequest {
	p.volatile = &volatile
	return p
}

func (p *VmServiceStartRequest) Send() (*VmServiceStartResponse, error) {
	rawURL := fmt.Sprintf("%s%s/start", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.AuthorizedKey(p.authorizedKey)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	if p.pause != nil {
		actionBuilder.Pause(*p.pause)
	}
	if p.useCloudInit != nil {
		actionBuilder.UseCloudInit(*p.useCloudInit)
	}
	if p.useIgnition != nil {
		actionBuilder.UseIgnition(*p.useIgnition)
	}
	if p.useInitialization != nil {
		actionBuilder.UseInitialization(*p.useInitialization)
	}
	if p.useSysprep != nil {
		actionBuilder.UseSysprep(*p.useSysprep)
	}
	actionBuilder.Vm(p.vm)
	if p.volatile != nil {
		actionBuilder.Volatile(*p.volatile)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceStartResponse), nil
}

func (p *VmServiceStartRequest) MustSend() *VmServiceStartResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Starts the virtual machine.
// If the virtual environment is complete and the virtual machine contains all necessary components to function,
// it can be started.
// This example starts the virtual machine:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/start
// ----
// With a request body:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceStartResponse struct {
}

//
// Starts the virtual machine.
// If the virtual environment is complete and the virtual machine contains all necessary components to function,
// it can be started.
// This example starts the virtual machine:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/start
// ----
// With a request body:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) Start() *VmServiceStartRequest {
	return &VmServiceStartRequest{VmService: p}
}

//
// This operation forces a virtual machine to power-off.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/stop
// ----
// The stop action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceStopRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	reason    *string
}

func (p *VmServiceStopRequest) Header(key, value string) *VmServiceStopRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceStopRequest) Query(key, value string) *VmServiceStopRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceStopRequest) Async(async bool) *VmServiceStopRequest {
	p.async = &async
	return p
}

func (p *VmServiceStopRequest) Reason(reason string) *VmServiceStopRequest {
	p.reason = &reason
	return p
}

func (p *VmServiceStopRequest) Send() (*VmServiceStopResponse, error) {
	rawURL := fmt.Sprintf("%s%s/stop", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.reason != nil {
		actionBuilder.Reason(*p.reason)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceStopResponse), nil
}

func (p *VmServiceStopRequest) MustSend() *VmServiceStopResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation forces a virtual machine to power-off.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/stop
// ----
// The stop action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceStopResponse struct {
}

//
// This operation forces a virtual machine to power-off.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/stop
// ----
// The stop action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) Stop() *VmServiceStopRequest {
	return &VmServiceStopRequest{VmService: p}
}

//
// This operation saves the virtual machine state to disk and stops it.
// Start a suspended virtual machine and restore the virtual machine state with the start action.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/suspend
// ----
// The suspend action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceSuspendRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceSuspendRequest) Header(key, value string) *VmServiceSuspendRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceSuspendRequest) Query(key, value string) *VmServiceSuspendRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceSuspendRequest) Async(async bool) *VmServiceSuspendRequest {
	p.async = &async
	return p
}

func (p *VmServiceSuspendRequest) Send() (*VmServiceSuspendResponse, error) {
	rawURL := fmt.Sprintf("%s%s/suspend", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceSuspendResponse), nil
}

func (p *VmServiceSuspendRequest) MustSend() *VmServiceSuspendResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation saves the virtual machine state to disk and stops it.
// Start a suspended virtual machine and restore the virtual machine state with the start action.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/suspend
// ----
// The suspend action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceSuspendResponse struct {
}

//
// This operation saves the virtual machine state to disk and stops it.
// Start a suspended virtual machine and restore the virtual machine state with the start action.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/suspend
// ----
// The suspend action does not take any action specific parameters;
// therefore, the request body should contain an empty `action`:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) Suspend() *VmServiceSuspendRequest {
	return &VmServiceSuspendRequest{VmService: p}
}

//
// Thaws virtual machine file systems.
// This operation thaws a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of a
// running virtual machine. Normally, this is done automatically by the manager, but this must be executed manually
// with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /api/vms/123/thawfilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceThawFilesystemsRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceThawFilesystemsRequest) Header(key, value string) *VmServiceThawFilesystemsRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceThawFilesystemsRequest) Query(key, value string) *VmServiceThawFilesystemsRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceThawFilesystemsRequest) Async(async bool) *VmServiceThawFilesystemsRequest {
	p.async = &async
	return p
}

func (p *VmServiceThawFilesystemsRequest) Send() (*VmServiceThawFilesystemsResponse, error) {
	rawURL := fmt.Sprintf("%s%s/thawfilesystems", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceThawFilesystemsResponse), nil
}

func (p *VmServiceThawFilesystemsRequest) MustSend() *VmServiceThawFilesystemsResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Thaws virtual machine file systems.
// This operation thaws a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of a
// running virtual machine. Normally, this is done automatically by the manager, but this must be executed manually
// with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /api/vms/123/thawfilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
type VmServiceThawFilesystemsResponse struct {
}

//
// Thaws virtual machine file systems.
// This operation thaws a virtual machine's file systems using the QEMU guest agent when taking a live snapshot of a
// running virtual machine. Normally, this is done automatically by the manager, but this must be executed manually
// with the API for virtual machines using OpenStack Volume (Cinder) disks.
// Example:
// [source]
// ----
// POST /api/vms/123/thawfilesystems
// ----
// [source,xml]
// ----
// <action/>
// ----
//
func (p *VmService) ThawFilesystems() *VmServiceThawFilesystemsRequest {
	return &VmServiceThawFilesystemsRequest{VmService: p}
}

//
// Generates a time-sensitive authentication token for accessing a virtual machine's display.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// The response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
// [IMPORTANT]
// ====
// If the virtual machine is configured to support only one graphics protocol
// then the generated authentication token will be valid for that protocol.
// But if the virtual machine is configured to support multiple protocols,
// VNC and SPICE, then the authentication token will only be valid for
// the SPICE protocol.
// In order to obtain an authentication token for a specific protocol, for
// example for VNC, use the `ticket` method of the <<services/vm_graphics_console,
// service>>, which manages the graphics consoles of the virtual machine, by sending
// a request:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// ====
//
type VmServiceTicketRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	ticket    *Ticket
}

func (p *VmServiceTicketRequest) Header(key, value string) *VmServiceTicketRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceTicketRequest) Query(key, value string) *VmServiceTicketRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceTicketRequest) Async(async bool) *VmServiceTicketRequest {
	p.async = &async
	return p
}

func (p *VmServiceTicketRequest) Ticket(ticket *Ticket) *VmServiceTicketRequest {
	p.ticket = ticket
	return p
}

func (p *VmServiceTicketRequest) Send() (*VmServiceTicketResponse, error) {
	rawURL := fmt.Sprintf("%s%s/ticket", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Ticket(p.ticket)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustTicket()
	return &VmServiceTicketResponse{ticket: result}, nil
}

func (p *VmServiceTicketRequest) MustSend() *VmServiceTicketResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Generates a time-sensitive authentication token for accessing a virtual machine's display.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// The response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
// [IMPORTANT]
// ====
// If the virtual machine is configured to support only one graphics protocol
// then the generated authentication token will be valid for that protocol.
// But if the virtual machine is configured to support multiple protocols,
// VNC and SPICE, then the authentication token will only be valid for
// the SPICE protocol.
// In order to obtain an authentication token for a specific protocol, for
// example for VNC, use the `ticket` method of the <<services/vm_graphics_console,
// service>>, which manages the graphics consoles of the virtual machine, by sending
// a request:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// ====
//
type VmServiceTicketResponse struct {
	ticket *Ticket
}

func (p *VmServiceTicketResponse) Ticket() (*Ticket, bool) {
	if p.ticket != nil {
		return p.ticket, true
	}
	return nil, false
}

func (p *VmServiceTicketResponse) MustTicket() *Ticket {
	if p.ticket == nil {
		panic("ticket in response does not exist")
	}
	return p.ticket
}

//
// Generates a time-sensitive authentication token for accessing a virtual machine's display.
// For example:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/ticket
// ----
// The client-provided action optionally includes a desired ticket value and/or an expiry time in seconds.
// The response specifies the actual ticket value and expiry used.
// [source,xml]
// ----
// <action>
//   <ticket>
//     <value>abcd12345</value>
//     <expiry>120</expiry>
//   </ticket>
// </action>
// ----
// [IMPORTANT]
// ====
// If the virtual machine is configured to support only one graphics protocol
// then the generated authentication token will be valid for that protocol.
// But if the virtual machine is configured to support multiple protocols,
// VNC and SPICE, then the authentication token will only be valid for
// the SPICE protocol.
// In order to obtain an authentication token for a specific protocol, for
// example for VNC, use the `ticket` method of the <<services/vm_graphics_console,
// service>>, which manages the graphics consoles of the virtual machine, by sending
// a request:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/graphicsconsoles/456/ticket
// ----
// ====
//
func (p *VmService) Ticket() *VmServiceTicketRequest {
	return &VmServiceTicketRequest{VmService: p}
}

//
// Exports a virtual machine to an export domain.
//
type VmServiceExportToExportDomainRequest struct {
	VmService        *VmService
	header           map[string]string
	query            map[string]string
	async            *bool
	discardSnapshots *bool
	exclusive        *bool
	storageDomain    *StorageDomain
}

func (p *VmServiceExportToExportDomainRequest) Header(key, value string) *VmServiceExportToExportDomainRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceExportToExportDomainRequest) Query(key, value string) *VmServiceExportToExportDomainRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceExportToExportDomainRequest) Async(async bool) *VmServiceExportToExportDomainRequest {
	p.async = &async
	return p
}

func (p *VmServiceExportToExportDomainRequest) DiscardSnapshots(discardSnapshots bool) *VmServiceExportToExportDomainRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}

func (p *VmServiceExportToExportDomainRequest) Exclusive(exclusive bool) *VmServiceExportToExportDomainRequest {
	p.exclusive = &exclusive
	return p
}

func (p *VmServiceExportToExportDomainRequest) StorageDomain(storageDomain *StorageDomain) *VmServiceExportToExportDomainRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *VmServiceExportToExportDomainRequest) Send() (*VmServiceExportToExportDomainResponse, error) {
	rawURL := fmt.Sprintf("%s%s/toexportdomain", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceExportToExportDomainResponse), nil
}

func (p *VmServiceExportToExportDomainRequest) MustSend() *VmServiceExportToExportDomainResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports a virtual machine to an export domain.
//
type VmServiceExportToExportDomainResponse struct {
}

//
// Exports a virtual machine to an export domain.
//
func (p *VmService) ExportToExportDomain() *VmServiceExportToExportDomainRequest {
	return &VmServiceExportToExportDomainRequest{VmService: p}
}

//
// Exports a virtual machine as an OVA file to a given path on a specified host.
//
type VmServiceExportToPathOnHostRequest struct {
	VmService        *VmService
	header           map[string]string
	query            map[string]string
	async            *bool
	directory        *string
	discardSnapshots *bool
	exclusive        *bool
	filename         *string
	host             *Host
	storageDomain    *StorageDomain
}

func (p *VmServiceExportToPathOnHostRequest) Header(key, value string) *VmServiceExportToPathOnHostRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceExportToPathOnHostRequest) Query(key, value string) *VmServiceExportToPathOnHostRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceExportToPathOnHostRequest) Async(async bool) *VmServiceExportToPathOnHostRequest {
	p.async = &async
	return p
}

func (p *VmServiceExportToPathOnHostRequest) Directory(directory string) *VmServiceExportToPathOnHostRequest {
	p.directory = &directory
	return p
}

func (p *VmServiceExportToPathOnHostRequest) DiscardSnapshots(discardSnapshots bool) *VmServiceExportToPathOnHostRequest {
	p.discardSnapshots = &discardSnapshots
	return p
}

func (p *VmServiceExportToPathOnHostRequest) Exclusive(exclusive bool) *VmServiceExportToPathOnHostRequest {
	p.exclusive = &exclusive
	return p
}

func (p *VmServiceExportToPathOnHostRequest) Filename(filename string) *VmServiceExportToPathOnHostRequest {
	p.filename = &filename
	return p
}

func (p *VmServiceExportToPathOnHostRequest) Host(host *Host) *VmServiceExportToPathOnHostRequest {
	p.host = host
	return p
}

func (p *VmServiceExportToPathOnHostRequest) StorageDomain(storageDomain *StorageDomain) *VmServiceExportToPathOnHostRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *VmServiceExportToPathOnHostRequest) Send() (*VmServiceExportToPathOnHostResponse, error) {
	rawURL := fmt.Sprintf("%s%s/topathonhost", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.directory != nil {
		actionBuilder.Directory(*p.directory)
	}
	if p.discardSnapshots != nil {
		actionBuilder.DiscardSnapshots(*p.discardSnapshots)
	}
	if p.exclusive != nil {
		actionBuilder.Exclusive(*p.exclusive)
	}
	if p.filename != nil {
		actionBuilder.Filename(*p.filename)
	}
	actionBuilder.Host(p.host)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceExportToPathOnHostResponse), nil
}

func (p *VmServiceExportToPathOnHostRequest) MustSend() *VmServiceExportToPathOnHostResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports a virtual machine as an OVA file to a given path on a specified host.
//
type VmServiceExportToPathOnHostResponse struct {
}

//
// Exports a virtual machine as an OVA file to a given path on a specified host.
//
func (p *VmService) ExportToPathOnHost() *VmServiceExportToPathOnHostRequest {
	return &VmServiceExportToPathOnHostRequest{VmService: p}
}

//
// Restores the virtual machine to the state it had before previewing the snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
type VmServiceUndoSnapshotRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
}

func (p *VmServiceUndoSnapshotRequest) Header(key, value string) *VmServiceUndoSnapshotRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceUndoSnapshotRequest) Query(key, value string) *VmServiceUndoSnapshotRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceUndoSnapshotRequest) Async(async bool) *VmServiceUndoSnapshotRequest {
	p.async = &async
	return p
}

func (p *VmServiceUndoSnapshotRequest) Send() (*VmServiceUndoSnapshotResponse, error) {
	rawURL := fmt.Sprintf("%s%s/undosnapshot", p.VmService.connection.URL(), p.VmService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmServiceUndoSnapshotResponse), nil
}

func (p *VmServiceUndoSnapshotRequest) MustSend() *VmServiceUndoSnapshotResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Restores the virtual machine to the state it had before previewing the snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
type VmServiceUndoSnapshotResponse struct {
}

//
// Restores the virtual machine to the state it had before previewing the snapshot.
// See the <<services/vm/methods/preview_snapshot, preview_snapshot>> operation for details.
//
func (p *VmService) UndoSnapshot() *VmServiceUndoSnapshotRequest {
	return &VmServiceUndoSnapshotRequest{VmService: p}
}

//
// Update the virtual machine in the system for the given virtual machine id.
//
type VmServiceUpdateRequest struct {
	VmService *VmService
	header    map[string]string
	query     map[string]string
	async     *bool
	nextRun   *bool
	vm        *Vm
}

func (p *VmServiceUpdateRequest) Header(key, value string) *VmServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmServiceUpdateRequest) Query(key, value string) *VmServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmServiceUpdateRequest) Async(async bool) *VmServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *VmServiceUpdateRequest) NextRun(nextRun bool) *VmServiceUpdateRequest {
	p.nextRun = &nextRun
	return p
}

func (p *VmServiceUpdateRequest) Vm(vm *Vm) *VmServiceUpdateRequest {
	p.vm = vm
	return p
}

func (p *VmServiceUpdateRequest) Send() (*VmServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmService.connection.URL(), p.VmService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.nextRun != nil {
		values["next_run"] = []string{fmt.Sprintf("%v", *p.nextRun)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLVmWriteOne(writer, p.vm, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLVmReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmServiceUpdateResponse{vm: result}, nil
}

func (p *VmServiceUpdateRequest) MustSend() *VmServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the virtual machine in the system for the given virtual machine id.
//
type VmServiceUpdateResponse struct {
	vm *Vm
}

func (p *VmServiceUpdateResponse) Vm() (*Vm, bool) {
	if p.vm != nil {
		return p.vm, true
	}
	return nil, false
}

func (p *VmServiceUpdateResponse) MustVm() *Vm {
	if p.vm == nil {
		panic("vm in response does not exist")
	}
	return p.vm
}

//
// Update the virtual machine in the system for the given virtual machine id.
//
func (p *VmService) Update() *VmServiceUpdateRequest {
	return &VmServiceUpdateRequest{VmService: p}
}

//
// List of scheduling labels assigned to this virtual machine.
//
func (op *VmService) AffinityLabelsService() *AssignedAffinityLabelsService {
	return NewAssignedAffinityLabelsService(op.connection, fmt.Sprintf("%s/affinitylabels", op.path))
}

//
//
func (op *VmService) ApplicationsService() *VmApplicationsService {
	return NewVmApplicationsService(op.connection, fmt.Sprintf("%s/applications", op.path))
}

//
// List of backups of this virtual machine.
//
func (op *VmService) BackupsService() *VmBackupsService {
	return NewVmBackupsService(op.connection, fmt.Sprintf("%s/backups", op.path))
}

//
//
func (op *VmService) CdromsService() *VmCdromsService {
	return NewVmCdromsService(op.connection, fmt.Sprintf("%s/cdroms", op.path))
}

//
// List of disks attached to this virtual machine.
//
func (op *VmService) DiskAttachmentsService() *DiskAttachmentsService {
	return NewDiskAttachmentsService(op.connection, fmt.Sprintf("%s/diskattachments", op.path))
}

//
//
func (op *VmService) GraphicsConsolesService() *VmGraphicsConsolesService {
	return NewVmGraphicsConsolesService(op.connection, fmt.Sprintf("%s/graphicsconsoles", op.path))
}

//
//
func (op *VmService) HostDevicesService() *VmHostDevicesService {
	return NewVmHostDevicesService(op.connection, fmt.Sprintf("%s/hostdevices", op.path))
}

//
// Reference to the service that can show the applicable errata available on the virtual machine.
// This information is taken from Katello.
//
func (op *VmService) KatelloErrataService() *KatelloErrataService {
	return NewKatelloErrataService(op.connection, fmt.Sprintf("%s/katelloerrata", op.path))
}

//
//
func (op *VmService) NicsService() *VmNicsService {
	return NewVmNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
//
func (op *VmService) NumaNodesService() *VmNumaNodesService {
	return NewVmNumaNodesService(op.connection, fmt.Sprintf("%s/numanodes", op.path))
}

//
//
func (op *VmService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *VmService) ReportedDevicesService() *VmReportedDevicesService {
	return NewVmReportedDevicesService(op.connection, fmt.Sprintf("%s/reporteddevices", op.path))
}

//
// Reference to the service that provides information about virtual machine user sessions.
//
func (op *VmService) SessionsService() *VmSessionsService {
	return NewVmSessionsService(op.connection, fmt.Sprintf("%s/sessions", op.path))
}

//
//
func (op *VmService) SnapshotsService() *SnapshotsService {
	return NewSnapshotsService(op.connection, fmt.Sprintf("%s/snapshots", op.path))
}

//
//
func (op *VmService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
//
func (op *VmService) TagsService() *AssignedTagsService {
	return NewAssignedTagsService(op.connection, fmt.Sprintf("%s/tags", op.path))
}

//
//
func (op *VmService) WatchdogsService() *VmWatchdogsService {
	return NewVmWatchdogsService(op.connection, fmt.Sprintf("%s/watchdogs", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "affinitylabels" {
		return op.AffinityLabelsService(), nil
	}
	if strings.HasPrefix(path, "affinitylabels/") {
		return op.AffinityLabelsService().Service(path[15:])
	}
	if path == "applications" {
		return op.ApplicationsService(), nil
	}
	if strings.HasPrefix(path, "applications/") {
		return op.ApplicationsService().Service(path[13:])
	}
	if path == "backups" {
		return op.BackupsService(), nil
	}
	if strings.HasPrefix(path, "backups/") {
		return op.BackupsService().Service(path[8:])
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "diskattachments" {
		return op.DiskAttachmentsService(), nil
	}
	if strings.HasPrefix(path, "diskattachments/") {
		return op.DiskAttachmentsService().Service(path[16:])
	}
	if path == "graphicsconsoles" {
		return op.GraphicsConsolesService(), nil
	}
	if strings.HasPrefix(path, "graphicsconsoles/") {
		return op.GraphicsConsolesService().Service(path[17:])
	}
	if path == "hostdevices" {
		return op.HostDevicesService(), nil
	}
	if strings.HasPrefix(path, "hostdevices/") {
		return op.HostDevicesService().Service(path[12:])
	}
	if path == "katelloerrata" {
		return op.KatelloErrataService(), nil
	}
	if strings.HasPrefix(path, "katelloerrata/") {
		return op.KatelloErrataService().Service(path[14:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	if path == "numanodes" {
		return op.NumaNodesService(), nil
	}
	if strings.HasPrefix(path, "numanodes/") {
		return op.NumaNodesService().Service(path[10:])
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "reporteddevices" {
		return op.ReportedDevicesService(), nil
	}
	if strings.HasPrefix(path, "reporteddevices/") {
		return op.ReportedDevicesService().Service(path[16:])
	}
	if path == "sessions" {
		return op.SessionsService(), nil
	}
	if strings.HasPrefix(path, "sessions/") {
		return op.SessionsService().Service(path[9:])
	}
	if path == "snapshots" {
		return op.SnapshotsService(), nil
	}
	if strings.HasPrefix(path, "snapshots/") {
		return op.SnapshotsService().Service(path[10:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	if path == "tags" {
		return op.TagsService(), nil
	}
	if strings.HasPrefix(path, "tags/") {
		return op.TagsService().Service(path[5:])
	}
	if path == "watchdogs" {
		return op.WatchdogsService(), nil
	}
	if strings.HasPrefix(path, "watchdogs/") {
		return op.WatchdogsService().Service(path[10:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmService) String() string {
	return fmt.Sprintf("VmService:%s", op.path)
}

//
//
type TemplateDisksService struct {
	BaseService
}

func NewTemplateDisksService(connection *Connection, path string) *TemplateDisksService {
	var result TemplateDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of disks of the template.
// The order of the returned list of disks isn't guaranteed.
//
type TemplateDisksServiceListRequest struct {
	TemplateDisksService *TemplateDisksService
	header               map[string]string
	query                map[string]string
	follow               *string
	max                  *int64
}

func (p *TemplateDisksServiceListRequest) Header(key, value string) *TemplateDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *TemplateDisksServiceListRequest) Query(key, value string) *TemplateDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *TemplateDisksServiceListRequest) Follow(follow string) *TemplateDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *TemplateDisksServiceListRequest) Max(max int64) *TemplateDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *TemplateDisksServiceListRequest) Send() (*TemplateDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.TemplateDisksService.connection.URL(), p.TemplateDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.TemplateDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.TemplateDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.TemplateDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.TemplateDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.TemplateDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &TemplateDisksServiceListResponse{disks: result}, nil
}

func (p *TemplateDisksServiceListRequest) MustSend() *TemplateDisksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of disks of the template.
// The order of the returned list of disks isn't guaranteed.
//
type TemplateDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *TemplateDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *TemplateDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Returns the list of disks of the template.
// The order of the returned list of disks isn't guaranteed.
//
func (p *TemplateDisksService) List() *TemplateDisksServiceListRequest {
	return &TemplateDisksServiceListRequest{TemplateDisksService: p}
}

//
//
func (op *TemplateDisksService) DiskService(id string) *TemplateDiskService {
	return NewTemplateDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *TemplateDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *TemplateDisksService) String() string {
	return fmt.Sprintf("TemplateDisksService:%s", op.path)
}

//
//
type FilterService struct {
	BaseService
}

func NewFilterService(connection *Connection, path string) *FilterService {
	var result FilterService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type FilterServiceGetRequest struct {
	FilterService *FilterService
	header        map[string]string
	query         map[string]string
	filter        *bool
	follow        *string
}

func (p *FilterServiceGetRequest) Header(key, value string) *FilterServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilterServiceGetRequest) Query(key, value string) *FilterServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilterServiceGetRequest) Filter(filter bool) *FilterServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *FilterServiceGetRequest) Follow(follow string) *FilterServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *FilterServiceGetRequest) Send() (*FilterServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FilterService.connection.URL(), p.FilterService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FilterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FilterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FilterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FilterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FilterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &FilterServiceGetResponse{result: result}, nil
}

func (p *FilterServiceGetRequest) MustSend() *FilterServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type FilterServiceGetResponse struct {
	result *Filter
}

func (p *FilterServiceGetResponse) Result() (*Filter, bool) {
	if p.result != nil {
		return p.result, true
	}
	return nil, false
}

func (p *FilterServiceGetResponse) MustResult() *Filter {
	if p.result == nil {
		panic("result in response does not exist")
	}
	return p.result
}

//
//
func (p *FilterService) Get() *FilterServiceGetRequest {
	return &FilterServiceGetRequest{FilterService: p}
}

//
//
type FilterServiceRemoveRequest struct {
	FilterService *FilterService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *FilterServiceRemoveRequest) Header(key, value string) *FilterServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FilterServiceRemoveRequest) Query(key, value string) *FilterServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FilterServiceRemoveRequest) Async(async bool) *FilterServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *FilterServiceRemoveRequest) Send() (*FilterServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FilterService.connection.URL(), p.FilterService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FilterService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FilterService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FilterService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FilterService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FilterService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(FilterServiceRemoveResponse), nil
}

func (p *FilterServiceRemoveRequest) MustSend() *FilterServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type FilterServiceRemoveResponse struct {
}

//
//
func (p *FilterService) Remove() *FilterServiceRemoveRequest {
	return &FilterServiceRemoveRequest{FilterService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FilterService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FilterService) String() string {
	return fmt.Sprintf("FilterService:%s", op.path)
}

//
// Provides read-only access to the global set of roles
//
type RolesService struct {
	BaseService
}

func NewRolesService(connection *Connection, path string) *RolesService {
	var result RolesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Create a new role. The role can be administrative or non-administrative and can have different permits.
// For example, to add the `MyRole` non-administrative role with permits to login and create virtual machines
// send a request like this (note that you have to pass permit id):
// [source]
// ----
// POST /ovirt-engine/api/roles
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyRole</name>
//   <description>My custom role to create virtual machines</description>
//   <administrative>false</administrative>
//   <permits>
//     <permit id="1"/>
//     <permit id="1300"/>
//   </permits>
// </group>
// ----
//
type RolesServiceAddRequest struct {
	RolesService *RolesService
	header       map[string]string
	query        map[string]string
	role         *Role
}

func (p *RolesServiceAddRequest) Header(key, value string) *RolesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RolesServiceAddRequest) Query(key, value string) *RolesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RolesServiceAddRequest) Role(role *Role) *RolesServiceAddRequest {
	p.role = role
	return p
}

func (p *RolesServiceAddRequest) Send() (*RolesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.RolesService.connection.URL(), p.RolesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLRoleWriteOne(writer, p.role, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.RolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.RolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.RolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.RolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.RolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &RolesServiceAddResponse{role: result}, nil
}

func (p *RolesServiceAddRequest) MustSend() *RolesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Create a new role. The role can be administrative or non-administrative and can have different permits.
// For example, to add the `MyRole` non-administrative role with permits to login and create virtual machines
// send a request like this (note that you have to pass permit id):
// [source]
// ----
// POST /ovirt-engine/api/roles
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyRole</name>
//   <description>My custom role to create virtual machines</description>
//   <administrative>false</administrative>
//   <permits>
//     <permit id="1"/>
//     <permit id="1300"/>
//   </permits>
// </group>
// ----
//
type RolesServiceAddResponse struct {
	role *Role
}

func (p *RolesServiceAddResponse) Role() (*Role, bool) {
	if p.role != nil {
		return p.role, true
	}
	return nil, false
}

func (p *RolesServiceAddResponse) MustRole() *Role {
	if p.role == nil {
		panic("role in response does not exist")
	}
	return p.role
}

//
// Create a new role. The role can be administrative or non-administrative and can have different permits.
// For example, to add the `MyRole` non-administrative role with permits to login and create virtual machines
// send a request like this (note that you have to pass permit id):
// [source]
// ----
// POST /ovirt-engine/api/roles
// ----
// With a request body like this:
// [source,xml]
// ----
// <role>
//   <name>MyRole</name>
//   <description>My custom role to create virtual machines</description>
//   <administrative>false</administrative>
//   <permits>
//     <permit id="1"/>
//     <permit id="1300"/>
//   </permits>
// </group>
// ----
//
func (p *RolesService) Add() *RolesServiceAddRequest {
	return &RolesServiceAddRequest{RolesService: p}
}

//
// List roles.
// [source]
// ----
// GET /ovirt-engine/api/roles
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <roles>
//   <role id="123">
//      <name>SuperUser</name>
//      <description>Roles management administrator</description>
//      <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//      <administrative>true</administrative>
//      <mutable>false</mutable>
//   </role>
//   ...
// </roles>
// ----
// The order of the returned list of roles isn't guaranteed.
//
type RolesServiceListRequest struct {
	RolesService *RolesService
	header       map[string]string
	query        map[string]string
	follow       *string
	max          *int64
}

func (p *RolesServiceListRequest) Header(key, value string) *RolesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *RolesServiceListRequest) Query(key, value string) *RolesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *RolesServiceListRequest) Follow(follow string) *RolesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *RolesServiceListRequest) Max(max int64) *RolesServiceListRequest {
	p.max = &max
	return p
}

func (p *RolesServiceListRequest) Send() (*RolesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.RolesService.connection.URL(), p.RolesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.RolesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.RolesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.RolesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.RolesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.RolesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLRoleReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &RolesServiceListResponse{roles: result}, nil
}

func (p *RolesServiceListRequest) MustSend() *RolesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List roles.
// [source]
// ----
// GET /ovirt-engine/api/roles
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <roles>
//   <role id="123">
//      <name>SuperUser</name>
//      <description>Roles management administrator</description>
//      <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//      <administrative>true</administrative>
//      <mutable>false</mutable>
//   </role>
//   ...
// </roles>
// ----
// The order of the returned list of roles isn't guaranteed.
//
type RolesServiceListResponse struct {
	roles *RoleSlice
}

func (p *RolesServiceListResponse) Roles() (*RoleSlice, bool) {
	if p.roles != nil {
		return p.roles, true
	}
	return nil, false
}

func (p *RolesServiceListResponse) MustRoles() *RoleSlice {
	if p.roles == nil {
		panic("roles in response does not exist")
	}
	return p.roles
}

//
// List roles.
// [source]
// ----
// GET /ovirt-engine/api/roles
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <roles>
//   <role id="123">
//      <name>SuperUser</name>
//      <description>Roles management administrator</description>
//      <link href="/ovirt-engine/api/roles/123/permits" rel="permits"/>
//      <administrative>true</administrative>
//      <mutable>false</mutable>
//   </role>
//   ...
// </roles>
// ----
// The order of the returned list of roles isn't guaranteed.
//
func (p *RolesService) List() *RolesServiceListRequest {
	return &RolesServiceListRequest{RolesService: p}
}

//
// Sub-resource locator method, returns individual role resource on which the remainder of the URI is dispatched.
//
func (op *RolesService) RoleService(id string) *RoleService {
	return NewRoleService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *RolesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.RoleService(path), nil
	}
	return op.RoleService(path[:index]).Service(path[index+1:])
}

func (op *RolesService) String() string {
	return fmt.Sprintf("RolesService:%s", op.path)
}

//
//
type HostHookService struct {
	BaseService
}

func NewHostHookService(connection *Connection, path string) *HostHookService {
	var result HostHookService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type HostHookServiceGetRequest struct {
	HostHookService *HostHookService
	header          map[string]string
	query           map[string]string
	follow          *string
}

func (p *HostHookServiceGetRequest) Header(key, value string) *HostHookServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostHookServiceGetRequest) Query(key, value string) *HostHookServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostHookServiceGetRequest) Follow(follow string) *HostHookServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *HostHookServiceGetRequest) Send() (*HostHookServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostHookService.connection.URL(), p.HostHookService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostHookService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostHookService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostHookService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostHookService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostHookService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHookReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &HostHookServiceGetResponse{hook: result}, nil
}

func (p *HostHookServiceGetRequest) MustSend() *HostHookServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type HostHookServiceGetResponse struct {
	hook *Hook
}

func (p *HostHookServiceGetResponse) Hook() (*Hook, bool) {
	if p.hook != nil {
		return p.hook, true
	}
	return nil, false
}

func (p *HostHookServiceGetResponse) MustHook() *Hook {
	if p.hook == nil {
		panic("hook in response does not exist")
	}
	return p.hook
}

//
//
func (p *HostHookService) Get() *HostHookServiceGetRequest {
	return &HostHookServiceGetRequest{HostHookService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostHookService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostHookService) String() string {
	return fmt.Sprintf("HostHookService:%s", op.path)
}

//
// A service managing a backup of a virtual machines.
//
type VmBackupService struct {
	BaseService
}

func NewVmBackupService(connection *Connection, path string) *VmBackupService {
	var result VmBackupService
	result.connection = connection
	result.path = path
	return &result
}

//
// Finalize the virtual machine backup entity.
// End backup, unlock resources, and perform cleanups.
//
type VmBackupServiceFinalizeRequest struct {
	VmBackupService *VmBackupService
	header          map[string]string
	query           map[string]string
}

func (p *VmBackupServiceFinalizeRequest) Header(key, value string) *VmBackupServiceFinalizeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmBackupServiceFinalizeRequest) Query(key, value string) *VmBackupServiceFinalizeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmBackupServiceFinalizeRequest) Send() (*VmBackupServiceFinalizeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/finalize", p.VmBackupService.connection.URL(), p.VmBackupService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmBackupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmBackupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmBackupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmBackupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmBackupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(VmBackupServiceFinalizeResponse), nil
}

func (p *VmBackupServiceFinalizeRequest) MustSend() *VmBackupServiceFinalizeResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Finalize the virtual machine backup entity.
// End backup, unlock resources, and perform cleanups.
//
type VmBackupServiceFinalizeResponse struct {
}

//
// Finalize the virtual machine backup entity.
// End backup, unlock resources, and perform cleanups.
//
func (p *VmBackupService) Finalize() *VmBackupServiceFinalizeRequest {
	return &VmBackupServiceFinalizeRequest{VmBackupService: p}
}

//
// Returns information about the virtual machine backup.
//
type VmBackupServiceGetRequest struct {
	VmBackupService *VmBackupService
	header          map[string]string
	query           map[string]string
	follow          *string
}

func (p *VmBackupServiceGetRequest) Header(key, value string) *VmBackupServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmBackupServiceGetRequest) Query(key, value string) *VmBackupServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmBackupServiceGetRequest) Follow(follow string) *VmBackupServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmBackupServiceGetRequest) Send() (*VmBackupServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmBackupService.connection.URL(), p.VmBackupService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmBackupService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmBackupService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmBackupService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmBackupService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmBackupService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBackupReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmBackupServiceGetResponse{backup: result}, nil
}

func (p *VmBackupServiceGetRequest) MustSend() *VmBackupServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns information about the virtual machine backup.
//
type VmBackupServiceGetResponse struct {
	backup *Backup
}

func (p *VmBackupServiceGetResponse) Backup() (*Backup, bool) {
	if p.backup != nil {
		return p.backup, true
	}
	return nil, false
}

func (p *VmBackupServiceGetResponse) MustBackup() *Backup {
	if p.backup == nil {
		panic("backup in response does not exist")
	}
	return p.backup
}

//
// Returns information about the virtual machine backup.
//
func (p *VmBackupService) Get() *VmBackupServiceGetRequest {
	return &VmBackupServiceGetRequest{VmBackupService: p}
}

//
// A reference to the service that lists the disks in backup.
//
func (op *VmBackupService) DisksService() *VmBackupDisksService {
	return NewVmBackupDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmBackupService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmBackupService) String() string {
	return fmt.Sprintf("VmBackupService:%s", op.path)
}

//
// This service manages a collection of all host labels assigned to an affinity group.
//
type AffinityGroupHostLabelsService struct {
	BaseService
}

func NewAffinityGroupHostLabelsService(connection *Connection, path string) *AffinityGroupHostLabelsService {
	var result AffinityGroupHostLabelsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a host label to the affinity group.
// For example, to add the label `789` to the affinity group `456` of cluster `123`,
// send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/hostlabels
// ....
// With the following body:
// [source,xml]
// ----
// <affinity_label id="789"/>
// ----
//
type AffinityGroupHostLabelsServiceAddRequest struct {
	AffinityGroupHostLabelsService *AffinityGroupHostLabelsService
	header                         map[string]string
	query                          map[string]string
	label                          *AffinityLabel
}

func (p *AffinityGroupHostLabelsServiceAddRequest) Header(key, value string) *AffinityGroupHostLabelsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupHostLabelsServiceAddRequest) Query(key, value string) *AffinityGroupHostLabelsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupHostLabelsServiceAddRequest) Label(label *AffinityLabel) *AffinityGroupHostLabelsServiceAddRequest {
	p.label = label
	return p
}

func (p *AffinityGroupHostLabelsServiceAddRequest) Send() (*AffinityGroupHostLabelsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupHostLabelsService.connection.URL(), p.AffinityGroupHostLabelsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLAffinityLabelWriteOne(writer, p.label, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupHostLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupHostLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupHostLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupHostLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupHostLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityGroupHostLabelsServiceAddResponse{label: result}, nil
}

func (p *AffinityGroupHostLabelsServiceAddRequest) MustSend() *AffinityGroupHostLabelsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a host label to the affinity group.
// For example, to add the label `789` to the affinity group `456` of cluster `123`,
// send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/hostlabels
// ....
// With the following body:
// [source,xml]
// ----
// <affinity_label id="789"/>
// ----
//
type AffinityGroupHostLabelsServiceAddResponse struct {
	label *AffinityLabel
}

func (p *AffinityGroupHostLabelsServiceAddResponse) Label() (*AffinityLabel, bool) {
	if p.label != nil {
		return p.label, true
	}
	return nil, false
}

func (p *AffinityGroupHostLabelsServiceAddResponse) MustLabel() *AffinityLabel {
	if p.label == nil {
		panic("label in response does not exist")
	}
	return p.label
}

//
// Adds a host label to the affinity group.
// For example, to add the label `789` to the affinity group `456` of cluster `123`,
// send a request like this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/hostlabels
// ....
// With the following body:
// [source,xml]
// ----
// <affinity_label id="789"/>
// ----
//
func (p *AffinityGroupHostLabelsService) Add() *AffinityGroupHostLabelsServiceAddRequest {
	return &AffinityGroupHostLabelsServiceAddRequest{AffinityGroupHostLabelsService: p}
}

//
// List all host labels assigned to this affinity group.
// The order of the returned labels isn't guaranteed.
//
type AffinityGroupHostLabelsServiceListRequest struct {
	AffinityGroupHostLabelsService *AffinityGroupHostLabelsService
	header                         map[string]string
	query                          map[string]string
	follow                         *string
	max                            *int64
}

func (p *AffinityGroupHostLabelsServiceListRequest) Header(key, value string) *AffinityGroupHostLabelsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupHostLabelsServiceListRequest) Query(key, value string) *AffinityGroupHostLabelsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupHostLabelsServiceListRequest) Follow(follow string) *AffinityGroupHostLabelsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AffinityGroupHostLabelsServiceListRequest) Max(max int64) *AffinityGroupHostLabelsServiceListRequest {
	p.max = &max
	return p
}

func (p *AffinityGroupHostLabelsServiceListRequest) Send() (*AffinityGroupHostLabelsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupHostLabelsService.connection.URL(), p.AffinityGroupHostLabelsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupHostLabelsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupHostLabelsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupHostLabelsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupHostLabelsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupHostLabelsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLAffinityLabelReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AffinityGroupHostLabelsServiceListResponse{labels: result}, nil
}

func (p *AffinityGroupHostLabelsServiceListRequest) MustSend() *AffinityGroupHostLabelsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all host labels assigned to this affinity group.
// The order of the returned labels isn't guaranteed.
//
type AffinityGroupHostLabelsServiceListResponse struct {
	labels *AffinityLabelSlice
}

func (p *AffinityGroupHostLabelsServiceListResponse) Labels() (*AffinityLabelSlice, bool) {
	if p.labels != nil {
		return p.labels, true
	}
	return nil, false
}

func (p *AffinityGroupHostLabelsServiceListResponse) MustLabels() *AffinityLabelSlice {
	if p.labels == nil {
		panic("labels in response does not exist")
	}
	return p.labels
}

//
// List all host labels assigned to this affinity group.
// The order of the returned labels isn't guaranteed.
//
func (p *AffinityGroupHostLabelsService) List() *AffinityGroupHostLabelsServiceListRequest {
	return &AffinityGroupHostLabelsServiceListRequest{AffinityGroupHostLabelsService: p}
}

//
// Access the service that manages the host label assignment to this affinity group.
//
func (op *AffinityGroupHostLabelsService) LabelService(id string) *AffinityGroupHostLabelService {
	return NewAffinityGroupHostLabelService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupHostLabelsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LabelService(path), nil
	}
	return op.LabelService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupHostLabelsService) String() string {
	return fmt.Sprintf("AffinityGroupHostLabelsService:%s", op.path)
}

//
// A service to manage a specific cluster network.
//
type ClusterNetworkService struct {
	BaseService
}

func NewClusterNetworkService(connection *Connection, path string) *ClusterNetworkService {
	var result ClusterNetworkService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves the cluster network details.
//
type ClusterNetworkServiceGetRequest struct {
	ClusterNetworkService *ClusterNetworkService
	header                map[string]string
	query                 map[string]string
	follow                *string
}

func (p *ClusterNetworkServiceGetRequest) Header(key, value string) *ClusterNetworkServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterNetworkServiceGetRequest) Query(key, value string) *ClusterNetworkServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterNetworkServiceGetRequest) Follow(follow string) *ClusterNetworkServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ClusterNetworkServiceGetRequest) Send() (*ClusterNetworkServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterNetworkService.connection.URL(), p.ClusterNetworkService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterNetworkServiceGetResponse{network: result}, nil
}

func (p *ClusterNetworkServiceGetRequest) MustSend() *ClusterNetworkServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the cluster network details.
//
type ClusterNetworkServiceGetResponse struct {
	network *Network
}

func (p *ClusterNetworkServiceGetResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *ClusterNetworkServiceGetResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Retrieves the cluster network details.
//
func (p *ClusterNetworkService) Get() *ClusterNetworkServiceGetRequest {
	return &ClusterNetworkServiceGetRequest{ClusterNetworkService: p}
}

//
// Unassigns the network from a cluster.
//
type ClusterNetworkServiceRemoveRequest struct {
	ClusterNetworkService *ClusterNetworkService
	header                map[string]string
	query                 map[string]string
}

func (p *ClusterNetworkServiceRemoveRequest) Header(key, value string) *ClusterNetworkServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterNetworkServiceRemoveRequest) Query(key, value string) *ClusterNetworkServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterNetworkServiceRemoveRequest) Send() (*ClusterNetworkServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterNetworkService.connection.URL(), p.ClusterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(ClusterNetworkServiceRemoveResponse), nil
}

func (p *ClusterNetworkServiceRemoveRequest) MustSend() *ClusterNetworkServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Unassigns the network from a cluster.
//
type ClusterNetworkServiceRemoveResponse struct {
}

//
// Unassigns the network from a cluster.
//
func (p *ClusterNetworkService) Remove() *ClusterNetworkServiceRemoveRequest {
	return &ClusterNetworkServiceRemoveRequest{ClusterNetworkService: p}
}

//
// Updates the network in the cluster.
//
type ClusterNetworkServiceUpdateRequest struct {
	ClusterNetworkService *ClusterNetworkService
	header                map[string]string
	query                 map[string]string
	network               *Network
}

func (p *ClusterNetworkServiceUpdateRequest) Header(key, value string) *ClusterNetworkServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterNetworkServiceUpdateRequest) Query(key, value string) *ClusterNetworkServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterNetworkServiceUpdateRequest) Network(network *Network) *ClusterNetworkServiceUpdateRequest {
	p.network = network
	return p
}

func (p *ClusterNetworkServiceUpdateRequest) Send() (*ClusterNetworkServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterNetworkService.connection.URL(), p.ClusterNetworkService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkWriteOne(writer, p.network, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterNetworkService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterNetworkService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterNetworkService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterNetworkService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterNetworkService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterNetworkServiceUpdateResponse{network: result}, nil
}

func (p *ClusterNetworkServiceUpdateRequest) MustSend() *ClusterNetworkServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the network in the cluster.
//
type ClusterNetworkServiceUpdateResponse struct {
	network *Network
}

func (p *ClusterNetworkServiceUpdateResponse) Network() (*Network, bool) {
	if p.network != nil {
		return p.network, true
	}
	return nil, false
}

func (p *ClusterNetworkServiceUpdateResponse) MustNetwork() *Network {
	if p.network == nil {
		panic("network in response does not exist")
	}
	return p.network
}

//
// Updates the network in the cluster.
//
func (p *ClusterNetworkService) Update() *ClusterNetworkServiceUpdateRequest {
	return &ClusterNetworkServiceUpdateRequest{ClusterNetworkService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterNetworkService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterNetworkService) String() string {
	return fmt.Sprintf("ClusterNetworkService:%s", op.path)
}

//
// A service to manage the network interfaces of a host.
//
type HostNicsService struct {
	BaseService
}

func NewHostNicsService(connection *Connection, path string) *HostNicsService {
	var result HostNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of network interfaces of the host.
// The order of the returned list of network interfaces isn't guaranteed.
//
type HostNicsServiceListRequest struct {
	HostNicsService *HostNicsService
	header          map[string]string
	query           map[string]string
	allContent      *bool
	follow          *string
	max             *int64
}

func (p *HostNicsServiceListRequest) Header(key, value string) *HostNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNicsServiceListRequest) Query(key, value string) *HostNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNicsServiceListRequest) AllContent(allContent bool) *HostNicsServiceListRequest {
	p.allContent = &allContent
	return p
}

func (p *HostNicsServiceListRequest) Follow(follow string) *HostNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *HostNicsServiceListRequest) Max(max int64) *HostNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *HostNicsServiceListRequest) Send() (*HostNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostNicsService.connection.URL(), p.HostNicsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostNicsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostNicsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostNicsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &HostNicsServiceListResponse{nics: result}, nil
}

func (p *HostNicsServiceListRequest) MustSend() *HostNicsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of network interfaces of the host.
// The order of the returned list of network interfaces isn't guaranteed.
//
type HostNicsServiceListResponse struct {
	nics *HostNicSlice
}

func (p *HostNicsServiceListResponse) Nics() (*HostNicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *HostNicsServiceListResponse) MustNics() *HostNicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Returns the list of network interfaces of the host.
// The order of the returned list of network interfaces isn't guaranteed.
//
func (p *HostNicsService) List() *HostNicsServiceListRequest {
	return &HostNicsServiceListRequest{HostNicsService: p}
}

//
// Reference to the service that manages a single network interface.
//
func (op *HostNicsService) NicService(id string) *HostNicService {
	return NewHostNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *HostNicsService) String() string {
	return fmt.Sprintf("HostNicsService:%s", op.path)
}

//
// A service to manage a specific event-subscription in the system.
//
type EventSubscriptionService struct {
	BaseService
}

func NewEventSubscriptionService(connection *Connection, path string) *EventSubscriptionService {
	var result EventSubscriptionService
	result.connection = connection
	result.path = path
	return &result
}

//
// Gets the information about the event-subscription.
// For example to retrieve the information about the subscription of user '123' to
// the event 'vm_console_detected':
// ....
// GET /ovirt-engine/api/users/123/vm_console_detected
// ....
// [source,xml]
// ----
// <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/vm_console_detected">
//   <event>vm_console_detected</event>
//   <notification_method>smtp</notification_method>
//   <user href="/ovirt-engine/api/users/123" id="123"/>
//   <address>a@b.com</address>
// </event-subscription>
// ----
//
type EventSubscriptionServiceGetRequest struct {
	EventSubscriptionService *EventSubscriptionService
	header                   map[string]string
	query                    map[string]string
}

func (p *EventSubscriptionServiceGetRequest) Header(key, value string) *EventSubscriptionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventSubscriptionServiceGetRequest) Query(key, value string) *EventSubscriptionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventSubscriptionServiceGetRequest) Send() (*EventSubscriptionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EventSubscriptionService.connection.URL(), p.EventSubscriptionService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventSubscriptionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventSubscriptionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventSubscriptionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventSubscriptionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventSubscriptionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLEventSubscriptionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &EventSubscriptionServiceGetResponse{eventSubscription: result}, nil
}

func (p *EventSubscriptionServiceGetRequest) MustSend() *EventSubscriptionServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Gets the information about the event-subscription.
// For example to retrieve the information about the subscription of user '123' to
// the event 'vm_console_detected':
// ....
// GET /ovirt-engine/api/users/123/vm_console_detected
// ....
// [source,xml]
// ----
// <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/vm_console_detected">
//   <event>vm_console_detected</event>
//   <notification_method>smtp</notification_method>
//   <user href="/ovirt-engine/api/users/123" id="123"/>
//   <address>a@b.com</address>
// </event-subscription>
// ----
//
type EventSubscriptionServiceGetResponse struct {
	eventSubscription *EventSubscription
}

func (p *EventSubscriptionServiceGetResponse) EventSubscription() (*EventSubscription, bool) {
	if p.eventSubscription != nil {
		return p.eventSubscription, true
	}
	return nil, false
}

func (p *EventSubscriptionServiceGetResponse) MustEventSubscription() *EventSubscription {
	if p.eventSubscription == nil {
		panic("eventSubscription in response does not exist")
	}
	return p.eventSubscription
}

//
// Gets the information about the event-subscription.
// For example to retrieve the information about the subscription of user '123' to
// the event 'vm_console_detected':
// ....
// GET /ovirt-engine/api/users/123/vm_console_detected
// ....
// [source,xml]
// ----
// <event-subscription href="/ovirt-engine/api/users/123/event-subscriptions/vm_console_detected">
//   <event>vm_console_detected</event>
//   <notification_method>smtp</notification_method>
//   <user href="/ovirt-engine/api/users/123" id="123"/>
//   <address>a@b.com</address>
// </event-subscription>
// ----
//
func (p *EventSubscriptionService) Get() *EventSubscriptionServiceGetRequest {
	return &EventSubscriptionServiceGetRequest{EventSubscriptionService: p}
}

//
// Removes the event-subscription from the system.
// For example to remove user 123's subscription to `vm_console_detected` event:
// ....
// DELETE /ovirt-engine/api/users/123/vm_console_detected
// ....
//
type EventSubscriptionServiceRemoveRequest struct {
	EventSubscriptionService *EventSubscriptionService
	header                   map[string]string
	query                    map[string]string
	async                    *bool
}

func (p *EventSubscriptionServiceRemoveRequest) Header(key, value string) *EventSubscriptionServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *EventSubscriptionServiceRemoveRequest) Query(key, value string) *EventSubscriptionServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *EventSubscriptionServiceRemoveRequest) Async(async bool) *EventSubscriptionServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *EventSubscriptionServiceRemoveRequest) Send() (*EventSubscriptionServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.EventSubscriptionService.connection.URL(), p.EventSubscriptionService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.EventSubscriptionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.EventSubscriptionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.EventSubscriptionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.EventSubscriptionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.EventSubscriptionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(EventSubscriptionServiceRemoveResponse), nil
}

func (p *EventSubscriptionServiceRemoveRequest) MustSend() *EventSubscriptionServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes the event-subscription from the system.
// For example to remove user 123's subscription to `vm_console_detected` event:
// ....
// DELETE /ovirt-engine/api/users/123/vm_console_detected
// ....
//
type EventSubscriptionServiceRemoveResponse struct {
}

//
// Removes the event-subscription from the system.
// For example to remove user 123's subscription to `vm_console_detected` event:
// ....
// DELETE /ovirt-engine/api/users/123/vm_console_detected
// ....
//
func (p *EventSubscriptionService) Remove() *EventSubscriptionServiceRemoveRequest {
	return &EventSubscriptionServiceRemoveRequest{EventSubscriptionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *EventSubscriptionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *EventSubscriptionService) String() string {
	return fmt.Sprintf("EventSubscriptionService:%s", op.path)
}

//
//
type AssignedCpuProfilesService struct {
	BaseService
}

func NewAssignedCpuProfilesService(connection *Connection, path string) *AssignedCpuProfilesService {
	var result AssignedCpuProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new cpu profile for the cluster.
//
type AssignedCpuProfilesServiceAddRequest struct {
	AssignedCpuProfilesService *AssignedCpuProfilesService
	header                     map[string]string
	query                      map[string]string
	profile                    *CpuProfile
}

func (p *AssignedCpuProfilesServiceAddRequest) Header(key, value string) *AssignedCpuProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceAddRequest) Query(key, value string) *AssignedCpuProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceAddRequest) Profile(profile *CpuProfile) *AssignedCpuProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *AssignedCpuProfilesServiceAddRequest) Send() (*AssignedCpuProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedCpuProfilesService.connection.URL(), p.AssignedCpuProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedCpuProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedCpuProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedCpuProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedCpuProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedCpuProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedCpuProfilesServiceAddResponse{profile: result}, nil
}

func (p *AssignedCpuProfilesServiceAddRequest) MustSend() *AssignedCpuProfilesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new cpu profile for the cluster.
//
type AssignedCpuProfilesServiceAddResponse struct {
	profile *CpuProfile
}

func (p *AssignedCpuProfilesServiceAddResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *AssignedCpuProfilesServiceAddResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new cpu profile for the cluster.
//
func (p *AssignedCpuProfilesService) Add() *AssignedCpuProfilesServiceAddRequest {
	return &AssignedCpuProfilesServiceAddRequest{AssignedCpuProfilesService: p}
}

//
// List the CPU profiles assigned to the cluster.
// The order of the returned CPU profiles isn't guaranteed.
//
type AssignedCpuProfilesServiceListRequest struct {
	AssignedCpuProfilesService *AssignedCpuProfilesService
	header                     map[string]string
	query                      map[string]string
	follow                     *string
	max                        *int64
}

func (p *AssignedCpuProfilesServiceListRequest) Header(key, value string) *AssignedCpuProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceListRequest) Query(key, value string) *AssignedCpuProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedCpuProfilesServiceListRequest) Follow(follow string) *AssignedCpuProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AssignedCpuProfilesServiceListRequest) Max(max int64) *AssignedCpuProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *AssignedCpuProfilesServiceListRequest) Send() (*AssignedCpuProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedCpuProfilesService.connection.URL(), p.AssignedCpuProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedCpuProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedCpuProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedCpuProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedCpuProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedCpuProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AssignedCpuProfilesServiceListResponse{profiles: result}, nil
}

func (p *AssignedCpuProfilesServiceListRequest) MustSend() *AssignedCpuProfilesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List the CPU profiles assigned to the cluster.
// The order of the returned CPU profiles isn't guaranteed.
//
type AssignedCpuProfilesServiceListResponse struct {
	profiles *CpuProfileSlice
}

func (p *AssignedCpuProfilesServiceListResponse) Profiles() (*CpuProfileSlice, bool) {
	if p.profiles != nil {
		return p.profiles, true
	}
	return nil, false
}

func (p *AssignedCpuProfilesServiceListResponse) MustProfiles() *CpuProfileSlice {
	if p.profiles == nil {
		panic("profiles in response does not exist")
	}
	return p.profiles
}

//
// List the CPU profiles assigned to the cluster.
// The order of the returned CPU profiles isn't guaranteed.
//
func (p *AssignedCpuProfilesService) List() *AssignedCpuProfilesServiceListRequest {
	return &AssignedCpuProfilesServiceListRequest{AssignedCpuProfilesService: p}
}

//
//
func (op *AssignedCpuProfilesService) ProfileService(id string) *AssignedCpuProfileService {
	return NewAssignedCpuProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedCpuProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *AssignedCpuProfilesService) String() string {
	return fmt.Sprintf("AssignedCpuProfilesService:%s", op.path)
}

//
// A service to fetch information elements received by Link Layer Discovery Protocol (LLDP).
//
type LinkLayerDiscoveryProtocolService struct {
	BaseService
}

func NewLinkLayerDiscoveryProtocolService(connection *Connection, path string) *LinkLayerDiscoveryProtocolService {
	var result LinkLayerDiscoveryProtocolService
	result.connection = connection
	result.path = path
	return &result
}

//
// Fetches information elements received by LLDP.
//
type LinkLayerDiscoveryProtocolServiceListRequest struct {
	LinkLayerDiscoveryProtocolService *LinkLayerDiscoveryProtocolService
	header                            map[string]string
	query                             map[string]string
	follow                            *string
}

func (p *LinkLayerDiscoveryProtocolServiceListRequest) Header(key, value string) *LinkLayerDiscoveryProtocolServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *LinkLayerDiscoveryProtocolServiceListRequest) Query(key, value string) *LinkLayerDiscoveryProtocolServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *LinkLayerDiscoveryProtocolServiceListRequest) Follow(follow string) *LinkLayerDiscoveryProtocolServiceListRequest {
	p.follow = &follow
	return p
}

func (p *LinkLayerDiscoveryProtocolServiceListRequest) Send() (*LinkLayerDiscoveryProtocolServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.LinkLayerDiscoveryProtocolService.connection.URL(), p.LinkLayerDiscoveryProtocolService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.LinkLayerDiscoveryProtocolService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.LinkLayerDiscoveryProtocolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.LinkLayerDiscoveryProtocolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.LinkLayerDiscoveryProtocolService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.LinkLayerDiscoveryProtocolService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLLinkLayerDiscoveryProtocolElementReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &LinkLayerDiscoveryProtocolServiceListResponse{elements: result}, nil
}

func (p *LinkLayerDiscoveryProtocolServiceListRequest) MustSend() *LinkLayerDiscoveryProtocolServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Fetches information elements received by LLDP.
//
type LinkLayerDiscoveryProtocolServiceListResponse struct {
	elements *LinkLayerDiscoveryProtocolElementSlice
}

func (p *LinkLayerDiscoveryProtocolServiceListResponse) Elements() (*LinkLayerDiscoveryProtocolElementSlice, bool) {
	if p.elements != nil {
		return p.elements, true
	}
	return nil, false
}

func (p *LinkLayerDiscoveryProtocolServiceListResponse) MustElements() *LinkLayerDiscoveryProtocolElementSlice {
	if p.elements == nil {
		panic("elements in response does not exist")
	}
	return p.elements
}

//
// Fetches information elements received by LLDP.
//
func (p *LinkLayerDiscoveryProtocolService) List() *LinkLayerDiscoveryProtocolServiceListRequest {
	return &LinkLayerDiscoveryProtocolServiceListRequest{LinkLayerDiscoveryProtocolService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *LinkLayerDiscoveryProtocolService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *LinkLayerDiscoveryProtocolService) String() string {
	return fmt.Sprintf("LinkLayerDiscoveryProtocolService:%s", op.path)
}

//
// Manages the set of storage limits configured for a quota.
//
type QuotaStorageLimitsService struct {
	BaseService
}

func NewQuotaStorageLimitsService(connection *Connection, path string) *QuotaStorageLimitsService {
	var result QuotaStorageLimitsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a storage limit to a specified quota.
// To create a 100GiB storage limit for all storage domains in a data center, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>100</limit>
// </quota_storage_limit>
// ----
// To create a 50GiB storage limit for a storage domain with the ID `000`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>50</limit>
//   <storage_domain id="000"/>
// </quota_storage_limit>
// ----
//
type QuotaStorageLimitsServiceAddRequest struct {
	QuotaStorageLimitsService *QuotaStorageLimitsService
	header                    map[string]string
	query                     map[string]string
	limit                     *QuotaStorageLimit
}

func (p *QuotaStorageLimitsServiceAddRequest) Header(key, value string) *QuotaStorageLimitsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceAddRequest) Query(key, value string) *QuotaStorageLimitsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceAddRequest) Limit(limit *QuotaStorageLimit) *QuotaStorageLimitsServiceAddRequest {
	p.limit = limit
	return p
}

func (p *QuotaStorageLimitsServiceAddRequest) Send() (*QuotaStorageLimitsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaStorageLimitsService.connection.URL(), p.QuotaStorageLimitsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQuotaStorageLimitWriteOne(writer, p.limit, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaStorageLimitsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaStorageLimitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaStorageLimitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaStorageLimitsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaStorageLimitsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QuotaStorageLimitsServiceAddResponse{limit: result}, nil
}

func (p *QuotaStorageLimitsServiceAddRequest) MustSend() *QuotaStorageLimitsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a storage limit to a specified quota.
// To create a 100GiB storage limit for all storage domains in a data center, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>100</limit>
// </quota_storage_limit>
// ----
// To create a 50GiB storage limit for a storage domain with the ID `000`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>50</limit>
//   <storage_domain id="000"/>
// </quota_storage_limit>
// ----
//
type QuotaStorageLimitsServiceAddResponse struct {
	limit *QuotaStorageLimit
}

func (p *QuotaStorageLimitsServiceAddResponse) Limit() (*QuotaStorageLimit, bool) {
	if p.limit != nil {
		return p.limit, true
	}
	return nil, false
}

func (p *QuotaStorageLimitsServiceAddResponse) MustLimit() *QuotaStorageLimit {
	if p.limit == nil {
		panic("limit in response does not exist")
	}
	return p.limit
}

//
// Adds a storage limit to a specified quota.
// To create a 100GiB storage limit for all storage domains in a data center, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>100</limit>
// </quota_storage_limit>
// ----
// To create a 50GiB storage limit for a storage domain with the ID `000`, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/quotas/456/quotastoragelimits
// ----
// With a request body like this:
// [source,xml]
// ----
// <quota_storage_limit>
//   <limit>50</limit>
//   <storage_domain id="000"/>
// </quota_storage_limit>
// ----
//
func (p *QuotaStorageLimitsService) Add() *QuotaStorageLimitsServiceAddRequest {
	return &QuotaStorageLimitsServiceAddRequest{QuotaStorageLimitsService: p}
}

//
// Returns the list of storage limits configured for the quota.
// The order of the returned list of storage limits is not guaranteed.
//
type QuotaStorageLimitsServiceListRequest struct {
	QuotaStorageLimitsService *QuotaStorageLimitsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *QuotaStorageLimitsServiceListRequest) Header(key, value string) *QuotaStorageLimitsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceListRequest) Query(key, value string) *QuotaStorageLimitsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QuotaStorageLimitsServiceListRequest) Follow(follow string) *QuotaStorageLimitsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *QuotaStorageLimitsServiceListRequest) Max(max int64) *QuotaStorageLimitsServiceListRequest {
	p.max = &max
	return p
}

func (p *QuotaStorageLimitsServiceListRequest) Send() (*QuotaStorageLimitsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QuotaStorageLimitsService.connection.URL(), p.QuotaStorageLimitsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QuotaStorageLimitsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QuotaStorageLimitsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QuotaStorageLimitsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QuotaStorageLimitsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QuotaStorageLimitsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQuotaStorageLimitReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &QuotaStorageLimitsServiceListResponse{limits: result}, nil
}

func (p *QuotaStorageLimitsServiceListRequest) MustSend() *QuotaStorageLimitsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of storage limits configured for the quota.
// The order of the returned list of storage limits is not guaranteed.
//
type QuotaStorageLimitsServiceListResponse struct {
	limits *QuotaStorageLimitSlice
}

func (p *QuotaStorageLimitsServiceListResponse) Limits() (*QuotaStorageLimitSlice, bool) {
	if p.limits != nil {
		return p.limits, true
	}
	return nil, false
}

func (p *QuotaStorageLimitsServiceListResponse) MustLimits() *QuotaStorageLimitSlice {
	if p.limits == nil {
		panic("limits in response does not exist")
	}
	return p.limits
}

//
// Returns the list of storage limits configured for the quota.
// The order of the returned list of storage limits is not guaranteed.
//
func (p *QuotaStorageLimitsService) List() *QuotaStorageLimitsServiceListRequest {
	return &QuotaStorageLimitsServiceListRequest{QuotaStorageLimitsService: p}
}

//
//
func (op *QuotaStorageLimitsService) LimitService(id string) *QuotaStorageLimitService {
	return NewQuotaStorageLimitService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QuotaStorageLimitsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.LimitService(path), nil
	}
	return op.LimitService(path[:index]).Service(path[index+1:])
}

func (op *QuotaStorageLimitsService) String() string {
	return fmt.Sprintf("QuotaStorageLimitsService:%s", op.path)
}

//
//
type SnapshotService struct {
	BaseService
}

func NewSnapshotService(connection *Connection, path string) *SnapshotService {
	var result SnapshotService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type SnapshotServiceGetRequest struct {
	SnapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
	follow          *string
}

func (p *SnapshotServiceGetRequest) Header(key, value string) *SnapshotServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceGetRequest) Query(key, value string) *SnapshotServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceGetRequest) Follow(follow string) *SnapshotServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *SnapshotServiceGetRequest) Send() (*SnapshotServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotService.connection.URL(), p.SnapshotService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSnapshotReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SnapshotServiceGetResponse{snapshot: result}, nil
}

func (p *SnapshotServiceGetRequest) MustSend() *SnapshotServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SnapshotServiceGetResponse struct {
	snapshot *Snapshot
}

func (p *SnapshotServiceGetResponse) Snapshot() (*Snapshot, bool) {
	if p.snapshot != nil {
		return p.snapshot, true
	}
	return nil, false
}

func (p *SnapshotServiceGetResponse) MustSnapshot() *Snapshot {
	if p.snapshot == nil {
		panic("snapshot in response does not exist")
	}
	return p.snapshot
}

//
//
func (p *SnapshotService) Get() *SnapshotServiceGetRequest {
	return &SnapshotServiceGetRequest{SnapshotService: p}
}

//
//
type SnapshotServiceRemoveRequest struct {
	SnapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
	allContent      *bool
	async           *bool
}

func (p *SnapshotServiceRemoveRequest) Header(key, value string) *SnapshotServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceRemoveRequest) Query(key, value string) *SnapshotServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceRemoveRequest) AllContent(allContent bool) *SnapshotServiceRemoveRequest {
	p.allContent = &allContent
	return p
}

func (p *SnapshotServiceRemoveRequest) Async(async bool) *SnapshotServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *SnapshotServiceRemoveRequest) Send() (*SnapshotServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotService.connection.URL(), p.SnapshotService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(SnapshotServiceRemoveResponse), nil
}

func (p *SnapshotServiceRemoveRequest) MustSend() *SnapshotServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SnapshotServiceRemoveResponse struct {
}

//
//
func (p *SnapshotService) Remove() *SnapshotServiceRemoveRequest {
	return &SnapshotServiceRemoveRequest{SnapshotService: p}
}

//
// Restores a virtual machine snapshot.
// For example, to restore the snapshot with identifier `456` of virtual machine with identifier `123` send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots/456/restore
// ----
// With an empty `action` in the body:
// [source,xml]
// ----
// <action/>
// ----
//
type SnapshotServiceRestoreRequest struct {
	SnapshotService *SnapshotService
	header          map[string]string
	query           map[string]string
	async           *bool
	disks           *DiskSlice
	restoreMemory   *bool
}

func (p *SnapshotServiceRestoreRequest) Header(key, value string) *SnapshotServiceRestoreRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotServiceRestoreRequest) Query(key, value string) *SnapshotServiceRestoreRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotServiceRestoreRequest) Async(async bool) *SnapshotServiceRestoreRequest {
	p.async = &async
	return p
}

func (p *SnapshotServiceRestoreRequest) Disks(disks *DiskSlice) *SnapshotServiceRestoreRequest {
	p.disks = disks
	return p
}

func (p *SnapshotServiceRestoreRequest) DisksOfAny(anys ...*Disk) *SnapshotServiceRestoreRequest {
	if p.disks == nil {
		p.disks = new(DiskSlice)
	}
	p.disks.slice = append(p.disks.slice, anys...)
	return p
}

func (p *SnapshotServiceRestoreRequest) RestoreMemory(restoreMemory bool) *SnapshotServiceRestoreRequest {
	p.restoreMemory = &restoreMemory
	return p
}

func (p *SnapshotServiceRestoreRequest) Send() (*SnapshotServiceRestoreResponse, error) {
	rawURL := fmt.Sprintf("%s%s/restore", p.SnapshotService.connection.URL(), p.SnapshotService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disks(p.disks)
	if p.restoreMemory != nil {
		actionBuilder.RestoreMemory(*p.restoreMemory)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(SnapshotServiceRestoreResponse), nil
}

func (p *SnapshotServiceRestoreRequest) MustSend() *SnapshotServiceRestoreResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Restores a virtual machine snapshot.
// For example, to restore the snapshot with identifier `456` of virtual machine with identifier `123` send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots/456/restore
// ----
// With an empty `action` in the body:
// [source,xml]
// ----
// <action/>
// ----
//
type SnapshotServiceRestoreResponse struct {
}

//
// Restores a virtual machine snapshot.
// For example, to restore the snapshot with identifier `456` of virtual machine with identifier `123` send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/vms/123/snapshots/456/restore
// ----
// With an empty `action` in the body:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *SnapshotService) Restore() *SnapshotServiceRestoreRequest {
	return &SnapshotServiceRestoreRequest{SnapshotService: p}
}

//
//
func (op *SnapshotService) CdromsService() *SnapshotCdromsService {
	return NewSnapshotCdromsService(op.connection, fmt.Sprintf("%s/cdroms", op.path))
}

//
//
func (op *SnapshotService) DisksService() *SnapshotDisksService {
	return NewSnapshotDisksService(op.connection, fmt.Sprintf("%s/disks", op.path))
}

//
//
func (op *SnapshotService) NicsService() *SnapshotNicsService {
	return NewSnapshotNicsService(op.connection, fmt.Sprintf("%s/nics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "cdroms" {
		return op.CdromsService(), nil
	}
	if strings.HasPrefix(path, "cdroms/") {
		return op.CdromsService().Service(path[7:])
	}
	if path == "disks" {
		return op.DisksService(), nil
	}
	if strings.HasPrefix(path, "disks/") {
		return op.DisksService().Service(path[6:])
	}
	if path == "nics" {
		return op.NicsService(), nil
	}
	if strings.HasPrefix(path, "nics/") {
		return op.NicsService().Service(path[5:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotService) String() string {
	return fmt.Sprintf("SnapshotService:%s", op.path)
}

//
// This service manages a single virtual machine label assigned to an affinity group.
//
type AffinityGroupVmLabelService struct {
	BaseService
}

func NewAffinityGroupVmLabelService(connection *Connection, path string) *AffinityGroupVmLabelService {
	var result AffinityGroupVmLabelService
	result.connection = connection
	result.path = path
	return &result
}

//
// Remove this label from the affinity group.
//
type AffinityGroupVmLabelServiceRemoveRequest struct {
	AffinityGroupVmLabelService *AffinityGroupVmLabelService
	header                      map[string]string
	query                       map[string]string
	async                       *bool
}

func (p *AffinityGroupVmLabelServiceRemoveRequest) Header(key, value string) *AffinityGroupVmLabelServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupVmLabelServiceRemoveRequest) Query(key, value string) *AffinityGroupVmLabelServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupVmLabelServiceRemoveRequest) Async(async bool) *AffinityGroupVmLabelServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *AffinityGroupVmLabelServiceRemoveRequest) Send() (*AffinityGroupVmLabelServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupVmLabelService.connection.URL(), p.AffinityGroupVmLabelService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupVmLabelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupVmLabelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupVmLabelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupVmLabelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupVmLabelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(AffinityGroupVmLabelServiceRemoveResponse), nil
}

func (p *AffinityGroupVmLabelServiceRemoveRequest) MustSend() *AffinityGroupVmLabelServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Remove this label from the affinity group.
//
type AffinityGroupVmLabelServiceRemoveResponse struct {
}

//
// Remove this label from the affinity group.
//
func (p *AffinityGroupVmLabelService) Remove() *AffinityGroupVmLabelServiceRemoveRequest {
	return &AffinityGroupVmLabelServiceRemoveRequest{AffinityGroupVmLabelService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupVmLabelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AffinityGroupVmLabelService) String() string {
	return fmt.Sprintf("AffinityGroupVmLabelService:%s", op.path)
}

//
// A service to list all external network providers provisioned by the system on the host.
//
type ExternalNetworkProviderConfigurationsService struct {
	BaseService
}

func NewExternalNetworkProviderConfigurationsService(connection *Connection, path string) *ExternalNetworkProviderConfigurationsService {
	var result ExternalNetworkProviderConfigurationsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of all external network providers on the host.
// The order of the returned list of networks is not guaranteed.
//
type ExternalNetworkProviderConfigurationsServiceListRequest struct {
	ExternalNetworkProviderConfigurationsService *ExternalNetworkProviderConfigurationsService
	header                                       map[string]string
	query                                        map[string]string
	follow                                       *string
}

func (p *ExternalNetworkProviderConfigurationsServiceListRequest) Header(key, value string) *ExternalNetworkProviderConfigurationsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalNetworkProviderConfigurationsServiceListRequest) Query(key, value string) *ExternalNetworkProviderConfigurationsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalNetworkProviderConfigurationsServiceListRequest) Follow(follow string) *ExternalNetworkProviderConfigurationsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ExternalNetworkProviderConfigurationsServiceListRequest) Send() (*ExternalNetworkProviderConfigurationsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalNetworkProviderConfigurationsService.connection.URL(), p.ExternalNetworkProviderConfigurationsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalNetworkProviderConfigurationsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalNetworkProviderConfigurationsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalNetworkProviderConfigurationsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalNetworkProviderConfigurationsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalNetworkProviderConfigurationsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLExternalNetworkProviderConfigurationReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ExternalNetworkProviderConfigurationsServiceListResponse{configurations: result}, nil
}

func (p *ExternalNetworkProviderConfigurationsServiceListRequest) MustSend() *ExternalNetworkProviderConfigurationsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of all external network providers on the host.
// The order of the returned list of networks is not guaranteed.
//
type ExternalNetworkProviderConfigurationsServiceListResponse struct {
	configurations *ExternalNetworkProviderConfigurationSlice
}

func (p *ExternalNetworkProviderConfigurationsServiceListResponse) Configurations() (*ExternalNetworkProviderConfigurationSlice, bool) {
	if p.configurations != nil {
		return p.configurations, true
	}
	return nil, false
}

func (p *ExternalNetworkProviderConfigurationsServiceListResponse) MustConfigurations() *ExternalNetworkProviderConfigurationSlice {
	if p.configurations == nil {
		panic("configurations in response does not exist")
	}
	return p.configurations
}

//
// Returns the list of all external network providers on the host.
// The order of the returned list of networks is not guaranteed.
//
func (p *ExternalNetworkProviderConfigurationsService) List() *ExternalNetworkProviderConfigurationsServiceListRequest {
	return &ExternalNetworkProviderConfigurationsServiceListRequest{ExternalNetworkProviderConfigurationsService: p}
}

//
//
func (op *ExternalNetworkProviderConfigurationsService) ConfigurationService(id string) *ExternalNetworkProviderConfigurationService {
	return NewExternalNetworkProviderConfigurationService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalNetworkProviderConfigurationsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ConfigurationService(path), nil
	}
	return op.ConfigurationService(path[:index]).Service(path[index+1:])
}

func (op *ExternalNetworkProviderConfigurationsService) String() string {
	return fmt.Sprintf("ExternalNetworkProviderConfigurationsService:%s", op.path)
}

//
//
type HostHooksService struct {
	BaseService
}

func NewHostHooksService(connection *Connection, path string) *HostHooksService {
	var result HostHooksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of hooks configured for the host.
// The order of the returned list of hooks is random.
//
type HostHooksServiceListRequest struct {
	HostHooksService *HostHooksService
	header           map[string]string
	query            map[string]string
	follow           *string
	max              *int64
}

func (p *HostHooksServiceListRequest) Header(key, value string) *HostHooksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostHooksServiceListRequest) Query(key, value string) *HostHooksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostHooksServiceListRequest) Follow(follow string) *HostHooksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *HostHooksServiceListRequest) Max(max int64) *HostHooksServiceListRequest {
	p.max = &max
	return p
}

func (p *HostHooksServiceListRequest) Send() (*HostHooksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostHooksService.connection.URL(), p.HostHooksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostHooksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostHooksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostHooksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostHooksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostHooksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHookReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &HostHooksServiceListResponse{hooks: result}, nil
}

func (p *HostHooksServiceListRequest) MustSend() *HostHooksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of hooks configured for the host.
// The order of the returned list of hooks is random.
//
type HostHooksServiceListResponse struct {
	hooks *HookSlice
}

func (p *HostHooksServiceListResponse) Hooks() (*HookSlice, bool) {
	if p.hooks != nil {
		return p.hooks, true
	}
	return nil, false
}

func (p *HostHooksServiceListResponse) MustHooks() *HookSlice {
	if p.hooks == nil {
		panic("hooks in response does not exist")
	}
	return p.hooks
}

//
// Returns the list of hooks configured for the host.
// The order of the returned list of hooks is random.
//
func (p *HostHooksService) List() *HostHooksServiceListRequest {
	return &HostHooksServiceListRequest{HostHooksService: p}
}

//
//
func (op *HostHooksService) HookService(id string) *HostHookService {
	return NewHostHookService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostHooksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HookService(path), nil
	}
	return op.HookService(path[:index]).Service(path[index+1:])
}

func (op *HostHooksService) String() string {
	return fmt.Sprintf("HostHooksService:%s", op.path)
}

//
// Manages a CDROM device of a virtual machine.
// Changing and ejecting the disk is done using always the `update` method, to change the value of the `file`
// attribute.
//
type VmCdromService struct {
	BaseService
}

func NewVmCdromService(connection *Connection, path string) *VmCdromService {
	var result VmCdromService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the information about this CDROM device.
// The information consists of `cdrom` attribute containing reference to the CDROM device, the virtual machine,
// and optionally the inserted disk.
// If there is a disk inserted then the `file` attribute will contain a reference to the ISO image:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <file id="mycd.iso"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
// If there is no disk inserted then the `file` attribute won't be reported:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
//
type VmCdromServiceGetRequest struct {
	VmCdromService *VmCdromService
	header         map[string]string
	query          map[string]string
	current        *bool
	follow         *string
}

func (p *VmCdromServiceGetRequest) Header(key, value string) *VmCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromServiceGetRequest) Query(key, value string) *VmCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromServiceGetRequest) Current(current bool) *VmCdromServiceGetRequest {
	p.current = &current
	return p
}

func (p *VmCdromServiceGetRequest) Follow(follow string) *VmCdromServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmCdromServiceGetRequest) Send() (*VmCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmCdromService.connection.URL(), p.VmCdromService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmCdromService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmCdromService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmCdromService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmCdromService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmCdromService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmCdromServiceGetResponse{cdrom: result}, nil
}

func (p *VmCdromServiceGetRequest) MustSend() *VmCdromServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the information about this CDROM device.
// The information consists of `cdrom` attribute containing reference to the CDROM device, the virtual machine,
// and optionally the inserted disk.
// If there is a disk inserted then the `file` attribute will contain a reference to the ISO image:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <file id="mycd.iso"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
// If there is no disk inserted then the `file` attribute won't be reported:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
//
type VmCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *VmCdromServiceGetResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *VmCdromServiceGetResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
// Returns the information about this CDROM device.
// The information consists of `cdrom` attribute containing reference to the CDROM device, the virtual machine,
// and optionally the inserted disk.
// If there is a disk inserted then the `file` attribute will contain a reference to the ISO image:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <file id="mycd.iso"/>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
// If there is no disk inserted then the `file` attribute won't be reported:
// [source,xml]
// ----
// <cdrom href="..." id="00000000-0000-0000-0000-000000000000">
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </cdrom>
// ----
//
func (p *VmCdromService) Get() *VmCdromServiceGetRequest {
	return &VmCdromServiceGetRequest{VmCdromService: p}
}

//
// Updates the information about this CDROM device.
// It allows to change or eject the disk by changing the value of the `file` attribute.
// For example, to insert or change the disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000
// ----
// The body should contain the new value for the `file` attribute:
// [source,xml]
// ----
// <cdrom>
//   <file id="mycd.iso"/>
// </cdrom>
// ----
// The value of the `id` attribute, `mycd.iso` in this example, should correspond to a file available in an
// attached ISO storage domain.
// To eject the disk use a `file` with an empty `id`:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// By default the above operations change permanently the disk that will be visible to the virtual machine
// after the next boot, but they don't have any effect on the currently running virtual machine. If you want
// to change the disk that is visible to the current running virtual machine, add the `current=true` parameter.
// For example, to eject the current disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000?current=true
// ----
// With a request body like this:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// IMPORTANT: The changes made with the `current=true` parameter are never persisted, so they won't have any
// effect after the virtual machine is rebooted.
//
type VmCdromServiceUpdateRequest struct {
	VmCdromService *VmCdromService
	header         map[string]string
	query          map[string]string
	cdrom          *Cdrom
	current        *bool
}

func (p *VmCdromServiceUpdateRequest) Header(key, value string) *VmCdromServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmCdromServiceUpdateRequest) Query(key, value string) *VmCdromServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmCdromServiceUpdateRequest) Cdrom(cdrom *Cdrom) *VmCdromServiceUpdateRequest {
	p.cdrom = cdrom
	return p
}

func (p *VmCdromServiceUpdateRequest) Current(current bool) *VmCdromServiceUpdateRequest {
	p.current = &current
	return p
}

func (p *VmCdromServiceUpdateRequest) Send() (*VmCdromServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmCdromService.connection.URL(), p.VmCdromService.path)
	values := make(url.Values)
	if p.current != nil {
		values["current"] = []string{fmt.Sprintf("%v", *p.current)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCdromWriteOne(writer, p.cdrom, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmCdromService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmCdromService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmCdromService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmCdromService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmCdromService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmCdromServiceUpdateResponse{cdrom: result}, nil
}

func (p *VmCdromServiceUpdateRequest) MustSend() *VmCdromServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the information about this CDROM device.
// It allows to change or eject the disk by changing the value of the `file` attribute.
// For example, to insert or change the disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000
// ----
// The body should contain the new value for the `file` attribute:
// [source,xml]
// ----
// <cdrom>
//   <file id="mycd.iso"/>
// </cdrom>
// ----
// The value of the `id` attribute, `mycd.iso` in this example, should correspond to a file available in an
// attached ISO storage domain.
// To eject the disk use a `file` with an empty `id`:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// By default the above operations change permanently the disk that will be visible to the virtual machine
// after the next boot, but they don't have any effect on the currently running virtual machine. If you want
// to change the disk that is visible to the current running virtual machine, add the `current=true` parameter.
// For example, to eject the current disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000?current=true
// ----
// With a request body like this:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// IMPORTANT: The changes made with the `current=true` parameter are never persisted, so they won't have any
// effect after the virtual machine is rebooted.
//
type VmCdromServiceUpdateResponse struct {
	cdrom *Cdrom
}

func (p *VmCdromServiceUpdateResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *VmCdromServiceUpdateResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
// Updates the information about this CDROM device.
// It allows to change or eject the disk by changing the value of the `file` attribute.
// For example, to insert or change the disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000
// ----
// The body should contain the new value for the `file` attribute:
// [source,xml]
// ----
// <cdrom>
//   <file id="mycd.iso"/>
// </cdrom>
// ----
// The value of the `id` attribute, `mycd.iso` in this example, should correspond to a file available in an
// attached ISO storage domain.
// To eject the disk use a `file` with an empty `id`:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// By default the above operations change permanently the disk that will be visible to the virtual machine
// after the next boot, but they don't have any effect on the currently running virtual machine. If you want
// to change the disk that is visible to the current running virtual machine, add the `current=true` parameter.
// For example, to eject the current disk send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/vms/123/cdroms/00000000-0000-0000-0000-000000000000?current=true
// ----
// With a request body like this:
// [source,xml]
// ----
// <cdrom>
//   <file id=""/>
// </cdrom>
// ----
// IMPORTANT: The changes made with the `current=true` parameter are never persisted, so they won't have any
// effect after the virtual machine is rebooted.
//
func (p *VmCdromService) Update() *VmCdromServiceUpdateRequest {
	return &VmCdromServiceUpdateRequest{VmCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmCdromService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmCdromService) String() string {
	return fmt.Sprintf("VmCdromService:%s", op.path)
}

//
// Manages the set of images available in an storage domain or in an OpenStack image provider.
//
type ImagesService struct {
	BaseService
}

func NewImagesService(connection *Connection, path string) *ImagesService {
	var result ImagesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the list of images available in the storage domain or provider.
// The order of the returned list of images isn't guaranteed.
//
type ImagesServiceListRequest struct {
	ImagesService *ImagesService
	header        map[string]string
	query         map[string]string
	follow        *string
	max           *int64
}

func (p *ImagesServiceListRequest) Header(key, value string) *ImagesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImagesServiceListRequest) Query(key, value string) *ImagesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImagesServiceListRequest) Follow(follow string) *ImagesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ImagesServiceListRequest) Max(max int64) *ImagesServiceListRequest {
	p.max = &max
	return p
}

func (p *ImagesServiceListRequest) Send() (*ImagesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ImagesService.connection.URL(), p.ImagesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImagesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImagesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImagesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImagesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImagesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ImagesServiceListResponse{images: result}, nil
}

func (p *ImagesServiceListRequest) MustSend() *ImagesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of images available in the storage domain or provider.
// The order of the returned list of images isn't guaranteed.
//
type ImagesServiceListResponse struct {
	images *ImageSlice
}

func (p *ImagesServiceListResponse) Images() (*ImageSlice, bool) {
	if p.images != nil {
		return p.images, true
	}
	return nil, false
}

func (p *ImagesServiceListResponse) MustImages() *ImageSlice {
	if p.images == nil {
		panic("images in response does not exist")
	}
	return p.images
}

//
// Returns the list of images available in the storage domain or provider.
// The order of the returned list of images isn't guaranteed.
//
func (p *ImagesService) List() *ImagesServiceListRequest {
	return &ImagesServiceListRequest{ImagesService: p}
}

//
//
func (op *ImagesService) ImageService(id string) *ImageService {
	return NewImageService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImagesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ImageService(path), nil
	}
	return op.ImageService(path[:index]).Service(path[index+1:])
}

func (op *ImagesService) String() string {
	return fmt.Sprintf("ImagesService:%s", op.path)
}

//
//
type HostNumaNodeService struct {
	BaseService
}

func NewHostNumaNodeService(connection *Connection, path string) *HostNumaNodeService {
	var result HostNumaNodeService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type HostNumaNodeServiceGetRequest struct {
	HostNumaNodeService *HostNumaNodeService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *HostNumaNodeServiceGetRequest) Header(key, value string) *HostNumaNodeServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostNumaNodeServiceGetRequest) Query(key, value string) *HostNumaNodeServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostNumaNodeServiceGetRequest) Follow(follow string) *HostNumaNodeServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *HostNumaNodeServiceGetRequest) Send() (*HostNumaNodeServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostNumaNodeService.connection.URL(), p.HostNumaNodeService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostNumaNodeService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostNumaNodeService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostNumaNodeService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostNumaNodeService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostNumaNodeService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNumaNodeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &HostNumaNodeServiceGetResponse{node: result}, nil
}

func (p *HostNumaNodeServiceGetRequest) MustSend() *HostNumaNodeServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type HostNumaNodeServiceGetResponse struct {
	node *NumaNode
}

func (p *HostNumaNodeServiceGetResponse) Node() (*NumaNode, bool) {
	if p.node != nil {
		return p.node, true
	}
	return nil, false
}

func (p *HostNumaNodeServiceGetResponse) MustNode() *NumaNode {
	if p.node == nil {
		panic("node in response does not exist")
	}
	return p.node
}

//
//
func (p *HostNumaNodeService) Get() *HostNumaNodeServiceGetRequest {
	return &HostNumaNodeServiceGetRequest{HostNumaNodeService: p}
}

//
//
func (op *HostNumaNodeService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostNumaNodeService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *HostNumaNodeService) String() string {
	return fmt.Sprintf("HostNumaNodeService:%s", op.path)
}

//
// A service to manage icons.
//
type IconsService struct {
	BaseService
}

func NewIconsService(connection *Connection, path string) *IconsService {
	var result IconsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get a list of icons.
// [source]
// ----
// GET /ovirt-engine/api/icons
// ----
// You will get a XML response which is similar to this one:
// [source,xml]
// ----
// <icons>
//   <icon id="123">
//     <data>...</data>
//     <media_type>image/png</media_type>
//   </icon>
//   ...
// </icons>
// ----
// The order of the returned list of icons isn't guaranteed.
//
type IconsServiceListRequest struct {
	IconsService *IconsService
	header       map[string]string
	query        map[string]string
	follow       *string
	max          *int64
}

func (p *IconsServiceListRequest) Header(key, value string) *IconsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IconsServiceListRequest) Query(key, value string) *IconsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IconsServiceListRequest) Follow(follow string) *IconsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *IconsServiceListRequest) Max(max int64) *IconsServiceListRequest {
	p.max = &max
	return p
}

func (p *IconsServiceListRequest) Send() (*IconsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.IconsService.connection.URL(), p.IconsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.IconsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.IconsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.IconsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.IconsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.IconsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIconReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &IconsServiceListResponse{icons: result}, nil
}

func (p *IconsServiceListRequest) MustSend() *IconsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get a list of icons.
// [source]
// ----
// GET /ovirt-engine/api/icons
// ----
// You will get a XML response which is similar to this one:
// [source,xml]
// ----
// <icons>
//   <icon id="123">
//     <data>...</data>
//     <media_type>image/png</media_type>
//   </icon>
//   ...
// </icons>
// ----
// The order of the returned list of icons isn't guaranteed.
//
type IconsServiceListResponse struct {
	icons *IconSlice
}

func (p *IconsServiceListResponse) Icons() (*IconSlice, bool) {
	if p.icons != nil {
		return p.icons, true
	}
	return nil, false
}

func (p *IconsServiceListResponse) MustIcons() *IconSlice {
	if p.icons == nil {
		panic("icons in response does not exist")
	}
	return p.icons
}

//
// Get a list of icons.
// [source]
// ----
// GET /ovirt-engine/api/icons
// ----
// You will get a XML response which is similar to this one:
// [source,xml]
// ----
// <icons>
//   <icon id="123">
//     <data>...</data>
//     <media_type>image/png</media_type>
//   </icon>
//   ...
// </icons>
// ----
// The order of the returned list of icons isn't guaranteed.
//
func (p *IconsService) List() *IconsServiceListRequest {
	return &IconsServiceListRequest{IconsService: p}
}

//
// Reference to the service that manages an specific icon.
//
func (op *IconsService) IconService(id string) *IconService {
	return NewIconService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IconsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.IconService(path), nil
	}
	return op.IconService(path[:index]).Service(path[index+1:])
}

func (op *IconsService) String() string {
	return fmt.Sprintf("IconsService:%s", op.path)
}

//
// Provides information about virtual machine user sessions.
//
type VmSessionsService struct {
	BaseService
}

func NewVmSessionsService(connection *Connection, path string) *VmSessionsService {
	var result VmSessionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Lists all user sessions for this virtual machine.
// For example, to retrieve the session information for virtual machine `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/sessions
// ----
// The response body will contain something like this:
// [source,xml]
// ----
// <sessions>
//   <session href="/ovirt-engine/api/vms/123/sessions/456" id="456">
//     <console_user>true</console_user>
//     <ip>
//       <address>192.168.122.1</address>
//     </ip>
//     <user href="/ovirt-engine/api/users/789" id="789"/>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </session>
//   ...
// </sessions>
// ----
// The order of the returned list of sessions isn't guaranteed.
//
type VmSessionsServiceListRequest struct {
	VmSessionsService *VmSessionsService
	header            map[string]string
	query             map[string]string
	follow            *string
	max               *int64
}

func (p *VmSessionsServiceListRequest) Header(key, value string) *VmSessionsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmSessionsServiceListRequest) Query(key, value string) *VmSessionsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmSessionsServiceListRequest) Follow(follow string) *VmSessionsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmSessionsServiceListRequest) Max(max int64) *VmSessionsServiceListRequest {
	p.max = &max
	return p
}

func (p *VmSessionsServiceListRequest) Send() (*VmSessionsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmSessionsService.connection.URL(), p.VmSessionsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmSessionsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmSessionsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmSessionsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmSessionsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmSessionsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSessionReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmSessionsServiceListResponse{sessions: result}, nil
}

func (p *VmSessionsServiceListRequest) MustSend() *VmSessionsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all user sessions for this virtual machine.
// For example, to retrieve the session information for virtual machine `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/sessions
// ----
// The response body will contain something like this:
// [source,xml]
// ----
// <sessions>
//   <session href="/ovirt-engine/api/vms/123/sessions/456" id="456">
//     <console_user>true</console_user>
//     <ip>
//       <address>192.168.122.1</address>
//     </ip>
//     <user href="/ovirt-engine/api/users/789" id="789"/>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </session>
//   ...
// </sessions>
// ----
// The order of the returned list of sessions isn't guaranteed.
//
type VmSessionsServiceListResponse struct {
	sessions *SessionSlice
}

func (p *VmSessionsServiceListResponse) Sessions() (*SessionSlice, bool) {
	if p.sessions != nil {
		return p.sessions, true
	}
	return nil, false
}

func (p *VmSessionsServiceListResponse) MustSessions() *SessionSlice {
	if p.sessions == nil {
		panic("sessions in response does not exist")
	}
	return p.sessions
}

//
// Lists all user sessions for this virtual machine.
// For example, to retrieve the session information for virtual machine `123` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/sessions
// ----
// The response body will contain something like this:
// [source,xml]
// ----
// <sessions>
//   <session href="/ovirt-engine/api/vms/123/sessions/456" id="456">
//     <console_user>true</console_user>
//     <ip>
//       <address>192.168.122.1</address>
//     </ip>
//     <user href="/ovirt-engine/api/users/789" id="789"/>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </session>
//   ...
// </sessions>
// ----
// The order of the returned list of sessions isn't guaranteed.
//
func (p *VmSessionsService) List() *VmSessionsServiceListRequest {
	return &VmSessionsServiceListRequest{VmSessionsService: p}
}

//
// Reference to the service that manages a specific session.
//
func (op *VmSessionsService) SessionService(id string) *VmSessionService {
	return NewVmSessionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmSessionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.SessionService(path), nil
	}
	return op.SessionService(path[:index]).Service(path[index+1:])
}

func (op *VmSessionsService) String() string {
	return fmt.Sprintf("VmSessionsService:%s", op.path)
}

//
// This service manages a collection of all hosts assigned to an affinity group.
//
type AffinityGroupHostsService struct {
	BaseService
}

func NewAffinityGroupHostsService(connection *Connection, path string) *AffinityGroupHostsService {
	var result AffinityGroupHostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds a host to the affinity group.
// For example, to add the host `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/hosts
// ....
// With the following body:
// [source,xml]
// ----
// <host id="789"/>
// ----
//
type AffinityGroupHostsServiceAddRequest struct {
	AffinityGroupHostsService *AffinityGroupHostsService
	header                    map[string]string
	query                     map[string]string
	host                      *Host
}

func (p *AffinityGroupHostsServiceAddRequest) Header(key, value string) *AffinityGroupHostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupHostsServiceAddRequest) Query(key, value string) *AffinityGroupHostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupHostsServiceAddRequest) Host(host *Host) *AffinityGroupHostsServiceAddRequest {
	p.host = host
	return p
}

func (p *AffinityGroupHostsServiceAddRequest) Send() (*AffinityGroupHostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupHostsService.connection.URL(), p.AffinityGroupHostsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupHostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupHostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupHostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AffinityGroupHostsServiceAddResponse{host: result}, nil
}

func (p *AffinityGroupHostsServiceAddRequest) MustSend() *AffinityGroupHostsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds a host to the affinity group.
// For example, to add the host `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/hosts
// ....
// With the following body:
// [source,xml]
// ----
// <host id="789"/>
// ----
//
type AffinityGroupHostsServiceAddResponse struct {
	host *Host
}

func (p *AffinityGroupHostsServiceAddResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *AffinityGroupHostsServiceAddResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Adds a host to the affinity group.
// For example, to add the host `789` to the affinity group `456` of cluster `123`, send a request like
// this:
// ....
// POST /ovirt-engine/api/clusters/123/affinitygroups/456/hosts
// ....
// With the following body:
// [source,xml]
// ----
// <host id="789"/>
// ----
//
func (p *AffinityGroupHostsService) Add() *AffinityGroupHostsServiceAddRequest {
	return &AffinityGroupHostsServiceAddRequest{AffinityGroupHostsService: p}
}

//
// List all hosts assigned to this affinity group.
// The order of the returned hosts isn't guaranteed.
//
type AffinityGroupHostsServiceListRequest struct {
	AffinityGroupHostsService *AffinityGroupHostsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *AffinityGroupHostsServiceListRequest) Header(key, value string) *AffinityGroupHostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AffinityGroupHostsServiceListRequest) Query(key, value string) *AffinityGroupHostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AffinityGroupHostsServiceListRequest) Follow(follow string) *AffinityGroupHostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AffinityGroupHostsServiceListRequest) Max(max int64) *AffinityGroupHostsServiceListRequest {
	p.max = &max
	return p
}

func (p *AffinityGroupHostsServiceListRequest) Send() (*AffinityGroupHostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AffinityGroupHostsService.connection.URL(), p.AffinityGroupHostsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AffinityGroupHostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AffinityGroupHostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AffinityGroupHostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AffinityGroupHostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AffinityGroupHostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AffinityGroupHostsServiceListResponse{hosts: result}, nil
}

func (p *AffinityGroupHostsServiceListRequest) MustSend() *AffinityGroupHostsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all hosts assigned to this affinity group.
// The order of the returned hosts isn't guaranteed.
//
type AffinityGroupHostsServiceListResponse struct {
	hosts *HostSlice
}

func (p *AffinityGroupHostsServiceListResponse) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *AffinityGroupHostsServiceListResponse) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// List all hosts assigned to this affinity group.
// The order of the returned hosts isn't guaranteed.
//
func (p *AffinityGroupHostsService) List() *AffinityGroupHostsServiceListRequest {
	return &AffinityGroupHostsServiceListRequest{AffinityGroupHostsService: p}
}

//
// Access the service that manages the host assignment to this affinity group.
//
func (op *AffinityGroupHostsService) HostService(id string) *AffinityGroupHostService {
	return NewAffinityGroupHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AffinityGroupHostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *AffinityGroupHostsService) String() string {
	return fmt.Sprintf("AffinityGroupHostsService:%s", op.path)
}

//
// A service to manage steps.
//
type StepsService struct {
	BaseService
}

func NewStepsService(connection *Connection, path string) *StepsService {
	var result StepsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add an external step to an existing job or to an existing step.
// For example, to add a step to `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps
// ----
// With the following request body:
// [source,xml]
// ----
// <step>
//   <description>Validating</description>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
// </step>
// ----
// The response should look like:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//   <external>true</external>
//   <number>2</number>
//   <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
type StepsServiceAddRequest struct {
	StepsService *StepsService
	header       map[string]string
	query        map[string]string
	step         *Step
}

func (p *StepsServiceAddRequest) Header(key, value string) *StepsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepsServiceAddRequest) Query(key, value string) *StepsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepsServiceAddRequest) Step(step *Step) *StepsServiceAddRequest {
	p.step = step
	return p
}

func (p *StepsServiceAddRequest) Send() (*StepsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StepsService.connection.URL(), p.StepsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLStepWriteOne(writer, p.step, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StepsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StepsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StepsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StepsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StepsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &StepsServiceAddResponse{step: result}, nil
}

func (p *StepsServiceAddRequest) MustSend() *StepsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add an external step to an existing job or to an existing step.
// For example, to add a step to `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps
// ----
// With the following request body:
// [source,xml]
// ----
// <step>
//   <description>Validating</description>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
// </step>
// ----
// The response should look like:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//   <external>true</external>
//   <number>2</number>
//   <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
type StepsServiceAddResponse struct {
	step *Step
}

func (p *StepsServiceAddResponse) Step() (*Step, bool) {
	if p.step != nil {
		return p.step, true
	}
	return nil, false
}

func (p *StepsServiceAddResponse) MustStep() *Step {
	if p.step == nil {
		panic("step in response does not exist")
	}
	return p.step
}

//
// Add an external step to an existing job or to an existing step.
// For example, to add a step to `job` with identifier `123` send the
// following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/123/steps
// ----
// With the following request body:
// [source,xml]
// ----
// <step>
//   <description>Validating</description>
//   <start_time>2016-12-12T23:07:26.605+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
// </step>
// ----
// The response should look like:
// [source,xml]
// ----
// <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//   </actions>
//   <description>Validating</description>
//   <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//   <external>true</external>
//   <number>2</number>
//   <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//   <status>started</status>
//   <type>validating</type>
//   <job href="/ovirt-engine/api/jobs/123" id="123"/>
// </step>
// ----
//
func (p *StepsService) Add() *StepsServiceAddRequest {
	return &StepsServiceAddRequest{StepsService: p}
}

//
// Retrieves the representation of the steps.
// [source]
// ----
// GET /ovirt-engine/api/job/123/steps
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <steps>
//   <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//     </actions>
//     <description>Validating</description>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//     <external>true</external>
//     <number>2</number>
//     <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//     <status>started</status>
//     <type>validating</type>
//     <job href="/ovirt-engine/api/jobs/123" id="123"/>
//   </step>
//   ...
// </steps>
// ----
// The order of the returned list of steps isn't guaranteed.
//
type StepsServiceListRequest struct {
	StepsService *StepsService
	header       map[string]string
	query        map[string]string
	follow       *string
	max          *int64
}

func (p *StepsServiceListRequest) Header(key, value string) *StepsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StepsServiceListRequest) Query(key, value string) *StepsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StepsServiceListRequest) Follow(follow string) *StepsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StepsServiceListRequest) Max(max int64) *StepsServiceListRequest {
	p.max = &max
	return p
}

func (p *StepsServiceListRequest) Send() (*StepsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StepsService.connection.URL(), p.StepsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StepsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StepsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StepsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StepsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StepsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStepReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StepsServiceListResponse{steps: result}, nil
}

func (p *StepsServiceListRequest) MustSend() *StepsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the representation of the steps.
// [source]
// ----
// GET /ovirt-engine/api/job/123/steps
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <steps>
//   <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//     </actions>
//     <description>Validating</description>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//     <external>true</external>
//     <number>2</number>
//     <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//     <status>started</status>
//     <type>validating</type>
//     <job href="/ovirt-engine/api/jobs/123" id="123"/>
//   </step>
//   ...
// </steps>
// ----
// The order of the returned list of steps isn't guaranteed.
//
type StepsServiceListResponse struct {
	steps *StepSlice
}

func (p *StepsServiceListResponse) Steps() (*StepSlice, bool) {
	if p.steps != nil {
		return p.steps, true
	}
	return nil, false
}

func (p *StepsServiceListResponse) MustSteps() *StepSlice {
	if p.steps == nil {
		panic("steps in response does not exist")
	}
	return p.steps
}

//
// Retrieves the representation of the steps.
// [source]
// ----
// GET /ovirt-engine/api/job/123/steps
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <steps>
//   <step href="/ovirt-engine/api/jobs/123/steps/456" id="456">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/steps/456/end" rel="end"/>
//     </actions>
//     <description>Validating</description>
//     <link href="/ovirt-engine/api/jobs/123/steps/456/statistics" rel="statistics"/>
//     <external>true</external>
//     <number>2</number>
//     <start_time>2016-12-13T01:06:15.380+02:00</start_time>
//     <status>started</status>
//     <type>validating</type>
//     <job href="/ovirt-engine/api/jobs/123" id="123"/>
//   </step>
//   ...
// </steps>
// ----
// The order of the returned list of steps isn't guaranteed.
//
func (p *StepsService) List() *StepsServiceListRequest {
	return &StepsServiceListRequest{StepsService: p}
}

//
// Reference to the step service.
//
func (op *StepsService) StepService(id string) *StepService {
	return NewStepService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StepsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StepService(path), nil
	}
	return op.StepService(path[:index]).Service(path[index+1:])
}

func (op *StepsService) String() string {
	return fmt.Sprintf("StepsService:%s", op.path)
}

//
// This service provides a mechanism to control an image transfer. The client will have
// to create a transfer by using <<services/image_transfers/methods/add, add>>
// of the <<services/image_transfers>> service, stating the image to transfer
// data to/from.
// After doing that, the transfer is managed by this service.
// *Using oVirt's Python's SDK:*
// Uploading a `disk` with id `123` (on a random host in the data center):
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       disk=types.Disk(
//          id='123'
//       )
//    )
// )
// ----
// Uploading a `disk` with id `123` on `host` id `456`:
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       disk=types.Disk(
//          id='123'
//       ),
//       host=types.Host(
//          id='456'
//      )
//    )
// )
// ----
// If the user wishes to download a disk rather than upload, he/she should specify
// `download` as the <<types/image_transfer_direction, direction>> attribute of the transfer.
// This will grant a read permission from the image, instead of a write permission.
// E.g:
// [source,python]
// ----
// transfers_service = system_service.image_transfers_service()
// transfer = transfers_service.add(
//    types.ImageTransfer(
//       disk=types.Disk(
//          id='123'
//       ),
//       direction=types.ImageTransferDirection.DOWNLOAD
//    )
// )
// ----
// Transfers have phases, which govern the flow of the upload/download.
// A client implementing such a flow should poll/check the transfer's phase and
// act accordingly. All the possible phases can be found in
// <<types/image_transfer_phase, ImageTransferPhase>>.
// After adding a new transfer, its phase will be <<types/image_transfer_phase, initializing>>.
// The client will have to poll on the transfer's phase until it changes.
// When the phase becomes <<types/image_transfer_phase, transferring>>,
// the session is ready to start the transfer.
// For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// while transfer.phase == types.ImageTransferPhase.INITIALIZING:
//    time.sleep(3)
//    transfer = transfer_service.get()
// ----
// At that stage, if the transfer's phase is <<types/image_transfer_phase, paused_system>>, then the session was
// not successfully established. One possible reason for that is that the ovirt-imageio-daemon is not running
// in the host that was selected for transfer.
// The transfer can be resumed by calling <<services/image_transfer/methods/resume, resume>>
// of the service that manages it.
// If the session was successfully established - the returned transfer entity will
// contain the <<types/image_transfer, proxy_url>> and <<types/image_transfer, signed_ticket>> attributes,
// which the client needs to use in order to transfer the required data. The client can choose whatever
// technique and tool for sending the HTTPS request with the image's data.
// - `proxy_url` is the address of a proxy server to the image, to do I/O to.
// - `signed_ticket` is the content that needs to be added to the `Authentication`
//    header in the HTTPS request, in order to perform a trusted communication.
// For example, Python's HTTPSConnection can be used in order to perform a transfer,
// so an `transfer_headers` dict is set for the upcoming transfer:
// [source,python]
// ----
// transfer_headers = {
//    'Authorization' :  transfer.signed_ticket,
// }
// ----
// Using Python's `HTTPSConnection`, a new connection is established:
// [source,python]
// ----
// # Extract the URI, port, and path from the transfer's proxy_url.
// url = urlparse.urlparse(transfer.proxy_url)
// # Create a new instance of the connection.
// proxy_connection = HTTPSConnection(
//    url.hostname,
//    url.port,
//    context=ssl.SSLContext(ssl.PROTOCOL_SSLv23)
// )
// ----
// For upload, the specific content range being sent must be noted in the `Content-Range` HTTPS
// header. This can be used in order to split the transfer into several requests for
// a more flexible process.
// For doing that, the client will have to repeatedly extend the transfer session
// to keep the channel open. Otherwise, the session will terminate and the transfer will
// get into `paused_system` phase, and HTTPS requests to the server will be rejected.
// E.g., the client can iterate on chunks of the file, and send them to the
// proxy server while asking the service to extend the session:
// [source,python]
// ----
// path = "/path/to/image"
// MB_per_request = 32
// with open(path, "rb") as disk:
//    size = os.path.getsize(path)
//    chunk_size = 1024*1024*MB_per_request
//    pos = 0
//    while (pos < size):
//       transfer_service.extend()
//       transfer_headers['Content-Range'] = "bytes %d-%d/%d" % (pos, min(pos + chunk_size, size)-1, size)
//       proxy_connection.request(
//          'PUT',
//          url.path,
//          disk.read(chunk_size),
//          headers=transfer_headers
//       )
//       r = proxy_connection.getresponse()
//       print r.status, r.reason, "Completed", "{:.0%}".format(pos/ float(size))
//       pos += chunk_size
// ----
// Similarly, for a download transfer, a `Range` header must be sent, making the download process
// more easily managed by downloading the disk in chunks.
// E.g., the client will again iterate on chunks of the disk image, but this time he/she will download
// it to a local file, rather than uploading its own file to the image:
// [source,python]
// ----
// output_file = "/home/user/downloaded_image"
// MiB_per_request = 32
// chunk_size = 1024*1024*MiB_per_request
// total = disk_size
// with open(output_file, "wb") as disk:
//    pos = 0
//    while pos < total:
//       transfer_service.extend()
//       transfer_headers['Range'] = "bytes=%d-%d" %  (pos, min(total, pos + chunk_size) - 1)
//       proxy_connection.request('GET', proxy_url.path, headers=transfer_headers)
//       r = proxy_connection.getresponse()
//       disk.write(r.read())
//       print "Completed", "{:.0%}".format(pos/ float(total))
//       pos += chunk_size
// ----
// When finishing the transfer, the user should call
// <<services/image_transfer/methods/finalize, finalize>>. This will make the
// final adjustments and verifications for finishing the transfer process.
// For example:
// [source,python]
// ----
// transfer_service.finalize()
// ----
// In case of an error, the transfer's phase will be changed to
// <<types/image_transfer_phase, finished_failure>>, and
// the disk's status will be changed to `Illegal`. Otherwise it will be changed to
// <<types/image_transfer_phase, finished_success>>, and the disk will be ready
// to be used. In both cases, the transfer entity will be removed shortly after.
// *Using HTTP and cURL calls:*
// - For upload, create a new disk first:
// * Specify 'initial_size' and 'provisioned_size' in bytes.
// * 'initial_size' must be bigger or the same as the size of the uploaded data.
// [source]
// ----
// POST /ovirt-engine/api/disks
// ----
// With a request body as follows:
// [source,xml]
// ----
// <disk>
//   <storage_domains>
//     <storage_domain id="123"/>
//   </storage_domains>
//   <alias>mydisk</alias>
//   <initial_size>1073741824</initial_size>
//   <provisioned_size>1073741824</provisioned_size>
//   <format>raw</format>
// </disk>
// ----
// - Create a new image transfer for downloading/uploading a `disk` with id `456`:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers
// ----
// With a request body as follows:
// [source,xml]
// ----
// <image_transfer>
//   <disk id="456"/>
//   <direction>upload|download</direction>
// </image_transfer>
// ----
// Will respond:
// [source,xml]
// ----
// <image_transfer id="123">
//   <direction>download|upload</direction>
//   <phase>initializing|transferring</phase>
//   <proxy_url>https://proxy_fqdn:54323/images/41c732d4-2210-4e7b-9e5c-4e2805baadbb</proxy_url>
//   <transfer_url>https://daemon_fqdn:54322/images/41c732d4-2210-4e7b-9e5c-4e2805baadbb</transfer_url>
//   ...
// </image_transfer>
// ----
// Note: If the phase is 'initializing', poll the `image_transfer` till its phase changes to 'transferring'.
// - Use the 'transfer_url' or 'proxy_url' to invoke a curl command:
// - use 'transfer_url' for transferring directly from/to ovirt-imageio-daemon,
//   or, use 'proxy_url' for transferring from/to ovirt-imageio-proxy.
//   Note: using the proxy would mitigate scenarios where there's no direct connectivity
//   to the daemon machine, e.g. vdsm machines are on a different network than the engine.
// -- Download:
// [source,shell]
// ----
// $ curl --cacert /etc/pki/ovirt-engine/ca.pem https://daemon_fqdn:54322/images/41c732d4-2210-4e7b-9e5c-4e2805baadbb -o <output_file>
// ----
// -- Upload:
// [source,shell]
// ----
// $ curl --cacert /etc/pki/ovirt-engine/ca.pem --upload-file <file_to_upload> -X PUT https://daemon_fqdn:54322/images/41c732d4-2210-4e7b-9e5c-4e2805baadbb
// ----
// - Finalize the image transfer by invoking the action:
// [source]
// ----
// POST /ovirt-engine/api/imagetransfers/123/finalize
// ----
// With a request body as follows:
// [source,xml]
// ----
// <action />
// ----
//
type ImageTransferService struct {
	BaseService
}

func NewImageTransferService(connection *Connection, path string) *ImageTransferService {
	var result ImageTransferService
	result.connection = connection
	result.path = path
	return &result
}

//
// Cancel the image transfer session. This terminates the transfer operation and removes the partial image.
//
type ImageTransferServiceCancelRequest struct {
	ImageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceCancelRequest) Header(key, value string) *ImageTransferServiceCancelRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceCancelRequest) Query(key, value string) *ImageTransferServiceCancelRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceCancelRequest) Send() (*ImageTransferServiceCancelResponse, error) {
	rawURL := fmt.Sprintf("%s%s/cancel", p.ImageTransferService.connection.URL(), p.ImageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransferService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransferService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransferService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServiceCancelResponse), nil
}

func (p *ImageTransferServiceCancelRequest) MustSend() *ImageTransferServiceCancelResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Cancel the image transfer session. This terminates the transfer operation and removes the partial image.
//
type ImageTransferServiceCancelResponse struct {
}

//
// Cancel the image transfer session. This terminates the transfer operation and removes the partial image.
//
func (p *ImageTransferService) Cancel() *ImageTransferServiceCancelRequest {
	return &ImageTransferServiceCancelRequest{ImageTransferService: p}
}

//
// Extend the image transfer session.
//
type ImageTransferServiceExtendRequest struct {
	ImageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceExtendRequest) Header(key, value string) *ImageTransferServiceExtendRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceExtendRequest) Query(key, value string) *ImageTransferServiceExtendRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceExtendRequest) Send() (*ImageTransferServiceExtendResponse, error) {
	rawURL := fmt.Sprintf("%s%s/extend", p.ImageTransferService.connection.URL(), p.ImageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransferService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransferService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransferService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServiceExtendResponse), nil
}

func (p *ImageTransferServiceExtendRequest) MustSend() *ImageTransferServiceExtendResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Extend the image transfer session.
//
type ImageTransferServiceExtendResponse struct {
}

//
// Extend the image transfer session.
//
func (p *ImageTransferService) Extend() *ImageTransferServiceExtendRequest {
	return &ImageTransferServiceExtendRequest{ImageTransferService: p}
}

//
// After finishing to transfer the data, finalize the transfer.
// This will make sure that the data being transferred is valid and fits the
// image entity that was targeted in the transfer. Specifically, will verify that
// if the image entity is a QCOW disk, the data uploaded is indeed a QCOW file,
// and that the image doesn't have a backing file.
//
type ImageTransferServiceFinalizeRequest struct {
	ImageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceFinalizeRequest) Header(key, value string) *ImageTransferServiceFinalizeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceFinalizeRequest) Query(key, value string) *ImageTransferServiceFinalizeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceFinalizeRequest) Send() (*ImageTransferServiceFinalizeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/finalize", p.ImageTransferService.connection.URL(), p.ImageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransferService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransferService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransferService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServiceFinalizeResponse), nil
}

func (p *ImageTransferServiceFinalizeRequest) MustSend() *ImageTransferServiceFinalizeResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// After finishing to transfer the data, finalize the transfer.
// This will make sure that the data being transferred is valid and fits the
// image entity that was targeted in the transfer. Specifically, will verify that
// if the image entity is a QCOW disk, the data uploaded is indeed a QCOW file,
// and that the image doesn't have a backing file.
//
type ImageTransferServiceFinalizeResponse struct {
}

//
// After finishing to transfer the data, finalize the transfer.
// This will make sure that the data being transferred is valid and fits the
// image entity that was targeted in the transfer. Specifically, will verify that
// if the image entity is a QCOW disk, the data uploaded is indeed a QCOW file,
// and that the image doesn't have a backing file.
//
func (p *ImageTransferService) Finalize() *ImageTransferServiceFinalizeRequest {
	return &ImageTransferServiceFinalizeRequest{ImageTransferService: p}
}

//
// Get the image transfer entity.
//
type ImageTransferServiceGetRequest struct {
	ImageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *ImageTransferServiceGetRequest) Header(key, value string) *ImageTransferServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceGetRequest) Query(key, value string) *ImageTransferServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceGetRequest) Follow(follow string) *ImageTransferServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ImageTransferServiceGetRequest) Send() (*ImageTransferServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ImageTransferService.connection.URL(), p.ImageTransferService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransferService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransferService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransferService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLImageTransferReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ImageTransferServiceGetResponse{imageTransfer: result}, nil
}

func (p *ImageTransferServiceGetRequest) MustSend() *ImageTransferServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get the image transfer entity.
//
type ImageTransferServiceGetResponse struct {
	imageTransfer *ImageTransfer
}

func (p *ImageTransferServiceGetResponse) ImageTransfer() (*ImageTransfer, bool) {
	if p.imageTransfer != nil {
		return p.imageTransfer, true
	}
	return nil, false
}

func (p *ImageTransferServiceGetResponse) MustImageTransfer() *ImageTransfer {
	if p.imageTransfer == nil {
		panic("imageTransfer in response does not exist")
	}
	return p.imageTransfer
}

//
// Get the image transfer entity.
//
func (p *ImageTransferService) Get() *ImageTransferServiceGetRequest {
	return &ImageTransferServiceGetRequest{ImageTransferService: p}
}

//
// Pause the image transfer session.
//
type ImageTransferServicePauseRequest struct {
	ImageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServicePauseRequest) Header(key, value string) *ImageTransferServicePauseRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServicePauseRequest) Query(key, value string) *ImageTransferServicePauseRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServicePauseRequest) Send() (*ImageTransferServicePauseResponse, error) {
	rawURL := fmt.Sprintf("%s%s/pause", p.ImageTransferService.connection.URL(), p.ImageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransferService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransferService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransferService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServicePauseResponse), nil
}

func (p *ImageTransferServicePauseRequest) MustSend() *ImageTransferServicePauseResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Pause the image transfer session.
//
type ImageTransferServicePauseResponse struct {
}

//
// Pause the image transfer session.
//
func (p *ImageTransferService) Pause() *ImageTransferServicePauseRequest {
	return &ImageTransferServicePauseRequest{ImageTransferService: p}
}

//
// Resume the image transfer session. The client will need to poll the transfer's phase until
// it is different than `resuming`. For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// transfer_service.resume()
// transfer = transfer_service.get()
// while transfer.phase == types.ImageTransferPhase.RESUMING:
//    time.sleep(1)
//    transfer = transfer_service.get()
// ----
//
type ImageTransferServiceResumeRequest struct {
	ImageTransferService *ImageTransferService
	header               map[string]string
	query                map[string]string
}

func (p *ImageTransferServiceResumeRequest) Header(key, value string) *ImageTransferServiceResumeRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ImageTransferServiceResumeRequest) Query(key, value string) *ImageTransferServiceResumeRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ImageTransferServiceResumeRequest) Send() (*ImageTransferServiceResumeResponse, error) {
	rawURL := fmt.Sprintf("%s%s/resume", p.ImageTransferService.connection.URL(), p.ImageTransferService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ImageTransferService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ImageTransferService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ImageTransferService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ImageTransferService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ImageTransferService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ImageTransferServiceResumeResponse), nil
}

func (p *ImageTransferServiceResumeRequest) MustSend() *ImageTransferServiceResumeResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Resume the image transfer session. The client will need to poll the transfer's phase until
// it is different than `resuming`. For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// transfer_service.resume()
// transfer = transfer_service.get()
// while transfer.phase == types.ImageTransferPhase.RESUMING:
//    time.sleep(1)
//    transfer = transfer_service.get()
// ----
//
type ImageTransferServiceResumeResponse struct {
}

//
// Resume the image transfer session. The client will need to poll the transfer's phase until
// it is different than `resuming`. For example:
// [source,python]
// ----
// transfer_service = transfers_service.image_transfer_service(transfer.id)
// transfer_service.resume()
// transfer = transfer_service.get()
// while transfer.phase == types.ImageTransferPhase.RESUMING:
//    time.sleep(1)
//    transfer = transfer_service.get()
// ----
//
func (p *ImageTransferService) Resume() *ImageTransferServiceResumeRequest {
	return &ImageTransferServiceResumeRequest{ImageTransferService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ImageTransferService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ImageTransferService) String() string {
	return fmt.Sprintf("ImageTransferService:%s", op.path)
}

//
//
type CpuProfilesService struct {
	BaseService
}

func NewCpuProfilesService(connection *Connection, path string) *CpuProfilesService {
	var result CpuProfilesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new cpu profile to the system.
//
type CpuProfilesServiceAddRequest struct {
	CpuProfilesService *CpuProfilesService
	header             map[string]string
	query              map[string]string
	profile            *CpuProfile
}

func (p *CpuProfilesServiceAddRequest) Header(key, value string) *CpuProfilesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfilesServiceAddRequest) Query(key, value string) *CpuProfilesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfilesServiceAddRequest) Profile(profile *CpuProfile) *CpuProfilesServiceAddRequest {
	p.profile = profile
	return p
}

func (p *CpuProfilesServiceAddRequest) Send() (*CpuProfilesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.CpuProfilesService.connection.URL(), p.CpuProfilesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLCpuProfileWriteOne(writer, p.profile, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.CpuProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.CpuProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.CpuProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.CpuProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.CpuProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &CpuProfilesServiceAddResponse{profile: result}, nil
}

func (p *CpuProfilesServiceAddRequest) MustSend() *CpuProfilesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new cpu profile to the system.
//
type CpuProfilesServiceAddResponse struct {
	profile *CpuProfile
}

func (p *CpuProfilesServiceAddResponse) Profile() (*CpuProfile, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *CpuProfilesServiceAddResponse) MustProfile() *CpuProfile {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Add a new cpu profile to the system.
//
func (p *CpuProfilesService) Add() *CpuProfilesServiceAddRequest {
	return &CpuProfilesServiceAddRequest{CpuProfilesService: p}
}

//
// Returns the list of CPU profiles of the system.
// The order of the returned list of CPU profiles is random.
//
type CpuProfilesServiceListRequest struct {
	CpuProfilesService *CpuProfilesService
	header             map[string]string
	query              map[string]string
	follow             *string
	max                *int64
}

func (p *CpuProfilesServiceListRequest) Header(key, value string) *CpuProfilesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *CpuProfilesServiceListRequest) Query(key, value string) *CpuProfilesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *CpuProfilesServiceListRequest) Follow(follow string) *CpuProfilesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *CpuProfilesServiceListRequest) Max(max int64) *CpuProfilesServiceListRequest {
	p.max = &max
	return p
}

func (p *CpuProfilesServiceListRequest) Send() (*CpuProfilesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.CpuProfilesService.connection.URL(), p.CpuProfilesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.CpuProfilesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.CpuProfilesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.CpuProfilesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.CpuProfilesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.CpuProfilesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCpuProfileReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &CpuProfilesServiceListResponse{profile: result}, nil
}

func (p *CpuProfilesServiceListRequest) MustSend() *CpuProfilesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of CPU profiles of the system.
// The order of the returned list of CPU profiles is random.
//
type CpuProfilesServiceListResponse struct {
	profile *CpuProfileSlice
}

func (p *CpuProfilesServiceListResponse) Profile() (*CpuProfileSlice, bool) {
	if p.profile != nil {
		return p.profile, true
	}
	return nil, false
}

func (p *CpuProfilesServiceListResponse) MustProfile() *CpuProfileSlice {
	if p.profile == nil {
		panic("profile in response does not exist")
	}
	return p.profile
}

//
// Returns the list of CPU profiles of the system.
// The order of the returned list of CPU profiles is random.
//
func (p *CpuProfilesService) List() *CpuProfilesServiceListRequest {
	return &CpuProfilesServiceListRequest{CpuProfilesService: p}
}

//
//
func (op *CpuProfilesService) ProfileService(id string) *CpuProfileService {
	return NewCpuProfileService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *CpuProfilesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ProfileService(path), nil
	}
	return op.ProfileService(path[:index]).Service(path[index+1:])
}

func (op *CpuProfilesService) String() string {
	return fmt.Sprintf("CpuProfilesService:%s", op.path)
}

//
// A service to manage collection of assignment of tags to specific entities in system.
//
type AssignedTagsService struct {
	BaseService
}

func NewAssignedTagsService(connection *Connection, path string) *AssignedTagsService {
	var result AssignedTagsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Assign tag to specific entity in the system.
// For example to assign tag `mytag` to virtual machine with the id `123` send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
//
type AssignedTagsServiceAddRequest struct {
	AssignedTagsService *AssignedTagsService
	header              map[string]string
	query               map[string]string
	tag                 *Tag
}

func (p *AssignedTagsServiceAddRequest) Header(key, value string) *AssignedTagsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagsServiceAddRequest) Query(key, value string) *AssignedTagsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagsServiceAddRequest) Tag(tag *Tag) *AssignedTagsServiceAddRequest {
	p.tag = tag
	return p
}

func (p *AssignedTagsServiceAddRequest) Send() (*AssignedTagsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedTagsService.connection.URL(), p.AssignedTagsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLTagWriteOne(writer, p.tag, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedTagsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedTagsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedTagsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedTagsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedTagsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AssignedTagsServiceAddResponse{tag: result}, nil
}

func (p *AssignedTagsServiceAddRequest) MustSend() *AssignedTagsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Assign tag to specific entity in the system.
// For example to assign tag `mytag` to virtual machine with the id `123` send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
//
type AssignedTagsServiceAddResponse struct {
	tag *Tag
}

func (p *AssignedTagsServiceAddResponse) Tag() (*Tag, bool) {
	if p.tag != nil {
		return p.tag, true
	}
	return nil, false
}

func (p *AssignedTagsServiceAddResponse) MustTag() *Tag {
	if p.tag == nil {
		panic("tag in response does not exist")
	}
	return p.tag
}

//
// Assign tag to specific entity in the system.
// For example to assign tag `mytag` to virtual machine with the id `123` send a request like this:
// ....
// POST /ovirt-engine/api/vms/123/tags
// ....
// With a request body like this:
// [source,xml]
// ----
// <tag>
//   <name>mytag</name>
// </tag>
// ----
//
func (p *AssignedTagsService) Add() *AssignedTagsServiceAddRequest {
	return &AssignedTagsServiceAddRequest{AssignedTagsService: p}
}

//
// List all tags assigned to the specific entity.
// For example to list all the tags of the virtual machine with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>mytag</name>
//     <description>mytag</description>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </tag>
// </tags>
// ----
// The order of the returned tags isn't guaranteed.
//
type AssignedTagsServiceListRequest struct {
	AssignedTagsService *AssignedTagsService
	header              map[string]string
	query               map[string]string
	follow              *string
	max                 *int64
}

func (p *AssignedTagsServiceListRequest) Header(key, value string) *AssignedTagsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AssignedTagsServiceListRequest) Query(key, value string) *AssignedTagsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AssignedTagsServiceListRequest) Follow(follow string) *AssignedTagsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AssignedTagsServiceListRequest) Max(max int64) *AssignedTagsServiceListRequest {
	p.max = &max
	return p
}

func (p *AssignedTagsServiceListRequest) Send() (*AssignedTagsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AssignedTagsService.connection.URL(), p.AssignedTagsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AssignedTagsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AssignedTagsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AssignedTagsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AssignedTagsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AssignedTagsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLTagReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AssignedTagsServiceListResponse{tags: result}, nil
}

func (p *AssignedTagsServiceListRequest) MustSend() *AssignedTagsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// List all tags assigned to the specific entity.
// For example to list all the tags of the virtual machine with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>mytag</name>
//     <description>mytag</description>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </tag>
// </tags>
// ----
// The order of the returned tags isn't guaranteed.
//
type AssignedTagsServiceListResponse struct {
	tags *TagSlice
}

func (p *AssignedTagsServiceListResponse) Tags() (*TagSlice, bool) {
	if p.tags != nil {
		return p.tags, true
	}
	return nil, false
}

func (p *AssignedTagsServiceListResponse) MustTags() *TagSlice {
	if p.tags == nil {
		panic("tags in response does not exist")
	}
	return p.tags
}

//
// List all tags assigned to the specific entity.
// For example to list all the tags of the virtual machine with id `123` send a request like this:
// ....
// GET /ovirt-engine/api/vms/123/tags
// ....
// [source,xml]
// ----
// <tags>
//   <tag href="/ovirt-engine/api/tags/222" id="222">
//     <name>mytag</name>
//     <description>mytag</description>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </tag>
// </tags>
// ----
// The order of the returned tags isn't guaranteed.
//
func (p *AssignedTagsService) List() *AssignedTagsServiceListRequest {
	return &AssignedTagsServiceListRequest{AssignedTagsService: p}
}

//
// Reference to the service that manages assignment of specific tag.
//
func (op *AssignedTagsService) TagService(id string) *AssignedTagService {
	return NewAssignedTagService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AssignedTagsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.TagService(path), nil
	}
	return op.TagService(path[:index]).Service(path[index+1:])
}

func (op *AssignedTagsService) String() string {
	return fmt.Sprintf("AssignedTagsService:%s", op.path)
}

//
// Service that provides values of configuration options of the system.
//
type SystemOptionsService struct {
	BaseService
}

func NewSystemOptionsService(connection *Connection, path string) *SystemOptionsService {
	var result SystemOptionsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns a reference to the service that provides values of specific configuration option.
//
func (op *SystemOptionsService) OptionService(id string) *SystemOptionService {
	return NewSystemOptionService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SystemOptionsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.OptionService(path), nil
	}
	return op.OptionService(path[:index]).Service(path[index+1:])
}

func (op *SystemOptionsService) String() string {
	return fmt.Sprintf("SystemOptionsService:%s", op.path)
}

//
//
type MacPoolService struct {
	BaseService
}

func NewMacPoolService(connection *Connection, path string) *MacPoolService {
	var result MacPoolService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type MacPoolServiceGetRequest struct {
	MacPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
	follow         *string
}

func (p *MacPoolServiceGetRequest) Header(key, value string) *MacPoolServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceGetRequest) Query(key, value string) *MacPoolServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceGetRequest) Follow(follow string) *MacPoolServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *MacPoolServiceGetRequest) Send() (*MacPoolServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.MacPoolService.connection.URL(), p.MacPoolService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.MacPoolService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.MacPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.MacPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.MacPoolService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.MacPoolService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &MacPoolServiceGetResponse{pool: result}, nil
}

func (p *MacPoolServiceGetRequest) MustSend() *MacPoolServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type MacPoolServiceGetResponse struct {
	pool *MacPool
}

func (p *MacPoolServiceGetResponse) Pool() (*MacPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *MacPoolServiceGetResponse) MustPool() *MacPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
//
func (p *MacPoolService) Get() *MacPoolServiceGetRequest {
	return &MacPoolServiceGetRequest{MacPoolService: p}
}

//
// Removes a MAC address pool.
// For example, to remove the MAC address pool having id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/macpools/123
// ----
//
type MacPoolServiceRemoveRequest struct {
	MacPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
	async          *bool
}

func (p *MacPoolServiceRemoveRequest) Header(key, value string) *MacPoolServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceRemoveRequest) Query(key, value string) *MacPoolServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceRemoveRequest) Async(async bool) *MacPoolServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *MacPoolServiceRemoveRequest) Send() (*MacPoolServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.MacPoolService.connection.URL(), p.MacPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.MacPoolService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.MacPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.MacPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.MacPoolService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.MacPoolService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(MacPoolServiceRemoveResponse), nil
}

func (p *MacPoolServiceRemoveRequest) MustSend() *MacPoolServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a MAC address pool.
// For example, to remove the MAC address pool having id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/macpools/123
// ----
//
type MacPoolServiceRemoveResponse struct {
}

//
// Removes a MAC address pool.
// For example, to remove the MAC address pool having id `123` send a request like this:
// [source]
// ----
// DELETE /ovirt-engine/api/macpools/123
// ----
//
func (p *MacPoolService) Remove() *MacPoolServiceRemoveRequest {
	return &MacPoolServiceRemoveRequest{MacPoolService: p}
}

//
// Updates a MAC address pool.
// The `name`, `description`, `allow_duplicates`, and `ranges` attributes can be updated.
// For example, to update the MAC address pool of id `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/macpools/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>UpdatedMACPool</name>
//   <description>An updated MAC address pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//     <range>
//       <from>02:1A:4A:01:00:00</from>
//       <to>02:1A:4A:FF:FF:FF</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
type MacPoolServiceUpdateRequest struct {
	MacPoolService *MacPoolService
	header         map[string]string
	query          map[string]string
	async          *bool
	pool           *MacPool
}

func (p *MacPoolServiceUpdateRequest) Header(key, value string) *MacPoolServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *MacPoolServiceUpdateRequest) Query(key, value string) *MacPoolServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *MacPoolServiceUpdateRequest) Async(async bool) *MacPoolServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *MacPoolServiceUpdateRequest) Pool(pool *MacPool) *MacPoolServiceUpdateRequest {
	p.pool = pool
	return p
}

func (p *MacPoolServiceUpdateRequest) Send() (*MacPoolServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.MacPoolService.connection.URL(), p.MacPoolService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLMacPoolWriteOne(writer, p.pool, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.MacPoolService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.MacPoolService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.MacPoolService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.MacPoolService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.MacPoolService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLMacPoolReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &MacPoolServiceUpdateResponse{pool: result}, nil
}

func (p *MacPoolServiceUpdateRequest) MustSend() *MacPoolServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates a MAC address pool.
// The `name`, `description`, `allow_duplicates`, and `ranges` attributes can be updated.
// For example, to update the MAC address pool of id `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/macpools/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>UpdatedMACPool</name>
//   <description>An updated MAC address pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//     <range>
//       <from>02:1A:4A:01:00:00</from>
//       <to>02:1A:4A:FF:FF:FF</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
type MacPoolServiceUpdateResponse struct {
	pool *MacPool
}

func (p *MacPoolServiceUpdateResponse) Pool() (*MacPool, bool) {
	if p.pool != nil {
		return p.pool, true
	}
	return nil, false
}

func (p *MacPoolServiceUpdateResponse) MustPool() *MacPool {
	if p.pool == nil {
		panic("pool in response does not exist")
	}
	return p.pool
}

//
// Updates a MAC address pool.
// The `name`, `description`, `allow_duplicates`, and `ranges` attributes can be updated.
// For example, to update the MAC address pool of id `123` send a request like this:
// [source]
// ----
// PUT /ovirt-engine/api/macpools/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <mac_pool>
//   <name>UpdatedMACPool</name>
//   <description>An updated MAC address pool</description>
//   <allow_duplicates>false</allow_duplicates>
//   <ranges>
//     <range>
//       <from>00:1A:4A:16:01:51</from>
//       <to>00:1A:4A:16:01:e6</to>
//     </range>
//     <range>
//       <from>02:1A:4A:01:00:00</from>
//       <to>02:1A:4A:FF:FF:FF</to>
//     </range>
//   </ranges>
// </mac_pool>
// ----
//
func (p *MacPoolService) Update() *MacPoolServiceUpdateRequest {
	return &MacPoolServiceUpdateRequest{MacPoolService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *MacPoolService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *MacPoolService) String() string {
	return fmt.Sprintf("MacPoolService:%s", op.path)
}

//
// A service to manage clusters.
//
type ClustersService struct {
	BaseService
}

func NewClustersService(connection *Connection, path string) *ClustersService {
	var result ClustersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new cluster.
// This requires the `name`, `cpu.type`, and `data_center` attributes. Identify the data center with either the `id`
// or `name` attribute.
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <data_center id="123"/>
// </cluster>
// ----
// To create a cluster with an external network provider to be deployed on
// every host that is added to the cluster, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body containing a reference to the desired provider:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <data_center id="123"/>
//   <external_network_providers>
//     <external_provider name="ovirt-provider-ovn"/>
//   </external_network_providers>
// </cluster>
// ----
//
type ClustersServiceAddRequest struct {
	ClustersService *ClustersService
	header          map[string]string
	query           map[string]string
	cluster         *Cluster
}

func (p *ClustersServiceAddRequest) Header(key, value string) *ClustersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClustersServiceAddRequest) Query(key, value string) *ClustersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClustersServiceAddRequest) Cluster(cluster *Cluster) *ClustersServiceAddRequest {
	p.cluster = cluster
	return p
}

func (p *ClustersServiceAddRequest) Send() (*ClustersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClustersService.connection.URL(), p.ClustersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLClusterWriteOne(writer, p.cluster, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClustersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClustersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClustersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClustersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClustersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClustersServiceAddResponse{cluster: result}, nil
}

func (p *ClustersServiceAddRequest) MustSend() *ClustersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new cluster.
// This requires the `name`, `cpu.type`, and `data_center` attributes. Identify the data center with either the `id`
// or `name` attribute.
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <data_center id="123"/>
// </cluster>
// ----
// To create a cluster with an external network provider to be deployed on
// every host that is added to the cluster, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body containing a reference to the desired provider:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <data_center id="123"/>
//   <external_network_providers>
//     <external_provider name="ovirt-provider-ovn"/>
//   </external_network_providers>
// </cluster>
// ----
//
type ClustersServiceAddResponse struct {
	cluster *Cluster
}

func (p *ClustersServiceAddResponse) Cluster() (*Cluster, bool) {
	if p.cluster != nil {
		return p.cluster, true
	}
	return nil, false
}

func (p *ClustersServiceAddResponse) MustCluster() *Cluster {
	if p.cluster == nil {
		panic("cluster in response does not exist")
	}
	return p.cluster
}

//
// Creates a new cluster.
// This requires the `name`, `cpu.type`, and `data_center` attributes. Identify the data center with either the `id`
// or `name` attribute.
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body like this:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <data_center id="123"/>
// </cluster>
// ----
// To create a cluster with an external network provider to be deployed on
// every host that is added to the cluster, send a request like this:
// [source]
// ----
// POST /ovirt-engine/api/clusters
// ----
// With a request body containing a reference to the desired provider:
// [source,xml]
// ----
// <cluster>
//   <name>mycluster</name>
//   <cpu>
//     <type>Intel Nehalem Family</type>
//   </cpu>
//   <data_center id="123"/>
//   <external_network_providers>
//     <external_provider name="ovirt-provider-ovn"/>
//   </external_network_providers>
// </cluster>
// ----
//
func (p *ClustersService) Add() *ClustersServiceAddRequest {
	return &ClustersServiceAddRequest{ClustersService: p}
}

//
// Returns the list of clusters of the system.
// The order of the returned clusters is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type ClustersServiceListRequest struct {
	ClustersService *ClustersService
	header          map[string]string
	query           map[string]string
	caseSensitive   *bool
	filter          *bool
	follow          *string
	max             *int64
	search          *string
}

func (p *ClustersServiceListRequest) Header(key, value string) *ClustersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClustersServiceListRequest) Query(key, value string) *ClustersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClustersServiceListRequest) CaseSensitive(caseSensitive bool) *ClustersServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *ClustersServiceListRequest) Filter(filter bool) *ClustersServiceListRequest {
	p.filter = &filter
	return p
}

func (p *ClustersServiceListRequest) Follow(follow string) *ClustersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ClustersServiceListRequest) Max(max int64) *ClustersServiceListRequest {
	p.max = &max
	return p
}

func (p *ClustersServiceListRequest) Search(search string) *ClustersServiceListRequest {
	p.search = &search
	return p
}

func (p *ClustersServiceListRequest) Send() (*ClustersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClustersService.connection.URL(), p.ClustersService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClustersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClustersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClustersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClustersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClustersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ClustersServiceListResponse{clusters: result}, nil
}

func (p *ClustersServiceListRequest) MustSend() *ClustersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of clusters of the system.
// The order of the returned clusters is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
type ClustersServiceListResponse struct {
	clusters *ClusterSlice
}

func (p *ClustersServiceListResponse) Clusters() (*ClusterSlice, bool) {
	if p.clusters != nil {
		return p.clusters, true
	}
	return nil, false
}

func (p *ClustersServiceListResponse) MustClusters() *ClusterSlice {
	if p.clusters == nil {
		panic("clusters in response does not exist")
	}
	return p.clusters
}

//
// Returns the list of clusters of the system.
// The order of the returned clusters is guaranteed only if the `sortby` clause is included in the
// `search` parameter.
//
func (p *ClustersService) List() *ClustersServiceListRequest {
	return &ClustersServiceListRequest{ClustersService: p}
}

//
// A reference to the service that manages a specific cluster.
//
func (op *ClustersService) ClusterService(id string) *ClusterService {
	return NewClusterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClustersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ClusterService(path), nil
	}
	return op.ClusterService(path[:index]).Service(path[index+1:])
}

func (op *ClustersService) String() string {
	return fmt.Sprintf("ClustersService:%s", op.path)
}

//
// A service to manage jobs.
//
type JobsService struct {
	BaseService
}

func NewJobsService(connection *Connection, path string) *JobsService {
	var result JobsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add an external job.
// For example, to add a job with the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs
// ----
// With the following request body:
// [source,xml]
// ----
// <job>
//   <description>Doing some work</description>
//   <auto_cleared>true</auto_cleared>
// </job>
// ----
// The response should look like:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Doing some work</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <external>true</external>
//   <last_updated>2016-12-13T02:15:42.130+02:00</last_updated>
//   <start_time>2016-12-13T02:15:42.130+02:00</start_time>
//   <status>started</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
type JobsServiceAddRequest struct {
	JobsService *JobsService
	header      map[string]string
	query       map[string]string
	job         *Job
}

func (p *JobsServiceAddRequest) Header(key, value string) *JobsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobsServiceAddRequest) Query(key, value string) *JobsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobsServiceAddRequest) Job(job *Job) *JobsServiceAddRequest {
	p.job = job
	return p
}

func (p *JobsServiceAddRequest) Send() (*JobsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.JobsService.connection.URL(), p.JobsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLJobWriteOne(writer, p.job, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.JobsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.JobsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.JobsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.JobsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.JobsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &JobsServiceAddResponse{job: result}, nil
}

func (p *JobsServiceAddRequest) MustSend() *JobsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add an external job.
// For example, to add a job with the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs
// ----
// With the following request body:
// [source,xml]
// ----
// <job>
//   <description>Doing some work</description>
//   <auto_cleared>true</auto_cleared>
// </job>
// ----
// The response should look like:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Doing some work</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <external>true</external>
//   <last_updated>2016-12-13T02:15:42.130+02:00</last_updated>
//   <start_time>2016-12-13T02:15:42.130+02:00</start_time>
//   <status>started</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
type JobsServiceAddResponse struct {
	job *Job
}

func (p *JobsServiceAddResponse) Job() (*Job, bool) {
	if p.job != nil {
		return p.job, true
	}
	return nil, false
}

func (p *JobsServiceAddResponse) MustJob() *Job {
	if p.job == nil {
		panic("job in response does not exist")
	}
	return p.job
}

//
// Add an external job.
// For example, to add a job with the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs
// ----
// With the following request body:
// [source,xml]
// ----
// <job>
//   <description>Doing some work</description>
//   <auto_cleared>true</auto_cleared>
// </job>
// ----
// The response should look like:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Doing some work</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <external>true</external>
//   <last_updated>2016-12-13T02:15:42.130+02:00</last_updated>
//   <start_time>2016-12-13T02:15:42.130+02:00</start_time>
//   <status>started</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
func (p *JobsService) Add() *JobsServiceAddRequest {
	return &JobsServiceAddRequest{JobsService: p}
}

//
// Retrieves the representation of the jobs.
// [source]
// ----
// GET /ovirt-engine/api/jobs
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <jobs>
//   <job href="/ovirt-engine/api/jobs/123" id="123">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//       <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//     </actions>
//     <description>Adding Disk</description>
//     <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//     <auto_cleared>true</auto_cleared>
//     <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//     <external>false</external>
//     <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//     <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//     <status>failed</status>
//     <owner href="/ovirt-engine/api/users/456" id="456"/>
//   </job>
//   ...
// </jobs>
// ----
// The order of the returned list of jobs isn't guaranteed.
//
type JobsServiceListRequest struct {
	JobsService   *JobsService
	header        map[string]string
	query         map[string]string
	caseSensitive *bool
	follow        *string
	max           *int64
	search        *string
}

func (p *JobsServiceListRequest) Header(key, value string) *JobsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobsServiceListRequest) Query(key, value string) *JobsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobsServiceListRequest) CaseSensitive(caseSensitive bool) *JobsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *JobsServiceListRequest) Follow(follow string) *JobsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *JobsServiceListRequest) Max(max int64) *JobsServiceListRequest {
	p.max = &max
	return p
}

func (p *JobsServiceListRequest) Search(search string) *JobsServiceListRequest {
	p.search = &search
	return p
}

func (p *JobsServiceListRequest) Send() (*JobsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.JobsService.connection.URL(), p.JobsService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.JobsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.JobsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.JobsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.JobsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.JobsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &JobsServiceListResponse{jobs: result}, nil
}

func (p *JobsServiceListRequest) MustSend() *JobsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the representation of the jobs.
// [source]
// ----
// GET /ovirt-engine/api/jobs
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <jobs>
//   <job href="/ovirt-engine/api/jobs/123" id="123">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//       <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//     </actions>
//     <description>Adding Disk</description>
//     <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//     <auto_cleared>true</auto_cleared>
//     <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//     <external>false</external>
//     <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//     <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//     <status>failed</status>
//     <owner href="/ovirt-engine/api/users/456" id="456"/>
//   </job>
//   ...
// </jobs>
// ----
// The order of the returned list of jobs isn't guaranteed.
//
type JobsServiceListResponse struct {
	jobs *JobSlice
}

func (p *JobsServiceListResponse) Jobs() (*JobSlice, bool) {
	if p.jobs != nil {
		return p.jobs, true
	}
	return nil, false
}

func (p *JobsServiceListResponse) MustJobs() *JobSlice {
	if p.jobs == nil {
		panic("jobs in response does not exist")
	}
	return p.jobs
}

//
// Retrieves the representation of the jobs.
// [source]
// ----
// GET /ovirt-engine/api/jobs
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <jobs>
//   <job href="/ovirt-engine/api/jobs/123" id="123">
//     <actions>
//       <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//       <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//     </actions>
//     <description>Adding Disk</description>
//     <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//     <auto_cleared>true</auto_cleared>
//     <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//     <external>false</external>
//     <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//     <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//     <status>failed</status>
//     <owner href="/ovirt-engine/api/users/456" id="456"/>
//   </job>
//   ...
// </jobs>
// ----
// The order of the returned list of jobs isn't guaranteed.
//
func (p *JobsService) List() *JobsServiceListRequest {
	return &JobsServiceListRequest{JobsService: p}
}

//
// Reference to the job service.
//
func (op *JobsService) JobService(id string) *JobService {
	return NewJobService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *JobsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.JobService(path), nil
	}
	return op.JobService(path[:index]).Service(path[index+1:])
}

func (op *JobsService) String() string {
	return fmt.Sprintf("JobsService:%s", op.path)
}

//
//
type VmSessionService struct {
	BaseService
}

func NewVmSessionService(connection *Connection, path string) *VmSessionService {
	var result VmSessionService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type VmSessionServiceGetRequest struct {
	VmSessionService *VmSessionService
	header           map[string]string
	query            map[string]string
	follow           *string
}

func (p *VmSessionServiceGetRequest) Header(key, value string) *VmSessionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmSessionServiceGetRequest) Query(key, value string) *VmSessionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmSessionServiceGetRequest) Follow(follow string) *VmSessionServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *VmSessionServiceGetRequest) Send() (*VmSessionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmSessionService.connection.URL(), p.VmSessionService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmSessionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmSessionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmSessionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmSessionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmSessionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSessionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &VmSessionServiceGetResponse{session: result}, nil
}

func (p *VmSessionServiceGetRequest) MustSend() *VmSessionServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type VmSessionServiceGetResponse struct {
	session *Session
}

func (p *VmSessionServiceGetResponse) Session() (*Session, bool) {
	if p.session != nil {
		return p.session, true
	}
	return nil, false
}

func (p *VmSessionServiceGetResponse) MustSession() *Session {
	if p.session == nil {
		panic("session in response does not exist")
	}
	return p.session
}

//
//
func (p *VmSessionService) Get() *VmSessionServiceGetRequest {
	return &VmSessionServiceGetRequest{VmSessionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmSessionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *VmSessionService) String() string {
	return fmt.Sprintf("VmSessionService:%s", op.path)
}

//
// A service that provides information about applications installed in a virtual machine.
//
type VmApplicationsService struct {
	BaseService
}

func NewVmApplicationsService(connection *Connection, path string) *VmApplicationsService {
	var result VmApplicationsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns a list of applications installed in the virtual machine.
// The order of the returned list of applications isn't guaranteed.
//
type VmApplicationsServiceListRequest struct {
	VmApplicationsService *VmApplicationsService
	header                map[string]string
	query                 map[string]string
	filter                *bool
	follow                *string
	max                   *int64
}

func (p *VmApplicationsServiceListRequest) Header(key, value string) *VmApplicationsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *VmApplicationsServiceListRequest) Query(key, value string) *VmApplicationsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *VmApplicationsServiceListRequest) Filter(filter bool) *VmApplicationsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *VmApplicationsServiceListRequest) Follow(follow string) *VmApplicationsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *VmApplicationsServiceListRequest) Max(max int64) *VmApplicationsServiceListRequest {
	p.max = &max
	return p
}

func (p *VmApplicationsServiceListRequest) Send() (*VmApplicationsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.VmApplicationsService.connection.URL(), p.VmApplicationsService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.VmApplicationsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.VmApplicationsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.VmApplicationsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.VmApplicationsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.VmApplicationsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLApplicationReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &VmApplicationsServiceListResponse{applications: result}, nil
}

func (p *VmApplicationsServiceListRequest) MustSend() *VmApplicationsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns a list of applications installed in the virtual machine.
// The order of the returned list of applications isn't guaranteed.
//
type VmApplicationsServiceListResponse struct {
	applications *ApplicationSlice
}

func (p *VmApplicationsServiceListResponse) Applications() (*ApplicationSlice, bool) {
	if p.applications != nil {
		return p.applications, true
	}
	return nil, false
}

func (p *VmApplicationsServiceListResponse) MustApplications() *ApplicationSlice {
	if p.applications == nil {
		panic("applications in response does not exist")
	}
	return p.applications
}

//
// Returns a list of applications installed in the virtual machine.
// The order of the returned list of applications isn't guaranteed.
//
func (p *VmApplicationsService) List() *VmApplicationsServiceListRequest {
	return &VmApplicationsServiceListRequest{VmApplicationsService: p}
}

//
// Returns a reference to the service that provides information about a specific application.
//
func (op *VmApplicationsService) ApplicationService(id string) *VmApplicationService {
	return NewVmApplicationService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *VmApplicationsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.ApplicationService(path), nil
	}
	return op.ApplicationService(path[:index]).Service(path[index+1:])
}

func (op *VmApplicationsService) String() string {
	return fmt.Sprintf("VmApplicationsService:%s", op.path)
}

//
//
type SnapshotCdromService struct {
	BaseService
}

func NewSnapshotCdromService(connection *Connection, path string) *SnapshotCdromService {
	var result SnapshotCdromService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type SnapshotCdromServiceGetRequest struct {
	SnapshotCdromService *SnapshotCdromService
	header               map[string]string
	query                map[string]string
	follow               *string
}

func (p *SnapshotCdromServiceGetRequest) Header(key, value string) *SnapshotCdromServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SnapshotCdromServiceGetRequest) Query(key, value string) *SnapshotCdromServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SnapshotCdromServiceGetRequest) Follow(follow string) *SnapshotCdromServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *SnapshotCdromServiceGetRequest) Send() (*SnapshotCdromServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SnapshotCdromService.connection.URL(), p.SnapshotCdromService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SnapshotCdromService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SnapshotCdromService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SnapshotCdromService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SnapshotCdromService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SnapshotCdromService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCdromReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SnapshotCdromServiceGetResponse{cdrom: result}, nil
}

func (p *SnapshotCdromServiceGetRequest) MustSend() *SnapshotCdromServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SnapshotCdromServiceGetResponse struct {
	cdrom *Cdrom
}

func (p *SnapshotCdromServiceGetResponse) Cdrom() (*Cdrom, bool) {
	if p.cdrom != nil {
		return p.cdrom, true
	}
	return nil, false
}

func (p *SnapshotCdromServiceGetResponse) MustCdrom() *Cdrom {
	if p.cdrom == nil {
		panic("cdrom in response does not exist")
	}
	return p.cdrom
}

//
//
func (p *SnapshotCdromService) Get() *SnapshotCdromServiceGetRequest {
	return &SnapshotCdromServiceGetRequest{SnapshotCdromService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SnapshotCdromService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SnapshotCdromService) String() string {
	return fmt.Sprintf("SnapshotCdromService:%s", op.path)
}

//
// A service to manage a job.
//
type JobService struct {
	BaseService
}

func NewJobService(connection *Connection, path string) *JobService {
	var result JobService
	result.connection = connection
	result.path = path
	return &result
}

//
// Set an external job execution to be cleared by the system.
// For example, to set a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/clear
// ----
// With the following request body:
// [source,xml]
// ----
// <action/>
// ----
//
type JobServiceClearRequest struct {
	JobService *JobService
	header     map[string]string
	query      map[string]string
	async      *bool
}

func (p *JobServiceClearRequest) Header(key, value string) *JobServiceClearRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceClearRequest) Query(key, value string) *JobServiceClearRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceClearRequest) Async(async bool) *JobServiceClearRequest {
	p.async = &async
	return p
}

func (p *JobServiceClearRequest) Send() (*JobServiceClearResponse, error) {
	rawURL := fmt.Sprintf("%s%s/clear", p.JobService.connection.URL(), p.JobService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.JobService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.JobService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.JobService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.JobService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.JobService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(JobServiceClearResponse), nil
}

func (p *JobServiceClearRequest) MustSend() *JobServiceClearResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Set an external job execution to be cleared by the system.
// For example, to set a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/clear
// ----
// With the following request body:
// [source,xml]
// ----
// <action/>
// ----
//
type JobServiceClearResponse struct {
}

//
// Set an external job execution to be cleared by the system.
// For example, to set a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/clear
// ----
// With the following request body:
// [source,xml]
// ----
// <action/>
// ----
//
func (p *JobService) Clear() *JobServiceClearRequest {
	return &JobServiceClearRequest{JobService: p}
}

//
// Marks an external job execution as ended.
// For example, to terminate a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <status>finished</status>
// </action>
// ----
//
type JobServiceEndRequest struct {
	JobService *JobService
	header     map[string]string
	query      map[string]string
	async      *bool
	force      *bool
	succeeded  *bool
}

func (p *JobServiceEndRequest) Header(key, value string) *JobServiceEndRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceEndRequest) Query(key, value string) *JobServiceEndRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceEndRequest) Async(async bool) *JobServiceEndRequest {
	p.async = &async
	return p
}

func (p *JobServiceEndRequest) Force(force bool) *JobServiceEndRequest {
	p.force = &force
	return p
}

func (p *JobServiceEndRequest) Succeeded(succeeded bool) *JobServiceEndRequest {
	p.succeeded = &succeeded
	return p
}

func (p *JobServiceEndRequest) Send() (*JobServiceEndResponse, error) {
	rawURL := fmt.Sprintf("%s%s/end", p.JobService.connection.URL(), p.JobService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.force != nil {
		actionBuilder.Force(*p.force)
	}
	if p.succeeded != nil {
		actionBuilder.Succeeded(*p.succeeded)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.JobService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.JobService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.JobService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.JobService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.JobService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(JobServiceEndResponse), nil
}

func (p *JobServiceEndRequest) MustSend() *JobServiceEndResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Marks an external job execution as ended.
// For example, to terminate a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <status>finished</status>
// </action>
// ----
//
type JobServiceEndResponse struct {
}

//
// Marks an external job execution as ended.
// For example, to terminate a job with identifier `123` send the following request:
// [source]
// ----
// POST /ovirt-engine/api/jobs/end
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <force>true</force>
//   <status>finished</status>
// </action>
// ----
//
func (p *JobService) End() *JobServiceEndRequest {
	return &JobServiceEndRequest{JobService: p}
}

//
// Retrieves a job.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Adding Disk</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//   <external>false</external>
//   <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//   <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//   <status>failed</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
type JobServiceGetRequest struct {
	JobService *JobService
	header     map[string]string
	query      map[string]string
	follow     *string
}

func (p *JobServiceGetRequest) Header(key, value string) *JobServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *JobServiceGetRequest) Query(key, value string) *JobServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *JobServiceGetRequest) Follow(follow string) *JobServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *JobServiceGetRequest) Send() (*JobServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.JobService.connection.URL(), p.JobService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.JobService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.JobService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.JobService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.JobService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.JobService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLJobReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &JobServiceGetResponse{job: result}, nil
}

func (p *JobServiceGetRequest) MustSend() *JobServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves a job.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Adding Disk</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//   <external>false</external>
//   <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//   <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//   <status>failed</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
type JobServiceGetResponse struct {
	job *Job
}

func (p *JobServiceGetResponse) Job() (*Job, bool) {
	if p.job != nil {
		return p.job, true
	}
	return nil, false
}

func (p *JobServiceGetResponse) MustJob() *Job {
	if p.job == nil {
		panic("job in response does not exist")
	}
	return p.job
}

//
// Retrieves a job.
// [source]
// ----
// GET /ovirt-engine/api/jobs/123
// ----
// You will receive response in XML like this one:
// [source,xml]
// ----
// <job href="/ovirt-engine/api/jobs/123" id="123">
//   <actions>
//     <link href="/ovirt-engine/api/jobs/123/clear" rel="clear"/>
//     <link href="/ovirt-engine/api/jobs/123/end" rel="end"/>
//   </actions>
//   <description>Adding Disk</description>
//   <link href="/ovirt-engine/api/jobs/123/steps" rel="steps"/>
//   <auto_cleared>true</auto_cleared>
//   <end_time>2016-12-12T23:07:29.758+02:00</end_time>
//   <external>false</external>
//   <last_updated>2016-12-12T23:07:29.758+02:00</last_updated>
//   <start_time>2016-12-12T23:07:26.593+02:00</start_time>
//   <status>failed</status>
//   <owner href="/ovirt-engine/api/users/456" id="456"/>
// </job>
// ----
//
func (p *JobService) Get() *JobServiceGetRequest {
	return &JobServiceGetRequest{JobService: p}
}

//
// List all the steps of the job.
// The order of the returned list of steps isn't guaranteed.
//
func (op *JobService) StepsService() *StepsService {
	return NewStepsService(op.connection, fmt.Sprintf("%s/steps", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *JobService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "steps" {
		return op.StepsService(), nil
	}
	if strings.HasPrefix(path, "steps/") {
		return op.StepsService().Service(path[6:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *JobService) String() string {
	return fmt.Sprintf("JobService:%s", op.path)
}

//
// A service to manage an icon (read-only).
//
type IconService struct {
	BaseService
}

func NewIconService(connection *Connection, path string) *IconService {
	var result IconService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get an icon.
// [source]
// ----
// GET /ovirt-engine/api/icons/123
// ----
// You will get a XML response like this one:
// [source,xml]
// ----
// <icon id="123">
//   <data>Some binary data here</data>
//   <media_type>image/png</media_type>
// </icon>
// ----
//
type IconServiceGetRequest struct {
	IconService *IconService
	header      map[string]string
	query       map[string]string
	follow      *string
}

func (p *IconServiceGetRequest) Header(key, value string) *IconServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IconServiceGetRequest) Query(key, value string) *IconServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IconServiceGetRequest) Follow(follow string) *IconServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *IconServiceGetRequest) Send() (*IconServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.IconService.connection.URL(), p.IconService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.IconService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.IconService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.IconService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.IconService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.IconService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIconReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &IconServiceGetResponse{icon: result}, nil
}

func (p *IconServiceGetRequest) MustSend() *IconServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get an icon.
// [source]
// ----
// GET /ovirt-engine/api/icons/123
// ----
// You will get a XML response like this one:
// [source,xml]
// ----
// <icon id="123">
//   <data>Some binary data here</data>
//   <media_type>image/png</media_type>
// </icon>
// ----
//
type IconServiceGetResponse struct {
	icon *Icon
}

func (p *IconServiceGetResponse) Icon() (*Icon, bool) {
	if p.icon != nil {
		return p.icon, true
	}
	return nil, false
}

func (p *IconServiceGetResponse) MustIcon() *Icon {
	if p.icon == nil {
		panic("icon in response does not exist")
	}
	return p.icon
}

//
// Get an icon.
// [source]
// ----
// GET /ovirt-engine/api/icons/123
// ----
// You will get a XML response like this one:
// [source,xml]
// ----
// <icon id="123">
//   <data>Some binary data here</data>
//   <media_type>image/png</media_type>
// </icon>
// ----
//
func (p *IconService) Get() *IconServiceGetRequest {
	return &IconServiceGetRequest{IconService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IconService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *IconService) String() string {
	return fmt.Sprintf("IconService:%s", op.path)
}

//
// A service that manages hosts.
//
type HostsService struct {
	BaseService
}

func NewHostsService(connection *Connection, path string) *HostsService {
	var result HostsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new host.
// The host is created based on the attributes of the `host` parameter. The `name`, `address`, and `root_password`
// properties are required.
// For example, to add a host, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With the following request body:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>myrootpassword</root_password>
// </host>
// ----
// NOTE: The `root_password` element is only included in the client-provided initial representation and is not
// exposed in the representations returned from subsequent requests.
// IMPORTANT: Since version 4.1.2 of the engine, when a host is newly added, the host's firewall
// definitions are overridden by default.
// To add a hosted engine host, use the optional `deploy_hosted_engine` parameter:
// [source]
// ----
// POST /ovirt-engine/api/hosts?deploy_hosted_engine=true
// ----
// If the cluster has a default external network provider that is supported for automatic deployment,
// the external network provider is deployed when adding the host.
// Only external network providers for OVN are supported for the automatic deployment.
// To deploy an external network provider other than the one defined in the clusters, overwrite the external
// network provider when adding hosts, by sending the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With a request body that contains a reference to the desired provider in the
// `external_network_provider_configuration`:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>123456</root_password>
//   <external_network_provider_configurations>
//     <external_network_provider_configuration>
//       <external_network_provider name="ovirt-provider-ovn"/>
//     </external_network_provider_configuration>
//   </external_network_provider_configurations>
// </host>
// ----
//
type HostsServiceAddRequest struct {
	HostsService         *HostsService
	header               map[string]string
	query                map[string]string
	activate             *bool
	deployHostedEngine   *bool
	host                 *Host
	undeployHostedEngine *bool
}

func (p *HostsServiceAddRequest) Header(key, value string) *HostsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostsServiceAddRequest) Query(key, value string) *HostsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostsServiceAddRequest) Activate(activate bool) *HostsServiceAddRequest {
	p.activate = &activate
	return p
}

func (p *HostsServiceAddRequest) DeployHostedEngine(deployHostedEngine bool) *HostsServiceAddRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *HostsServiceAddRequest) Host(host *Host) *HostsServiceAddRequest {
	p.host = host
	return p
}

func (p *HostsServiceAddRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostsServiceAddRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *HostsServiceAddRequest) Send() (*HostsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostsService.connection.URL(), p.HostsService.path)
	values := make(url.Values)
	if p.activate != nil {
		values["activate"] = []string{fmt.Sprintf("%v", *p.activate)}
	}

	if p.deployHostedEngine != nil {
		values["deploy_hosted_engine"] = []string{fmt.Sprintf("%v", *p.deployHostedEngine)}
	}

	if p.undeployHostedEngine != nil {
		values["undeploy_hosted_engine"] = []string{fmt.Sprintf("%v", *p.undeployHostedEngine)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLHostWriteOne(writer, p.host, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &HostsServiceAddResponse{host: result}, nil
}

func (p *HostsServiceAddRequest) MustSend() *HostsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new host.
// The host is created based on the attributes of the `host` parameter. The `name`, `address`, and `root_password`
// properties are required.
// For example, to add a host, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With the following request body:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>myrootpassword</root_password>
// </host>
// ----
// NOTE: The `root_password` element is only included in the client-provided initial representation and is not
// exposed in the representations returned from subsequent requests.
// IMPORTANT: Since version 4.1.2 of the engine, when a host is newly added, the host's firewall
// definitions are overridden by default.
// To add a hosted engine host, use the optional `deploy_hosted_engine` parameter:
// [source]
// ----
// POST /ovirt-engine/api/hosts?deploy_hosted_engine=true
// ----
// If the cluster has a default external network provider that is supported for automatic deployment,
// the external network provider is deployed when adding the host.
// Only external network providers for OVN are supported for the automatic deployment.
// To deploy an external network provider other than the one defined in the clusters, overwrite the external
// network provider when adding hosts, by sending the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With a request body that contains a reference to the desired provider in the
// `external_network_provider_configuration`:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>123456</root_password>
//   <external_network_provider_configurations>
//     <external_network_provider_configuration>
//       <external_network_provider name="ovirt-provider-ovn"/>
//     </external_network_provider_configuration>
//   </external_network_provider_configurations>
// </host>
// ----
//
type HostsServiceAddResponse struct {
	host *Host
}

func (p *HostsServiceAddResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *HostsServiceAddResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Creates a new host.
// The host is created based on the attributes of the `host` parameter. The `name`, `address`, and `root_password`
// properties are required.
// For example, to add a host, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With the following request body:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>myrootpassword</root_password>
// </host>
// ----
// NOTE: The `root_password` element is only included in the client-provided initial representation and is not
// exposed in the representations returned from subsequent requests.
// IMPORTANT: Since version 4.1.2 of the engine, when a host is newly added, the host's firewall
// definitions are overridden by default.
// To add a hosted engine host, use the optional `deploy_hosted_engine` parameter:
// [source]
// ----
// POST /ovirt-engine/api/hosts?deploy_hosted_engine=true
// ----
// If the cluster has a default external network provider that is supported for automatic deployment,
// the external network provider is deployed when adding the host.
// Only external network providers for OVN are supported for the automatic deployment.
// To deploy an external network provider other than the one defined in the clusters, overwrite the external
// network provider when adding hosts, by sending the following request:
// [source]
// ----
// POST /ovirt-engine/api/hosts
// ----
// With a request body that contains a reference to the desired provider in the
// `external_network_provider_configuration`:
// [source,xml]
// ----
// <host>
//   <name>myhost</name>
//   <address>myhost.example.com</address>
//   <root_password>123456</root_password>
//   <external_network_provider_configurations>
//     <external_network_provider_configuration>
//       <external_network_provider name="ovirt-provider-ovn"/>
//     </external_network_provider_configuration>
//   </external_network_provider_configurations>
// </host>
// ----
//
func (p *HostsService) Add() *HostsServiceAddRequest {
	return &HostsServiceAddRequest{HostsService: p}
}

//
// Get a list of all available hosts.
// For example, to list the hosts send the following request:
// ....
// GET /ovirt-engine/api/hosts
// ....
// The response body will be similar to this:
// [source,xml]
// ----
// <hosts>
//   <host href="/ovirt-engine/api/hosts/123" id="123">
//     ...
//   </host>
//   <host href="/ovirt-engine/api/hosts/456" id="456">
//     ...
//   </host>
//   ...
// </host>
// ----
// The order of the returned list of hosts is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
type HostsServiceListRequest struct {
	HostsService              *HostsService
	header                    map[string]string
	query                     map[string]string
	allContent                *bool
	caseSensitive             *bool
	checkVmsInAffinityClosure *bool
	filter                    *bool
	follow                    *string
	max                       *int64
	migrationTargetOf         *string
	search                    *string
}

func (p *HostsServiceListRequest) Header(key, value string) *HostsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostsServiceListRequest) Query(key, value string) *HostsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostsServiceListRequest) AllContent(allContent bool) *HostsServiceListRequest {
	p.allContent = &allContent
	return p
}

func (p *HostsServiceListRequest) CaseSensitive(caseSensitive bool) *HostsServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *HostsServiceListRequest) CheckVmsInAffinityClosure(checkVmsInAffinityClosure bool) *HostsServiceListRequest {
	p.checkVmsInAffinityClosure = &checkVmsInAffinityClosure
	return p
}

func (p *HostsServiceListRequest) Filter(filter bool) *HostsServiceListRequest {
	p.filter = &filter
	return p
}

func (p *HostsServiceListRequest) Follow(follow string) *HostsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *HostsServiceListRequest) Max(max int64) *HostsServiceListRequest {
	p.max = &max
	return p
}

func (p *HostsServiceListRequest) MigrationTargetOf(migrationTargetOf string) *HostsServiceListRequest {
	p.migrationTargetOf = &migrationTargetOf
	return p
}

func (p *HostsServiceListRequest) Search(search string) *HostsServiceListRequest {
	p.search = &search
	return p
}

func (p *HostsServiceListRequest) Send() (*HostsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.HostsService.connection.URL(), p.HostsService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.checkVmsInAffinityClosure != nil {
		values["check_vms_in_affinity_closure"] = []string{fmt.Sprintf("%v", *p.checkVmsInAffinityClosure)}
	}

	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.migrationTargetOf != nil {
		values["migration_target_of"] = []string{fmt.Sprintf("%v", *p.migrationTargetOf)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLHostReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &HostsServiceListResponse{hosts: result}, nil
}

func (p *HostsServiceListRequest) MustSend() *HostsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get a list of all available hosts.
// For example, to list the hosts send the following request:
// ....
// GET /ovirt-engine/api/hosts
// ....
// The response body will be similar to this:
// [source,xml]
// ----
// <hosts>
//   <host href="/ovirt-engine/api/hosts/123" id="123">
//     ...
//   </host>
//   <host href="/ovirt-engine/api/hosts/456" id="456">
//     ...
//   </host>
//   ...
// </host>
// ----
// The order of the returned list of hosts is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
type HostsServiceListResponse struct {
	hosts *HostSlice
}

func (p *HostsServiceListResponse) Hosts() (*HostSlice, bool) {
	if p.hosts != nil {
		return p.hosts, true
	}
	return nil, false
}

func (p *HostsServiceListResponse) MustHosts() *HostSlice {
	if p.hosts == nil {
		panic("hosts in response does not exist")
	}
	return p.hosts
}

//
// Get a list of all available hosts.
// For example, to list the hosts send the following request:
// ....
// GET /ovirt-engine/api/hosts
// ....
// The response body will be similar to this:
// [source,xml]
// ----
// <hosts>
//   <host href="/ovirt-engine/api/hosts/123" id="123">
//     ...
//   </host>
//   <host href="/ovirt-engine/api/hosts/456" id="456">
//     ...
//   </host>
//   ...
// </host>
// ----
// The order of the returned list of hosts is guaranteed only if the `sortby` clause is included in
// the `search` parameter.
//
func (p *HostsService) List() *HostsServiceListRequest {
	return &HostsServiceListRequest{HostsService: p}
}

//
// Add a new host to the system providing the host root password. This has been deprecated and provided for backwards compatibility.
//
type HostsServiceAddUsingRootPasswordRequest struct {
	HostsService         *HostsService
	header               map[string]string
	query                map[string]string
	activate             *bool
	deployHostedEngine   *bool
	host                 *Host
	undeployHostedEngine *bool
}

func (p *HostsServiceAddUsingRootPasswordRequest) Header(key, value string) *HostsServiceAddUsingRootPasswordRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostsServiceAddUsingRootPasswordRequest) Query(key, value string) *HostsServiceAddUsingRootPasswordRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostsServiceAddUsingRootPasswordRequest) Activate(activate bool) *HostsServiceAddUsingRootPasswordRequest {
	p.activate = &activate
	return p
}

func (p *HostsServiceAddUsingRootPasswordRequest) DeployHostedEngine(deployHostedEngine bool) *HostsServiceAddUsingRootPasswordRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *HostsServiceAddUsingRootPasswordRequest) Host(host *Host) *HostsServiceAddUsingRootPasswordRequest {
	p.host = host
	return p
}

func (p *HostsServiceAddUsingRootPasswordRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostsServiceAddUsingRootPasswordRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *HostsServiceAddUsingRootPasswordRequest) Send() (*HostsServiceAddUsingRootPasswordResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingrootpassword", p.HostsService.connection.URL(), p.HostsService.path)
	actionBuilder := NewActionBuilder()
	if p.activate != nil {
		actionBuilder.Activate(*p.activate)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustHost()
	return &HostsServiceAddUsingRootPasswordResponse{host: result}, nil
}

func (p *HostsServiceAddUsingRootPasswordRequest) MustSend() *HostsServiceAddUsingRootPasswordResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new host to the system providing the host root password. This has been deprecated and provided for backwards compatibility.
//
type HostsServiceAddUsingRootPasswordResponse struct {
	host *Host
}

func (p *HostsServiceAddUsingRootPasswordResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *HostsServiceAddUsingRootPasswordResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Add a new host to the system providing the host root password. This has been deprecated and provided for backwards compatibility.
//
func (p *HostsService) AddUsingRootPassword() *HostsServiceAddUsingRootPasswordRequest {
	return &HostsServiceAddUsingRootPasswordRequest{HostsService: p}
}

//
// Add a new host to the system providing the ssh password or fingerprint.
//
type HostsServiceAddUsingSshRequest struct {
	HostsService         *HostsService
	header               map[string]string
	query                map[string]string
	activate             *bool
	deployHostedEngine   *bool
	host                 *Host
	undeployHostedEngine *bool
}

func (p *HostsServiceAddUsingSshRequest) Header(key, value string) *HostsServiceAddUsingSshRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *HostsServiceAddUsingSshRequest) Query(key, value string) *HostsServiceAddUsingSshRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *HostsServiceAddUsingSshRequest) Activate(activate bool) *HostsServiceAddUsingSshRequest {
	p.activate = &activate
	return p
}

func (p *HostsServiceAddUsingSshRequest) DeployHostedEngine(deployHostedEngine bool) *HostsServiceAddUsingSshRequest {
	p.deployHostedEngine = &deployHostedEngine
	return p
}

func (p *HostsServiceAddUsingSshRequest) Host(host *Host) *HostsServiceAddUsingSshRequest {
	p.host = host
	return p
}

func (p *HostsServiceAddUsingSshRequest) UndeployHostedEngine(undeployHostedEngine bool) *HostsServiceAddUsingSshRequest {
	p.undeployHostedEngine = &undeployHostedEngine
	return p
}

func (p *HostsServiceAddUsingSshRequest) Send() (*HostsServiceAddUsingSshResponse, error) {
	rawURL := fmt.Sprintf("%s%s/usingssh", p.HostsService.connection.URL(), p.HostsService.path)
	actionBuilder := NewActionBuilder()
	if p.activate != nil {
		actionBuilder.Activate(*p.activate)
	}
	if p.deployHostedEngine != nil {
		actionBuilder.DeployHostedEngine(*p.deployHostedEngine)
	}
	actionBuilder.Host(p.host)
	if p.undeployHostedEngine != nil {
		actionBuilder.UndeployHostedEngine(*p.undeployHostedEngine)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.HostsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.HostsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.HostsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.HostsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.HostsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	action, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	result := action.MustHost()
	return &HostsServiceAddUsingSshResponse{host: result}, nil
}

func (p *HostsServiceAddUsingSshRequest) MustSend() *HostsServiceAddUsingSshResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new host to the system providing the ssh password or fingerprint.
//
type HostsServiceAddUsingSshResponse struct {
	host *Host
}

func (p *HostsServiceAddUsingSshResponse) Host() (*Host, bool) {
	if p.host != nil {
		return p.host, true
	}
	return nil, false
}

func (p *HostsServiceAddUsingSshResponse) MustHost() *Host {
	if p.host == nil {
		panic("host in response does not exist")
	}
	return p.host
}

//
// Add a new host to the system providing the ssh password or fingerprint.
//
func (p *HostsService) AddUsingSsh() *HostsServiceAddUsingSshRequest {
	return &HostsServiceAddUsingSshRequest{HostsService: p}
}

//
// A Reference to service managing a specific host.
//
func (op *HostsService) HostService(id string) *HostService {
	return NewHostService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *HostsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.HostService(path), nil
	}
	return op.HostService(path[:index]).Service(path[index+1:])
}

func (op *HostsService) String() string {
	return fmt.Sprintf("HostsService:%s", op.path)
}

//
//
type InstanceTypesService struct {
	BaseService
}

func NewInstanceTypesService(connection *Connection, path string) *InstanceTypesService {
	var result InstanceTypesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Creates a new instance type.
// This requires only a name attribute and can include all hardware configurations of the
// virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/instancetypes
// ----
// With a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
// </template>
// ----
// Creating an instance type with all hardware configurations with a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
//   <console>
//     <enabled>true</enabled>
//   </console>
//   <cpu>
//     <topology>
//       <cores>2</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
//   <custom_cpu_model>AMD Opteron_G2</custom_cpu_model>
//   <custom_emulated_machine>q35</custom_emulated_machine>
//   <display>
//     <monitors>1</monitors>
//     <single_qxl_pci>true</single_qxl_pci>
//     <smartcard_enabled>true</smartcard_enabled>
//     <type>spice</type>
//   </display>
//   <high_availability>
//     <enabled>true</enabled>
//     <priority>1</priority>
//   </high_availability>
//   <io>
//     <threads>2</threads>
//   </io>
//   <memory>4294967296</memory>
//   <memory_policy>
//     <ballooning>true</ballooning>
//     <guaranteed>268435456</guaranteed>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <compressed>inherit</compressed>
//     <policy id="00000000-0000-0000-0000-000000000000"/>
//   </migration>
//   <migration_downtime>2</migration_downtime>
//   <os>
//     <boot>
//       <devices>
//         <device>hd</device>
//       </devices>
//     </boot>
//   </os>
//   <rng_device>
//     <rate>
//       <bytes>200</bytes>
//       <period>2</period>
//     </rate>
//     <source>urandom</source>
//   </rng_device>
//   <soundcard_enabled>true</soundcard_enabled>
//   <usb>
//     <enabled>true</enabled>
//     <type>native</type>
//   </usb>
//   <virtio_scsi>
//     <enabled>true</enabled>
//   </virtio_scsi>
// </instance_type>
// ----
//
type InstanceTypesServiceAddRequest struct {
	InstanceTypesService *InstanceTypesService
	header               map[string]string
	query                map[string]string
	instanceType         *InstanceType
}

func (p *InstanceTypesServiceAddRequest) Header(key, value string) *InstanceTypesServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypesServiceAddRequest) Query(key, value string) *InstanceTypesServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypesServiceAddRequest) InstanceType(instanceType *InstanceType) *InstanceTypesServiceAddRequest {
	p.instanceType = instanceType
	return p
}

func (p *InstanceTypesServiceAddRequest) Send() (*InstanceTypesServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypesService.connection.URL(), p.InstanceTypesService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLInstanceTypeWriteOne(writer, p.instanceType, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypesServiceAddResponse{instanceType: result}, nil
}

func (p *InstanceTypesServiceAddRequest) MustSend() *InstanceTypesServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Creates a new instance type.
// This requires only a name attribute and can include all hardware configurations of the
// virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/instancetypes
// ----
// With a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
// </template>
// ----
// Creating an instance type with all hardware configurations with a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
//   <console>
//     <enabled>true</enabled>
//   </console>
//   <cpu>
//     <topology>
//       <cores>2</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
//   <custom_cpu_model>AMD Opteron_G2</custom_cpu_model>
//   <custom_emulated_machine>q35</custom_emulated_machine>
//   <display>
//     <monitors>1</monitors>
//     <single_qxl_pci>true</single_qxl_pci>
//     <smartcard_enabled>true</smartcard_enabled>
//     <type>spice</type>
//   </display>
//   <high_availability>
//     <enabled>true</enabled>
//     <priority>1</priority>
//   </high_availability>
//   <io>
//     <threads>2</threads>
//   </io>
//   <memory>4294967296</memory>
//   <memory_policy>
//     <ballooning>true</ballooning>
//     <guaranteed>268435456</guaranteed>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <compressed>inherit</compressed>
//     <policy id="00000000-0000-0000-0000-000000000000"/>
//   </migration>
//   <migration_downtime>2</migration_downtime>
//   <os>
//     <boot>
//       <devices>
//         <device>hd</device>
//       </devices>
//     </boot>
//   </os>
//   <rng_device>
//     <rate>
//       <bytes>200</bytes>
//       <period>2</period>
//     </rate>
//     <source>urandom</source>
//   </rng_device>
//   <soundcard_enabled>true</soundcard_enabled>
//   <usb>
//     <enabled>true</enabled>
//     <type>native</type>
//   </usb>
//   <virtio_scsi>
//     <enabled>true</enabled>
//   </virtio_scsi>
// </instance_type>
// ----
//
type InstanceTypesServiceAddResponse struct {
	instanceType *InstanceType
}

func (p *InstanceTypesServiceAddResponse) InstanceType() (*InstanceType, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

func (p *InstanceTypesServiceAddResponse) MustInstanceType() *InstanceType {
	if p.instanceType == nil {
		panic("instanceType in response does not exist")
	}
	return p.instanceType
}

//
// Creates a new instance type.
// This requires only a name attribute and can include all hardware configurations of the
// virtual machine.
// [source]
// ----
// POST /ovirt-engine/api/instancetypes
// ----
// With a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
// </template>
// ----
// Creating an instance type with all hardware configurations with a request body like this:
// [source,xml]
// ----
// <instance_type>
//   <name>myinstancetype</name>
//   <console>
//     <enabled>true</enabled>
//   </console>
//   <cpu>
//     <topology>
//       <cores>2</cores>
//       <sockets>2</sockets>
//       <threads>1</threads>
//     </topology>
//   </cpu>
//   <custom_cpu_model>AMD Opteron_G2</custom_cpu_model>
//   <custom_emulated_machine>q35</custom_emulated_machine>
//   <display>
//     <monitors>1</monitors>
//     <single_qxl_pci>true</single_qxl_pci>
//     <smartcard_enabled>true</smartcard_enabled>
//     <type>spice</type>
//   </display>
//   <high_availability>
//     <enabled>true</enabled>
//     <priority>1</priority>
//   </high_availability>
//   <io>
//     <threads>2</threads>
//   </io>
//   <memory>4294967296</memory>
//   <memory_policy>
//     <ballooning>true</ballooning>
//     <guaranteed>268435456</guaranteed>
//   </memory_policy>
//   <migration>
//     <auto_converge>inherit</auto_converge>
//     <compressed>inherit</compressed>
//     <policy id="00000000-0000-0000-0000-000000000000"/>
//   </migration>
//   <migration_downtime>2</migration_downtime>
//   <os>
//     <boot>
//       <devices>
//         <device>hd</device>
//       </devices>
//     </boot>
//   </os>
//   <rng_device>
//     <rate>
//       <bytes>200</bytes>
//       <period>2</period>
//     </rate>
//     <source>urandom</source>
//   </rng_device>
//   <soundcard_enabled>true</soundcard_enabled>
//   <usb>
//     <enabled>true</enabled>
//     <type>native</type>
//   </usb>
//   <virtio_scsi>
//     <enabled>true</enabled>
//   </virtio_scsi>
// </instance_type>
// ----
//
func (p *InstanceTypesService) Add() *InstanceTypesServiceAddRequest {
	return &InstanceTypesServiceAddRequest{InstanceTypesService: p}
}

//
// Lists all existing instance types in the system.
// The order of the returned list of instance types isn't guaranteed.
//
type InstanceTypesServiceListRequest struct {
	InstanceTypesService *InstanceTypesService
	header               map[string]string
	query                map[string]string
	caseSensitive        *bool
	follow               *string
	max                  *int64
	search               *string
}

func (p *InstanceTypesServiceListRequest) Header(key, value string) *InstanceTypesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypesServiceListRequest) Query(key, value string) *InstanceTypesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypesServiceListRequest) CaseSensitive(caseSensitive bool) *InstanceTypesServiceListRequest {
	p.caseSensitive = &caseSensitive
	return p
}

func (p *InstanceTypesServiceListRequest) Follow(follow string) *InstanceTypesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *InstanceTypesServiceListRequest) Max(max int64) *InstanceTypesServiceListRequest {
	p.max = &max
	return p
}

func (p *InstanceTypesServiceListRequest) Search(search string) *InstanceTypesServiceListRequest {
	p.search = &search
	return p
}

func (p *InstanceTypesServiceListRequest) Send() (*InstanceTypesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypesService.connection.URL(), p.InstanceTypesService.path)
	values := make(url.Values)
	if p.caseSensitive != nil {
		values["case_sensitive"] = []string{fmt.Sprintf("%v", *p.caseSensitive)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLInstanceTypeReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &InstanceTypesServiceListResponse{instanceType: result}, nil
}

func (p *InstanceTypesServiceListRequest) MustSend() *InstanceTypesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all existing instance types in the system.
// The order of the returned list of instance types isn't guaranteed.
//
type InstanceTypesServiceListResponse struct {
	instanceType *InstanceTypeSlice
}

func (p *InstanceTypesServiceListResponse) InstanceType() (*InstanceTypeSlice, bool) {
	if p.instanceType != nil {
		return p.instanceType, true
	}
	return nil, false
}

func (p *InstanceTypesServiceListResponse) MustInstanceType() *InstanceTypeSlice {
	if p.instanceType == nil {
		panic("instanceType in response does not exist")
	}
	return p.instanceType
}

//
// Lists all existing instance types in the system.
// The order of the returned list of instance types isn't guaranteed.
//
func (p *InstanceTypesService) List() *InstanceTypesServiceListRequest {
	return &InstanceTypesServiceListRequest{InstanceTypesService: p}
}

//
//
func (op *InstanceTypesService) InstanceTypeService(id string) *InstanceTypeService {
	return NewInstanceTypeService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.InstanceTypeService(path), nil
	}
	return op.InstanceTypeService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypesService) String() string {
	return fmt.Sprintf("InstanceTypesService:%s", op.path)
}

//
// A service that provides values of specific configuration option of the system.
//
type SystemOptionService struct {
	BaseService
}

func NewSystemOptionService(connection *Connection, path string) *SystemOptionService {
	var result SystemOptionService
	result.connection = connection
	result.path = path
	return &result
}

//
// Get the values of specific configuration option.
// For example to retrieve the values of configuration option `MigrationPoliciesSupported` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/options/MigrationPoliciesSupported
// ----
// The response to that request will be the following:
// [source,xml]
// ----
// <system_option href="/ovirt-engine/api/options/MigrationPoliciesSupported" id="MigrationPoliciesSupported">
//   <name>MigrationPoliciesSupported</name>
//   <values>
//     <system_option_value>
//       <value>true</value>
//       <version>4.0</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.1</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.2</version>
//     </system_option_value>
//     <system_option_value>
//       <value>false</value>
//       <version>3.6</version>
//     </system_option_value>
//   </values>
// </system_option>
// ----
// NOTE: The appropriate permissions are required to query configuration options. Some options can be queried
// only by users with administrator permissions.
// [IMPORTANT]
// ====
// There is NO backward compatibility and no guarantee about the names or values of the options. Options may be
// removed and their meaning can be changed at any point.
// We strongly discourage the use of this service for applications other than the ones that are released
// simultaneously with the engine. Usage by other applications is not supported. Therefore there will be no
// documentation listing accessible configuration options.
// ====
//
type SystemOptionServiceGetRequest struct {
	SystemOptionService *SystemOptionService
	header              map[string]string
	query               map[string]string
	version             *string
}

func (p *SystemOptionServiceGetRequest) Header(key, value string) *SystemOptionServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SystemOptionServiceGetRequest) Query(key, value string) *SystemOptionServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SystemOptionServiceGetRequest) Version(version string) *SystemOptionServiceGetRequest {
	p.version = &version
	return p
}

func (p *SystemOptionServiceGetRequest) Send() (*SystemOptionServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SystemOptionService.connection.URL(), p.SystemOptionService.path)
	values := make(url.Values)
	if p.version != nil {
		values["version"] = []string{fmt.Sprintf("%v", *p.version)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SystemOptionService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SystemOptionService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SystemOptionService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SystemOptionService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SystemOptionService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSystemOptionReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SystemOptionServiceGetResponse{option: result}, nil
}

func (p *SystemOptionServiceGetRequest) MustSend() *SystemOptionServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Get the values of specific configuration option.
// For example to retrieve the values of configuration option `MigrationPoliciesSupported` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/options/MigrationPoliciesSupported
// ----
// The response to that request will be the following:
// [source,xml]
// ----
// <system_option href="/ovirt-engine/api/options/MigrationPoliciesSupported" id="MigrationPoliciesSupported">
//   <name>MigrationPoliciesSupported</name>
//   <values>
//     <system_option_value>
//       <value>true</value>
//       <version>4.0</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.1</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.2</version>
//     </system_option_value>
//     <system_option_value>
//       <value>false</value>
//       <version>3.6</version>
//     </system_option_value>
//   </values>
// </system_option>
// ----
// NOTE: The appropriate permissions are required to query configuration options. Some options can be queried
// only by users with administrator permissions.
// [IMPORTANT]
// ====
// There is NO backward compatibility and no guarantee about the names or values of the options. Options may be
// removed and their meaning can be changed at any point.
// We strongly discourage the use of this service for applications other than the ones that are released
// simultaneously with the engine. Usage by other applications is not supported. Therefore there will be no
// documentation listing accessible configuration options.
// ====
//
type SystemOptionServiceGetResponse struct {
	option *SystemOption
}

func (p *SystemOptionServiceGetResponse) Option() (*SystemOption, bool) {
	if p.option != nil {
		return p.option, true
	}
	return nil, false
}

func (p *SystemOptionServiceGetResponse) MustOption() *SystemOption {
	if p.option == nil {
		panic("option in response does not exist")
	}
	return p.option
}

//
// Get the values of specific configuration option.
// For example to retrieve the values of configuration option `MigrationPoliciesSupported` send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/options/MigrationPoliciesSupported
// ----
// The response to that request will be the following:
// [source,xml]
// ----
// <system_option href="/ovirt-engine/api/options/MigrationPoliciesSupported" id="MigrationPoliciesSupported">
//   <name>MigrationPoliciesSupported</name>
//   <values>
//     <system_option_value>
//       <value>true</value>
//       <version>4.0</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.1</version>
//     </system_option_value>
//     <system_option_value>
//       <value>true</value>
//       <version>4.2</version>
//     </system_option_value>
//     <system_option_value>
//       <value>false</value>
//       <version>3.6</version>
//     </system_option_value>
//   </values>
// </system_option>
// ----
// NOTE: The appropriate permissions are required to query configuration options. Some options can be queried
// only by users with administrator permissions.
// [IMPORTANT]
// ====
// There is NO backward compatibility and no guarantee about the names or values of the options. Options may be
// removed and their meaning can be changed at any point.
// We strongly discourage the use of this service for applications other than the ones that are released
// simultaneously with the engine. Usage by other applications is not supported. Therefore there will be no
// documentation listing accessible configuration options.
// ====
//
func (p *SystemOptionService) Get() *SystemOptionServiceGetRequest {
	return &SystemOptionServiceGetRequest{SystemOptionService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SystemOptionService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SystemOptionService) String() string {
	return fmt.Sprintf("SystemOptionService:%s", op.path)
}

//
// A service to manage bookmarks.
//
type BookmarksService struct {
	BaseService
}

func NewBookmarksService(connection *Connection, path string) *BookmarksService {
	var result BookmarksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adding a new bookmark.
// Example of adding a bookmark:
// [source]
// ----
// POST /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
type BookmarksServiceAddRequest struct {
	BookmarksService *BookmarksService
	header           map[string]string
	query            map[string]string
	bookmark         *Bookmark
}

func (p *BookmarksServiceAddRequest) Header(key, value string) *BookmarksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarksServiceAddRequest) Query(key, value string) *BookmarksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarksServiceAddRequest) Bookmark(bookmark *Bookmark) *BookmarksServiceAddRequest {
	p.bookmark = bookmark
	return p
}

func (p *BookmarksServiceAddRequest) Send() (*BookmarksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BookmarksService.connection.URL(), p.BookmarksService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLBookmarkWriteOne(writer, p.bookmark, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BookmarksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BookmarksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BookmarksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BookmarksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BookmarksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &BookmarksServiceAddResponse{bookmark: result}, nil
}

func (p *BookmarksServiceAddRequest) MustSend() *BookmarksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adding a new bookmark.
// Example of adding a bookmark:
// [source]
// ----
// POST /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
type BookmarksServiceAddResponse struct {
	bookmark *Bookmark
}

func (p *BookmarksServiceAddResponse) Bookmark() (*Bookmark, bool) {
	if p.bookmark != nil {
		return p.bookmark, true
	}
	return nil, false
}

func (p *BookmarksServiceAddResponse) MustBookmark() *Bookmark {
	if p.bookmark == nil {
		panic("bookmark in response does not exist")
	}
	return p.bookmark
}

//
// Adding a new bookmark.
// Example of adding a bookmark:
// [source]
// ----
// POST /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmark>
//   <name>new_example_vm</name>
//   <value>vm: name=new_example*</value>
// </bookmark>
// ----
//
func (p *BookmarksService) Add() *BookmarksServiceAddRequest {
	return &BookmarksServiceAddRequest{BookmarksService: p}
}

//
// Listing all the available bookmarks.
// Example of listing bookmarks:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmarks>
//   <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//     <name>database</name>
//     <value>vm: name=database*</value>
//   </bookmark>
//   <bookmark href="/ovirt-engine/api/bookmarks/456" id="456">
//     <name>example</name>
//     <value>vm: name=example*</value>
//   </bookmark>
// </bookmarks>
// ----
// The order of the returned bookmarks isn't guaranteed.
//
type BookmarksServiceListRequest struct {
	BookmarksService *BookmarksService
	header           map[string]string
	query            map[string]string
	follow           *string
	max              *int64
}

func (p *BookmarksServiceListRequest) Header(key, value string) *BookmarksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *BookmarksServiceListRequest) Query(key, value string) *BookmarksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *BookmarksServiceListRequest) Follow(follow string) *BookmarksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *BookmarksServiceListRequest) Max(max int64) *BookmarksServiceListRequest {
	p.max = &max
	return p
}

func (p *BookmarksServiceListRequest) Send() (*BookmarksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.BookmarksService.connection.URL(), p.BookmarksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.BookmarksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.BookmarksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.BookmarksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.BookmarksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.BookmarksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLBookmarkReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &BookmarksServiceListResponse{bookmarks: result}, nil
}

func (p *BookmarksServiceListRequest) MustSend() *BookmarksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Listing all the available bookmarks.
// Example of listing bookmarks:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmarks>
//   <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//     <name>database</name>
//     <value>vm: name=database*</value>
//   </bookmark>
//   <bookmark href="/ovirt-engine/api/bookmarks/456" id="456">
//     <name>example</name>
//     <value>vm: name=example*</value>
//   </bookmark>
// </bookmarks>
// ----
// The order of the returned bookmarks isn't guaranteed.
//
type BookmarksServiceListResponse struct {
	bookmarks *BookmarkSlice
}

func (p *BookmarksServiceListResponse) Bookmarks() (*BookmarkSlice, bool) {
	if p.bookmarks != nil {
		return p.bookmarks, true
	}
	return nil, false
}

func (p *BookmarksServiceListResponse) MustBookmarks() *BookmarkSlice {
	if p.bookmarks == nil {
		panic("bookmarks in response does not exist")
	}
	return p.bookmarks
}

//
// Listing all the available bookmarks.
// Example of listing bookmarks:
// [source]
// ----
// GET /ovirt-engine/api/bookmarks
// ----
// [source,xml]
// ----
// <bookmarks>
//   <bookmark href="/ovirt-engine/api/bookmarks/123" id="123">
//     <name>database</name>
//     <value>vm: name=database*</value>
//   </bookmark>
//   <bookmark href="/ovirt-engine/api/bookmarks/456" id="456">
//     <name>example</name>
//     <value>vm: name=example*</value>
//   </bookmark>
// </bookmarks>
// ----
// The order of the returned bookmarks isn't guaranteed.
//
func (p *BookmarksService) List() *BookmarksServiceListRequest {
	return &BookmarksServiceListRequest{BookmarksService: p}
}

//
// A reference to the service managing a specific bookmark.
//
func (op *BookmarksService) BookmarkService(id string) *BookmarkService {
	return NewBookmarkService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *BookmarksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.BookmarkService(path), nil
	}
	return op.BookmarkService(path[:index]).Service(path[index+1:])
}

func (op *BookmarksService) String() string {
	return fmt.Sprintf("BookmarksService:%s", op.path)
}

//
// Manages the set of network attachments of a host or host NIC.
//
type NetworkAttachmentsService struct {
	BaseService
}

func NewNetworkAttachmentsService(connection *Connection, path string) *NetworkAttachmentsService {
	var result NetworkAttachmentsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new network attachment to the network interface.
//
type NetworkAttachmentsServiceAddRequest struct {
	NetworkAttachmentsService *NetworkAttachmentsService
	header                    map[string]string
	query                     map[string]string
	attachment                *NetworkAttachment
}

func (p *NetworkAttachmentsServiceAddRequest) Header(key, value string) *NetworkAttachmentsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentsServiceAddRequest) Query(key, value string) *NetworkAttachmentsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentsServiceAddRequest) Attachment(attachment *NetworkAttachment) *NetworkAttachmentsServiceAddRequest {
	p.attachment = attachment
	return p
}

func (p *NetworkAttachmentsServiceAddRequest) Send() (*NetworkAttachmentsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkAttachmentsService.connection.URL(), p.NetworkAttachmentsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNetworkAttachmentWriteOne(writer, p.attachment, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkAttachmentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkAttachmentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkAttachmentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &NetworkAttachmentsServiceAddResponse{attachment: result}, nil
}

func (p *NetworkAttachmentsServiceAddRequest) MustSend() *NetworkAttachmentsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new network attachment to the network interface.
//
type NetworkAttachmentsServiceAddResponse struct {
	attachment *NetworkAttachment
}

func (p *NetworkAttachmentsServiceAddResponse) Attachment() (*NetworkAttachment, bool) {
	if p.attachment != nil {
		return p.attachment, true
	}
	return nil, false
}

func (p *NetworkAttachmentsServiceAddResponse) MustAttachment() *NetworkAttachment {
	if p.attachment == nil {
		panic("attachment in response does not exist")
	}
	return p.attachment
}

//
// Add a new network attachment to the network interface.
//
func (p *NetworkAttachmentsService) Add() *NetworkAttachmentsServiceAddRequest {
	return &NetworkAttachmentsServiceAddRequest{NetworkAttachmentsService: p}
}

//
// Returns the list of network attachments of the host or host NIC.
// The order of the returned list of network attachments isn't guaranteed.
//
type NetworkAttachmentsServiceListRequest struct {
	NetworkAttachmentsService *NetworkAttachmentsService
	header                    map[string]string
	query                     map[string]string
	follow                    *string
	max                       *int64
}

func (p *NetworkAttachmentsServiceListRequest) Header(key, value string) *NetworkAttachmentsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *NetworkAttachmentsServiceListRequest) Query(key, value string) *NetworkAttachmentsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *NetworkAttachmentsServiceListRequest) Follow(follow string) *NetworkAttachmentsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *NetworkAttachmentsServiceListRequest) Max(max int64) *NetworkAttachmentsServiceListRequest {
	p.max = &max
	return p
}

func (p *NetworkAttachmentsServiceListRequest) Send() (*NetworkAttachmentsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.NetworkAttachmentsService.connection.URL(), p.NetworkAttachmentsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.NetworkAttachmentsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.NetworkAttachmentsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.NetworkAttachmentsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.NetworkAttachmentsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.NetworkAttachmentsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNetworkAttachmentReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &NetworkAttachmentsServiceListResponse{attachments: result}, nil
}

func (p *NetworkAttachmentsServiceListRequest) MustSend() *NetworkAttachmentsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of network attachments of the host or host NIC.
// The order of the returned list of network attachments isn't guaranteed.
//
type NetworkAttachmentsServiceListResponse struct {
	attachments *NetworkAttachmentSlice
}

func (p *NetworkAttachmentsServiceListResponse) Attachments() (*NetworkAttachmentSlice, bool) {
	if p.attachments != nil {
		return p.attachments, true
	}
	return nil, false
}

func (p *NetworkAttachmentsServiceListResponse) MustAttachments() *NetworkAttachmentSlice {
	if p.attachments == nil {
		panic("attachments in response does not exist")
	}
	return p.attachments
}

//
// Returns the list of network attachments of the host or host NIC.
// The order of the returned list of network attachments isn't guaranteed.
//
func (p *NetworkAttachmentsService) List() *NetworkAttachmentsServiceListRequest {
	return &NetworkAttachmentsServiceListRequest{NetworkAttachmentsService: p}
}

//
//
func (op *NetworkAttachmentsService) AttachmentService(id string) *NetworkAttachmentService {
	return NewNetworkAttachmentService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *NetworkAttachmentsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.AttachmentService(path), nil
	}
	return op.AttachmentService(path[:index]).Service(path[index+1:])
}

func (op *NetworkAttachmentsService) String() string {
	return fmt.Sprintf("NetworkAttachmentsService:%s", op.path)
}

//
// A service to view certificates for external provider.
//
type ExternalProviderCertificatesService struct {
	BaseService
}

func NewExternalProviderCertificatesService(connection *Connection, path string) *ExternalProviderCertificatesService {
	var result ExternalProviderCertificatesService
	result.connection = connection
	result.path = path
	return &result
}

//
// Returns the chain of certificates presented by the external provider.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificates
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificates>
//   <certificate id="789">...</certificate>
//   ...
// </certificates>
// ----
// The order of the returned certificates is always guaranteed to be the sign order: the first is the
// certificate of the server itself, the second the certificate of the CA that signs the first, so on.
//
type ExternalProviderCertificatesServiceListRequest struct {
	ExternalProviderCertificatesService *ExternalProviderCertificatesService
	header                              map[string]string
	query                               map[string]string
	follow                              *string
	max                                 *int64
}

func (p *ExternalProviderCertificatesServiceListRequest) Header(key, value string) *ExternalProviderCertificatesServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderCertificatesServiceListRequest) Query(key, value string) *ExternalProviderCertificatesServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderCertificatesServiceListRequest) Follow(follow string) *ExternalProviderCertificatesServiceListRequest {
	p.follow = &follow
	return p
}

func (p *ExternalProviderCertificatesServiceListRequest) Max(max int64) *ExternalProviderCertificatesServiceListRequest {
	p.max = &max
	return p
}

func (p *ExternalProviderCertificatesServiceListRequest) Send() (*ExternalProviderCertificatesServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ExternalProviderCertificatesService.connection.URL(), p.ExternalProviderCertificatesService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalProviderCertificatesService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalProviderCertificatesService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalProviderCertificatesService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalProviderCertificatesService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalProviderCertificatesService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLCertificateReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &ExternalProviderCertificatesServiceListResponse{certificates: result}, nil
}

func (p *ExternalProviderCertificatesServiceListRequest) MustSend() *ExternalProviderCertificatesServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the chain of certificates presented by the external provider.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificates
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificates>
//   <certificate id="789">...</certificate>
//   ...
// </certificates>
// ----
// The order of the returned certificates is always guaranteed to be the sign order: the first is the
// certificate of the server itself, the second the certificate of the CA that signs the first, so on.
//
type ExternalProviderCertificatesServiceListResponse struct {
	certificates *CertificateSlice
}

func (p *ExternalProviderCertificatesServiceListResponse) Certificates() (*CertificateSlice, bool) {
	if p.certificates != nil {
		return p.certificates, true
	}
	return nil, false
}

func (p *ExternalProviderCertificatesServiceListResponse) MustCertificates() *CertificateSlice {
	if p.certificates == nil {
		panic("certificates in response does not exist")
	}
	return p.certificates
}

//
// Returns the chain of certificates presented by the external provider.
// [source]
// ----
// GET /ovirt-engine/api/externalhostproviders/123/certificates
// ----
// And here is sample response:
// [source,xml]
// ----
// <certificates>
//   <certificate id="789">...</certificate>
//   ...
// </certificates>
// ----
// The order of the returned certificates is always guaranteed to be the sign order: the first is the
// certificate of the server itself, the second the certificate of the CA that signs the first, so on.
//
func (p *ExternalProviderCertificatesService) List() *ExternalProviderCertificatesServiceListRequest {
	return &ExternalProviderCertificatesServiceListRequest{ExternalProviderCertificatesService: p}
}

//
// Reference to service that manages a specific certificate
// for this external provider.
//
func (op *ExternalProviderCertificatesService) CertificateService(id string) *ExternalProviderCertificateService {
	return NewExternalProviderCertificateService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderCertificatesService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.CertificateService(path), nil
	}
	return op.CertificateService(path[:index]).Service(path[index+1:])
}

func (op *ExternalProviderCertificatesService) String() string {
	return fmt.Sprintf("ExternalProviderCertificatesService:%s", op.path)
}

//
// Manages the set of _quality of service_ configurations available in a data center.
//
type QossService struct {
	BaseService
}

func NewQossService(connection *Connection, path string) *QossService {
	var result QossService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a new QoS to the dataCenter.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/qoss
// ----
// The response will look as follows:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>10</max_iops>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type QossServiceAddRequest struct {
	QossService *QossService
	header      map[string]string
	query       map[string]string
	qos         *Qos
}

func (p *QossServiceAddRequest) Header(key, value string) *QossServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QossServiceAddRequest) Query(key, value string) *QossServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QossServiceAddRequest) Qos(qos *Qos) *QossServiceAddRequest {
	p.qos = qos
	return p
}

func (p *QossServiceAddRequest) Send() (*QossServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QossService.connection.URL(), p.QossService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLQosWriteOne(writer, p.qos, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QossService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QossService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QossService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QossService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QossService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &QossServiceAddResponse{qos: result}, nil
}

func (p *QossServiceAddRequest) MustSend() *QossServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a new QoS to the dataCenter.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/qoss
// ----
// The response will look as follows:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>10</max_iops>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
type QossServiceAddResponse struct {
	qos *Qos
}

func (p *QossServiceAddResponse) Qos() (*Qos, bool) {
	if p.qos != nil {
		return p.qos, true
	}
	return nil, false
}

func (p *QossServiceAddResponse) MustQos() *Qos {
	if p.qos == nil {
		panic("qos in response does not exist")
	}
	return p.qos
}

//
// Add a new QoS to the dataCenter.
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/qoss
// ----
// The response will look as follows:
// [source,xml]
// ----
// <qos href="/ovirt-engine/api/datacenters/123/qoss/123" id="123">
//   <name>123</name>
//   <description>123</description>
//   <max_iops>10</max_iops>
//   <type>storage</type>
//   <data_center href="/ovirt-engine/api/datacenters/123" id="123"/>
// </qos>
// ----
//
func (p *QossService) Add() *QossServiceAddRequest {
	return &QossServiceAddRequest{QossService: p}
}

//
// Returns the list of _quality of service_ configurations available in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenter/123/qoss
// ----
// You will get response which will look like this:
// [source, xml]
// ----
// <qoss>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/1" id="1">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/2" id="2">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/3" id="3">...</qos>
// </qoss>
// ----
// The returned list of quality of service configurations isn't guaranteed.
//
type QossServiceListRequest struct {
	QossService *QossService
	header      map[string]string
	query       map[string]string
	follow      *string
	max         *int64
}

func (p *QossServiceListRequest) Header(key, value string) *QossServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *QossServiceListRequest) Query(key, value string) *QossServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *QossServiceListRequest) Follow(follow string) *QossServiceListRequest {
	p.follow = &follow
	return p
}

func (p *QossServiceListRequest) Max(max int64) *QossServiceListRequest {
	p.max = &max
	return p
}

func (p *QossServiceListRequest) Send() (*QossServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.QossService.connection.URL(), p.QossService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.QossService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.QossService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.QossService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.QossService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.QossService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLQosReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &QossServiceListResponse{qoss: result}, nil
}

func (p *QossServiceListRequest) MustSend() *QossServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of _quality of service_ configurations available in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenter/123/qoss
// ----
// You will get response which will look like this:
// [source, xml]
// ----
// <qoss>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/1" id="1">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/2" id="2">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/3" id="3">...</qos>
// </qoss>
// ----
// The returned list of quality of service configurations isn't guaranteed.
//
type QossServiceListResponse struct {
	qoss *QosSlice
}

func (p *QossServiceListResponse) Qoss() (*QosSlice, bool) {
	if p.qoss != nil {
		return p.qoss, true
	}
	return nil, false
}

func (p *QossServiceListResponse) MustQoss() *QosSlice {
	if p.qoss == nil {
		panic("qoss in response does not exist")
	}
	return p.qoss
}

//
// Returns the list of _quality of service_ configurations available in the data center.
// [source]
// ----
// GET /ovirt-engine/api/datacenter/123/qoss
// ----
// You will get response which will look like this:
// [source, xml]
// ----
// <qoss>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/1" id="1">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/2" id="2">...</qos>
//   <qos href="/ovirt-engine/api/datacenters/123/qoss/3" id="3">...</qos>
// </qoss>
// ----
// The returned list of quality of service configurations isn't guaranteed.
//
func (p *QossService) List() *QossServiceListRequest {
	return &QossServiceListRequest{QossService: p}
}

//
// A reference to a service managing a specific QoS.
//
func (op *QossService) QosService(id string) *QosService {
	return NewQosService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *QossService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.QosService(path), nil
	}
	return op.QosService(path[:index]).Service(path[index+1:])
}

func (op *QossService) String() string {
	return fmt.Sprintf("QossService:%s", op.path)
}

//
// Provides information about a specific cluster level. See the <<services/cluster_levels,ClusterLevels>> service for
// more information.
//
type ClusterLevelService struct {
	BaseService
}

func NewClusterLevelService(connection *Connection, path string) *ClusterLevelService {
	var result ClusterLevelService
	result.connection = connection
	result.path = path
	return &result
}

//
// Provides the information about the capabilities of the specific cluster level managed by this service.
// For example, to find what CPU types are supported by level 3.6 you can send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/3.6
// ----
// That will return a <<types/cluster_level, ClusterLevel>> object containing the supported CPU types, and other
// information which describes the cluster level:
// [source,xml]
// ----
// <cluster_level id="3.6">
//   <cpu_types>
//     <cpu_type>
//       <name>Intel Nehalem Family</name>
//       <level>3</level>
//       <architecture>x86_64</architecture>
//     </cpu_type>
//     ...
//   </cpu_types>
//   <permits>
//     <permit id="1">
//       <name>create_vm</name>
//       <administrative>false</administrative>
//     </permit>
//     ...
//   </permits>
// </cluster_level>
// ----
//
type ClusterLevelServiceGetRequest struct {
	ClusterLevelService *ClusterLevelService
	header              map[string]string
	query               map[string]string
	follow              *string
}

func (p *ClusterLevelServiceGetRequest) Header(key, value string) *ClusterLevelServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ClusterLevelServiceGetRequest) Query(key, value string) *ClusterLevelServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ClusterLevelServiceGetRequest) Follow(follow string) *ClusterLevelServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *ClusterLevelServiceGetRequest) Send() (*ClusterLevelServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.ClusterLevelService.connection.URL(), p.ClusterLevelService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ClusterLevelService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ClusterLevelService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ClusterLevelService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ClusterLevelService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ClusterLevelService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLClusterLevelReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &ClusterLevelServiceGetResponse{level: result}, nil
}

func (p *ClusterLevelServiceGetRequest) MustSend() *ClusterLevelServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Provides the information about the capabilities of the specific cluster level managed by this service.
// For example, to find what CPU types are supported by level 3.6 you can send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/3.6
// ----
// That will return a <<types/cluster_level, ClusterLevel>> object containing the supported CPU types, and other
// information which describes the cluster level:
// [source,xml]
// ----
// <cluster_level id="3.6">
//   <cpu_types>
//     <cpu_type>
//       <name>Intel Nehalem Family</name>
//       <level>3</level>
//       <architecture>x86_64</architecture>
//     </cpu_type>
//     ...
//   </cpu_types>
//   <permits>
//     <permit id="1">
//       <name>create_vm</name>
//       <administrative>false</administrative>
//     </permit>
//     ...
//   </permits>
// </cluster_level>
// ----
//
type ClusterLevelServiceGetResponse struct {
	level *ClusterLevel
}

func (p *ClusterLevelServiceGetResponse) Level() (*ClusterLevel, bool) {
	if p.level != nil {
		return p.level, true
	}
	return nil, false
}

func (p *ClusterLevelServiceGetResponse) MustLevel() *ClusterLevel {
	if p.level == nil {
		panic("level in response does not exist")
	}
	return p.level
}

//
// Provides the information about the capabilities of the specific cluster level managed by this service.
// For example, to find what CPU types are supported by level 3.6 you can send a request like this:
// [source]
// ----
// GET /ovirt-engine/api/clusterlevels/3.6
// ----
// That will return a <<types/cluster_level, ClusterLevel>> object containing the supported CPU types, and other
// information which describes the cluster level:
// [source,xml]
// ----
// <cluster_level id="3.6">
//   <cpu_types>
//     <cpu_type>
//       <name>Intel Nehalem Family</name>
//       <level>3</level>
//       <architecture>x86_64</architecture>
//     </cpu_type>
//     ...
//   </cpu_types>
//   <permits>
//     <permit id="1">
//       <name>create_vm</name>
//       <administrative>false</administrative>
//     </permit>
//     ...
//   </permits>
// </cluster_level>
// ----
//
func (p *ClusterLevelService) Get() *ClusterLevelServiceGetRequest {
	return &ClusterLevelServiceGetRequest{ClusterLevelService: p}
}

//
// Reference to the service that manages the collection of supported features for this cluster level.
//
func (op *ClusterLevelService) ClusterFeaturesService() *ClusterFeaturesService {
	return NewClusterFeaturesService(op.connection, fmt.Sprintf("%s/clusterfeatures", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ClusterLevelService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "clusterfeatures" {
		return op.ClusterFeaturesService(), nil
	}
	if strings.HasPrefix(path, "clusterfeatures/") {
		return op.ClusterFeaturesService().Service(path[16:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ClusterLevelService) String() string {
	return fmt.Sprintf("ClusterLevelService:%s", op.path)
}

//
// Manages a single disk.
//
type DiskService struct {
	BaseService
}

func NewDiskService(connection *Connection, path string) *DiskService {
	var result DiskService
	result.connection = connection
	result.path = path
	return &result
}

//
// This operation copies a disk to the specified storage domain.
// For example, a disk can be copied using the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/copy
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk>
//     <name>mydisk</name>
//   </disk>
// </action>
// ----
// If the disk profile or the quota currently used by the disk are not defined for the new storage domain, they
// can be explicitly specified. If they are not specified, the first available disk profile and the default quota are used.
// For example, to specify disk profile `987` and quota `753`, send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
type DiskServiceCopyRequest struct {
	DiskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	disk          *Disk
	diskProfile   *DiskProfile
	filter        *bool
	quota         *Quota
	storageDomain *StorageDomain
}

func (p *DiskServiceCopyRequest) Header(key, value string) *DiskServiceCopyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceCopyRequest) Query(key, value string) *DiskServiceCopyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceCopyRequest) Async(async bool) *DiskServiceCopyRequest {
	p.async = &async
	return p
}

func (p *DiskServiceCopyRequest) Disk(disk *Disk) *DiskServiceCopyRequest {
	p.disk = disk
	return p
}

func (p *DiskServiceCopyRequest) DiskProfile(diskProfile *DiskProfile) *DiskServiceCopyRequest {
	p.diskProfile = diskProfile
	return p
}

func (p *DiskServiceCopyRequest) Filter(filter bool) *DiskServiceCopyRequest {
	p.filter = &filter
	return p
}

func (p *DiskServiceCopyRequest) Quota(quota *Quota) *DiskServiceCopyRequest {
	p.quota = quota
	return p
}

func (p *DiskServiceCopyRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceCopyRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *DiskServiceCopyRequest) Send() (*DiskServiceCopyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/copy", p.DiskService.connection.URL(), p.DiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.Disk(p.disk)
	actionBuilder.DiskProfile(p.diskProfile)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Quota(p.quota)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceCopyResponse), nil
}

func (p *DiskServiceCopyRequest) MustSend() *DiskServiceCopyResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// This operation copies a disk to the specified storage domain.
// For example, a disk can be copied using the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/copy
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk>
//     <name>mydisk</name>
//   </disk>
// </action>
// ----
// If the disk profile or the quota currently used by the disk are not defined for the new storage domain, they
// can be explicitly specified. If they are not specified, the first available disk profile and the default quota are used.
// For example, to specify disk profile `987` and quota `753`, send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
type DiskServiceCopyResponse struct {
}

//
// This operation copies a disk to the specified storage domain.
// For example, a disk can be copied using the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/copy
// ----
// With a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk>
//     <name>mydisk</name>
//   </disk>
// </action>
// ----
// If the disk profile or the quota currently used by the disk are not defined for the new storage domain, they
// can be explicitly specified. If they are not specified, the first available disk profile and the default quota are used.
// For example, to specify disk profile `987` and quota `753`, send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
func (p *DiskService) Copy() *DiskServiceCopyRequest {
	return &DiskServiceCopyRequest{DiskService: p}
}

//
// Exports a disk to an export storage domain.
//
type DiskServiceExportRequest struct {
	DiskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	filter        *bool
	storageDomain *StorageDomain
}

func (p *DiskServiceExportRequest) Header(key, value string) *DiskServiceExportRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceExportRequest) Query(key, value string) *DiskServiceExportRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceExportRequest) Async(async bool) *DiskServiceExportRequest {
	p.async = &async
	return p
}

func (p *DiskServiceExportRequest) Filter(filter bool) *DiskServiceExportRequest {
	p.filter = &filter
	return p
}

func (p *DiskServiceExportRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceExportRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *DiskServiceExportRequest) Send() (*DiskServiceExportResponse, error) {
	rawURL := fmt.Sprintf("%s%s/export", p.DiskService.connection.URL(), p.DiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceExportResponse), nil
}

func (p *DiskServiceExportRequest) MustSend() *DiskServiceExportResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Exports a disk to an export storage domain.
//
type DiskServiceExportResponse struct {
}

//
// Exports a disk to an export storage domain.
//
func (p *DiskService) Export() *DiskServiceExportRequest {
	return &DiskServiceExportRequest{DiskService: p}
}

//
// Retrieves the description of the disk.
//
type DiskServiceGetRequest struct {
	DiskService *DiskService
	header      map[string]string
	query       map[string]string
	allContent  *bool
	follow      *string
}

func (p *DiskServiceGetRequest) Header(key, value string) *DiskServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceGetRequest) Query(key, value string) *DiskServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceGetRequest) AllContent(allContent bool) *DiskServiceGetRequest {
	p.allContent = &allContent
	return p
}

func (p *DiskServiceGetRequest) Follow(follow string) *DiskServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *DiskServiceGetRequest) Send() (*DiskServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskService.connection.URL(), p.DiskService.path)
	values := make(url.Values)
	if p.allContent != nil {
		values["all_content"] = []string{fmt.Sprintf("%v", *p.allContent)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskServiceGetResponse{disk: result}, nil
}

func (p *DiskServiceGetRequest) MustSend() *DiskServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves the description of the disk.
//
type DiskServiceGetResponse struct {
	disk *Disk
}

func (p *DiskServiceGetResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *DiskServiceGetResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Retrieves the description of the disk.
//
func (p *DiskService) Get() *DiskServiceGetRequest {
	return &DiskServiceGetRequest{DiskService: p}
}

//
// Moves a disk to another storage domain.
// For example, to move the disk with identifier `123` to a storage domain with identifier `456` send the following
// request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/move
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
// </action>
// ----
// If the disk profile or the quota used currently by
// the disk aren't defined for the new storage domain,
// then they can be explicitly specified. If they aren't
// then the first available disk profile and the default
// quota are used.
// For example, to explicitly use disk profile `987` and
// quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
type DiskServiceMoveRequest struct {
	DiskService   *DiskService
	header        map[string]string
	query         map[string]string
	async         *bool
	diskProfile   *DiskProfile
	filter        *bool
	quota         *Quota
	storageDomain *StorageDomain
}

func (p *DiskServiceMoveRequest) Header(key, value string) *DiskServiceMoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceMoveRequest) Query(key, value string) *DiskServiceMoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceMoveRequest) Async(async bool) *DiskServiceMoveRequest {
	p.async = &async
	return p
}

func (p *DiskServiceMoveRequest) DiskProfile(diskProfile *DiskProfile) *DiskServiceMoveRequest {
	p.diskProfile = diskProfile
	return p
}

func (p *DiskServiceMoveRequest) Filter(filter bool) *DiskServiceMoveRequest {
	p.filter = &filter
	return p
}

func (p *DiskServiceMoveRequest) Quota(quota *Quota) *DiskServiceMoveRequest {
	p.quota = quota
	return p
}

func (p *DiskServiceMoveRequest) StorageDomain(storageDomain *StorageDomain) *DiskServiceMoveRequest {
	p.storageDomain = storageDomain
	return p
}

func (p *DiskServiceMoveRequest) Send() (*DiskServiceMoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s/move", p.DiskService.connection.URL(), p.DiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	actionBuilder.DiskProfile(p.diskProfile)
	if p.filter != nil {
		actionBuilder.Filter(*p.filter)
	}
	actionBuilder.Quota(p.quota)
	actionBuilder.StorageDomain(p.storageDomain)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceMoveResponse), nil
}

func (p *DiskServiceMoveRequest) MustSend() *DiskServiceMoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Moves a disk to another storage domain.
// For example, to move the disk with identifier `123` to a storage domain with identifier `456` send the following
// request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/move
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
// </action>
// ----
// If the disk profile or the quota used currently by
// the disk aren't defined for the new storage domain,
// then they can be explicitly specified. If they aren't
// then the first available disk profile and the default
// quota are used.
// For example, to explicitly use disk profile `987` and
// quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
type DiskServiceMoveResponse struct {
}

//
// Moves a disk to another storage domain.
// For example, to move the disk with identifier `123` to a storage domain with identifier `456` send the following
// request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/move
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
// </action>
// ----
// If the disk profile or the quota used currently by
// the disk aren't defined for the new storage domain,
// then they can be explicitly specified. If they aren't
// then the first available disk profile and the default
// quota are used.
// For example, to explicitly use disk profile `987` and
// quota `753` send a request body like this:
// [source,xml]
// ----
// <action>
//   <storage_domain id="456"/>
//   <disk_profile id="987"/>
//   <quota id="753"/>
// </action>
// ----
//
func (p *DiskService) Move() *DiskServiceMoveRequest {
	return &DiskServiceMoveRequest{DiskService: p}
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
type DiskServiceReduceRequest struct {
	DiskService *DiskService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *DiskServiceReduceRequest) Header(key, value string) *DiskServiceReduceRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceReduceRequest) Query(key, value string) *DiskServiceReduceRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceReduceRequest) Async(async bool) *DiskServiceReduceRequest {
	p.async = &async
	return p
}

func (p *DiskServiceReduceRequest) Send() (*DiskServiceReduceResponse, error) {
	rawURL := fmt.Sprintf("%s%s/reduce", p.DiskService.connection.URL(), p.DiskService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceReduceResponse), nil
}

func (p *DiskServiceReduceRequest) MustSend() *DiskServiceReduceResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
type DiskServiceReduceResponse struct {
}

//
// Reduces the size of the disk image.
// Invokes _reduce_ on the logical volume (i.e. this is only applicable for block storage domains).
// This is applicable for floating disks and disks attached to non-running virtual machines.
// There is no need to specify the size as the optimal size is calculated automatically.
//
func (p *DiskService) Reduce() *DiskServiceReduceRequest {
	return &DiskServiceReduceRequest{DiskService: p}
}

//
// Refreshes a direct LUN disk with up-to-date information from the storage.
// Refreshing a direct LUN disk is useful when:
// - The LUN was added using the API without the host parameter, and therefore does not contain
//   any information from the storage (see <<services/disks/methods/add, DisksService::add>>).
// - New information about the LUN is available on the storage and you want to update the LUN with it.
// To refresh direct LUN disk `123` using host `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/refreshlun
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <host id='456'/>
// </action>
// ----
//
type DiskServiceRefreshLunRequest struct {
	DiskService *DiskService
	header      map[string]string
	query       map[string]string
	host        *Host
}

func (p *DiskServiceRefreshLunRequest) Header(key, value string) *DiskServiceRefreshLunRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceRefreshLunRequest) Query(key, value string) *DiskServiceRefreshLunRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceRefreshLunRequest) Host(host *Host) *DiskServiceRefreshLunRequest {
	p.host = host
	return p
}

func (p *DiskServiceRefreshLunRequest) Send() (*DiskServiceRefreshLunResponse, error) {
	rawURL := fmt.Sprintf("%s%s/refreshlun", p.DiskService.connection.URL(), p.DiskService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Host(p.host)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceRefreshLunResponse), nil
}

func (p *DiskServiceRefreshLunRequest) MustSend() *DiskServiceRefreshLunResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Refreshes a direct LUN disk with up-to-date information from the storage.
// Refreshing a direct LUN disk is useful when:
// - The LUN was added using the API without the host parameter, and therefore does not contain
//   any information from the storage (see <<services/disks/methods/add, DisksService::add>>).
// - New information about the LUN is available on the storage and you want to update the LUN with it.
// To refresh direct LUN disk `123` using host `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/refreshlun
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <host id='456'/>
// </action>
// ----
//
type DiskServiceRefreshLunResponse struct {
}

//
// Refreshes a direct LUN disk with up-to-date information from the storage.
// Refreshing a direct LUN disk is useful when:
// - The LUN was added using the API without the host parameter, and therefore does not contain
//   any information from the storage (see <<services/disks/methods/add, DisksService::add>>).
// - New information about the LUN is available on the storage and you want to update the LUN with it.
// To refresh direct LUN disk `123` using host `456`, send the following request:
// [source]
// ----
// POST /ovirt-engine/api/disks/123/refreshlun
// ----
// With the following request body:
// [source,xml]
// ----
// <action>
//   <host id='456'/>
// </action>
// ----
//
func (p *DiskService) RefreshLun() *DiskServiceRefreshLunRequest {
	return &DiskServiceRefreshLunRequest{DiskService: p}
}

//
// Removes a disk.
//
type DiskServiceRemoveRequest struct {
	DiskService *DiskService
	header      map[string]string
	query       map[string]string
	async       *bool
}

func (p *DiskServiceRemoveRequest) Header(key, value string) *DiskServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceRemoveRequest) Query(key, value string) *DiskServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceRemoveRequest) Async(async bool) *DiskServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *DiskServiceRemoveRequest) Send() (*DiskServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskService.connection.URL(), p.DiskService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(DiskServiceRemoveResponse), nil
}

func (p *DiskServiceRemoveRequest) MustSend() *DiskServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Removes a disk.
//
type DiskServiceRemoveResponse struct {
}

//
// Removes a disk.
//
func (p *DiskService) Remove() *DiskServiceRemoveRequest {
	return &DiskServiceRemoveRequest{DiskService: p}
}

//
// Sparsify the disk.
// Sparsification frees space in the disk image that is not used by its
// filesystem. As a result, the image will occupy less space on the storage.
// Currently sparsification works only on disks without snapshots. Disks
// having derived disks are also not allowed.
//
type DiskServiceSparsifyRequest struct {
	DiskService *DiskService
	header      map[string]string
	query       map[string]string
}

func (p *DiskServiceSparsifyRequest) Header(key, value string) *DiskServiceSparsifyRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceSparsifyRequest) Query(key, value string) *DiskServiceSparsifyRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceSparsifyRequest) Send() (*DiskServiceSparsifyResponse, error) {
	rawURL := fmt.Sprintf("%s%s/sparsify", p.DiskService.connection.URL(), p.DiskService.path)
	actionBuilder := NewActionBuilder()
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(DiskServiceSparsifyResponse), nil
}

func (p *DiskServiceSparsifyRequest) MustSend() *DiskServiceSparsifyResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Sparsify the disk.
// Sparsification frees space in the disk image that is not used by its
// filesystem. As a result, the image will occupy less space on the storage.
// Currently sparsification works only on disks without snapshots. Disks
// having derived disks are also not allowed.
//
type DiskServiceSparsifyResponse struct {
}

//
// Sparsify the disk.
// Sparsification frees space in the disk image that is not used by its
// filesystem. As a result, the image will occupy less space on the storage.
// Currently sparsification works only on disks without snapshots. Disks
// having derived disks are also not allowed.
//
func (p *DiskService) Sparsify() *DiskServiceSparsifyRequest {
	return &DiskServiceSparsifyRequest{DiskService: p}
}

//
// Updates the parameters of the specified disk.
// This operation allows updating the following floating disk properties:
// * For Image disks: `provisioned_size`, `alias`, `description`, `wipe_after_delete`, `shareable`, `backup` and `disk_profile`.
// * For LUN disks: `alias`, `description` and `shareable`.
// * For Cinder and Managed Block disks: `provisioned_size`, `alias` and `description`.
// * For VM attached disks, the `qcow_version` can also be updated.
// For example, a disk's update can be done by using the following request:
// [source]
// ----
// PUT /ovirt-engine/api/disks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <disk>
//   <qcow_version>qcow2_v3</qcow_version>
//   <alias>new-alias</alias>
//   <description>new-desc</description>
// </disk>
// ----
// Since the backend operation is asynchronous, the disk element that is returned
// to the user might not be synced with the changed properties.
//
type DiskServiceUpdateRequest struct {
	DiskService *DiskService
	header      map[string]string
	query       map[string]string
	disk        *Disk
}

func (p *DiskServiceUpdateRequest) Header(key, value string) *DiskServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *DiskServiceUpdateRequest) Query(key, value string) *DiskServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *DiskServiceUpdateRequest) Disk(disk *Disk) *DiskServiceUpdateRequest {
	p.disk = disk
	return p
}

func (p *DiskServiceUpdateRequest) Send() (*DiskServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.DiskService.connection.URL(), p.DiskService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.DiskService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.DiskService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.DiskService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.DiskService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.DiskService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &DiskServiceUpdateResponse{disk: result}, nil
}

func (p *DiskServiceUpdateRequest) MustSend() *DiskServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Updates the parameters of the specified disk.
// This operation allows updating the following floating disk properties:
// * For Image disks: `provisioned_size`, `alias`, `description`, `wipe_after_delete`, `shareable`, `backup` and `disk_profile`.
// * For LUN disks: `alias`, `description` and `shareable`.
// * For Cinder and Managed Block disks: `provisioned_size`, `alias` and `description`.
// * For VM attached disks, the `qcow_version` can also be updated.
// For example, a disk's update can be done by using the following request:
// [source]
// ----
// PUT /ovirt-engine/api/disks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <disk>
//   <qcow_version>qcow2_v3</qcow_version>
//   <alias>new-alias</alias>
//   <description>new-desc</description>
// </disk>
// ----
// Since the backend operation is asynchronous, the disk element that is returned
// to the user might not be synced with the changed properties.
//
type DiskServiceUpdateResponse struct {
	disk *Disk
}

func (p *DiskServiceUpdateResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *DiskServiceUpdateResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Updates the parameters of the specified disk.
// This operation allows updating the following floating disk properties:
// * For Image disks: `provisioned_size`, `alias`, `description`, `wipe_after_delete`, `shareable`, `backup` and `disk_profile`.
// * For LUN disks: `alias`, `description` and `shareable`.
// * For Cinder and Managed Block disks: `provisioned_size`, `alias` and `description`.
// * For VM attached disks, the `qcow_version` can also be updated.
// For example, a disk's update can be done by using the following request:
// [source]
// ----
// PUT /ovirt-engine/api/disks/123
// ----
// With a request body like this:
// [source,xml]
// ----
// <disk>
//   <qcow_version>qcow2_v3</qcow_version>
//   <alias>new-alias</alias>
//   <description>new-desc</description>
// </disk>
// ----
// Since the backend operation is asynchronous, the disk element that is returned
// to the user might not be synced with the changed properties.
//
func (p *DiskService) Update() *DiskServiceUpdateRequest {
	return &DiskServiceUpdateRequest{DiskService: p}
}

//
// Reference to the service that manages the permissions assigned to the disk.
//
func (op *DiskService) PermissionsService() *AssignedPermissionsService {
	return NewAssignedPermissionsService(op.connection, fmt.Sprintf("%s/permissions", op.path))
}

//
//
func (op *DiskService) StatisticsService() *StatisticsService {
	return NewStatisticsService(op.connection, fmt.Sprintf("%s/statistics", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *DiskService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "permissions" {
		return op.PermissionsService(), nil
	}
	if strings.HasPrefix(path, "permissions/") {
		return op.PermissionsService().Service(path[12:])
	}
	if path == "statistics" {
		return op.StatisticsService(), nil
	}
	if strings.HasPrefix(path, "statistics/") {
		return op.StatisticsService().Service(path[11:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *DiskService) String() string {
	return fmt.Sprintf("DiskService:%s", op.path)
}

//
// Provides capability to manage external providers.
//
type ExternalProviderService struct {
	BaseService
}

func NewExternalProviderService(connection *Connection, path string) *ExternalProviderService {
	var result ExternalProviderService
	result.connection = connection
	result.path = path
	return &result
}

//
// Import the SSL certificates of the external host provider.
//
type ExternalProviderServiceImportCertificatesRequest struct {
	ExternalProviderService *ExternalProviderService
	header                  map[string]string
	query                   map[string]string
	certificates            *CertificateSlice
}

func (p *ExternalProviderServiceImportCertificatesRequest) Header(key, value string) *ExternalProviderServiceImportCertificatesRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderServiceImportCertificatesRequest) Query(key, value string) *ExternalProviderServiceImportCertificatesRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderServiceImportCertificatesRequest) Certificates(certificates *CertificateSlice) *ExternalProviderServiceImportCertificatesRequest {
	p.certificates = certificates
	return p
}

func (p *ExternalProviderServiceImportCertificatesRequest) CertificatesOfAny(anys ...*Certificate) *ExternalProviderServiceImportCertificatesRequest {
	if p.certificates == nil {
		p.certificates = new(CertificateSlice)
	}
	p.certificates.slice = append(p.certificates.slice, anys...)
	return p
}

func (p *ExternalProviderServiceImportCertificatesRequest) Send() (*ExternalProviderServiceImportCertificatesResponse, error) {
	rawURL := fmt.Sprintf("%s%s/importcertificates", p.ExternalProviderService.connection.URL(), p.ExternalProviderService.path)
	actionBuilder := NewActionBuilder()
	actionBuilder.Certificates(p.certificates)
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ExternalProviderServiceImportCertificatesResponse), nil
}

func (p *ExternalProviderServiceImportCertificatesRequest) MustSend() *ExternalProviderServiceImportCertificatesResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Import the SSL certificates of the external host provider.
//
type ExternalProviderServiceImportCertificatesResponse struct {
}

//
// Import the SSL certificates of the external host provider.
//
func (p *ExternalProviderService) ImportCertificates() *ExternalProviderServiceImportCertificatesRequest {
	return &ExternalProviderServiceImportCertificatesRequest{ExternalProviderService: p}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type ExternalProviderServiceTestConnectivityRequest struct {
	ExternalProviderService *ExternalProviderService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *ExternalProviderServiceTestConnectivityRequest) Header(key, value string) *ExternalProviderServiceTestConnectivityRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *ExternalProviderServiceTestConnectivityRequest) Query(key, value string) *ExternalProviderServiceTestConnectivityRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *ExternalProviderServiceTestConnectivityRequest) Async(async bool) *ExternalProviderServiceTestConnectivityRequest {
	p.async = &async
	return p
}

func (p *ExternalProviderServiceTestConnectivityRequest) Send() (*ExternalProviderServiceTestConnectivityResponse, error) {
	rawURL := fmt.Sprintf("%s%s/testconnectivity", p.ExternalProviderService.connection.URL(), p.ExternalProviderService.path)
	actionBuilder := NewActionBuilder()
	if p.async != nil {
		actionBuilder.Async(*p.async)
	}
	action, err := actionBuilder.Build()
	if err != nil {
		return nil, err
	}
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err = XMLActionWriteOne(writer, action, "")
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.ExternalProviderService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.ExternalProviderService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.ExternalProviderService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.ExternalProviderService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.ExternalProviderService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	_, errCheckAction := CheckAction(resp)
	if errCheckAction != nil {
		return nil, errCheckAction
	}
	return new(ExternalProviderServiceTestConnectivityResponse), nil
}

func (p *ExternalProviderServiceTestConnectivityRequest) MustSend() *ExternalProviderServiceTestConnectivityResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
type ExternalProviderServiceTestConnectivityResponse struct {
}

//
// In order to test connectivity for external provider we need
// to run following request where 123 is an id of a provider.
// [source]
// ----
// POST /ovirt-engine/api/externalhostproviders/123/testconnectivity
// ----
//
func (p *ExternalProviderService) TestConnectivity() *ExternalProviderServiceTestConnectivityRequest {
	return &ExternalProviderServiceTestConnectivityRequest{ExternalProviderService: p}
}

//
// A service to view certificates for this external provider.
//
func (op *ExternalProviderService) CertificatesService() *ExternalProviderCertificatesService {
	return NewExternalProviderCertificatesService(op.connection, fmt.Sprintf("%s/certificates", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *ExternalProviderService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "certificates" {
		return op.CertificatesService(), nil
	}
	if strings.HasPrefix(path, "certificates/") {
		return op.CertificatesService().Service(path[13:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *ExternalProviderService) String() string {
	return fmt.Sprintf("ExternalProviderService:%s", op.path)
}

//
// Manages the collection of disks available inside an storage domain that is attached to a data center.
//
type AttachedStorageDomainDisksService struct {
	BaseService
}

func NewAttachedStorageDomainDisksService(connection *Connection, path string) *AttachedStorageDomainDisksService {
	var result AttachedStorageDomainDisksService
	result.connection = connection
	result.path = path
	return &result
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
type AttachedStorageDomainDisksServiceAddRequest struct {
	AttachedStorageDomainDisksService *AttachedStorageDomainDisksService
	header                            map[string]string
	query                             map[string]string
	disk                              *Disk
	unregistered                      *bool
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Header(key, value string) *AttachedStorageDomainDisksServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Query(key, value string) *AttachedStorageDomainDisksServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Disk(disk *Disk) *AttachedStorageDomainDisksServiceAddRequest {
	p.disk = disk
	return p
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Unregistered(unregistered bool) *AttachedStorageDomainDisksServiceAddRequest {
	p.unregistered = &unregistered
	return p
}

func (p *AttachedStorageDomainDisksServiceAddRequest) Send() (*AttachedStorageDomainDisksServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainDisksService.connection.URL(), p.AttachedStorageDomainDisksService.path)
	values := make(url.Values)
	if p.unregistered != nil {
		values["unregistered"] = []string{fmt.Sprintf("%v", *p.unregistered)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLDiskWriteOne(writer, p.disk, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &AttachedStorageDomainDisksServiceAddResponse{disk: result}, nil
}

func (p *AttachedStorageDomainDisksServiceAddRequest) MustSend() *AttachedStorageDomainDisksServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
type AttachedStorageDomainDisksServiceAddResponse struct {
	disk *Disk
}

func (p *AttachedStorageDomainDisksServiceAddResponse) Disk() (*Disk, bool) {
	if p.disk != nil {
		return p.disk, true
	}
	return nil, false
}

func (p *AttachedStorageDomainDisksServiceAddResponse) MustDisk() *Disk {
	if p.disk == nil {
		panic("disk in response does not exist")
	}
	return p.disk
}

//
// Adds or registers a disk.
// IMPORTANT: Since version 4.2 of the engine this operation is deprecated, and preserved only for backwards
// compatibility. It will be removed in the future. To add a new disk use the <<services/disks/methods/add, add>>
// operation of the service that manages the disks of the system. To register an unregistered disk use the
// <<services/attached_storage_domain_disk/methods/register, register>> operation of the service that manages
// that disk.
//
func (p *AttachedStorageDomainDisksService) Add() *AttachedStorageDomainDisksServiceAddRequest {
	return &AttachedStorageDomainDisksServiceAddRequest{AttachedStorageDomainDisksService: p}
}

//
// Retrieve the list of disks that are available in the storage domain.
//
type AttachedStorageDomainDisksServiceListRequest struct {
	AttachedStorageDomainDisksService *AttachedStorageDomainDisksService
	header                            map[string]string
	query                             map[string]string
	follow                            *string
	max                               *int64
}

func (p *AttachedStorageDomainDisksServiceListRequest) Header(key, value string) *AttachedStorageDomainDisksServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceListRequest) Query(key, value string) *AttachedStorageDomainDisksServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *AttachedStorageDomainDisksServiceListRequest) Follow(follow string) *AttachedStorageDomainDisksServiceListRequest {
	p.follow = &follow
	return p
}

func (p *AttachedStorageDomainDisksServiceListRequest) Max(max int64) *AttachedStorageDomainDisksServiceListRequest {
	p.max = &max
	return p
}

func (p *AttachedStorageDomainDisksServiceListRequest) Send() (*AttachedStorageDomainDisksServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.AttachedStorageDomainDisksService.connection.URL(), p.AttachedStorageDomainDisksService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.AttachedStorageDomainDisksService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.AttachedStorageDomainDisksService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.AttachedStorageDomainDisksService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.AttachedStorageDomainDisksService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.AttachedStorageDomainDisksService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLDiskReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &AttachedStorageDomainDisksServiceListResponse{disks: result}, nil
}

func (p *AttachedStorageDomainDisksServiceListRequest) MustSend() *AttachedStorageDomainDisksServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieve the list of disks that are available in the storage domain.
//
type AttachedStorageDomainDisksServiceListResponse struct {
	disks *DiskSlice
}

func (p *AttachedStorageDomainDisksServiceListResponse) Disks() (*DiskSlice, bool) {
	if p.disks != nil {
		return p.disks, true
	}
	return nil, false
}

func (p *AttachedStorageDomainDisksServiceListResponse) MustDisks() *DiskSlice {
	if p.disks == nil {
		panic("disks in response does not exist")
	}
	return p.disks
}

//
// Retrieve the list of disks that are available in the storage domain.
//
func (p *AttachedStorageDomainDisksService) List() *AttachedStorageDomainDisksServiceListRequest {
	return &AttachedStorageDomainDisksServiceListRequest{AttachedStorageDomainDisksService: p}
}

//
// Reference to the service that manages a specific disk.
//
func (op *AttachedStorageDomainDisksService) DiskService(id string) *AttachedStorageDomainDiskService {
	return NewAttachedStorageDomainDiskService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AttachedStorageDomainDisksService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.DiskService(path), nil
	}
	return op.DiskService(path[:index]).Service(path[index+1:])
}

func (op *AttachedStorageDomainDisksService) String() string {
	return fmt.Sprintf("AttachedStorageDomainDisksService:%s", op.path)
}

//
//
type InstanceTypeNicsService struct {
	BaseService
}

func NewInstanceTypeNicsService(connection *Connection, path string) *InstanceTypeNicsService {
	var result InstanceTypeNicsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add new network interface to the instance type.
//
type InstanceTypeNicsServiceAddRequest struct {
	InstanceTypeNicsService *InstanceTypeNicsService
	header                  map[string]string
	query                   map[string]string
	nic                     *Nic
}

func (p *InstanceTypeNicsServiceAddRequest) Header(key, value string) *InstanceTypeNicsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicsServiceAddRequest) Query(key, value string) *InstanceTypeNicsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicsServiceAddRequest) Nic(nic *Nic) *InstanceTypeNicsServiceAddRequest {
	p.nic = nic
	return p
}

func (p *InstanceTypeNicsServiceAddRequest) Send() (*InstanceTypeNicsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeNicsService.connection.URL(), p.InstanceTypeNicsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLNicWriteOne(writer, p.nic, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeNicsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeNicsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeNicsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &InstanceTypeNicsServiceAddResponse{nic: result}, nil
}

func (p *InstanceTypeNicsServiceAddRequest) MustSend() *InstanceTypeNicsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add new network interface to the instance type.
//
type InstanceTypeNicsServiceAddResponse struct {
	nic *Nic
}

func (p *InstanceTypeNicsServiceAddResponse) Nic() (*Nic, bool) {
	if p.nic != nil {
		return p.nic, true
	}
	return nil, false
}

func (p *InstanceTypeNicsServiceAddResponse) MustNic() *Nic {
	if p.nic == nil {
		panic("nic in response does not exist")
	}
	return p.nic
}

//
// Add new network interface to the instance type.
//
func (p *InstanceTypeNicsService) Add() *InstanceTypeNicsServiceAddRequest {
	return &InstanceTypeNicsServiceAddRequest{InstanceTypeNicsService: p}
}

//
// Lists all the configured network interface of the instance type.
// The order of the returned list of network interfaces isn't guaranteed.
//
type InstanceTypeNicsServiceListRequest struct {
	InstanceTypeNicsService *InstanceTypeNicsService
	header                  map[string]string
	query                   map[string]string
	follow                  *string
	max                     *int64
	search                  *string
}

func (p *InstanceTypeNicsServiceListRequest) Header(key, value string) *InstanceTypeNicsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Query(key, value string) *InstanceTypeNicsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Follow(follow string) *InstanceTypeNicsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Max(max int64) *InstanceTypeNicsServiceListRequest {
	p.max = &max
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Search(search string) *InstanceTypeNicsServiceListRequest {
	p.search = &search
	return p
}

func (p *InstanceTypeNicsServiceListRequest) Send() (*InstanceTypeNicsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.InstanceTypeNicsService.connection.URL(), p.InstanceTypeNicsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.search != nil {
		values["search"] = []string{fmt.Sprintf("%v", *p.search)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.InstanceTypeNicsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.InstanceTypeNicsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.InstanceTypeNicsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.InstanceTypeNicsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.InstanceTypeNicsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLNicReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &InstanceTypeNicsServiceListResponse{nics: result}, nil
}

func (p *InstanceTypeNicsServiceListRequest) MustSend() *InstanceTypeNicsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Lists all the configured network interface of the instance type.
// The order of the returned list of network interfaces isn't guaranteed.
//
type InstanceTypeNicsServiceListResponse struct {
	nics *NicSlice
}

func (p *InstanceTypeNicsServiceListResponse) Nics() (*NicSlice, bool) {
	if p.nics != nil {
		return p.nics, true
	}
	return nil, false
}

func (p *InstanceTypeNicsServiceListResponse) MustNics() *NicSlice {
	if p.nics == nil {
		panic("nics in response does not exist")
	}
	return p.nics
}

//
// Lists all the configured network interface of the instance type.
// The order of the returned list of network interfaces isn't guaranteed.
//
func (p *InstanceTypeNicsService) List() *InstanceTypeNicsServiceListRequest {
	return &InstanceTypeNicsServiceListRequest{InstanceTypeNicsService: p}
}

//
//
func (op *InstanceTypeNicsService) NicService(id string) *InstanceTypeNicService {
	return NewInstanceTypeNicService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *InstanceTypeNicsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.NicService(path), nil
	}
	return op.NicService(path[:index]).Service(path[index+1:])
}

func (op *InstanceTypeNicsService) String() string {
	return fmt.Sprintf("InstanceTypeNicsService:%s", op.path)
}

//
//
type SchedulingPolicyService struct {
	BaseService
}

func NewSchedulingPolicyService(connection *Connection, path string) *SchedulingPolicyService {
	var result SchedulingPolicyService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type SchedulingPolicyServiceGetRequest struct {
	SchedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	filter                  *bool
	follow                  *string
}

func (p *SchedulingPolicyServiceGetRequest) Header(key, value string) *SchedulingPolicyServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceGetRequest) Query(key, value string) *SchedulingPolicyServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceGetRequest) Filter(filter bool) *SchedulingPolicyServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *SchedulingPolicyServiceGetRequest) Follow(follow string) *SchedulingPolicyServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *SchedulingPolicyServiceGetRequest) Send() (*SchedulingPolicyServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SchedulingPolicyService.connection.URL(), p.SchedulingPolicyService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SchedulingPolicyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SchedulingPolicyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SchedulingPolicyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SchedulingPolicyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SchedulingPolicyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SchedulingPolicyServiceGetResponse{policy: result}, nil
}

func (p *SchedulingPolicyServiceGetRequest) MustSend() *SchedulingPolicyServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SchedulingPolicyServiceGetResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPolicyServiceGetResponse) Policy() (*SchedulingPolicy, bool) {
	if p.policy != nil {
		return p.policy, true
	}
	return nil, false
}

func (p *SchedulingPolicyServiceGetResponse) MustPolicy() *SchedulingPolicy {
	if p.policy == nil {
		panic("policy in response does not exist")
	}
	return p.policy
}

//
//
func (p *SchedulingPolicyService) Get() *SchedulingPolicyServiceGetRequest {
	return &SchedulingPolicyServiceGetRequest{SchedulingPolicyService: p}
}

//
//
type SchedulingPolicyServiceRemoveRequest struct {
	SchedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
}

func (p *SchedulingPolicyServiceRemoveRequest) Header(key, value string) *SchedulingPolicyServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceRemoveRequest) Query(key, value string) *SchedulingPolicyServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceRemoveRequest) Async(async bool) *SchedulingPolicyServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *SchedulingPolicyServiceRemoveRequest) Send() (*SchedulingPolicyServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SchedulingPolicyService.connection.URL(), p.SchedulingPolicyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SchedulingPolicyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SchedulingPolicyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SchedulingPolicyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SchedulingPolicyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SchedulingPolicyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(SchedulingPolicyServiceRemoveResponse), nil
}

func (p *SchedulingPolicyServiceRemoveRequest) MustSend() *SchedulingPolicyServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type SchedulingPolicyServiceRemoveResponse struct {
}

//
//
func (p *SchedulingPolicyService) Remove() *SchedulingPolicyServiceRemoveRequest {
	return &SchedulingPolicyServiceRemoveRequest{SchedulingPolicyService: p}
}

//
// Update the specified user defined scheduling policy in the system.
//
type SchedulingPolicyServiceUpdateRequest struct {
	SchedulingPolicyService *SchedulingPolicyService
	header                  map[string]string
	query                   map[string]string
	async                   *bool
	policy                  *SchedulingPolicy
}

func (p *SchedulingPolicyServiceUpdateRequest) Header(key, value string) *SchedulingPolicyServiceUpdateRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *SchedulingPolicyServiceUpdateRequest) Query(key, value string) *SchedulingPolicyServiceUpdateRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *SchedulingPolicyServiceUpdateRequest) Async(async bool) *SchedulingPolicyServiceUpdateRequest {
	p.async = &async
	return p
}

func (p *SchedulingPolicyServiceUpdateRequest) Policy(policy *SchedulingPolicy) *SchedulingPolicyServiceUpdateRequest {
	p.policy = policy
	return p
}

func (p *SchedulingPolicyServiceUpdateRequest) Send() (*SchedulingPolicyServiceUpdateResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.SchedulingPolicyService.connection.URL(), p.SchedulingPolicyService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLSchedulingPolicyWriteOne(writer, p.policy, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("PUT", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.SchedulingPolicyService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.SchedulingPolicyService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.SchedulingPolicyService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.SchedulingPolicyService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.SchedulingPolicyService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLSchedulingPolicyReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &SchedulingPolicyServiceUpdateResponse{policy: result}, nil
}

func (p *SchedulingPolicyServiceUpdateRequest) MustSend() *SchedulingPolicyServiceUpdateResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Update the specified user defined scheduling policy in the system.
//
type SchedulingPolicyServiceUpdateResponse struct {
	policy *SchedulingPolicy
}

func (p *SchedulingPolicyServiceUpdateResponse) Policy() (*SchedulingPolicy, bool) {
	if p.policy != nil {
		return p.policy, true
	}
	return nil, false
}

func (p *SchedulingPolicyServiceUpdateResponse) MustPolicy() *SchedulingPolicy {
	if p.policy == nil {
		panic("policy in response does not exist")
	}
	return p.policy
}

//
// Update the specified user defined scheduling policy in the system.
//
func (p *SchedulingPolicyService) Update() *SchedulingPolicyServiceUpdateRequest {
	return &SchedulingPolicyServiceUpdateRequest{SchedulingPolicyService: p}
}

//
//
func (op *SchedulingPolicyService) BalancesService() *BalancesService {
	return NewBalancesService(op.connection, fmt.Sprintf("%s/balances", op.path))
}

//
//
func (op *SchedulingPolicyService) FiltersService() *FiltersService {
	return NewFiltersService(op.connection, fmt.Sprintf("%s/filters", op.path))
}

//
//
func (op *SchedulingPolicyService) WeightsService() *WeightsService {
	return NewWeightsService(op.connection, fmt.Sprintf("%s/weights", op.path))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *SchedulingPolicyService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	if path == "balances" {
		return op.BalancesService(), nil
	}
	if strings.HasPrefix(path, "balances/") {
		return op.BalancesService().Service(path[9:])
	}
	if path == "filters" {
		return op.FiltersService(), nil
	}
	if strings.HasPrefix(path, "filters/") {
		return op.FiltersService().Service(path[8:])
	}
	if path == "weights" {
		return op.WeightsService(), nil
	}
	if strings.HasPrefix(path, "weights/") {
		return op.WeightsService().Service(path[8:])
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *SchedulingPolicyService) String() string {
	return fmt.Sprintf("SchedulingPolicyService:%s", op.path)
}

//
//
type StatisticsService struct {
	BaseService
}

func NewStatisticsService(connection *Connection, path string) *StatisticsService {
	var result StatisticsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Retrieves a list of statistics.
// For example, to retrieve the statistics for virtual machine `123` send a
// request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics
// ----
// The result will be like this:
// [source,xml]
// ----
// <statistics>
//   <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//     <name>memory.installed</name>
//     <description>Total memory configured</description>
//     <kind>gauge</kind>
//     <type>integer</type>
//     <unit>bytes</unit>
//     <values>
//       <value>
//         <datum>1073741824</datum>
//       </value>
//     </values>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </statistic>
//   ...
// </statistics>
// ----
// Just a single part of the statistics can be retrieved by specifying its id at the end of the URI. That means:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics/456
// ----
// Outputs:
// [source,xml]
// ----
// <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//   <name>memory.installed</name>
//   <description>Total memory configured</description>
//   <kind>gauge</kind>
//   <type>integer</type>
//   <unit>bytes</unit>
//   <values>
//     <value>
//       <datum>1073741824</datum>
//     </value>
//   </values>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </statistic>
// ----
// The order of the returned list of statistics isn't guaranteed.
//
type StatisticsServiceListRequest struct {
	StatisticsService *StatisticsService
	header            map[string]string
	query             map[string]string
	follow            *string
	max               *int64
}

func (p *StatisticsServiceListRequest) Header(key, value string) *StatisticsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *StatisticsServiceListRequest) Query(key, value string) *StatisticsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *StatisticsServiceListRequest) Follow(follow string) *StatisticsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *StatisticsServiceListRequest) Max(max int64) *StatisticsServiceListRequest {
	p.max = &max
	return p
}

func (p *StatisticsServiceListRequest) Send() (*StatisticsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.StatisticsService.connection.URL(), p.StatisticsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.StatisticsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.StatisticsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.StatisticsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.StatisticsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.StatisticsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLStatisticReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &StatisticsServiceListResponse{statistics: result}, nil
}

func (p *StatisticsServiceListRequest) MustSend() *StatisticsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Retrieves a list of statistics.
// For example, to retrieve the statistics for virtual machine `123` send a
// request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics
// ----
// The result will be like this:
// [source,xml]
// ----
// <statistics>
//   <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//     <name>memory.installed</name>
//     <description>Total memory configured</description>
//     <kind>gauge</kind>
//     <type>integer</type>
//     <unit>bytes</unit>
//     <values>
//       <value>
//         <datum>1073741824</datum>
//       </value>
//     </values>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </statistic>
//   ...
// </statistics>
// ----
// Just a single part of the statistics can be retrieved by specifying its id at the end of the URI. That means:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics/456
// ----
// Outputs:
// [source,xml]
// ----
// <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//   <name>memory.installed</name>
//   <description>Total memory configured</description>
//   <kind>gauge</kind>
//   <type>integer</type>
//   <unit>bytes</unit>
//   <values>
//     <value>
//       <datum>1073741824</datum>
//     </value>
//   </values>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </statistic>
// ----
// The order of the returned list of statistics isn't guaranteed.
//
type StatisticsServiceListResponse struct {
	statistics *StatisticSlice
}

func (p *StatisticsServiceListResponse) Statistics() (*StatisticSlice, bool) {
	if p.statistics != nil {
		return p.statistics, true
	}
	return nil, false
}

func (p *StatisticsServiceListResponse) MustStatistics() *StatisticSlice {
	if p.statistics == nil {
		panic("statistics in response does not exist")
	}
	return p.statistics
}

//
// Retrieves a list of statistics.
// For example, to retrieve the statistics for virtual machine `123` send a
// request like this:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics
// ----
// The result will be like this:
// [source,xml]
// ----
// <statistics>
//   <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//     <name>memory.installed</name>
//     <description>Total memory configured</description>
//     <kind>gauge</kind>
//     <type>integer</type>
//     <unit>bytes</unit>
//     <values>
//       <value>
//         <datum>1073741824</datum>
//       </value>
//     </values>
//     <vm href="/ovirt-engine/api/vms/123" id="123"/>
//   </statistic>
//   ...
// </statistics>
// ----
// Just a single part of the statistics can be retrieved by specifying its id at the end of the URI. That means:
// [source]
// ----
// GET /ovirt-engine/api/vms/123/statistics/456
// ----
// Outputs:
// [source,xml]
// ----
// <statistic href="/ovirt-engine/api/vms/123/statistics/456" id="456">
//   <name>memory.installed</name>
//   <description>Total memory configured</description>
//   <kind>gauge</kind>
//   <type>integer</type>
//   <unit>bytes</unit>
//   <values>
//     <value>
//       <datum>1073741824</datum>
//     </value>
//   </values>
//   <vm href="/ovirt-engine/api/vms/123" id="123"/>
// </statistic>
// ----
// The order of the returned list of statistics isn't guaranteed.
//
func (p *StatisticsService) List() *StatisticsServiceListRequest {
	return &StatisticsServiceListRequest{StatisticsService: p}
}

//
//
func (op *StatisticsService) StatisticService(id string) *StatisticService {
	return NewStatisticService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *StatisticsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.StatisticService(path), nil
	}
	return op.StatisticService(path[:index]).Service(path[index+1:])
}

func (op *StatisticsService) String() string {
	return fmt.Sprintf("StatisticsService:%s", op.path)
}

//
// Manages the filters used by an scheduling policy.
//
type FiltersService struct {
	BaseService
}

func NewFiltersService(connection *Connection, path string) *FiltersService {
	var result FiltersService
	result.connection = connection
	result.path = path
	return &result
}

//
// Add a filter to a specified user defined scheduling policy.
//
type FiltersServiceAddRequest struct {
	FiltersService *FiltersService
	header         map[string]string
	query          map[string]string
	filter         *Filter
}

func (p *FiltersServiceAddRequest) Header(key, value string) *FiltersServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FiltersServiceAddRequest) Query(key, value string) *FiltersServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FiltersServiceAddRequest) Filter(filter *Filter) *FiltersServiceAddRequest {
	p.filter = filter
	return p
}

func (p *FiltersServiceAddRequest) Send() (*FiltersServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FiltersService.connection.URL(), p.FiltersService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLFilterWriteOne(writer, p.filter, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FiltersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FiltersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FiltersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FiltersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FiltersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &FiltersServiceAddResponse{filter: result}, nil
}

func (p *FiltersServiceAddRequest) MustSend() *FiltersServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Add a filter to a specified user defined scheduling policy.
//
type FiltersServiceAddResponse struct {
	filter *Filter
}

func (p *FiltersServiceAddResponse) Filter() (*Filter, bool) {
	if p.filter != nil {
		return p.filter, true
	}
	return nil, false
}

func (p *FiltersServiceAddResponse) MustFilter() *Filter {
	if p.filter == nil {
		panic("filter in response does not exist")
	}
	return p.filter
}

//
// Add a filter to a specified user defined scheduling policy.
//
func (p *FiltersService) Add() *FiltersServiceAddRequest {
	return &FiltersServiceAddRequest{FiltersService: p}
}

//
// Returns the list of filters used by the scheduling policy.
// The order of the returned list of filters isn't guaranteed.
//
type FiltersServiceListRequest struct {
	FiltersService *FiltersService
	header         map[string]string
	query          map[string]string
	filter         *bool
	follow         *string
	max            *int64
}

func (p *FiltersServiceListRequest) Header(key, value string) *FiltersServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *FiltersServiceListRequest) Query(key, value string) *FiltersServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *FiltersServiceListRequest) Filter(filter bool) *FiltersServiceListRequest {
	p.filter = &filter
	return p
}

func (p *FiltersServiceListRequest) Follow(follow string) *FiltersServiceListRequest {
	p.follow = &follow
	return p
}

func (p *FiltersServiceListRequest) Max(max int64) *FiltersServiceListRequest {
	p.max = &max
	return p
}

func (p *FiltersServiceListRequest) Send() (*FiltersServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.FiltersService.connection.URL(), p.FiltersService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.FiltersService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.FiltersService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.FiltersService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.FiltersService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.FiltersService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLFilterReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &FiltersServiceListResponse{filters: result}, nil
}

func (p *FiltersServiceListRequest) MustSend() *FiltersServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of filters used by the scheduling policy.
// The order of the returned list of filters isn't guaranteed.
//
type FiltersServiceListResponse struct {
	filters *FilterSlice
}

func (p *FiltersServiceListResponse) Filters() (*FilterSlice, bool) {
	if p.filters != nil {
		return p.filters, true
	}
	return nil, false
}

func (p *FiltersServiceListResponse) MustFilters() *FilterSlice {
	if p.filters == nil {
		panic("filters in response does not exist")
	}
	return p.filters
}

//
// Returns the list of filters used by the scheduling policy.
// The order of the returned list of filters isn't guaranteed.
//
func (p *FiltersService) List() *FiltersServiceListRequest {
	return &FiltersServiceListRequest{FiltersService: p}
}

//
//
func (op *FiltersService) FilterService(id string) *FilterService {
	return NewFilterService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FiltersService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.FilterService(path), nil
	}
	return op.FilterService(path[:index]).Service(path[index+1:])
}

func (op *FiltersService) String() string {
	return fmt.Sprintf("FiltersService:%s", op.path)
}

//
//
type IscsiBondsService struct {
	BaseService
}

func NewIscsiBondsService(connection *Connection, path string) *IscsiBondsService {
	var result IscsiBondsService
	result.connection = connection
	result.path = path
	return &result
}

//
// Create a new iSCSI bond on a data center.
// For example, to create a new iSCSI bond on data center `123` using storage connections `456` and `789`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/iscsibonds
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//   <name>mybond</name>
//   <storage_connections>
//     <storage_connection id="456"/>
//     <storage_connection id="789"/>
//   </storage_connections>
//   <networks>
//     <network id="abc"/>
//   </networks>
// </iscsi_bond>
// ----
//
type IscsiBondsServiceAddRequest struct {
	IscsiBondsService *IscsiBondsService
	header            map[string]string
	query             map[string]string
	bond              *IscsiBond
}

func (p *IscsiBondsServiceAddRequest) Header(key, value string) *IscsiBondsServiceAddRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondsServiceAddRequest) Query(key, value string) *IscsiBondsServiceAddRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondsServiceAddRequest) Bond(bond *IscsiBond) *IscsiBondsServiceAddRequest {
	p.bond = bond
	return p
}

func (p *IscsiBondsServiceAddRequest) Send() (*IscsiBondsServiceAddResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.IscsiBondsService.connection.URL(), p.IscsiBondsService.path)
	values := make(url.Values)
	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	var body bytes.Buffer
	writer := NewXMLWriter(&body)
	err := XMLIscsiBondWriteOne(writer, p.bond, "")
	if err != nil {
		return nil, err
	}
	writer.Flush()
	req, err := http.NewRequest("POST", rawURL, &body)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.IscsiBondsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.IscsiBondsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.IscsiBondsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.IscsiBondsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.IscsiBondsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200, 201, 202}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &IscsiBondsServiceAddResponse{bond: result}, nil
}

func (p *IscsiBondsServiceAddRequest) MustSend() *IscsiBondsServiceAddResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Create a new iSCSI bond on a data center.
// For example, to create a new iSCSI bond on data center `123` using storage connections `456` and `789`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/iscsibonds
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//   <name>mybond</name>
//   <storage_connections>
//     <storage_connection id="456"/>
//     <storage_connection id="789"/>
//   </storage_connections>
//   <networks>
//     <network id="abc"/>
//   </networks>
// </iscsi_bond>
// ----
//
type IscsiBondsServiceAddResponse struct {
	bond *IscsiBond
}

func (p *IscsiBondsServiceAddResponse) Bond() (*IscsiBond, bool) {
	if p.bond != nil {
		return p.bond, true
	}
	return nil, false
}

func (p *IscsiBondsServiceAddResponse) MustBond() *IscsiBond {
	if p.bond == nil {
		panic("bond in response does not exist")
	}
	return p.bond
}

//
// Create a new iSCSI bond on a data center.
// For example, to create a new iSCSI bond on data center `123` using storage connections `456` and `789`, send a
// request like this:
// [source]
// ----
// POST /ovirt-engine/api/datacenters/123/iscsibonds
// ----
// The request body should look like this:
// [source,xml]
// ----
// <iscsi_bond>
//   <name>mybond</name>
//   <storage_connections>
//     <storage_connection id="456"/>
//     <storage_connection id="789"/>
//   </storage_connections>
//   <networks>
//     <network id="abc"/>
//   </networks>
// </iscsi_bond>
// ----
//
func (p *IscsiBondsService) Add() *IscsiBondsServiceAddRequest {
	return &IscsiBondsServiceAddRequest{IscsiBondsService: p}
}

//
// Returns the list of iSCSI bonds configured in the data center.
// The order of the returned list of iSCSI bonds isn't guaranteed.
//
type IscsiBondsServiceListRequest struct {
	IscsiBondsService *IscsiBondsService
	header            map[string]string
	query             map[string]string
	follow            *string
	max               *int64
}

func (p *IscsiBondsServiceListRequest) Header(key, value string) *IscsiBondsServiceListRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *IscsiBondsServiceListRequest) Query(key, value string) *IscsiBondsServiceListRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *IscsiBondsServiceListRequest) Follow(follow string) *IscsiBondsServiceListRequest {
	p.follow = &follow
	return p
}

func (p *IscsiBondsServiceListRequest) Max(max int64) *IscsiBondsServiceListRequest {
	p.max = &max
	return p
}

func (p *IscsiBondsServiceListRequest) Send() (*IscsiBondsServiceListResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.IscsiBondsService.connection.URL(), p.IscsiBondsService.path)
	values := make(url.Values)
	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.max != nil {
		values["max"] = []string{fmt.Sprintf("%v", *p.max)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.IscsiBondsService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.IscsiBondsService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.IscsiBondsService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.IscsiBondsService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.IscsiBondsService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLIscsiBondReadMany(reader, nil)
	if err != nil {
		return nil, err
	}
	return &IscsiBondsServiceListResponse{bonds: result}, nil
}

func (p *IscsiBondsServiceListRequest) MustSend() *IscsiBondsServiceListResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
// Returns the list of iSCSI bonds configured in the data center.
// The order of the returned list of iSCSI bonds isn't guaranteed.
//
type IscsiBondsServiceListResponse struct {
	bonds *IscsiBondSlice
}

func (p *IscsiBondsServiceListResponse) Bonds() (*IscsiBondSlice, bool) {
	if p.bonds != nil {
		return p.bonds, true
	}
	return nil, false
}

func (p *IscsiBondsServiceListResponse) MustBonds() *IscsiBondSlice {
	if p.bonds == nil {
		panic("bonds in response does not exist")
	}
	return p.bonds
}

//
// Returns the list of iSCSI bonds configured in the data center.
// The order of the returned list of iSCSI bonds isn't guaranteed.
//
func (p *IscsiBondsService) List() *IscsiBondsServiceListRequest {
	return &IscsiBondsServiceListRequest{IscsiBondsService: p}
}

//
//
func (op *IscsiBondsService) IscsiBondService(id string) *IscsiBondService {
	return NewIscsiBondService(op.connection, fmt.Sprintf("%s/%s", op.path, id))
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *IscsiBondsService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	index := strings.Index(path, "/")
	if index == -1 {
		return op.IscsiBondService(path), nil
	}
	return op.IscsiBondService(path[:index]).Service(path[index+1:])
}

func (op *IscsiBondsService) String() string {
	return fmt.Sprintf("IscsiBondsService:%s", op.path)
}

//
//
type WeightService struct {
	BaseService
}

func NewWeightService(connection *Connection, path string) *WeightService {
	var result WeightService
	result.connection = connection
	result.path = path
	return &result
}

//
//
type WeightServiceGetRequest struct {
	WeightService *WeightService
	header        map[string]string
	query         map[string]string
	filter        *bool
	follow        *string
}

func (p *WeightServiceGetRequest) Header(key, value string) *WeightServiceGetRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightServiceGetRequest) Query(key, value string) *WeightServiceGetRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightServiceGetRequest) Filter(filter bool) *WeightServiceGetRequest {
	p.filter = &filter
	return p
}

func (p *WeightServiceGetRequest) Follow(follow string) *WeightServiceGetRequest {
	p.follow = &follow
	return p
}

func (p *WeightServiceGetRequest) Send() (*WeightServiceGetResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.WeightService.connection.URL(), p.WeightService.path)
	values := make(url.Values)
	if p.filter != nil {
		values["filter"] = []string{fmt.Sprintf("%v", *p.filter)}
	}

	if p.follow != nil {
		values["follow"] = []string{fmt.Sprintf("%v", *p.follow)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("GET", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.WeightService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.WeightService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.WeightService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.WeightService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.WeightService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	respBodyBytes, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	reader := NewXMLReader(respBodyBytes)
	result, err := XMLWeightReadOne(reader, nil, "")
	if err != nil {
		return nil, err
	}
	return &WeightServiceGetResponse{weight: result}, nil
}

func (p *WeightServiceGetRequest) MustSend() *WeightServiceGetResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type WeightServiceGetResponse struct {
	weight *Weight
}

func (p *WeightServiceGetResponse) Weight() (*Weight, bool) {
	if p.weight != nil {
		return p.weight, true
	}
	return nil, false
}

func (p *WeightServiceGetResponse) MustWeight() *Weight {
	if p.weight == nil {
		panic("weight in response does not exist")
	}
	return p.weight
}

//
//
func (p *WeightService) Get() *WeightServiceGetRequest {
	return &WeightServiceGetRequest{WeightService: p}
}

//
//
type WeightServiceRemoveRequest struct {
	WeightService *WeightService
	header        map[string]string
	query         map[string]string
	async         *bool
}

func (p *WeightServiceRemoveRequest) Header(key, value string) *WeightServiceRemoveRequest {
	if p.header == nil {
		p.header = make(map[string]string)
	}
	p.header[key] = value
	return p
}

func (p *WeightServiceRemoveRequest) Query(key, value string) *WeightServiceRemoveRequest {
	if p.query == nil {
		p.query = make(map[string]string)
	}
	p.query[key] = value
	return p
}

func (p *WeightServiceRemoveRequest) Async(async bool) *WeightServiceRemoveRequest {
	p.async = &async
	return p
}

func (p *WeightServiceRemoveRequest) Send() (*WeightServiceRemoveResponse, error) {
	rawURL := fmt.Sprintf("%s%s", p.WeightService.connection.URL(), p.WeightService.path)
	values := make(url.Values)
	if p.async != nil {
		values["async"] = []string{fmt.Sprintf("%v", *p.async)}
	}

	if p.query != nil {
		for k, v := range p.query {
			values[k] = []string{v}
		}
	}
	if len(values) > 0 {
		rawURL = fmt.Sprintf("%s?%s", rawURL, values.Encode())
	}
	req, err := http.NewRequest("DELETE", rawURL, nil)
	if err != nil {
		return nil, err
	}

	for hk, hv := range p.WeightService.connection.headers {
		req.Header.Add(hk, hv)
	}

	if p.header != nil {
		for hk, hv := range p.header {
			req.Header.Add(hk, hv)
		}
	}

	req.Header.Add("User-Agent", fmt.Sprintf("GoSDK/%s", SDK_VERSION))
	req.Header.Add("Version", "4")
	req.Header.Add("Content-Type", "application/xml")
	req.Header.Add("Accept", "application/xml")
	// get OAuth access token
	token, err := p.WeightService.connection.authenticate()
	if err != nil {
		return nil, err
	}
	req.Header.Add("Authorization", fmt.Sprintf("Bearer %s", token))
	// Send the request and wait for the response
	resp, err := p.WeightService.connection.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if p.WeightService.connection.logFunc != nil {
		dumpReq, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			return nil, err
		}
		dumpResp, err := httputil.DumpResponse(resp, true)
		if err != nil {
			return nil, err
		}
		p.WeightService.connection.logFunc("<<<<<<Request:\n%sResponse:\n%s>>>>>>\n", string(dumpReq), string(dumpResp))
	}
	if !Contains(resp.StatusCode, []int{200}) {
		return nil, CheckFault(resp)
	}
	_, errReadBody := ioutil.ReadAll(resp.Body)
	if errReadBody != nil {
		return nil, errReadBody
	}
	return new(WeightServiceRemoveResponse), nil
}

func (p *WeightServiceRemoveRequest) MustSend() *WeightServiceRemoveResponse {
	if v, err := p.Send(); err != nil {
		panic(err)
	} else {
		return v
	}
}

//
//
type WeightServiceRemoveResponse struct {
}

//
//
func (p *WeightService) Remove() *WeightServiceRemoveRequest {
	return &WeightServiceRemoveRequest{WeightService: p}
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *WeightService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *WeightService) String() string {
	return fmt.Sprintf("WeightService:%s", op.path)
}

//
//
type FollowService struct {
	BaseService
}

func NewFollowService(connection *Connection, path string) *FollowService {
	var result FollowService
	result.connection = connection
	result.path = path
	return &result
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *FollowService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *FollowService) String() string {
	return fmt.Sprintf("FollowService:%s", op.path)
}

//
// This annotation is intended to specify what oVirt area is the annotated concept related to. Currently the following
// areas are in use, and they are closely related to the oVirt teams, but not necessarily the same:
// - Infrastructure
// - Network
// - SLA
// - Storage
// - Virtualization
// A concept may be associated to more than one area, or to no area.
// The value of this annotation is intended for reporting only, and it doesn't affect at all the generated code or the
// validity of the model
//
type AreaService struct {
	BaseService
}

func NewAreaService(connection *Connection, path string) *AreaService {
	var result AreaService
	result.connection = connection
	result.path = path
	return &result
}

//
// Service locator method, returns individual service on which the URI is dispatched.
//
func (op *AreaService) Service(path string) (Service, error) {
	if path == "" {
		return op, nil
	}
	return nil, fmt.Errorf("The path <%s> doesn't correspond to any service", path)
}

func (op *AreaService) String() string {
	return fmt.Sprintf("AreaService:%s", op.path)
}
