// Copyright IBM Corp. 2017, 2021 All Rights Reserved.
// Licensed under the Mozilla Public License v2.0

// Package kubernetesserviceapiv1 : Operations and models for the KubernetesServiceApiV1 service
package kubernetesserviceapiv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	common "github.ibm.com/ibmcloud/kubernetesservice-go-sdk/common"
)

// KubernetesServiceApiV1 : With IBM Cloud Kubernetes Service, you can deploy highly available apps in containers that
// run in Kubernetes clusters. You can use this API to create and manage your Kubernetes clusters. To learn more about
// the IBM Cloud Kubernetes Service, view the docs at
// https://cloud.ibm.com/docs/containers?topic=containers-getting-started. For a list of the IBM Cloud Identity and
// Access Management (IAM) action and Activity Tracker events by API method, see
// https://cloud.ibm.com/docs/containers?topic=containers-api-at-iam.
//
// The base URL for this API is https://containers.cloud.ibm.com/global. To generate a client of the API to use in
// automation, see the swagger.json file: https://containers.cloud.ibm.com/global/swagger-global-api/swagger.json.
//
// Version: 1.1
type KubernetesServiceApiV1 struct {
	Service *core.BaseService
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://containers.cloud.ibm.com/global"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "kubernetes_service_api"

// KubernetesServiceApiV1Options : Service options
type KubernetesServiceApiV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewKubernetesServiceApiV1UsingExternalConfig : constructs an instance of KubernetesServiceApiV1 with passed in options and external configuration.
func NewKubernetesServiceApiV1UsingExternalConfig(options *KubernetesServiceApiV1Options) (kubernetesServiceApi *KubernetesServiceApiV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	kubernetesServiceApi, err = NewKubernetesServiceApiV1(options)
	if err != nil {
		return
	}

	err = kubernetesServiceApi.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = kubernetesServiceApi.Service.SetServiceURL(options.URL)
	}
	return
}

// NewKubernetesServiceApiV1 : constructs an instance of KubernetesServiceApiV1 with passed in options.
func NewKubernetesServiceApiV1(options *KubernetesServiceApiV1Options) (service *KubernetesServiceApiV1, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &KubernetesServiceApiV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "kubernetesServiceApi" suitable for processing requests.
func (kubernetesServiceApi *KubernetesServiceApiV1) Clone() *KubernetesServiceApiV1 {
	if core.IsNil(kubernetesServiceApi) {
		return nil
	}
	clone := *kubernetesServiceApi
	clone.Service = kubernetesServiceApi.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (kubernetesServiceApi *KubernetesServiceApiV1) SetServiceURL(url string) error {
	return kubernetesServiceApi.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (kubernetesServiceApi *KubernetesServiceApiV1) GetServiceURL() string {
	return kubernetesServiceApi.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (kubernetesServiceApi *KubernetesServiceApiV1) SetDefaultHeaders(headers http.Header) {
	kubernetesServiceApi.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (kubernetesServiceApi *KubernetesServiceApiV1) SetEnableGzipCompression(enableGzip bool) {
	kubernetesServiceApi.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (kubernetesServiceApi *KubernetesServiceApiV1) GetEnableGzipCompression() bool {
	return kubernetesServiceApi.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (kubernetesServiceApi *KubernetesServiceApiV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	kubernetesServiceApi.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (kubernetesServiceApi *KubernetesServiceApiV1) DisableRetries() {
	kubernetesServiceApi.Service.DisableRetries()
}

// GetUserCredentials : View the IBM Cloud infrastructure (SoftLayer) account credentials that are set for your IBM Cloud Kubernetes Service account
// Get the infrastructure user name of the credentials that are used to access the IBM Cloud infrastructure (SoftLayer)
// portfolio. Infrastructure credentials are set per region and resource group.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetUserCredentials(getUserCredentialsOptions *GetUserCredentialsOptions) (result *Credentials, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetUserCredentialsWithContext(context.Background(), getUserCredentialsOptions)
}

// GetUserCredentialsWithContext is an alternate form of the GetUserCredentials method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetUserCredentialsWithContext(ctx context.Context, getUserCredentialsOptions *GetUserCredentialsOptions) (result *Credentials, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getUserCredentialsOptions, "getUserCredentialsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getUserCredentialsOptions, "getUserCredentialsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/credentials`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getUserCredentialsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetUserCredentials")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getUserCredentialsOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*getUserCredentialsOptions.XRegion))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCredentials)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// StoreUserCredentials : Set IBM Cloud infrastructure (SoftLayer) account credentials for your IBM Cloud Kubernetes Service account
// Set the IBM Cloud infrastructure (SoftLayer) user name, API key, and refresh token for your IBM Cloud Kubernetes
// Service account. Do not set multiple credentials for one IBM Cloud Kubernetes Service account. Every IBM Cloud
// Kubernetes Service account is linked to one IBM Cloud infrastructure (SoftLayer) portfolio only.
func (kubernetesServiceApi *KubernetesServiceApiV1) StoreUserCredentials(storeUserCredentialsOptions *StoreUserCredentialsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.StoreUserCredentialsWithContext(context.Background(), storeUserCredentialsOptions)
}

// StoreUserCredentialsWithContext is an alternate form of the StoreUserCredentials method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) StoreUserCredentialsWithContext(ctx context.Context, storeUserCredentialsOptions *StoreUserCredentialsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(storeUserCredentialsOptions, "storeUserCredentialsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(storeUserCredentialsOptions, "storeUserCredentialsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/credentials`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range storeUserCredentialsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "StoreUserCredentials")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if storeUserCredentialsOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*storeUserCredentialsOptions.XRegion))
	}
	if storeUserCredentialsOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*storeUserCredentialsOptions.XAuthRefreshToken))
	}
	if storeUserCredentialsOptions.XAuthSoftlayerUsername != nil {
		builder.AddHeader("X-Auth-Softlayer-Username", fmt.Sprint(*storeUserCredentialsOptions.XAuthSoftlayerUsername))
	}
	if storeUserCredentialsOptions.XAuthSoftlayerAPIKey != nil {
		builder.AddHeader("X-Auth-Softlayer-APIKey", fmt.Sprint(*storeUserCredentialsOptions.XAuthSoftlayerAPIKey))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RemoveUserCredentials : Remove IBM Cloud infrastructure (SoftLayer) account credentials from your IBM Cloud Kubernetes Service account
// Remove the IBM Cloud infrastructure (SoftLayer) user name, API key, and refresh token from your IBM Cloud Kubernetes
// Service account for a region and resource group. After removing the credentials, you cannot access that IBM Cloud
// infrastructure (SoftLayer) account through your IBM Cloud Kubernetes Service account anymore.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveUserCredentials(removeUserCredentialsOptions *RemoveUserCredentialsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveUserCredentialsWithContext(context.Background(), removeUserCredentialsOptions)
}

// RemoveUserCredentialsWithContext is an alternate form of the RemoveUserCredentials method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveUserCredentialsWithContext(ctx context.Context, removeUserCredentialsOptions *RemoveUserCredentialsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeUserCredentialsOptions, "removeUserCredentialsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeUserCredentialsOptions, "removeUserCredentialsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/credentials`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeUserCredentialsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveUserCredentials")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if removeUserCredentialsOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*removeUserCredentialsOptions.XRegion))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetInfraPermissions : Get details on the permissions that the IBM Cloud infrastructure (SoftLayer) credentials have
// Get details on the compute, networking, and storage permissions that the IBM Cloud infrastructure (SoftLayer)
// credentials have in this region and resource group. To review what IBM Cloud infrastructure (SoftLayer) credentials
// are set, use the `GET /v1/credentials` API, or run `ibmcloud ks credential get` or `ibmcloud ks api-key info`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetInfraPermissions(getInfraPermissionsOptions *GetInfraPermissionsOptions) (result *AccountStatus, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetInfraPermissionsWithContext(context.Background(), getInfraPermissionsOptions)
}

// GetInfraPermissionsWithContext is an alternate form of the GetInfraPermissions method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetInfraPermissionsWithContext(ctx context.Context, getInfraPermissionsOptions *GetInfraPermissionsOptions) (result *AccountStatus, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getInfraPermissionsOptions, "getInfraPermissionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getInfraPermissionsOptions, "getInfraPermissionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/infra-permissions`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getInfraPermissionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetInfraPermissions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getInfraPermissionsOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*getInfraPermissionsOptions.XRegion))
	}
	if getInfraPermissionsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getInfraPermissionsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAccountStatus)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ResetUserAPIKey : Reset the IAM API key
// Replace the IAM API key for the IBM Cloud Kubernetes Service in a region and resource group. The API key is used to
// access the IBM Cloud Infratructure (SoftLayer) portfolio and is required to manage your clusters. To avoid service
// interruptions, do not replace the API key unless your existing key is compromised.
func (kubernetesServiceApi *KubernetesServiceApiV1) ResetUserAPIKey(resetUserAPIKeyOptions *ResetUserAPIKeyOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ResetUserAPIKeyWithContext(context.Background(), resetUserAPIKeyOptions)
}

// ResetUserAPIKeyWithContext is an alternate form of the ResetUserAPIKey method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ResetUserAPIKeyWithContext(ctx context.Context, resetUserAPIKeyOptions *ResetUserAPIKeyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(resetUserAPIKeyOptions, "resetUserAPIKeyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(resetUserAPIKeyOptions, "resetUserAPIKeyOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/keys`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range resetUserAPIKeyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ResetUserAPIKey")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if resetUserAPIKeyOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*resetUserAPIKeyOptions.XRegion))
	}
	if resetUserAPIKeyOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*resetUserAPIKeyOptions.XAuthRefreshToken))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetVlanSpanning : View the VLAN spanning status
// View the VLAN spanning status for an IBM Cloud Infrastructure (SoftLayer) account. VLAN spanning enables all devices
// on an account to communicate with each other by means of the private network, regardless of its assigned VLAN.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVlanSpanning(getVlanSpanningOptions *GetVlanSpanningOptions) (result *VlanSpan, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetVlanSpanningWithContext(context.Background(), getVlanSpanningOptions)
}

// GetVlanSpanningWithContext is an alternate form of the GetVlanSpanning method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVlanSpanningWithContext(ctx context.Context, getVlanSpanningOptions *GetVlanSpanningOptions) (result *VlanSpan, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVlanSpanningOptions, "getVlanSpanningOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVlanSpanningOptions, "getVlanSpanningOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/subnets/vlan-spanning`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVlanSpanningOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetVlanSpanning")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getVlanSpanningOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*getVlanSpanningOptions.XRegion))
	}
	if getVlanSpanningOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getVlanSpanningOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVlanSpan)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetClusterACLs : Get a cluster's private service endpoint allowlist
// List all subnets in the allowlist for a cluster's private service endpoint. This list includes subnets that you
// manually added by using the `PATCH /v1/acl/{idOrName}/add` API and subnets that are automatically added and managed
// by IBM, such as worker node subnets.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterACLs(getClusterACLsOptions *GetClusterACLsOptions) (result *ACLResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterACLsWithContext(context.Background(), getClusterACLsOptions)
}

// GetClusterACLsWithContext is an alternate form of the GetClusterACLs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterACLsWithContext(ctx context.Context, getClusterACLsOptions *GetClusterACLsOptions) (result *ACLResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterACLsOptions, "getClusterACLsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterACLsOptions, "getClusterACLsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterACLsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/acl/{idOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterACLsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterACLs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterACLsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterACLsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalACLResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DisableClusterACLs : Disable the subnet allowlist for a cluster's private service endpoint
// Disable the subnet allowlist feature for a cluster's private service endpoint. After you disable this feature,
// authorized requests to your cluster master through the cluster's private service endpoint can originate from any
// subnet.
func (kubernetesServiceApi *KubernetesServiceApiV1) DisableClusterACLs(disableClusterACLsOptions *DisableClusterACLsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DisableClusterACLsWithContext(context.Background(), disableClusterACLsOptions)
}

// DisableClusterACLsWithContext is an alternate form of the DisableClusterACLs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DisableClusterACLsWithContext(ctx context.Context, disableClusterACLsOptions *DisableClusterACLsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(disableClusterACLsOptions, "disableClusterACLsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(disableClusterACLsOptions, "disableClusterACLsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *disableClusterACLsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/acl/{idOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range disableClusterACLsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DisableClusterACLs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if disableClusterACLsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*disableClusterACLsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// AddClusterACLs : Add subnets to a cluster's private service endpoint allowlist
// After you use the `POST /v1/acl/{idOrName}/enable` API to enable an allowlist for your cluster's private service
// endpoint, add subnets to the allowlist. Only authorized requests to your cluster master that originate from subnets
// in this allowlist are permitted through the cluster's private service endpoint. By default, subnets for your
// cluster's worker nodes are added to this allowlist so that worker nodes can communicate with the master through the
// private service endpoint.
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterACLs(addClusterACLsOptions *AddClusterACLsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AddClusterACLsWithContext(context.Background(), addClusterACLsOptions)
}

// AddClusterACLsWithContext is an alternate form of the AddClusterACLs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterACLsWithContext(ctx context.Context, addClusterACLsOptions *AddClusterACLsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addClusterACLsOptions, "addClusterACLsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addClusterACLsOptions, "addClusterACLsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *addClusterACLsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/acl/{idOrName}/add`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addClusterACLsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AddClusterACLs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if addClusterACLsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*addClusterACLsOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if addClusterACLsOptions.AclList != nil {
		body["aclList"] = addClusterACLsOptions.AclList
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// EnableClusterACLs : Enable a subnet allowlist for a cluster's private service endpoint
// Enable the subnet allowlist feature for a cluster's private service endpoint. After you enable this feature, you can
// use the `PATCH /v1/acl/{idOrName}/add` API to add subnets to the allowlist for this cluster's private service
// endpoint. Only authorized requests to your cluster master that originate from subnets in the allowlist are permitted
// through the cluster's private service endpoint. If the public service endpoint is enabled for your cluster,
// authorized requests are still permitted through the public service endpoint.
func (kubernetesServiceApi *KubernetesServiceApiV1) EnableClusterACLs(enableClusterACLsOptions *EnableClusterACLsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.EnableClusterACLsWithContext(context.Background(), enableClusterACLsOptions)
}

// EnableClusterACLsWithContext is an alternate form of the EnableClusterACLs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) EnableClusterACLsWithContext(ctx context.Context, enableClusterACLsOptions *EnableClusterACLsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(enableClusterACLsOptions, "enableClusterACLsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(enableClusterACLsOptions, "enableClusterACLsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *enableClusterACLsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/acl/{idOrName}/enable`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range enableClusterACLsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "EnableClusterACLs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if enableClusterACLsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*enableClusterACLsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RemoveClusterACLs : Remove subnets from a cluster's private service endpoint allowlist
// Remove subnets that you previously added to the allowlist for a cluster's private service endpoint. After a subnet is
// removed, any requests that originate from this subnet to the cluster master through the private service endpoint are
// denied.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveClusterACLs(removeClusterACLsOptions *RemoveClusterACLsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveClusterACLsWithContext(context.Background(), removeClusterACLsOptions)
}

// RemoveClusterACLsWithContext is an alternate form of the RemoveClusterACLs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveClusterACLsWithContext(ctx context.Context, removeClusterACLsOptions *RemoveClusterACLsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeClusterACLsOptions, "removeClusterACLsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeClusterACLsOptions, "removeClusterACLsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *removeClusterACLsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/acl/{idOrName}/rm`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeClusterACLsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveClusterACLs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if removeClusterACLsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*removeClusterACLsOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if removeClusterACLsOptions.AclList != nil {
		body["aclList"] = removeClusterACLsOptions.AclList
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// EnableALB : Enable an existing ALB in a cluster
// Enable a public or private ALB in your standard cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) EnableALB(enableALBOptions *EnableALBOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.EnableALBWithContext(context.Background(), enableALBOptions)
}

// EnableALBWithContext is an alternate form of the EnableALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) EnableALBWithContext(ctx context.Context, enableALBOptions *EnableALBOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(enableALBOptions, "enableALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(enableALBOptions, "enableALBOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/albs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range enableALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "EnableALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if enableALBOptions.AlbBuild != nil {
		body["albBuild"] = enableALBOptions.AlbBuild
	}
	if enableALBOptions.AlbID != nil {
		body["albID"] = enableALBOptions.AlbID
	}
	if enableALBOptions.AlbType != nil {
		body["albType"] = enableALBOptions.AlbType
	}
	if enableALBOptions.Albip != nil {
		body["albip"] = enableALBOptions.Albip
	}
	if enableALBOptions.AuthBuild != nil {
		body["authBuild"] = enableALBOptions.AuthBuild
	}
	if enableALBOptions.ClusterID != nil {
		body["clusterID"] = enableALBOptions.ClusterID
	}
	if enableALBOptions.CreatedDate != nil {
		body["createdDate"] = enableALBOptions.CreatedDate
	}
	if enableALBOptions.DisableDeployment != nil {
		body["disableDeployment"] = enableALBOptions.DisableDeployment
	}
	if enableALBOptions.Enable != nil {
		body["enable"] = enableALBOptions.Enable
	}
	if enableALBOptions.Name != nil {
		body["name"] = enableALBOptions.Name
	}
	if enableALBOptions.NlbVersion != nil {
		body["nlbVersion"] = enableALBOptions.NlbVersion
	}
	if enableALBOptions.NumOfInstances != nil {
		body["numOfInstances"] = enableALBOptions.NumOfInstances
	}
	if enableALBOptions.Resize != nil {
		body["resize"] = enableALBOptions.Resize
	}
	if enableALBOptions.State != nil {
		body["state"] = enableALBOptions.State
	}
	if enableALBOptions.Status != nil {
		body["status"] = enableALBOptions.Status
	}
	if enableALBOptions.VlanID != nil {
		body["vlanID"] = enableALBOptions.VlanID
	}
	if enableALBOptions.Zone != nil {
		body["zone"] = enableALBOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetClusterALB : View details of an ALB
// View detailed information for an ALB in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterALB(getClusterALBOptions *GetClusterALBOptions) (result *ALBConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterALBWithContext(context.Background(), getClusterALBOptions)
}

// GetClusterALBWithContext is an alternate form of the GetClusterALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterALBWithContext(ctx context.Context, getClusterALBOptions *GetClusterALBOptions) (result *ALBConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterALBOptions, "getClusterALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterALBOptions, "getClusterALBOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"albID": *getClusterALBOptions.AlbID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/albs/{albID}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalALBConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DisableALB : Disable an ALB in your cluster
// Disable a public or private ALB in your standard cluster. When you disable an ALB, the IP address that the ALB used
// goes back into the pool of available portable IPs so that another service can use the IP. If you later try to
// re-enable the ALB, the ALB might report an error if the IP address it previously used is now in use by another
// service. You can either stop running the other service or specify another IP address to use when you re-enable the
// ALB.
func (kubernetesServiceApi *KubernetesServiceApiV1) DisableALB(disableALBOptions *DisableALBOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DisableALBWithContext(context.Background(), disableALBOptions)
}

// DisableALBWithContext is an alternate form of the DisableALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DisableALBWithContext(ctx context.Context, disableALBOptions *DisableALBOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(disableALBOptions, "disableALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(disableALBOptions, "disableALBOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"albID": *disableALBOptions.AlbID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/albs/{albID}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range disableALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DisableALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	if disableALBOptions.DisableDeployment != nil {
		builder.AddQuery("disableDeployment", fmt.Sprint(*disableALBOptions.DisableDeployment))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetAvailableALBTypes : List the ALB types that are supported
// List the ALB types that are supported.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAvailableALBTypes(getAvailableALBTypesOptions *GetAvailableALBTypesOptions) (result []string, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetAvailableALBTypesWithContext(context.Background(), getAvailableALBTypesOptions)
}

// GetAvailableALBTypesWithContext is an alternate form of the GetAvailableALBTypes method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAvailableALBTypesWithContext(ctx context.Context, getAvailableALBTypesOptions *GetAvailableALBTypesOptions) (result []string, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getAvailableALBTypesOptions, "getAvailableALBTypesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/albtypes`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getAvailableALBTypesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetAvailableALBTypes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, &result)

	return
}

// GetClusterALBs : List all ALBs in a cluster
// List all ALB IDs in a cluster. If no ALB IDs are returned, then the cluster does not have a portable subnet.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterALBs(getClusterALBsOptions *GetClusterALBsOptions) (result []ClusterALB, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterALBsWithContext(context.Background(), getClusterALBsOptions)
}

// GetClusterALBsWithContext is an alternate form of the GetClusterALBs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterALBsWithContext(ctx context.Context, getClusterALBsOptions *GetClusterALBsOptions) (result []ClusterALB, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterALBsOptions, "getClusterALBsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterALBsOptions, "getClusterALBsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterALBsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/clusters/{idOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterALBsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterALBs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterALBsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterALBsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterALB)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateALBs : Force a one-time update of all ALB pods to the latest build
// If automatic updates for Ingress ALBs are disabled, you can force a one-time update of your ALB pods. When you choose
// to manually update the ALBs, all ALB pods in the cluster are updated to the latest build. You cannot update an
// individual ALB or choose which build to update the ALBs to. Automatic updates remain disabled.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateALBs(updateALBsOptions *UpdateALBsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateALBsWithContext(context.Background(), updateALBsOptions)
}

// UpdateALBsWithContext is an alternate form of the UpdateALBs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateALBsWithContext(ctx context.Context, updateALBsOptions *UpdateALBsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateALBsOptions, "updateALBsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateALBsOptions, "updateALBsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *updateALBsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/clusters/{idOrName}/update`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateALBsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateALBs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if updateALBsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*updateALBsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetUpdatePolicy : Check if automatic updates for Ingress ALBs are enabled in a cluster
// Check if automatic updates for Ingress ALBs are enabled and whether your ALB pods are updated to the latest build
// version.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetUpdatePolicy(getUpdatePolicyOptions *GetUpdatePolicyOptions) (result *UpdatePolicy, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetUpdatePolicyWithContext(context.Background(), getUpdatePolicyOptions)
}

// GetUpdatePolicyWithContext is an alternate form of the GetUpdatePolicy method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetUpdatePolicyWithContext(ctx context.Context, getUpdatePolicyOptions *GetUpdatePolicyOptions) (result *UpdatePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getUpdatePolicyOptions, "getUpdatePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getUpdatePolicyOptions, "getUpdatePolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getUpdatePolicyOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/clusters/{idOrName}/updatepolicy`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getUpdatePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetUpdatePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getUpdatePolicyOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getUpdatePolicyOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUpdatePolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ChangeUpdatePolicy : Enable or disable automatic updates for the Ingress ALBs in a cluster
// By default, automatic updates to Ingress ALBs are enabled. ALB pods are automatically updated when a new build
// version is available. To instead update the Ingress ALB component manually, you can use this call to disable
// automatic updates, then use the `PUT /clusters/{idOrName}/update` call to update all ALB pods. Note: When you update
// the major or minor Kubernetes version of your cluster, IBM automatically makes necessary changes to the Ingress
// deployment, but does not change the build version of your Ingress ALBs. You are responsible for checking the
// compatability of the latest Kubernetes versions and your Ingress ALB add-on images. If automatic updates for the
// Ingress ALB component are disabled, you can re-enable automatic updates. Whenever the next build version becomes
// available, the ALBs are automatically updated to the latest build.
func (kubernetesServiceApi *KubernetesServiceApiV1) ChangeUpdatePolicy(changeUpdatePolicyOptions *ChangeUpdatePolicyOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ChangeUpdatePolicyWithContext(context.Background(), changeUpdatePolicyOptions)
}

// ChangeUpdatePolicyWithContext is an alternate form of the ChangeUpdatePolicy method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ChangeUpdatePolicyWithContext(ctx context.Context, changeUpdatePolicyOptions *ChangeUpdatePolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(changeUpdatePolicyOptions, "changeUpdatePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(changeUpdatePolicyOptions, "changeUpdatePolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *changeUpdatePolicyOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/clusters/{idOrName}/updatepolicy`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range changeUpdatePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ChangeUpdatePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if changeUpdatePolicyOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*changeUpdatePolicyOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if changeUpdatePolicyOptions.AutoUpdate != nil {
		body["autoUpdate"] = changeUpdatePolicyOptions.AutoUpdate
	}
	if changeUpdatePolicyOptions.LatestVersion != nil {
		body["latestVersion"] = changeUpdatePolicyOptions.LatestVersion
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RollbackUpdate : Roll back all ALB pods in a cluster to their previously running build
// If your ALB pods were recently updated, but a custom configuration for your ALBs is affected by the latest build, you
// can roll back the update to the build that your ALB pods were previously running. After you roll back an update,
// automatic updates for ALB pods are disabled. To re-enable automatic updates, use the `PUT
// /clusters/{idOrName}/updatepolicy` call.
func (kubernetesServiceApi *KubernetesServiceApiV1) RollbackUpdate(rollbackUpdateOptions *RollbackUpdateOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RollbackUpdateWithContext(context.Background(), rollbackUpdateOptions)
}

// RollbackUpdateWithContext is an alternate form of the RollbackUpdate method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RollbackUpdateWithContext(ctx context.Context, rollbackUpdateOptions *RollbackUpdateOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(rollbackUpdateOptions, "rollbackUpdateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(rollbackUpdateOptions, "rollbackUpdateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *rollbackUpdateOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/clusters/{idOrName}/updaterollback`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range rollbackUpdateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RollbackUpdate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if rollbackUpdateOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*rollbackUpdateOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateALB : Create a public or private ALB in a specified zone and VLAN
// Create a new public or private ALB in a specified zone on a specified VLAN. You can also optionally specify an IP
// address on that VLAN in that zone for the ALB to use.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateALB(createALBOptions *CreateALBOptions) (result *AlbCreateResp, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateALBWithContext(context.Background(), createALBOptions)
}

// CreateALBWithContext is an alternate form of the CreateALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateALBWithContext(ctx context.Context, createALBOptions *CreateALBOptions) (result *AlbCreateResp, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createALBOptions, "createALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createALBOptions, "createALBOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *createALBOptions.IdOrName,
		"zoneId":   *createALBOptions.ZoneID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/clusters/{idOrName}/zone/{zoneId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createALBOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*createALBOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if createALBOptions.EnableByDefault != nil {
		body["enableByDefault"] = createALBOptions.EnableByDefault
	}
	if createALBOptions.IngressImage != nil {
		body["ingressImage"] = createALBOptions.IngressImage
	}
	if createALBOptions.Ip != nil {
		body["ip"] = createALBOptions.Ip
	}
	if createALBOptions.NlbVersion != nil {
		body["nlbVersion"] = createALBOptions.NlbVersion
	}
	if createALBOptions.Type != nil {
		body["type"] = createALBOptions.Type
	}
	if createALBOptions.VlanID != nil {
		body["vlanID"] = createALBOptions.VlanID
	}
	if createALBOptions.Zone != nil {
		body["zone"] = createALBOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAlbCreateResp)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateALBSecret : Update an ALB secret that you imported from Certificate Manager
// Update a certificate from your IBM Cloud Certificate Manager instance to the ALB in a cluster. You can only update
// certificates that are imported from the same Certificate Manager instance.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateALBSecret(updateALBSecretOptions *UpdateALBSecretOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateALBSecretWithContext(context.Background(), updateALBSecretOptions)
}

// UpdateALBSecretWithContext is an alternate form of the UpdateALBSecret method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateALBSecretWithContext(ctx context.Context, updateALBSecretOptions *UpdateALBSecretOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateALBSecretOptions, "updateALBSecretOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateALBSecretOptions, "updateALBSecretOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/albsecrets`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateALBSecretOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateALBSecret")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateALBSecretOptions.CertCrn != nil {
		body["certCrn"] = updateALBSecretOptions.CertCrn
	}
	if updateALBSecretOptions.CloudCertInstanceID != nil {
		body["cloudCertInstanceID"] = updateALBSecretOptions.CloudCertInstanceID
	}
	if updateALBSecretOptions.ClusterCrn != nil {
		body["clusterCrn"] = updateALBSecretOptions.ClusterCrn
	}
	if updateALBSecretOptions.ClusterID != nil {
		body["clusterID"] = updateALBSecretOptions.ClusterID
	}
	if updateALBSecretOptions.DomainName != nil {
		body["domainName"] = updateALBSecretOptions.DomainName
	}
	if updateALBSecretOptions.ExpiresOn != nil {
		body["expiresOn"] = updateALBSecretOptions.ExpiresOn
	}
	if updateALBSecretOptions.IssuerName != nil {
		body["issuerName"] = updateALBSecretOptions.IssuerName
	}
	if updateALBSecretOptions.SecretName != nil {
		body["secretName"] = updateALBSecretOptions.SecretName
	}
	if updateALBSecretOptions.State != nil {
		body["state"] = updateALBSecretOptions.State
	}
	if updateALBSecretOptions.Status != nil {
		body["status"] = updateALBSecretOptions.Status
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateALBSecret : Import an ALB secret from Certificate Manager
// Import a secret for an ALB by deploying a certificate from your IBM Cloud Certificate Manager instance into your
// cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateALBSecret(createALBSecretOptions *CreateALBSecretOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateALBSecretWithContext(context.Background(), createALBSecretOptions)
}

// CreateALBSecretWithContext is an alternate form of the CreateALBSecret method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateALBSecretWithContext(ctx context.Context, createALBSecretOptions *CreateALBSecretOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createALBSecretOptions, "createALBSecretOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createALBSecretOptions, "createALBSecretOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/albsecrets`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createALBSecretOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateALBSecret")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createALBSecretOptions.CertCrn != nil {
		body["certCrn"] = createALBSecretOptions.CertCrn
	}
	if createALBSecretOptions.CloudCertInstanceID != nil {
		body["cloudCertInstanceID"] = createALBSecretOptions.CloudCertInstanceID
	}
	if createALBSecretOptions.ClusterCrn != nil {
		body["clusterCrn"] = createALBSecretOptions.ClusterCrn
	}
	if createALBSecretOptions.ClusterID != nil {
		body["clusterID"] = createALBSecretOptions.ClusterID
	}
	if createALBSecretOptions.DomainName != nil {
		body["domainName"] = createALBSecretOptions.DomainName
	}
	if createALBSecretOptions.ExpiresOn != nil {
		body["expiresOn"] = createALBSecretOptions.ExpiresOn
	}
	if createALBSecretOptions.IssuerName != nil {
		body["issuerName"] = createALBSecretOptions.IssuerName
	}
	if createALBSecretOptions.SecretName != nil {
		body["secretName"] = createALBSecretOptions.SecretName
	}
	if createALBSecretOptions.State != nil {
		body["state"] = createALBSecretOptions.State
	}
	if createALBSecretOptions.Status != nil {
		body["status"] = createALBSecretOptions.Status
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// ViewClusterALBSecrets : View details of an ALB secret that you imported from Certificate Manager
// If you imported a certificate from IBM Cloud Certificate Manager to the ALB in a cluster, view information about the
// TLS certificate, such as the secrets that are associated with it.
func (kubernetesServiceApi *KubernetesServiceApiV1) ViewClusterALBSecrets(viewClusterALBSecretsOptions *ViewClusterALBSecretsOptions) (result *ClusterALBSecret, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ViewClusterALBSecretsWithContext(context.Background(), viewClusterALBSecretsOptions)
}

// ViewClusterALBSecretsWithContext is an alternate form of the ViewClusterALBSecrets method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ViewClusterALBSecretsWithContext(ctx context.Context, viewClusterALBSecretsOptions *ViewClusterALBSecretsOptions) (result *ClusterALBSecret, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(viewClusterALBSecretsOptions, "viewClusterALBSecretsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(viewClusterALBSecretsOptions, "viewClusterALBSecretsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *viewClusterALBSecretsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/clusters/{idOrName}/albsecrets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range viewClusterALBSecretsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ViewClusterALBSecrets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if viewClusterALBSecretsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*viewClusterALBSecretsOptions.XAuthResourceGroup))
	}

	if viewClusterALBSecretsOptions.AlbSecretName != nil {
		builder.AddQuery("albSecretName", fmt.Sprint(*viewClusterALBSecretsOptions.AlbSecretName))
	}
	if viewClusterALBSecretsOptions.CertCrn != nil {
		builder.AddQuery("certCrn", fmt.Sprint(*viewClusterALBSecretsOptions.CertCrn))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterALBSecret)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteClusterALBSecrets : Delete an ALB secret that is imported from Certificate Manager from a cluster
// If you imported a certificate from IBM Cloud Certificate Manager to an ALB in a cluster, remove the secret from the
// cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteClusterALBSecrets(deleteClusterALBSecretsOptions *DeleteClusterALBSecretsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteClusterALBSecretsWithContext(context.Background(), deleteClusterALBSecretsOptions)
}

// DeleteClusterALBSecretsWithContext is an alternate form of the DeleteClusterALBSecrets method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteClusterALBSecretsWithContext(ctx context.Context, deleteClusterALBSecretsOptions *DeleteClusterALBSecretsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteClusterALBSecretsOptions, "deleteClusterALBSecretsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteClusterALBSecretsOptions, "deleteClusterALBSecretsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *deleteClusterALBSecretsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/alb/clusters/{idOrName}/albsecrets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteClusterALBSecretsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteClusterALBSecrets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteClusterALBSecretsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*deleteClusterALBSecretsOptions.XAuthResourceGroup))
	}

	if deleteClusterALBSecretsOptions.AlbSecretName != nil {
		builder.AddQuery("albSecretName", fmt.Sprint(*deleteClusterALBSecretsOptions.AlbSecretName))
	}
	if deleteClusterALBSecretsOptions.CertCrn != nil {
		builder.AddQuery("certCrn", fmt.Sprint(*deleteClusterALBSecretsOptions.CertCrn))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetAuditWebhook : View details for an audit webhook configuration
// View the URL for the remote logging service that you are sending API server audit logs to.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAuditWebhook(getAuditWebhookOptions *GetAuditWebhookOptions) (result *AuditWebhookConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetAuditWebhookWithContext(context.Background(), getAuditWebhookOptions)
}

// GetAuditWebhookWithContext is an alternate form of the GetAuditWebhook method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAuditWebhookWithContext(ctx context.Context, getAuditWebhookOptions *GetAuditWebhookOptions) (result *AuditWebhookConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getAuditWebhookOptions, "getAuditWebhookOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getAuditWebhookOptions, "getAuditWebhookOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getAuditWebhookOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/apiserverconfigs/auditwebhook`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getAuditWebhookOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetAuditWebhook")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getAuditWebhookOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getAuditWebhookOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAuditWebhookConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateAuditWebhook : Create or update an audit webhook configuration for a cluster
// Create or update an audit webhook configuration for a cluster. The webhook sends Kubernetes API server audit logs
// that allow you to monitor API requests to your cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateAuditWebhook(updateAuditWebhookOptions *UpdateAuditWebhookOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateAuditWebhookWithContext(context.Background(), updateAuditWebhookOptions)
}

// UpdateAuditWebhookWithContext is an alternate form of the UpdateAuditWebhook method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateAuditWebhookWithContext(ctx context.Context, updateAuditWebhookOptions *UpdateAuditWebhookOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateAuditWebhookOptions, "updateAuditWebhookOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateAuditWebhookOptions, "updateAuditWebhookOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *updateAuditWebhookOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/apiserverconfigs/auditwebhook`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateAuditWebhookOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateAuditWebhook")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if updateAuditWebhookOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*updateAuditWebhookOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if updateAuditWebhookOptions.AuditServer != nil {
		body["auditServer"] = updateAuditWebhookOptions.AuditServer
	}
	if updateAuditWebhookOptions.CaCertificate != nil {
		body["caCertificate"] = updateAuditWebhookOptions.CaCertificate
	}
	if updateAuditWebhookOptions.ClientCertificate != nil {
		body["clientCertificate"] = updateAuditWebhookOptions.ClientCertificate
	}
	if updateAuditWebhookOptions.ClientKey != nil {
		body["clientKey"] = updateAuditWebhookOptions.ClientKey
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// DeleteAuditWebhook : Delete an audit webhook configuration
// Disable the webhook backend configuration for the cluster's API server. Diabling the webhook backend stops forwarding
// API server audit logs to a remote server.
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteAuditWebhook(deleteAuditWebhookOptions *DeleteAuditWebhookOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteAuditWebhookWithContext(context.Background(), deleteAuditWebhookOptions)
}

// DeleteAuditWebhookWithContext is an alternate form of the DeleteAuditWebhook method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteAuditWebhookWithContext(ctx context.Context, deleteAuditWebhookOptions *DeleteAuditWebhookOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteAuditWebhookOptions, "deleteAuditWebhookOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteAuditWebhookOptions, "deleteAuditWebhookOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *deleteAuditWebhookOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/apiserverconfigs/auditwebhook`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteAuditWebhookOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteAuditWebhook")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteAuditWebhookOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*deleteAuditWebhookOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetLBConfig : Get configuration of load balancers for Ingress ALBs
// Get settings for load balancers that expose Ingress ALBs in your cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetLBConfig(getLBConfigOptions *GetLBConfigOptions) (result *LBConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetLBConfigWithContext(context.Background(), getLBConfigOptions)
}

// GetLBConfigWithContext is an alternate form of the GetLBConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetLBConfigWithContext(ctx context.Context, getLBConfigOptions *GetLBConfigOptions) (result *LBConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLBConfigOptions, "getLBConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLBConfigOptions, "getLBConfigOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/ingress/v2/load-balancer/configuration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLBConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetLBConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("cluster", fmt.Sprint(*getLBConfigOptions.Cluster))
	builder.AddQuery("type", fmt.Sprint(*getLBConfigOptions.Type))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLBConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// PatchLBConfig : Update the configuration of load balancers for Ingress ALBs
// Configure settings for load balancers that expose Ingress ALBs in your cluster. After you use this API to set load
// balancer options, the existing load balancers are deleted and recreated, which can cause service disruptions. Two
// unused IP addresses for each new load balancer must be available in each subnet during the load balancer recreation.
// To configure load balancers that expose only your public ALBs or only your private ALBs, specify `public` or
// `private` for the `type` field in the request body. If you leave the `type` field empty, the configuration is applied
// to all load balancers that expose ALBs in the cluster.
//
// Available features:
//   + `proxyProtocol`:
//     + Limitations:
//       + This feature is supported only for VPC Gen 2 clusters that run Kubernetes version 1.18 or later.
//       + This feature is cluster-level, therefore `type` field of the request must be empty.
//     + Configuration:
//       + `enable`: Set to `true` to enable or `false` to disable the PROXY protocol for the ALB load balancers. The
// PROXY protocol enables load balancers to pass client connection information that is contained in headers on the
// client request, including the client IP address, the proxy server IP address, and both port numbers, to ALBs.
//       + `headerTimeout`: The timeout value, in seconds, for the load balancer to receive the PROXY protocol headers
// that contain the client connection information. This option has effect only on ALBs running the Kubernetes Ingress
// image. Default: `5`
//       + `cidr`: Load balancer CIDRs from which ALBs process information in PROXY protocol headers. If requests that
// contain PROXY headers originate from load balancers in other IP ranges, the information in the headers is not process
// by the ALB. This option has effect only on ALBs running the Kubernetes Ingress image. Default: `0.0.0.0/0`.
func (kubernetesServiceApi *KubernetesServiceApiV1) PatchLBConfig(patchLBConfigOptions *PatchLBConfigOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.PatchLBConfigWithContext(context.Background(), patchLBConfigOptions)
}

// PatchLBConfigWithContext is an alternate form of the PatchLBConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) PatchLBConfigWithContext(ctx context.Context, patchLBConfigOptions *PatchLBConfigOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchLBConfigOptions, "patchLBConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(patchLBConfigOptions, "patchLBConfigOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/ingress/v2/load-balancer/configuration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range patchLBConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "PatchLBConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if patchLBConfigOptions.Cluster != nil {
		body["cluster"] = patchLBConfigOptions.Cluster
	}
	if patchLBConfigOptions.ProxyProtocol != nil {
		body["proxyProtocol"] = patchLBConfigOptions.ProxyProtocol
	}
	if patchLBConfigOptions.Type != nil {
		body["type"] = patchLBConfigOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateSecret : Create an Ingress secret for a certificate
// Create an Ingress secret from a certificate stored in IBM Cloud Certificate Manager.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSecret(createSecretOptions *CreateSecretOptions) (result *Secret, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateSecretWithContext(context.Background(), createSecretOptions)
}

// CreateSecretWithContext is an alternate form of the CreateSecret method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSecretWithContext(ctx context.Context, createSecretOptions *CreateSecretOptions) (result *Secret, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSecretOptions, "createSecretOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSecretOptions, "createSecretOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/ingress/v2/secret/createSecret`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSecretOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateSecret")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSecretOptions.Cluster != nil {
		body["cluster"] = createSecretOptions.Cluster
	}
	if createSecretOptions.Crn != nil {
		body["crn"] = createSecretOptions.Crn
	}
	if createSecretOptions.Name != nil {
		body["name"] = createSecretOptions.Name
	}
	if createSecretOptions.Namespace != nil {
		body["namespace"] = createSecretOptions.Namespace
	}
	if createSecretOptions.Persistence != nil {
		body["persistence"] = createSecretOptions.Persistence
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecret)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteIngressSecret : Delete an Ingress secret from the cluster
// Delete an Ingress secret from the cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteIngressSecret(deleteIngressSecretOptions *DeleteIngressSecretOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteIngressSecretWithContext(context.Background(), deleteIngressSecretOptions)
}

// DeleteIngressSecretWithContext is an alternate form of the DeleteIngressSecret method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteIngressSecretWithContext(ctx context.Context, deleteIngressSecretOptions *DeleteIngressSecretOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteIngressSecretOptions, "deleteIngressSecretOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteIngressSecretOptions, "deleteIngressSecretOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/ingress/v2/secret/deleteSecret`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteIngressSecretOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteIngressSecret")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if deleteIngressSecretOptions.Cluster != nil {
		body["cluster"] = deleteIngressSecretOptions.Cluster
	}
	if deleteIngressSecretOptions.DeleteCert != nil {
		body["delete_cert"] = deleteIngressSecretOptions.DeleteCert
	}
	if deleteIngressSecretOptions.Name != nil {
		body["name"] = deleteIngressSecretOptions.Name
	}
	if deleteIngressSecretOptions.Namespace != nil {
		body["namespace"] = deleteIngressSecretOptions.Namespace
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetSecret : View Ingress secret details
// View Ingress secret details.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSecret(getSecretOptions *GetSecretOptions) (result *Secret, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSecretWithContext(context.Background(), getSecretOptions)
}

// GetSecretWithContext is an alternate form of the GetSecret method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSecretWithContext(ctx context.Context, getSecretOptions *GetSecretOptions) (result *Secret, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecretOptions, "getSecretOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecretOptions, "getSecretOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/ingress/v2/secret/getSecret`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecretOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSecret")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("cluster", fmt.Sprint(*getSecretOptions.Cluster))
	builder.AddQuery("name", fmt.Sprint(*getSecretOptions.Name))
	builder.AddQuery("namespace", fmt.Sprint(*getSecretOptions.Namespace))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecret)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSecrets : View Ingress secrets for a cluster
// View Ingress secrets for a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSecrets(getSecretsOptions *GetSecretsOptions) (result []Secret, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSecretsWithContext(context.Background(), getSecretsOptions)
}

// GetSecretsWithContext is an alternate form of the GetSecrets method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSecretsWithContext(ctx context.Context, getSecretsOptions *GetSecretsOptions) (result []Secret, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSecretsOptions, "getSecretsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSecretsOptions, "getSecretsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/ingress/v2/secret/getSecrets`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSecretsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSecrets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("cluster", fmt.Sprint(*getSecretsOptions.Cluster))
	if getSecretsOptions.ShowDeleted != nil {
		builder.AddQuery("showDeleted", fmt.Sprint(*getSecretsOptions.ShowDeleted))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecret)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateSecret : Update an Ingress secret for a certificate
// Update an Ingress secret for a certificate stored in IBM Cloud Certificate Manager.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateSecret(updateSecretOptions *UpdateSecretOptions) (result *Secret, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateSecretWithContext(context.Background(), updateSecretOptions)
}

// UpdateSecretWithContext is an alternate form of the UpdateSecret method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateSecretWithContext(ctx context.Context, updateSecretOptions *UpdateSecretOptions) (result *Secret, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSecretOptions, "updateSecretOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSecretOptions, "updateSecretOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/ingress/v2/secret/updateSecret`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSecretOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateSecret")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSecretOptions.Cluster != nil {
		body["cluster"] = updateSecretOptions.Cluster
	}
	if updateSecretOptions.Crn != nil {
		body["crn"] = updateSecretOptions.Crn
	}
	if updateSecretOptions.Name != nil {
		body["name"] = updateSecretOptions.Name
	}
	if updateSecretOptions.Namespace != nil {
		body["namespace"] = updateSecretOptions.Namespace
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSecret)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CleanupMigration : Clean up any Ingress resources and ConfigMaps that are no longer needed after an Ingress migration
// After you complete an Ingress migration, remove the migration tool, Ingress resources, and ConfigMaps that are no
// longer needed. Use the `delete-generated-resources` option to delete all resources that were automatically generated
// during an Ingress migration, including the Ingress resources and ConfigMaps listed in the
// 'MigratedResource.MigratedAs' arrays of GET /v2/alb/getMigrationStatus responses. Use the `delete-test-ingresses`
// option to delete all Ingress resources of class `test`. Use the `delete-community-ingresses` option to delete all
// Ingress resources of class `public-iks-k8s-nginx` or `private-iks-k8s-nginx`. Use the `delete-iks-ingresses` to
// delete all Ingress resources of class `iks-nginx`, class `nginx`, or of no class. Use the
// `reset-community-controller-configmap` option to reset the `ibm-k8s-controller-config` ConfigMap to the default
// settings. For more info, see https://cloud.ibm.com/docs/containers?topic=containers-ingress-types.
func (kubernetesServiceApi *KubernetesServiceApiV1) CleanupMigration(cleanupMigrationOptions *CleanupMigrationOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CleanupMigrationWithContext(context.Background(), cleanupMigrationOptions)
}

// CleanupMigrationWithContext is an alternate form of the CleanupMigration method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CleanupMigrationWithContext(ctx context.Context, cleanupMigrationOptions *CleanupMigrationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(cleanupMigrationOptions, "cleanupMigrationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(cleanupMigrationOptions, "cleanupMigrationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/cleanupMigration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range cleanupMigrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CleanupMigration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if cleanupMigrationOptions.Cluster != nil {
		body["cluster"] = cleanupMigrationOptions.Cluster
	}
	if cleanupMigrationOptions.Options != nil {
		body["options"] = cleanupMigrationOptions.Options
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2GetClusterALB : View details of an ALB
// View detailed information for an ALB in a VPC or classic cluster. An `ALBConfig` response will be returned for ALBs
// in classic clusters.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetClusterALB(v2GetClusterALBOptions *V2GetClusterALBOptions) (result *VpcALBConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2GetClusterALBWithContext(context.Background(), v2GetClusterALBOptions)
}

// V2GetClusterALBWithContext is an alternate form of the V2GetClusterALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetClusterALBWithContext(ctx context.Context, v2GetClusterALBOptions *V2GetClusterALBOptions) (result *VpcALBConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2GetClusterALBOptions, "v2GetClusterALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2GetClusterALBOptions, "v2GetClusterALBOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/getAlb`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2GetClusterALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2GetClusterALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("albID", fmt.Sprint(*v2GetClusterALBOptions.AlbID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVpcALBConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSupportedImages : List supported Ingress controller images
// List the community Kubernetes Ingress controller and IBM Cloud Kubernetes Service ALB images that are supported.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSupportedImages(getSupportedImagesOptions *GetSupportedImagesOptions) (result []string, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSupportedImagesWithContext(context.Background(), getSupportedImagesOptions)
}

// GetSupportedImagesWithContext is an alternate form of the GetSupportedImages method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSupportedImagesWithContext(ctx context.Context, getSupportedImagesOptions *GetSupportedImagesOptions) (result []string, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getSupportedImagesOptions, "getSupportedImagesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/getAlbImages`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSupportedImagesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSupportedImages")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, &result)

	return
}

// V2GetClusterALBs : List all ALBs in a cluster
// List all ALBs in a VPC or classic cluster. A `ClusterALB` response will be returned for classic clusters.
//
// Note: If no ALB IDs are returned for a VPC cluster, no VPC load balancer exists for the ALBs. If no ALB IDs are
// returned for a classic cluster, no available portable subnet exists in the VLANs that your ALBs are on.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetClusterALBs(v2GetClusterALBsOptions *V2GetClusterALBsOptions) (result *VpcClusterALB, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2GetClusterALBsWithContext(context.Background(), v2GetClusterALBsOptions)
}

// V2GetClusterALBsWithContext is an alternate form of the V2GetClusterALBs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetClusterALBsWithContext(ctx context.Context, v2GetClusterALBsOptions *V2GetClusterALBsOptions) (result *VpcClusterALB, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2GetClusterALBsOptions, "v2GetClusterALBsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2GetClusterALBsOptions, "v2GetClusterALBsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/getClusterAlbs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2GetClusterALBsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2GetClusterALBs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if v2GetClusterALBsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2GetClusterALBsOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*v2GetClusterALBsOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVpcClusterALB)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetMigrationStatus : Get the status of the migration process
// Check the status of the migration of your IBM Cloud Ingress configmap and resources to the Kubernetes Ingress format.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMigrationStatus(getMigrationStatusOptions *GetMigrationStatusOptions) (result *MigrationStatus, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetMigrationStatusWithContext(context.Background(), getMigrationStatusOptions)
}

// GetMigrationStatusWithContext is an alternate form of the GetMigrationStatus method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMigrationStatusWithContext(ctx context.Context, getMigrationStatusOptions *GetMigrationStatusOptions) (result *MigrationStatus, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getMigrationStatusOptions, "getMigrationStatusOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getMigrationStatusOptions, "getMigrationStatusOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/getMigrationStatus`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getMigrationStatusOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetMigrationStatus")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("cluster", fmt.Sprint(*getMigrationStatusOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMigrationStatus)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetStatus : Get the status of the ingress resources in a cluster
// Check the status of the IBM provided subdomain and application load balancers.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStatus(getStatusOptions *GetStatusOptions) (result *IngressStatus, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetStatusWithContext(context.Background(), getStatusOptions)
}

// GetStatusWithContext is an alternate form of the GetStatus method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStatusWithContext(ctx context.Context, getStatusOptions *GetStatusOptions) (result *IngressStatus, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getStatusOptions, "getStatusOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getStatusOptions, "getStatusOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/getStatus`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStatusOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetStatus")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("cluster", fmt.Sprint(*getStatusOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIngressStatus)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// StartMigration : Start a migration of your IBM Cloud Ingress ConfigMap and Ingress resources to the Kubernetes Ingress format
// Start a `test`, `test-with-private` or `production` migration of your IBM Cloud Ingress configmap and resources to
// use with ALBs that run the Kubernetes Ingress image. This call does not change the image type of your ALBs. For more
// info, see https://cloud.ibm.com/docs/containers?topic=containers-ingress-types.
func (kubernetesServiceApi *KubernetesServiceApiV1) StartMigration(startMigrationOptions *StartMigrationOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.StartMigrationWithContext(context.Background(), startMigrationOptions)
}

// StartMigrationWithContext is an alternate form of the StartMigration method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) StartMigrationWithContext(ctx context.Context, startMigrationOptions *StartMigrationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(startMigrationOptions, "startMigrationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(startMigrationOptions, "startMigrationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/startMigration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range startMigrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "StartMigration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if startMigrationOptions.Cluster != nil {
		body["cluster"] = startMigrationOptions.Cluster
	}
	if startMigrationOptions.Options != nil {
		body["options"] = startMigrationOptions.Options
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2UpdateALB : Update ALBs in a cluster
// Update one or more public or private ALBs to a supported IBM Cloud Kubernetes Service ALB image or a supported
// community Kubernetes Ingress controller image. To update your ALB to a specified image version, automatic updates
// must be disabled. You can check the automatic update status by using the GET
// /v1/alb/clusters/{idOrName}/updatepolicy call. NOTE: You cannot use this call to switch your ALB from one type
// of image to another, such as from an IBM Cloud Kubernetes Service ALB image to a community Kubernetes Ingress
// controller image. Instead, first disable the ALB by using the DELETE /v1/alb/albs/{albID} call (classic) or the
// POST /v2/alb/vpc/disableAlb call (VPC). Then, enable the ALB by using the POST /v1/alb/albs (classic) or POST
// /v2/alb/vpc/enableAlb (VPC) call, and include the ALB image that you want to switch to in the input parameter.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2UpdateALB(v2UpdateALBOptions *V2UpdateALBOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2UpdateALBWithContext(context.Background(), v2UpdateALBOptions)
}

// V2UpdateALBWithContext is an alternate form of the V2UpdateALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2UpdateALBWithContext(ctx context.Context, v2UpdateALBOptions *V2UpdateALBOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2UpdateALBOptions, "v2UpdateALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2UpdateALBOptions, "v2UpdateALBOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/updateAlb`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2UpdateALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2UpdateALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if v2UpdateALBOptions.AlbBuild != nil {
		body["albBuild"] = v2UpdateALBOptions.AlbBuild
	}
	if v2UpdateALBOptions.AlbList != nil {
		body["albList"] = v2UpdateALBOptions.AlbList
	}
	if v2UpdateALBOptions.Cluster != nil {
		body["cluster"] = v2UpdateALBOptions.Cluster
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// VpcCreateALB : Create a public or private ALB in a specified zone and VPC cluster
// Create a new public or private ALB in a specified zone and VPC cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcCreateALB(vpcCreateALBOptions *VpcCreateALBOptions) (result *AlbCreateResp, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcCreateALBWithContext(context.Background(), vpcCreateALBOptions)
}

// VpcCreateALBWithContext is an alternate form of the VpcCreateALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcCreateALBWithContext(ctx context.Context, vpcCreateALBOptions *VpcCreateALBOptions) (result *AlbCreateResp, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcCreateALBOptions, "vpcCreateALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcCreateALBOptions, "vpcCreateALBOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/vpc/createAlb`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcCreateALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcCreateALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if vpcCreateALBOptions.Cluster != nil {
		body["cluster"] = vpcCreateALBOptions.Cluster
	}
	if vpcCreateALBOptions.EnableByDefault != nil {
		body["enableByDefault"] = vpcCreateALBOptions.EnableByDefault
	}
	if vpcCreateALBOptions.IngressImage != nil {
		body["ingressImage"] = vpcCreateALBOptions.IngressImage
	}
	if vpcCreateALBOptions.Type != nil {
		body["type"] = vpcCreateALBOptions.Type
	}
	if vpcCreateALBOptions.Zone != nil {
		body["zone"] = vpcCreateALBOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAlbCreateResp)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcDisableALB : Disable an ALB in your VPC cluster
// Disable a public or private ALB in your VPC cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcDisableALB(vpcDisableALBOptions *VpcDisableALBOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcDisableALBWithContext(context.Background(), vpcDisableALBOptions)
}

// VpcDisableALBWithContext is an alternate form of the VpcDisableALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcDisableALBWithContext(ctx context.Context, vpcDisableALBOptions *VpcDisableALBOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcDisableALBOptions, "vpcDisableALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcDisableALBOptions, "vpcDisableALBOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/vpc/disableAlb`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcDisableALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcDisableALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if vpcDisableALBOptions.AlbBuild != nil {
		body["albBuild"] = vpcDisableALBOptions.AlbBuild
	}
	if vpcDisableALBOptions.AlbID != nil {
		body["albID"] = vpcDisableALBOptions.AlbID
	}
	if vpcDisableALBOptions.AlbType != nil {
		body["albType"] = vpcDisableALBOptions.AlbType
	}
	if vpcDisableALBOptions.AuthBuild != nil {
		body["authBuild"] = vpcDisableALBOptions.AuthBuild
	}
	if vpcDisableALBOptions.Cluster != nil {
		body["cluster"] = vpcDisableALBOptions.Cluster
	}
	if vpcDisableALBOptions.CreatedDate != nil {
		body["createdDate"] = vpcDisableALBOptions.CreatedDate
	}
	if vpcDisableALBOptions.DisableDeployment != nil {
		body["disableDeployment"] = vpcDisableALBOptions.DisableDeployment
	}
	if vpcDisableALBOptions.Enable != nil {
		body["enable"] = vpcDisableALBOptions.Enable
	}
	if vpcDisableALBOptions.LoadBalancerHostname != nil {
		body["loadBalancerHostname"] = vpcDisableALBOptions.LoadBalancerHostname
	}
	if vpcDisableALBOptions.Name != nil {
		body["name"] = vpcDisableALBOptions.Name
	}
	if vpcDisableALBOptions.NumOfInstances != nil {
		body["numOfInstances"] = vpcDisableALBOptions.NumOfInstances
	}
	if vpcDisableALBOptions.Resize != nil {
		body["resize"] = vpcDisableALBOptions.Resize
	}
	if vpcDisableALBOptions.State != nil {
		body["state"] = vpcDisableALBOptions.State
	}
	if vpcDisableALBOptions.Status != nil {
		body["status"] = vpcDisableALBOptions.Status
	}
	if vpcDisableALBOptions.Zone != nil {
		body["zone"] = vpcDisableALBOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// VpcEnableALB : Enable an existing ALB in a VPC cluster
// Enable a public or private ALB in your VPC cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcEnableALB(vpcEnableALBOptions *VpcEnableALBOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcEnableALBWithContext(context.Background(), vpcEnableALBOptions)
}

// VpcEnableALBWithContext is an alternate form of the VpcEnableALB method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcEnableALBWithContext(ctx context.Context, vpcEnableALBOptions *VpcEnableALBOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcEnableALBOptions, "vpcEnableALBOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcEnableALBOptions, "vpcEnableALBOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/alb/vpc/enableAlb`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcEnableALBOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcEnableALB")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if vpcEnableALBOptions.AlbBuild != nil {
		body["albBuild"] = vpcEnableALBOptions.AlbBuild
	}
	if vpcEnableALBOptions.AlbID != nil {
		body["albID"] = vpcEnableALBOptions.AlbID
	}
	if vpcEnableALBOptions.AlbType != nil {
		body["albType"] = vpcEnableALBOptions.AlbType
	}
	if vpcEnableALBOptions.AuthBuild != nil {
		body["authBuild"] = vpcEnableALBOptions.AuthBuild
	}
	if vpcEnableALBOptions.Cluster != nil {
		body["cluster"] = vpcEnableALBOptions.Cluster
	}
	if vpcEnableALBOptions.CreatedDate != nil {
		body["createdDate"] = vpcEnableALBOptions.CreatedDate
	}
	if vpcEnableALBOptions.DisableDeployment != nil {
		body["disableDeployment"] = vpcEnableALBOptions.DisableDeployment
	}
	if vpcEnableALBOptions.Enable != nil {
		body["enable"] = vpcEnableALBOptions.Enable
	}
	if vpcEnableALBOptions.LoadBalancerHostname != nil {
		body["loadBalancerHostname"] = vpcEnableALBOptions.LoadBalancerHostname
	}
	if vpcEnableALBOptions.Name != nil {
		body["name"] = vpcEnableALBOptions.Name
	}
	if vpcEnableALBOptions.NumOfInstances != nil {
		body["numOfInstances"] = vpcEnableALBOptions.NumOfInstances
	}
	if vpcEnableALBOptions.Resize != nil {
		body["resize"] = vpcEnableALBOptions.Resize
	}
	if vpcEnableALBOptions.State != nil {
		body["state"] = vpcEnableALBOptions.State
	}
	if vpcEnableALBOptions.Status != nil {
		body["status"] = vpcEnableALBOptions.Status
	}
	if vpcEnableALBOptions.Zone != nil {
		body["zone"] = vpcEnableALBOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2DisablePrivateServiceEndpoint : Disables a private service endpoint for a cluster
func (kubernetesServiceApi *KubernetesServiceApiV1) V2DisablePrivateServiceEndpoint(v2DisablePrivateServiceEndpointOptions *V2DisablePrivateServiceEndpointOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2DisablePrivateServiceEndpointWithContext(context.Background(), v2DisablePrivateServiceEndpointOptions)
}

// V2DisablePrivateServiceEndpointWithContext is an alternate form of the V2DisablePrivateServiceEndpoint method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2DisablePrivateServiceEndpointWithContext(ctx context.Context, v2DisablePrivateServiceEndpointOptions *V2DisablePrivateServiceEndpointOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2DisablePrivateServiceEndpointOptions, "v2DisablePrivateServiceEndpointOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2DisablePrivateServiceEndpointOptions, "v2DisablePrivateServiceEndpointOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/disablePrivateServiceEndpoint`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2DisablePrivateServiceEndpointOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2DisablePrivateServiceEndpoint")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2DisablePrivateServiceEndpointOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2DisablePrivateServiceEndpointOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2DisablePrivateServiceEndpointOptions.Cluster != nil {
		body["cluster"] = v2DisablePrivateServiceEndpointOptions.Cluster
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2DisablePublicServiceEndpoint : Disables a public service endpoint for a cluster
func (kubernetesServiceApi *KubernetesServiceApiV1) V2DisablePublicServiceEndpoint(v2DisablePublicServiceEndpointOptions *V2DisablePublicServiceEndpointOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2DisablePublicServiceEndpointWithContext(context.Background(), v2DisablePublicServiceEndpointOptions)
}

// V2DisablePublicServiceEndpointWithContext is an alternate form of the V2DisablePublicServiceEndpoint method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2DisablePublicServiceEndpointWithContext(ctx context.Context, v2DisablePublicServiceEndpointOptions *V2DisablePublicServiceEndpointOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2DisablePublicServiceEndpointOptions, "v2DisablePublicServiceEndpointOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2DisablePublicServiceEndpointOptions, "v2DisablePublicServiceEndpointOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/disablePublicServiceEndpoint`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2DisablePublicServiceEndpointOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2DisablePublicServiceEndpoint")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2DisablePublicServiceEndpointOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2DisablePublicServiceEndpointOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2DisablePublicServiceEndpointOptions.Cluster != nil {
		body["cluster"] = v2DisablePublicServiceEndpointOptions.Cluster
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2EnablePrivateServiceEndpoint : Enables the private service endpoint for a cluster
func (kubernetesServiceApi *KubernetesServiceApiV1) V2EnablePrivateServiceEndpoint(v2EnablePrivateServiceEndpointOptions *V2EnablePrivateServiceEndpointOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2EnablePrivateServiceEndpointWithContext(context.Background(), v2EnablePrivateServiceEndpointOptions)
}

// V2EnablePrivateServiceEndpointWithContext is an alternate form of the V2EnablePrivateServiceEndpoint method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2EnablePrivateServiceEndpointWithContext(ctx context.Context, v2EnablePrivateServiceEndpointOptions *V2EnablePrivateServiceEndpointOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2EnablePrivateServiceEndpointOptions, "v2EnablePrivateServiceEndpointOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2EnablePrivateServiceEndpointOptions, "v2EnablePrivateServiceEndpointOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/enablePrivateServiceEndpoint`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2EnablePrivateServiceEndpointOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2EnablePrivateServiceEndpoint")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2EnablePrivateServiceEndpointOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2EnablePrivateServiceEndpointOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2EnablePrivateServiceEndpointOptions.Cluster != nil {
		body["cluster"] = v2EnablePrivateServiceEndpointOptions.Cluster
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2EnablePublicServiceEndpoint : Enables the public service endpoint for a cluster
func (kubernetesServiceApi *KubernetesServiceApiV1) V2EnablePublicServiceEndpoint(v2EnablePublicServiceEndpointOptions *V2EnablePublicServiceEndpointOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2EnablePublicServiceEndpointWithContext(context.Background(), v2EnablePublicServiceEndpointOptions)
}

// V2EnablePublicServiceEndpointWithContext is an alternate form of the V2EnablePublicServiceEndpoint method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2EnablePublicServiceEndpointWithContext(ctx context.Context, v2EnablePublicServiceEndpointOptions *V2EnablePublicServiceEndpointOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2EnablePublicServiceEndpointOptions, "v2EnablePublicServiceEndpointOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2EnablePublicServiceEndpointOptions, "v2EnablePublicServiceEndpointOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/enablePublicServiceEndpoint`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2EnablePublicServiceEndpointOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2EnablePublicServiceEndpoint")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2EnablePublicServiceEndpointOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2EnablePublicServiceEndpointOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2EnablePublicServiceEndpointOptions.Cluster != nil {
		body["cluster"] = v2EnablePublicServiceEndpointOptions.Cluster
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2EnablePullSecret : The V2EnablePullSecret operation.
// Enables registry pull secrets for a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2EnablePullSecret(v2EnablePullSecretOptions *V2EnablePullSecretOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2EnablePullSecretWithContext(context.Background(), v2EnablePullSecretOptions)
}

// V2EnablePullSecretWithContext is an alternate form of the V2EnablePullSecret method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2EnablePullSecretWithContext(ctx context.Context, v2EnablePullSecretOptions *V2EnablePullSecretOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2EnablePullSecretOptions, "v2EnablePullSecretOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2EnablePullSecretOptions, "v2EnablePullSecretOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/enablePullSecret`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2EnablePullSecretOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2EnablePullSecret")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2EnablePullSecretOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2EnablePullSecretOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2EnablePullSecretOptions.Cluster != nil {
		body["cluster"] = v2EnablePullSecretOptions.Cluster
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2GetVersions : List available IBM Cloud Kubernetes Service versions
// List available IBM Cloud Kubernetes Service versions that you can use to create a cluster in a region. The container
// management platform version that you select is installed on your cluster master and worker nodes. Later, you can
// update the version but cannot roll back to a previous version or switch to a different container management platform.
// If you want to use multiple versions, create a separate cluster for each version.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetVersions(v2GetVersionsOptions *V2GetVersionsOptions) (result []IKSVersion, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2GetVersionsWithContext(context.Background(), v2GetVersionsOptions)
}

// V2GetVersionsWithContext is an alternate form of the V2GetVersions method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetVersionsWithContext(ctx context.Context, v2GetVersionsOptions *V2GetVersionsOptions) (result []IKSVersion, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(v2GetVersionsOptions, "v2GetVersionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getVersions`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2GetVersionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2GetVersions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIKSVersion)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteSecret : Remove a secret from an NLB subdomain
// Delete a secret from an NLB subdomain in your cluster and prevent future renewal of the certificate. You might remove
// the secret from an NLB subdomain if you no longer use the subdomain or disassociate it from your NLB IP addresses.
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteSecret(deleteSecretOptions *DeleteSecretOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteSecretWithContext(context.Background(), deleteSecretOptions)
}

// DeleteSecretWithContext is an alternate form of the DeleteSecret method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteSecretWithContext(ctx context.Context, deleteSecretOptions *DeleteSecretOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteSecretOptions, "deleteSecretOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteSecretOptions, "deleteSecretOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/nlb-dns/deleteSecret`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteSecretOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteSecret")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if deleteSecretOptions.Cluster != nil {
		body["cluster"] = deleteSecretOptions.Cluster
	}
	if deleteSecretOptions.Subdomain != nil {
		body["subdomain"] = deleteSecretOptions.Subdomain
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetNlbDNSList : List registered NLB subdomains in a cluster
// List NLB subdomains and either the NLB IP addresses (classic clusters) or the load balancer hostnames (VPC clusters)
// that are registered with the DNS provider for each NLB subdomain.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetNlbDNSList(getNlbDNSListOptions *GetNlbDNSListOptions) (result []NlbVPCListConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetNlbDNSListWithContext(context.Background(), getNlbDNSListOptions)
}

// GetNlbDNSListWithContext is an alternate form of the GetNlbDNSList method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetNlbDNSListWithContext(ctx context.Context, getNlbDNSListOptions *GetNlbDNSListOptions) (result []NlbVPCListConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNlbDNSListOptions, "getNlbDNSListOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNlbDNSListOptions, "getNlbDNSListOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/nlb-dns/getNlbDNSList`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNlbDNSListOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetNlbDNSList")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("cluster", fmt.Sprint(*getNlbDNSListOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNlbVPCListConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSatLocationNlbDNSList : List registered NLB subdomains in a Satellite location
// Get the details for the NLB subdomains along with the NLB IP addresses or CNAME records that are registered with the
// DNS provider for each NLB subdomain. Your Satellite location has a set of hosts that run control plane operations to
// manage your Satellite components across all the clusters in the location. If your location becomes unavailable, you
// might use the NLB subdomain and IP address details of the hosts to help troubleshoot.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatLocationNlbDNSList(getSatLocationNlbDNSListOptions *GetSatLocationNlbDNSListOptions) (result []NlbVPCListConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSatLocationNlbDNSListWithContext(context.Background(), getSatLocationNlbDNSListOptions)
}

// GetSatLocationNlbDNSListWithContext is an alternate form of the GetSatLocationNlbDNSList method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatLocationNlbDNSListWithContext(ctx context.Context, getSatLocationNlbDNSListOptions *GetSatLocationNlbDNSListOptions) (result []NlbVPCListConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSatLocationNlbDNSListOptions, "getSatLocationNlbDNSListOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSatLocationNlbDNSListOptions, "getSatLocationNlbDNSListOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/nlb-dns/getSatLocationSubdomains`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSatLocationNlbDNSListOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSatLocationNlbDNSList")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("controller", fmt.Sprint(*getSatLocationNlbDNSListOptions.Controller))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNlbVPCListConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RegenerateCert : Regenerates cert for secret
// Regenerate the certificate and recreate the secret for an NLB subdomain. You might regenerate an NLB subdomain's
// certificate and secret if you previously deleted the secret.
func (kubernetesServiceApi *KubernetesServiceApiV1) RegenerateCert(regenerateCertOptions *RegenerateCertOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RegenerateCertWithContext(context.Background(), regenerateCertOptions)
}

// RegenerateCertWithContext is an alternate form of the RegenerateCert method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RegenerateCertWithContext(ctx context.Context, regenerateCertOptions *RegenerateCertOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(regenerateCertOptions, "regenerateCertOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(regenerateCertOptions, "regenerateCertOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/nlb-dns/regenerateCert`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range regenerateCertOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RegenerateCert")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if regenerateCertOptions.Cluster != nil {
		body["cluster"] = regenerateCertOptions.Cluster
	}
	if regenerateCertOptions.Subdomain != nil {
		body["subdomain"] = regenerateCertOptions.Subdomain
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RegisterMultishiftCluster : Registers domains: c001, c002, c003, each tied to a corresponding IP and c000 tied to all of the IPs for the cluster. Also registers 1 cname, ce00, for the specified multishift cluster
// Registers Multishift domains for a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) RegisterMultishiftCluster(registerMultishiftClusterOptions *RegisterMultishiftClusterOptions) (result *MSCRegisterResp, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RegisterMultishiftClusterWithContext(context.Background(), registerMultishiftClusterOptions)
}

// RegisterMultishiftClusterWithContext is an alternate form of the RegisterMultishiftCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RegisterMultishiftClusterWithContext(ctx context.Context, registerMultishiftClusterOptions *RegisterMultishiftClusterOptions) (result *MSCRegisterResp, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(registerMultishiftClusterOptions, "registerMultishiftClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(registerMultishiftClusterOptions, "registerMultishiftClusterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/nlb-dns/registerMSCDomains`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range registerMultishiftClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RegisterMultishiftCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if registerMultishiftClusterOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*registerMultishiftClusterOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if registerMultishiftClusterOptions.Controller != nil {
		body["controller"] = registerMultishiftClusterOptions.Controller
	}
	if registerMultishiftClusterOptions.Ips != nil {
		body["ips"] = registerMultishiftClusterOptions.Ips
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMSCRegisterResp)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ReplaceLBHostname : Update the DNS record for an NLB subdomain by replacing the load balancer hostname
// In a VPC cluster, update the DNS record for an NLB subdomain by replacing the load balancer hostname that is
// currently associated with the NLB subdomain with another load balancer hostname. Only one load balancer hostname can
// be associated with an NLB DNS record at a time.
func (kubernetesServiceApi *KubernetesServiceApiV1) ReplaceLBHostname(replaceLBHostnameOptions *ReplaceLBHostnameOptions) (result *NlbVPCConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ReplaceLBHostnameWithContext(context.Background(), replaceLBHostnameOptions)
}

// ReplaceLBHostnameWithContext is an alternate form of the ReplaceLBHostname method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ReplaceLBHostnameWithContext(ctx context.Context, replaceLBHostnameOptions *ReplaceLBHostnameOptions) (result *NlbVPCConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceLBHostnameOptions, "replaceLBHostnameOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceLBHostnameOptions, "replaceLBHostnameOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/nlb-dns/vpc/ReplaceLBHostname`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceLBHostnameOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ReplaceLBHostname")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if replaceLBHostnameOptions.Cluster != nil {
		body["cluster"] = replaceLBHostnameOptions.Cluster
	}
	if replaceLBHostnameOptions.LbHostname != nil {
		body["lbHostname"] = replaceLBHostnameOptions.LbHostname
	}
	if replaceLBHostnameOptions.NlbSubdomain != nil {
		body["nlbSubdomain"] = replaceLBHostnameOptions.NlbSubdomain
	}
	if replaceLBHostnameOptions.SecretNamespace != nil {
		body["secretNamespace"] = replaceLBHostnameOptions.SecretNamespace
	}
	if replaceLBHostnameOptions.Type != nil {
		body["type"] = replaceLBHostnameOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNlbVPCConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateNlbDNS : Create a new NLB subdomain in a VPC cluster and associate a load balancer hostname with it
// In a VPC cluster, create a new NLB subdomain and register a VPC load balancer hostname with the DNS provider. Note
// that you can create the NLB subdomain with only one VPC load balancer hostname. If the registration fails, an error
// from the DNS provider is returned.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateNlbDNS(createNlbDNSOptions *CreateNlbDNSOptions) (result *NlbVPCConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateNlbDNSWithContext(context.Background(), createNlbDNSOptions)
}

// CreateNlbDNSWithContext is an alternate form of the CreateNlbDNS method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateNlbDNSWithContext(ctx context.Context, createNlbDNSOptions *CreateNlbDNSOptions) (result *NlbVPCConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createNlbDNSOptions, "createNlbDNSOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createNlbDNSOptions, "createNlbDNSOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/nlb-dns/vpc/createNlbDNS`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createNlbDNSOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateNlbDNS")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createNlbDNSOptions.Cluster != nil {
		body["cluster"] = createNlbDNSOptions.Cluster
	}
	if createNlbDNSOptions.LbHostname != nil {
		body["lbHostname"] = createNlbDNSOptions.LbHostname
	}
	if createNlbDNSOptions.NlbSubdomain != nil {
		body["nlbSubdomain"] = createNlbDNSOptions.NlbSubdomain
	}
	if createNlbDNSOptions.SecretNamespace != nil {
		body["secretNamespace"] = createNlbDNSOptions.SecretNamespace
	}
	if createNlbDNSOptions.Type != nil {
		body["type"] = createNlbDNSOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNlbVPCConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveLBHostname : Remove the load balancer hostname from the DNS record for an existing NLB subdomain
// In a VPC cluster, remove a load balancer hostname from the DNS record for an existing NLB subdomain. After you remove
// the load balancer hostname, the NLB subdomain still exists, but no load balancer is associated with it.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveLBHostname(removeLBHostnameOptions *RemoveLBHostnameOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveLBHostnameWithContext(context.Background(), removeLBHostnameOptions)
}

// RemoveLBHostnameWithContext is an alternate form of the RemoveLBHostname method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveLBHostnameWithContext(ctx context.Context, removeLBHostnameOptions *RemoveLBHostnameOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeLBHostnameOptions, "removeLBHostnameOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeLBHostnameOptions, "removeLBHostnameOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/nlb-dns/vpc/removeLBHostname`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeLBHostnameOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveLBHostname")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if removeLBHostnameOptions.Cluster != nil {
		body["cluster"] = removeLBHostnameOptions.Cluster
	}
	if removeLBHostnameOptions.LbHostname != nil {
		body["lbHostname"] = removeLBHostnameOptions.LbHostname
	}
	if removeLBHostnameOptions.NlbSubdomain != nil {
		body["nlbSubdomain"] = removeLBHostnameOptions.NlbSubdomain
	}
	if removeLBHostnameOptions.SecretNamespace != nil {
		body["secretNamespace"] = removeLBHostnameOptions.SecretNamespace
	}
	if removeLBHostnameOptions.Type != nil {
		body["type"] = removeLBHostnameOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// ReplaceWorker : Replace a worker node with a new worker node
// Delete the specified worker node from the cluster and create a new worker node in the same worker pool to replace the
// deleted worker node. The new worker node is assigned new public or private IP addresses. When the worker node is
// deleted, it is cordoned and drained to reschedule the pods that run on the worker node before deleting it, to avoid
// downtime for your apps. You might replace a worker node if you cannot reload or update the worker node, such as if it
// enters a troubled state.
func (kubernetesServiceApi *KubernetesServiceApiV1) ReplaceWorker(replaceWorkerOptions *ReplaceWorkerOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ReplaceWorkerWithContext(context.Background(), replaceWorkerOptions)
}

// ReplaceWorkerWithContext is an alternate form of the ReplaceWorker method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ReplaceWorkerWithContext(ctx context.Context, replaceWorkerOptions *ReplaceWorkerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(replaceWorkerOptions, "replaceWorkerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(replaceWorkerOptions, "replaceWorkerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/replaceWorker`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range replaceWorkerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ReplaceWorker")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if replaceWorkerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*replaceWorkerOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if replaceWorkerOptions.Cluster != nil {
		body["cluster"] = replaceWorkerOptions.Cluster
	}
	if replaceWorkerOptions.Update != nil {
		body["update"] = replaceWorkerOptions.Update
	}
	if replaceWorkerOptions.WorkerID != nil {
		body["workerID"] = replaceWorkerOptions.WorkerID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2UpdateMaster : Update the version of the Kubernetes cluster master node
// Update the Kubernetes master to the default API version. During the update, you cannot access or change the cluster.
// Worker nodes, apps, and resources that have been deployed by the user are not modified and will continue to run. You
// might need to change your YAML files for future deployments. For details, see the release notes at
// https://cloud.ibm.com/docs/containers?topic=containers-cs_versions.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2UpdateMaster(v2UpdateMasterOptions *V2UpdateMasterOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2UpdateMasterWithContext(context.Background(), v2UpdateMasterOptions)
}

// V2UpdateMasterWithContext is an alternate form of the V2UpdateMaster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2UpdateMasterWithContext(ctx context.Context, v2UpdateMasterOptions *V2UpdateMasterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2UpdateMasterOptions, "v2UpdateMasterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2UpdateMasterOptions, "v2UpdateMasterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/updateMaster`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2UpdateMasterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2UpdateMaster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2UpdateMasterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2UpdateMasterOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2UpdateMasterOptions.Cluster != nil {
		body["cluster"] = v2UpdateMasterOptions.Cluster
	}
	if v2UpdateMasterOptions.Force != nil {
		body["force"] = v2UpdateMasterOptions.Force
	}
	if v2UpdateMasterOptions.Version != nil {
		body["version"] = v2UpdateMasterOptions.Version
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetClusters : List the clusters that you have access to
// List the clusters that you have access to.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusters(getClustersOptions *GetClustersOptions) (result []Cluster, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClustersWithContext(context.Background(), getClustersOptions)
}

// GetClustersWithContext is an alternate form of the GetClusters method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClustersWithContext(ctx context.Context, getClustersOptions *GetClustersOptions) (result []Cluster, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getClustersOptions, "getClustersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClustersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClustersOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClustersOptions.XAuthResourceGroup))
	}

	if getClustersOptions.Location != nil {
		builder.AddQuery("location", fmt.Sprint(*getClustersOptions.Location))
	}
	if getClustersOptions.ShowResources != nil {
		builder.AddQuery("showResources", fmt.Sprint(*getClustersOptions.ShowResources))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCluster)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateCluster : Create a cluster
// Create a cluster in the IBM Cloud account that you are logged into. Note: This call requires Administrator platform
// role for IBM Cloud Kubernetes Service at the account level, the Administrator platform role for IBM Cloud Container
// Registry at the account level, and the Super User role for IBM Cloud infrastructure (SoftLayer).
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateCluster(createClusterOptions *CreateClusterOptions) (result *ClusterCreateResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateClusterWithContext(context.Background(), createClusterOptions)
}

// CreateClusterWithContext is an alternate form of the CreateCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateClusterWithContext(ctx context.Context, createClusterOptions *CreateClusterOptions) (result *ClusterCreateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createClusterOptions, "createClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createClusterOptions, "createClusterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createClusterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*createClusterOptions.XAuthResourceGroup))
	}
	if createClusterOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*createClusterOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if createClusterOptions.CseAclEnabled != nil {
		body["cseAclEnabled"] = createClusterOptions.CseAclEnabled
	}
	if createClusterOptions.DataCenter != nil {
		body["dataCenter"] = createClusterOptions.DataCenter
	}
	if createClusterOptions.DefaultWorkerPoolEntitlement != nil {
		body["defaultWorkerPoolEntitlement"] = createClusterOptions.DefaultWorkerPoolEntitlement
	}
	if createClusterOptions.DefaultWorkerPoolName != nil {
		body["defaultWorkerPoolName"] = createClusterOptions.DefaultWorkerPoolName
	}
	if createClusterOptions.DisableAutoUpdate != nil {
		body["disableAutoUpdate"] = createClusterOptions.DisableAutoUpdate
	}
	if createClusterOptions.DiskEncryption != nil {
		body["diskEncryption"] = createClusterOptions.DiskEncryption
	}
	if createClusterOptions.GatewayEnabled != nil {
		body["gatewayEnabled"] = createClusterOptions.GatewayEnabled
	}
	if createClusterOptions.Isolation != nil {
		body["isolation"] = createClusterOptions.Isolation
	}
	if createClusterOptions.MachineType != nil {
		body["machineType"] = createClusterOptions.MachineType
	}
	if createClusterOptions.MasterVersion != nil {
		body["masterVersion"] = createClusterOptions.MasterVersion
	}
	if createClusterOptions.Name != nil {
		body["name"] = createClusterOptions.Name
	}
	if createClusterOptions.NoSubnet != nil {
		body["noSubnet"] = createClusterOptions.NoSubnet
	}
	if createClusterOptions.PodSubnet != nil {
		body["podSubnet"] = createClusterOptions.PodSubnet
	}
	if createClusterOptions.Prefix != nil {
		body["prefix"] = createClusterOptions.Prefix
	}
	if createClusterOptions.PrivateSeviceEndpoint != nil {
		body["privateSeviceEndpoint"] = createClusterOptions.PrivateSeviceEndpoint
	}
	if createClusterOptions.PrivateVlan != nil {
		body["privateVlan"] = createClusterOptions.PrivateVlan
	}
	if createClusterOptions.PublicServiceEndpoint != nil {
		body["publicServiceEndpoint"] = createClusterOptions.PublicServiceEndpoint
	}
	if createClusterOptions.PublicVlan != nil {
		body["publicVlan"] = createClusterOptions.PublicVlan
	}
	if createClusterOptions.ServiceSubnet != nil {
		body["serviceSubnet"] = createClusterOptions.ServiceSubnet
	}
	if createClusterOptions.SkipPermPrecheck != nil {
		body["skipPermPrecheck"] = createClusterOptions.SkipPermPrecheck
	}
	if createClusterOptions.WorkerNum != nil {
		body["workerNum"] = createClusterOptions.WorkerNum
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterCreateResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetCluster1 : View details for a cluster
// View detailed information for a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetCluster1(getCluster1Options *GetCluster1Options) (result *Cluster, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetCluster1WithContext(context.Background(), getCluster1Options)
}

// GetCluster1WithContext is an alternate form of the GetCluster1 method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetCluster1WithContext(ctx context.Context, getCluster1Options *GetCluster1Options) (result *Cluster, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getCluster1Options, "getCluster1Options cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getCluster1Options, "getCluster1Options")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getCluster1Options.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getCluster1Options.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetCluster1")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getCluster1Options.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getCluster1Options.XAuthResourceGroup))
	}

	if getCluster1Options.ShowResources != nil {
		builder.AddQuery("showResources", fmt.Sprint(*getCluster1Options.ShowResources))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCluster)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateCluster : Update the version of the Kubernetes cluster master node
// Update the Kubernetes master to the default API version. During the update, you cannot access or change the cluster.
// Worker nodes, apps, and resources that have been deployed by the user are not modified and will continue to run. You
// might need to change your YAML files for future deployments. For details, see the release notes at
// https://cloud.ibm.com/docs/containers?topic=containers-cs_versions.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateCluster(updateClusterOptions *UpdateClusterOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateClusterWithContext(context.Background(), updateClusterOptions)
}

// UpdateClusterWithContext is an alternate form of the UpdateCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateClusterWithContext(ctx context.Context, updateClusterOptions *UpdateClusterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateClusterOptions, "updateClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateClusterOptions, "updateClusterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *updateClusterOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if updateClusterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*updateClusterOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if updateClusterOptions.Action != nil {
		body["action"] = updateClusterOptions.Action
	}
	if updateClusterOptions.Force != nil {
		body["force"] = updateClusterOptions.Force
	}
	if updateClusterOptions.Version != nil {
		body["version"] = updateClusterOptions.Version
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RemoveCluster : Delete a cluster
// Delete a cluster from the IBM Cloud account that you are logged in to. When you delete a cluster, all worker nodes,
// apps, and containers are permanently deleted. This action cannot be undone.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveCluster(removeClusterOptions *RemoveClusterOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveClusterWithContext(context.Background(), removeClusterOptions)
}

// RemoveClusterWithContext is an alternate form of the RemoveCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveClusterWithContext(ctx context.Context, removeClusterOptions *RemoveClusterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeClusterOptions, "removeClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeClusterOptions, "removeClusterOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *removeClusterOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if removeClusterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*removeClusterOptions.XAuthResourceGroup))
	}

	if removeClusterOptions.DeleteResources != nil {
		builder.AddQuery("deleteResources", fmt.Sprint(*removeClusterOptions.DeleteResources))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetClusterAddons : View details of the add-ons that are enabled in a cluster
// View details of the add-ons that are enabled in a cluster, including the add-on versions.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterAddons(getClusterAddonsOptions *GetClusterAddonsOptions) (result []ClusterAddon, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterAddonsWithContext(context.Background(), getClusterAddonsOptions)
}

// GetClusterAddonsWithContext is an alternate form of the GetClusterAddons method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterAddonsWithContext(ctx context.Context, getClusterAddonsOptions *GetClusterAddonsOptions) (result []ClusterAddon, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterAddonsOptions, "getClusterAddonsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterAddonsOptions, "getClusterAddonsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterAddonsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/addons`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterAddonsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterAddons")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterAddonsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterAddonsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterAddon)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ManageClusterAddons : Enable, disable, or update add-ons for a cluster
// Enable, disable, or update add-ons for a cluster. Note: This call requires the Administrator IAM platform role for
// IBM Cloud Kubernetes Service in the account.
func (kubernetesServiceApi *KubernetesServiceApiV1) ManageClusterAddons(manageClusterAddonsOptions *ManageClusterAddonsOptions) (result *AddonResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ManageClusterAddonsWithContext(context.Background(), manageClusterAddonsOptions)
}

// ManageClusterAddonsWithContext is an alternate form of the ManageClusterAddons method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ManageClusterAddonsWithContext(ctx context.Context, manageClusterAddonsOptions *ManageClusterAddonsOptions) (result *AddonResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(manageClusterAddonsOptions, "manageClusterAddonsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(manageClusterAddonsOptions, "manageClusterAddonsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *manageClusterAddonsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/addons`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range manageClusterAddonsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ManageClusterAddons")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if manageClusterAddonsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*manageClusterAddonsOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if manageClusterAddonsOptions.Addons != nil {
		body["addons"] = manageClusterAddonsOptions.Addons
	}
	if manageClusterAddonsOptions.Enable != nil {
		body["enable"] = manageClusterAddonsOptions.Enable
	}
	if manageClusterAddonsOptions.Update != nil {
		body["update"] = manageClusterAddonsOptions.Update
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddonResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetClusterConfig : Get the cluster-specific configuration and certificates
// Get the cluster-specific Kubernetes configuration data and certificates as a tar file to connect to your cluster and
// run Kubernetes API calls. To retrieve the administrator certificates and keys, pass `admin` at the end of the path.
// For example, `/v1/clusters/{idOrName}/config/admin`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterConfig(getClusterConfigOptions *GetClusterConfigOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterConfigWithContext(context.Background(), getClusterConfigOptions)
}

// GetClusterConfigWithContext is an alternate form of the GetClusterConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterConfigWithContext(ctx context.Context, getClusterConfigOptions *GetClusterConfigOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterConfigOptions, "getClusterConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterConfigOptions, "getClusterConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterConfigOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/config`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if getClusterConfigOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*getClusterConfigOptions.XAuthRefreshToken))
	}
	if getClusterConfigOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterConfigOptions.XAuthResourceGroup))
	}

	if getClusterConfigOptions.Sub != nil {
		builder.AddQuery("sub", fmt.Sprint(*getClusterConfigOptions.Sub))
	}
	if getClusterConfigOptions.Format != nil {
		builder.AddQuery("format", fmt.Sprint(*getClusterConfigOptions.Format))
	}
	if getClusterConfigOptions.CreateNetworkConfig != nil {
		builder.AddQuery("createNetworkConfig", fmt.Sprint(*getClusterConfigOptions.CreateNetworkConfig))
	}
	if getClusterConfigOptions.SkipRBAC != nil {
		builder.AddQuery("skipRBAC", fmt.Sprint(*getClusterConfigOptions.SkipRBAC))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateKMSConfig : Create a Key Protect configuration for a cluster
// Create a Key Protect configuration for the key management service (KMS) provider in your cluster. Your Key Protect
// customer root key (CRK) is used to encrypt the Kubernetes secrets within your cluster. After you add Key Protect to
// your cluster, you can update the instance, endpoint, or CRK parameters that are used, but you cannot remove Key
// Protect from your cluster. Note: This call requires Administrator platform role for IBM Cloud Kubernetes Service at
// the account level, the Administrator platform role for IBM Cloud Container Registry at the account level, and the
// Super User role for IBM Cloud infrastructure (SoftLayer).
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateKMSConfig(createKMSConfigOptions *CreateKMSConfigOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateKMSConfigWithContext(context.Background(), createKMSConfigOptions)
}

// CreateKMSConfigWithContext is an alternate form of the CreateKMSConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateKMSConfigWithContext(ctx context.Context, createKMSConfigOptions *CreateKMSConfigOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createKMSConfigOptions, "createKMSConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createKMSConfigOptions, "createKMSConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *createKMSConfigOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/kms`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createKMSConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateKMSConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if createKMSConfigOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*createKMSConfigOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if createKMSConfigOptions.CrkID != nil {
		body["crkID"] = createKMSConfigOptions.CrkID
	}
	if createKMSConfigOptions.InstanceID != nil {
		body["instanceID"] = createKMSConfigOptions.InstanceID
	}
	if createKMSConfigOptions.URL != nil {
		body["url"] = createKMSConfigOptions.URL
	}
	if createKMSConfigOptions.ServiceToService != nil {
		body["serviceToService"] = createKMSConfigOptions.ServiceToService
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// HandleMasterAPIServer : Refresh the Kubernetes master
// Restart the Kubernetes master in the cluster to apply changes to the API server configuration.
func (kubernetesServiceApi *KubernetesServiceApiV1) HandleMasterAPIServer(handleMasterAPIServerOptions *HandleMasterAPIServerOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.HandleMasterAPIServerWithContext(context.Background(), handleMasterAPIServerOptions)
}

// HandleMasterAPIServerWithContext is an alternate form of the HandleMasterAPIServer method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) HandleMasterAPIServerWithContext(ctx context.Context, handleMasterAPIServerOptions *HandleMasterAPIServerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(handleMasterAPIServerOptions, "handleMasterAPIServerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(handleMasterAPIServerOptions, "handleMasterAPIServerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *handleMasterAPIServerOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/masters`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range handleMasterAPIServerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "HandleMasterAPIServer")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if handleMasterAPIServerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*handleMasterAPIServerOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if handleMasterAPIServerOptions.Action != nil {
		body["action"] = handleMasterAPIServerOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// ListServicesForAllNamespaces : List the IBM Cloud services bound to a cluster across all namespaces
// List the IBM Cloud services that are bound all of the Kubernetes namespace in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) ListServicesForAllNamespaces(listServicesForAllNamespacesOptions *ListServicesForAllNamespacesOptions) (result []BoundService, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ListServicesForAllNamespacesWithContext(context.Background(), listServicesForAllNamespacesOptions)
}

// ListServicesForAllNamespacesWithContext is an alternate form of the ListServicesForAllNamespaces method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ListServicesForAllNamespacesWithContext(ctx context.Context, listServicesForAllNamespacesOptions *ListServicesForAllNamespacesOptions) (result []BoundService, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listServicesForAllNamespacesOptions, "listServicesForAllNamespacesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listServicesForAllNamespacesOptions, "listServicesForAllNamespacesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *listServicesForAllNamespacesOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/services`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listServicesForAllNamespacesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ListServicesForAllNamespaces")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if listServicesForAllNamespacesOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*listServicesForAllNamespacesOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBoundService)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// BindServiceToNamespace : Bind an IBM Cloud service to a cluster
// Bind an IBM Cloud service instance to a Kubernetes namespace in your cluster. To view available IBM Cloud services
// from the IBM Cloud catalog, run `ibmcloud catalog search --kind service`. If you already provisioned IBM Cloud
// service instances in an IBM Cloud space, you can list them by running `ibmcloud resource service-instances`. Note:
// You can add only IBM Cloud services that support service keys, and you must add the service in the same resource
// group that the cluster is in.
func (kubernetesServiceApi *KubernetesServiceApiV1) BindServiceToNamespace(bindServiceToNamespaceOptions *BindServiceToNamespaceOptions) (result *BoundService, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.BindServiceToNamespaceWithContext(context.Background(), bindServiceToNamespaceOptions)
}

// BindServiceToNamespaceWithContext is an alternate form of the BindServiceToNamespace method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) BindServiceToNamespaceWithContext(ctx context.Context, bindServiceToNamespaceOptions *BindServiceToNamespaceOptions) (result *BoundService, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(bindServiceToNamespaceOptions, "bindServiceToNamespaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(bindServiceToNamespaceOptions, "bindServiceToNamespaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *bindServiceToNamespaceOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/services`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range bindServiceToNamespaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "BindServiceToNamespace")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if bindServiceToNamespaceOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*bindServiceToNamespaceOptions.XAuthResourceGroup))
	}

	_, err = builder.SetBodyContentJSON(bindServiceToNamespaceOptions.ServiceBindRequest)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBoundService)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListServicesInNamespace : List the IBM Cloud services bound to a specific namespace in a cluster
// List the IBM Cloud services that are bound to a specific Kubernetes namespace in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) ListServicesInNamespace(listServicesInNamespaceOptions *ListServicesInNamespaceOptions) (result []BoundService, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ListServicesInNamespaceWithContext(context.Background(), listServicesInNamespaceOptions)
}

// ListServicesInNamespaceWithContext is an alternate form of the ListServicesInNamespace method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ListServicesInNamespaceWithContext(ctx context.Context, listServicesInNamespaceOptions *ListServicesInNamespaceOptions) (result []BoundService, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listServicesInNamespaceOptions, "listServicesInNamespaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listServicesInNamespaceOptions, "listServicesInNamespaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":  *listServicesInNamespaceOptions.IdOrName,
		"namespace": *listServicesInNamespaceOptions.Namespace,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/services/{namespace}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listServicesInNamespaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ListServicesInNamespace")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if listServicesInNamespaceOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*listServicesInNamespaceOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBoundService)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UnbindServiceFromNamespace : Unbind an IBM Cloud service from a cluster
// Unbind an IBM Cloud service instance from a Kubernetes namespace in your cluster. Note: When you remove an IBM Cloud
// service, the service credentials are removed from the cluster. If a pod is still using the service, it fails because
// the service credentials cannot be found.
func (kubernetesServiceApi *KubernetesServiceApiV1) UnbindServiceFromNamespace(unbindServiceFromNamespaceOptions *UnbindServiceFromNamespaceOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UnbindServiceFromNamespaceWithContext(context.Background(), unbindServiceFromNamespaceOptions)
}

// UnbindServiceFromNamespaceWithContext is an alternate form of the UnbindServiceFromNamespace method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UnbindServiceFromNamespaceWithContext(ctx context.Context, unbindServiceFromNamespaceOptions *UnbindServiceFromNamespaceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(unbindServiceFromNamespaceOptions, "unbindServiceFromNamespaceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(unbindServiceFromNamespaceOptions, "unbindServiceFromNamespaceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":          *unbindServiceFromNamespaceOptions.IdOrName,
		"namespace":         *unbindServiceFromNamespaceOptions.Namespace,
		"serviceInstanceId": *unbindServiceFromNamespaceOptions.ServiceInstanceID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/services/{namespace}/{serviceInstanceId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range unbindServiceFromNamespaceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UnbindServiceFromNamespace")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if unbindServiceFromNamespaceOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*unbindServiceFromNamespaceOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetClusterSubnets : List subnets from your IBM Cloud infrastructure (SoftLayer) account that are bound to a cluster
// List subnets from your IBM Cloud infrastructure (SoftLayer) account that are bound to a cluster. A one time per
// account prerequisite POST to `/v1/credentials` is required.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterSubnets(getClusterSubnetsOptions *GetClusterSubnetsOptions) (result []VlanConfigField, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterSubnetsWithContext(context.Background(), getClusterSubnetsOptions)
}

// GetClusterSubnetsWithContext is an alternate form of the GetClusterSubnets method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterSubnetsWithContext(ctx context.Context, getClusterSubnetsOptions *GetClusterSubnetsOptions) (result []VlanConfigField, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterSubnetsOptions, "getClusterSubnetsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterSubnetsOptions, "getClusterSubnetsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterSubnetsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/subnets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterSubnetsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterSubnets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterSubnetsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterSubnetsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVlanConfigField)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// AddClusterSubnet : Add an existing IBM Cloud infrastructure (SoftLayer) subnet to an existing cluster
// Make an existing subnet available to a Kubernetes cluster. Note: When you make a subnet available to a cluster, IP
// addresses of this subnet are used for cluster networking purposes. To avoid IP address conflicts, make sure that you
// use a subnet with one cluster only. Do not use a subnet for multiple clusters or for other purposes outside of
// Kubernetes Service at the same time.
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterSubnet(addClusterSubnetOptions *AddClusterSubnetOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AddClusterSubnetWithContext(context.Background(), addClusterSubnetOptions)
}

// AddClusterSubnetWithContext is an alternate form of the AddClusterSubnet method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterSubnetWithContext(ctx context.Context, addClusterSubnetOptions *AddClusterSubnetOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addClusterSubnetOptions, "addClusterSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addClusterSubnetOptions, "addClusterSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *addClusterSubnetOptions.IdOrName,
		"subnetId": *addClusterSubnetOptions.SubnetID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/subnets/{subnetId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addClusterSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AddClusterSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if addClusterSubnetOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*addClusterSubnetOptions.XAuthRefreshToken))
	}
	if addClusterSubnetOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*addClusterSubnetOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// DetachClusterSubnet : Detach a public or private portable subnet from a cluster
// Detach a subnet in your IBM Cloud infrastructure (SoftLayer) account from a cluster. The subnet remains available in
// your infrastructure account after it is detached.
func (kubernetesServiceApi *KubernetesServiceApiV1) DetachClusterSubnet(detachClusterSubnetOptions *DetachClusterSubnetOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DetachClusterSubnetWithContext(context.Background(), detachClusterSubnetOptions)
}

// DetachClusterSubnetWithContext is an alternate form of the DetachClusterSubnet method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DetachClusterSubnetWithContext(ctx context.Context, detachClusterSubnetOptions *DetachClusterSubnetOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(detachClusterSubnetOptions, "detachClusterSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(detachClusterSubnetOptions, "detachClusterSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *detachClusterSubnetOptions.IdOrName,
		"subnetId": *detachClusterSubnetOptions.SubnetID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/subnets/{subnetId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range detachClusterSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DetachClusterSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if detachClusterSubnetOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*detachClusterSubnetOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetClusterUserSubnet : List user-managed subnets that are bound to a cluster
// List user-managed subnets that are bound to a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterUserSubnet(getClusterUserSubnetOptions *GetClusterUserSubnetOptions) (result []VlanConfigField, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterUserSubnetWithContext(context.Background(), getClusterUserSubnetOptions)
}

// GetClusterUserSubnetWithContext is an alternate form of the GetClusterUserSubnet method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterUserSubnetWithContext(ctx context.Context, getClusterUserSubnetOptions *GetClusterUserSubnetOptions) (result []VlanConfigField, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterUserSubnetOptions, "getClusterUserSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterUserSubnetOptions, "getClusterUserSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterUserSubnetOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/usersubnets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterUserSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterUserSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterUserSubnetOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterUserSubnetOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVlanConfigField)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// AddClusterUserSubnet : Add an existing user-managed subnet to a cluster
// Make your own private subnet available to an Kubernetes Service cluster. This private subnet is not one provided by
// IBM Cloud infrastructure (SoftLayer). As such, you must configure any inbound and outbound network traffic routing
// for the subnet. Note: When you add a private user subnet to a cluster, IP addresses of this subnet are used for
// private Load Balancers in the cluster. To avoid IP address conflicts, make sure that you use a subnet with one
// cluster only. Do not use a subnet for multiple clusters or for other purposes outside of Kubernetes Service at the
// same time.
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterUserSubnet(addClusterUserSubnetOptions *AddClusterUserSubnetOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AddClusterUserSubnetWithContext(context.Background(), addClusterUserSubnetOptions)
}

// AddClusterUserSubnetWithContext is an alternate form of the AddClusterUserSubnet method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterUserSubnetWithContext(ctx context.Context, addClusterUserSubnetOptions *AddClusterUserSubnetOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addClusterUserSubnetOptions, "addClusterUserSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addClusterUserSubnetOptions, "addClusterUserSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *addClusterUserSubnetOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/usersubnets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addClusterUserSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AddClusterUserSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if addClusterUserSubnetOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*addClusterUserSubnetOptions.XAuthRefreshToken))
	}
	if addClusterUserSubnetOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*addClusterUserSubnetOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if addClusterUserSubnetOptions.Cidr != nil {
		body["cidr"] = addClusterUserSubnetOptions.Cidr
	}
	if addClusterUserSubnetOptions.VlanID != nil {
		body["vlan_id"] = addClusterUserSubnetOptions.VlanID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RemoveClusterUserSubnet : Remove a user-managed subnet from a cluster
// Remove a private user-managed subnet from an Kubernetes Service cluster. Note: Any service that was deployed to an IP
// address from your own private subnet remains active after the subnet is removed.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveClusterUserSubnet(removeClusterUserSubnetOptions *RemoveClusterUserSubnetOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveClusterUserSubnetWithContext(context.Background(), removeClusterUserSubnetOptions)
}

// RemoveClusterUserSubnetWithContext is an alternate form of the RemoveClusterUserSubnet method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveClusterUserSubnetWithContext(ctx context.Context, removeClusterUserSubnetOptions *RemoveClusterUserSubnetOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeClusterUserSubnetOptions, "removeClusterUserSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeClusterUserSubnetOptions, "removeClusterUserSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *removeClusterUserSubnetOptions.IdOrName,
		"subnetId": *removeClusterUserSubnetOptions.SubnetID,
		"vlanId":   *removeClusterUserSubnetOptions.VlanID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/usersubnets/{subnetId}/vlans/{vlanId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeClusterUserSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveClusterUserSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if removeClusterUserSubnetOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*removeClusterUserSubnetOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateClusterSubnet : Create an IBM Cloud infrastructure (SoftLayer) subnet and add it to an existing cluster
// Create a subnet and make it available to a Kubernetes cluster. Note: When you make a subnet available to a cluster,
// IP addresses of this subnet are used for cluster networking purposes. To avoid IP address conflicts, make sure that
// you use a subnet with one cluster only. Do not use a subnet for multiple clusters or for other purposes outside of
// Kubernetes Service at the same time.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateClusterSubnet(createClusterSubnetOptions *CreateClusterSubnetOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateClusterSubnetWithContext(context.Background(), createClusterSubnetOptions)
}

// CreateClusterSubnetWithContext is an alternate form of the CreateClusterSubnet method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateClusterSubnetWithContext(ctx context.Context, createClusterSubnetOptions *CreateClusterSubnetOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createClusterSubnetOptions, "createClusterSubnetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createClusterSubnetOptions, "createClusterSubnetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *createClusterSubnetOptions.IdOrName,
		"vlanId":   *createClusterSubnetOptions.VlanID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/vlans/{vlanId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createClusterSubnetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateClusterSubnet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if createClusterSubnetOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*createClusterSubnetOptions.XAuthRefreshToken))
	}
	if createClusterSubnetOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*createClusterSubnetOptions.XAuthResourceGroup))
	}

	if createClusterSubnetOptions.Size != nil {
		builder.AddQuery("size", fmt.Sprint(*createClusterSubnetOptions.Size))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetClusterWebhooks : List all webhooks for a cluster
// List all webhooks for a Kubernetes cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterWebhooks(getClusterWebhooksOptions *GetClusterWebhooksOptions) (result []ClusterWebhook, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterWebhooksWithContext(context.Background(), getClusterWebhooksOptions)
}

// GetClusterWebhooksWithContext is an alternate form of the GetClusterWebhooks method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterWebhooksWithContext(ctx context.Context, getClusterWebhooksOptions *GetClusterWebhooksOptions) (result []ClusterWebhook, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterWebhooksOptions, "getClusterWebhooksOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterWebhooksOptions, "getClusterWebhooksOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterWebhooksOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/webhooks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterWebhooksOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterWebhooks")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterWebhooksOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterWebhooksOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterWebhook)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// AddClusterWebhooks : Add a webhook to a cluster
// Add a webhook to a Kubernetes cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterWebhooks(addClusterWebhooksOptions *AddClusterWebhooksOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AddClusterWebhooksWithContext(context.Background(), addClusterWebhooksOptions)
}

// AddClusterWebhooksWithContext is an alternate form of the AddClusterWebhooks method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterWebhooksWithContext(ctx context.Context, addClusterWebhooksOptions *AddClusterWebhooksOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addClusterWebhooksOptions, "addClusterWebhooksOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addClusterWebhooksOptions, "addClusterWebhooksOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *addClusterWebhooksOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/webhooks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addClusterWebhooksOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AddClusterWebhooks")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if addClusterWebhooksOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*addClusterWebhooksOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if addClusterWebhooksOptions.Level != nil {
		body["level"] = addClusterWebhooksOptions.Level
	}
	if addClusterWebhooksOptions.Type != nil {
		body["type"] = addClusterWebhooksOptions.Type
	}
	if addClusterWebhooksOptions.URL != nil {
		body["url"] = addClusterWebhooksOptions.URL
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetWorkerPools : List the worker pools in a cluster
// List all the worker pools that you have in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerPools(getWorkerPoolsOptions *GetWorkerPoolsOptions) (result []WorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetWorkerPoolsWithContext(context.Background(), getWorkerPoolsOptions)
}

// GetWorkerPoolsWithContext is an alternate form of the GetWorkerPools method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerPoolsWithContext(ctx context.Context, getWorkerPoolsOptions *GetWorkerPoolsOptions) (result []WorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getWorkerPoolsOptions, "getWorkerPoolsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getWorkerPoolsOptions, "getWorkerPoolsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getWorkerPoolsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workerpools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getWorkerPoolsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetWorkerPools")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getWorkerPoolsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getWorkerPoolsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateWorkerPool : Create a worker pool for a cluster
// Create a worker pool for the specified cluster. Creating a worker pool requires Operator access to Kubernetes Service
// in the IBM Cloud account.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateWorkerPool(createWorkerPoolOptions *CreateWorkerPoolOptions) (result *WorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateWorkerPoolWithContext(context.Background(), createWorkerPoolOptions)
}

// CreateWorkerPoolWithContext is an alternate form of the CreateWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateWorkerPoolWithContext(ctx context.Context, createWorkerPoolOptions *CreateWorkerPoolOptions) (result *WorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createWorkerPoolOptions, "createWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createWorkerPoolOptions, "createWorkerPoolOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *createWorkerPoolOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workerpools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createWorkerPoolOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*createWorkerPoolOptions.XAuthRefreshToken))
	}
	if createWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*createWorkerPoolOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if createWorkerPoolOptions.DiskEncryption != nil {
		body["diskEncryption"] = createWorkerPoolOptions.DiskEncryption
	}
	if createWorkerPoolOptions.Entitlement != nil {
		body["entitlement"] = createWorkerPoolOptions.Entitlement
	}
	if createWorkerPoolOptions.Isolation != nil {
		body["isolation"] = createWorkerPoolOptions.Isolation
	}
	if createWorkerPoolOptions.Labels != nil {
		body["labels"] = createWorkerPoolOptions.Labels
	}
	if createWorkerPoolOptions.MachineType != nil {
		body["machineType"] = createWorkerPoolOptions.MachineType
	}
	if createWorkerPoolOptions.Name != nil {
		body["name"] = createWorkerPoolOptions.Name
	}
	if createWorkerPoolOptions.SizePerZone != nil {
		body["sizePerZone"] = createWorkerPoolOptions.SizePerZone
	}
	if createWorkerPoolOptions.Zones != nil {
		body["zones"] = createWorkerPoolOptions.Zones
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetWorkerPool1 : View details for a worker pool
// View detailed information for a worker pool.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerPool1(getWorkerPool1Options *GetWorkerPool1Options) (result *WorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetWorkerPool1WithContext(context.Background(), getWorkerPool1Options)
}

// GetWorkerPool1WithContext is an alternate form of the GetWorkerPool1 method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerPool1WithContext(ctx context.Context, getWorkerPool1Options *GetWorkerPool1Options) (result *WorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getWorkerPool1Options, "getWorkerPool1Options cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getWorkerPool1Options, "getWorkerPool1Options")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":     *getWorkerPool1Options.IdOrName,
		"poolidOrName": *getWorkerPool1Options.PoolidOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workerpools/{poolidOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getWorkerPool1Options.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetWorkerPool1")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getWorkerPool1Options.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getWorkerPool1Options.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveWorkerPool : Remove a worker pool from a cluster
// Remove a worker pool from a cluster. All worker nodes in the pool are deleted. Your pods are rescheduled when you
// delete. To avoid downtime, be sure that you have enough workers to run your workload.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveWorkerPool(removeWorkerPoolOptions *RemoveWorkerPoolOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveWorkerPoolWithContext(context.Background(), removeWorkerPoolOptions)
}

// RemoveWorkerPoolWithContext is an alternate form of the RemoveWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveWorkerPoolWithContext(ctx context.Context, removeWorkerPoolOptions *RemoveWorkerPoolOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeWorkerPoolOptions, "removeWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeWorkerPoolOptions, "removeWorkerPoolOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":     *removeWorkerPoolOptions.IdOrName,
		"poolidOrName": *removeWorkerPoolOptions.PoolidOrName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workerpools/{poolidOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if removeWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*removeWorkerPoolOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// PatchWorkerPool : Resize or rebalance a worker pool
// To change the number of worker nodes in a worker pool, you can resize or rebalance the worker pool. When you resize
// the worker pool, you change the number of worker nodes that are created in each zone of the worker pool. For example,
// if you set the size per zone to 3 and have 3 zones in the pool, you have 9 worker nodes in total. When you rebalance
// the worker pool, you return the number of worker nodes in the worker pool to a balanced state. For example, if you
// remove some worker nodes such as to troubleshoot an issue, you might have an uneven number of nodes across zones. You
// might delete 2 worker nodes in zone dal13 but still have 3 worker nodes each in zones dal10 and dal12 for a total of
// 7 worker nodes. To fix this unbalanced state, rebalance the worker pool. After rebalancing, the worker pool has 9
// worker nodes again. Rebalancing does not change the size per zone of the worker pool, even if you specify a different
// size per zone.
func (kubernetesServiceApi *KubernetesServiceApiV1) PatchWorkerPool(patchWorkerPoolOptions *PatchWorkerPoolOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.PatchWorkerPoolWithContext(context.Background(), patchWorkerPoolOptions)
}

// PatchWorkerPoolWithContext is an alternate form of the PatchWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) PatchWorkerPoolWithContext(ctx context.Context, patchWorkerPoolOptions *PatchWorkerPoolOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(patchWorkerPoolOptions, "patchWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(patchWorkerPoolOptions, "patchWorkerPoolOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":     *patchWorkerPoolOptions.IdOrName,
		"poolidOrName": *patchWorkerPoolOptions.PoolidOrName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workerpools/{poolidOrName}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range patchWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "PatchWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if patchWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*patchWorkerPoolOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if patchWorkerPoolOptions.AllowSingleOpenShiftWorker != nil {
		body["allowSingleOpenShiftWorker"] = patchWorkerPoolOptions.AllowSingleOpenShiftWorker
	}
	if patchWorkerPoolOptions.Labels != nil {
		body["labels"] = patchWorkerPoolOptions.Labels
	}
	if patchWorkerPoolOptions.ReasonForResize != nil {
		body["reasonForResize"] = patchWorkerPoolOptions.ReasonForResize
	}
	if patchWorkerPoolOptions.SizePerZone != nil {
		body["sizePerZone"] = patchWorkerPoolOptions.SizePerZone
	}
	if patchWorkerPoolOptions.State != nil {
		body["state"] = patchWorkerPoolOptions.State
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// AddWorkerPoolZone : Add a zone to the specified worker pool for a cluster
// Add a zone to the specified worker pool for a cluster. Workers will be provisioned in each provided zone based on the
// size of the pool.
func (kubernetesServiceApi *KubernetesServiceApiV1) AddWorkerPoolZone(addWorkerPoolZoneOptions *AddWorkerPoolZoneOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AddWorkerPoolZoneWithContext(context.Background(), addWorkerPoolZoneOptions)
}

// AddWorkerPoolZoneWithContext is an alternate form of the AddWorkerPoolZone method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AddWorkerPoolZoneWithContext(ctx context.Context, addWorkerPoolZoneOptions *AddWorkerPoolZoneOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addWorkerPoolZoneOptions, "addWorkerPoolZoneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addWorkerPoolZoneOptions, "addWorkerPoolZoneOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":     *addWorkerPoolZoneOptions.IdOrName,
		"poolidOrName": *addWorkerPoolZoneOptions.PoolidOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workerpools/{poolidOrName}/zones`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addWorkerPoolZoneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AddWorkerPoolZone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if addWorkerPoolZoneOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*addWorkerPoolZoneOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if addWorkerPoolZoneOptions.ID != nil {
		body["id"] = addWorkerPoolZoneOptions.ID
	}
	if addWorkerPoolZoneOptions.PrivateVlan != nil {
		body["privateVlan"] = addWorkerPoolZoneOptions.PrivateVlan
	}
	if addWorkerPoolZoneOptions.PublicVlan != nil {
		body["publicVlan"] = addWorkerPoolZoneOptions.PublicVlan
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RemoveWorkerPoolZone : Remove a zone from a worker pool
// Remove a zone from a worker pool. All worker nodes in the specified worker pool are deleted from the specified zone.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveWorkerPoolZone(removeWorkerPoolZoneOptions *RemoveWorkerPoolZoneOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveWorkerPoolZoneWithContext(context.Background(), removeWorkerPoolZoneOptions)
}

// RemoveWorkerPoolZoneWithContext is an alternate form of the RemoveWorkerPoolZone method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveWorkerPoolZoneWithContext(ctx context.Context, removeWorkerPoolZoneOptions *RemoveWorkerPoolZoneOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeWorkerPoolZoneOptions, "removeWorkerPoolZoneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeWorkerPoolZoneOptions, "removeWorkerPoolZoneOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":     *removeWorkerPoolZoneOptions.IdOrName,
		"poolidOrName": *removeWorkerPoolZoneOptions.PoolidOrName,
		"zoneid":       *removeWorkerPoolZoneOptions.Zoneid,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workerpools/{poolidOrName}/zones/{zoneid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeWorkerPoolZoneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveWorkerPoolZone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if removeWorkerPoolZoneOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*removeWorkerPoolZoneOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// AddWorkerPoolZoneNetwork : Updates network configuration for a worker pool for a given zone
func (kubernetesServiceApi *KubernetesServiceApiV1) AddWorkerPoolZoneNetwork(addWorkerPoolZoneNetworkOptions *AddWorkerPoolZoneNetworkOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AddWorkerPoolZoneNetworkWithContext(context.Background(), addWorkerPoolZoneNetworkOptions)
}

// AddWorkerPoolZoneNetworkWithContext is an alternate form of the AddWorkerPoolZoneNetwork method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AddWorkerPoolZoneNetworkWithContext(ctx context.Context, addWorkerPoolZoneNetworkOptions *AddWorkerPoolZoneNetworkOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addWorkerPoolZoneNetworkOptions, "addWorkerPoolZoneNetworkOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addWorkerPoolZoneNetworkOptions, "addWorkerPoolZoneNetworkOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":     *addWorkerPoolZoneNetworkOptions.IdOrName,
		"poolidOrName": *addWorkerPoolZoneNetworkOptions.PoolidOrName,
		"zoneid":       *addWorkerPoolZoneNetworkOptions.Zoneid,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workerpools/{poolidOrName}/zones/{zoneid}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addWorkerPoolZoneNetworkOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AddWorkerPoolZoneNetwork")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if addWorkerPoolZoneNetworkOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*addWorkerPoolZoneNetworkOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if addWorkerPoolZoneNetworkOptions.PrivateVlan != nil {
		body["privateVlan"] = addWorkerPoolZoneNetworkOptions.PrivateVlan
	}
	if addWorkerPoolZoneNetworkOptions.PublicVlan != nil {
		body["publicVlan"] = addWorkerPoolZoneNetworkOptions.PublicVlan
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetClusterWorkers : List all worker nodes in a cluster
// List all worker nodes and the status of each in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterWorkers(getClusterWorkersOptions *GetClusterWorkersOptions) (result []Worker, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterWorkersWithContext(context.Background(), getClusterWorkersOptions)
}

// GetClusterWorkersWithContext is an alternate form of the GetClusterWorkers method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterWorkersWithContext(ctx context.Context, getClusterWorkersOptions *GetClusterWorkersOptions) (result []Worker, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterWorkersOptions, "getClusterWorkersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterWorkersOptions, "getClusterWorkersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterWorkersOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workers`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterWorkersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterWorkers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterWorkersOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterWorkersOptions.XAuthResourceGroup))
	}

	if getClusterWorkersOptions.Pool != nil {
		builder.AddQuery("pool", fmt.Sprint(*getClusterWorkersOptions.Pool))
	}
	if getClusterWorkersOptions.ShowDeleted != nil {
		builder.AddQuery("showDeleted", fmt.Sprint(*getClusterWorkersOptions.ShowDeleted))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalWorker)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// AddClusterWorkers : Add worker nodes to a cluster
// Add additional worker nodes to a Kubernetes cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterWorkers(addClusterWorkersOptions *AddClusterWorkersOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AddClusterWorkersWithContext(context.Background(), addClusterWorkersOptions)
}

// AddClusterWorkersWithContext is an alternate form of the AddClusterWorkers method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AddClusterWorkersWithContext(ctx context.Context, addClusterWorkersOptions *AddClusterWorkersOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addClusterWorkersOptions, "addClusterWorkersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addClusterWorkersOptions, "addClusterWorkersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *addClusterWorkersOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workers`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addClusterWorkersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AddClusterWorkers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if addClusterWorkersOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*addClusterWorkersOptions.XAuthResourceGroup))
	}
	if addClusterWorkersOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*addClusterWorkersOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if addClusterWorkersOptions.DataCenter != nil {
		body["dataCenter"] = addClusterWorkersOptions.DataCenter
	}
	if addClusterWorkersOptions.DiskEncryption != nil {
		body["diskEncryption"] = addClusterWorkersOptions.DiskEncryption
	}
	if addClusterWorkersOptions.Isolation != nil {
		body["isolation"] = addClusterWorkersOptions.Isolation
	}
	if addClusterWorkersOptions.MachineType != nil {
		body["machineType"] = addClusterWorkersOptions.MachineType
	}
	if addClusterWorkersOptions.Prefix != nil {
		body["prefix"] = addClusterWorkersOptions.Prefix
	}
	if addClusterWorkersOptions.PrivateVlan != nil {
		body["privateVlan"] = addClusterWorkersOptions.PrivateVlan
	}
	if addClusterWorkersOptions.PublicVlan != nil {
		body["publicVlan"] = addClusterWorkersOptions.PublicVlan
	}
	if addClusterWorkersOptions.WorkerNum != nil {
		body["workerNum"] = addClusterWorkersOptions.WorkerNum
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetWorkers : View details of a worker node
// View detailed information for a worker node.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkers(getWorkersOptions *GetWorkersOptions) (result *Worker, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetWorkersWithContext(context.Background(), getWorkersOptions)
}

// GetWorkersWithContext is an alternate form of the GetWorkers method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkersWithContext(ctx context.Context, getWorkersOptions *GetWorkersOptions) (result *Worker, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getWorkersOptions, "getWorkersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getWorkersOptions, "getWorkersOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getWorkersOptions.IdOrName,
		"workerId": *getWorkersOptions.WorkerID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workers/{workerId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getWorkersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetWorkers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getWorkersOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getWorkersOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalWorker)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateClusterWorker : Reboot, reload, or update a worker node for a cluster
// Reboot, reload, or update a worker node in a Kubernetes cluster. If a problem exists with a worker node, try to
// reload it, which reloads all the configurations and updates the worker node with the latest image and Kubernetes
// patch version. When you reboot a worker node, its state remains the same such as `deployed`, but its status updates
// as the machine in your infrastructure account is restarted. If you update the worker node, it is reimaged with the
// Kubernetes version that matches the cluster master. If you reboot, reload, or update a worker node, data is deleted
// if not stored outside the worker node in persistent storage. This action cannot be undone.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateClusterWorker(updateClusterWorkerOptions *UpdateClusterWorkerOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateClusterWorkerWithContext(context.Background(), updateClusterWorkerOptions)
}

// UpdateClusterWorkerWithContext is an alternate form of the UpdateClusterWorker method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateClusterWorkerWithContext(ctx context.Context, updateClusterWorkerOptions *UpdateClusterWorkerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateClusterWorkerOptions, "updateClusterWorkerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateClusterWorkerOptions, "updateClusterWorkerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *updateClusterWorkerOptions.IdOrName,
		"workerId": *updateClusterWorkerOptions.WorkerID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workers/{workerId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateClusterWorkerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateClusterWorker")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if updateClusterWorkerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*updateClusterWorkerOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if updateClusterWorkerOptions.Action != nil {
		body["action"] = updateClusterWorkerOptions.Action
	}
	if updateClusterWorkerOptions.Force != nil {
		body["force"] = updateClusterWorkerOptions.Force
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RemoveClusterWorker : Delete a worker node from a cluster
// Delete a worker node from a cluster. This action cannot be undone. When you delete the worker node, the worker node
// is cordoned and drained so that its pods are rescheduled onto remaining worker nodes in the cluster. Make sure that
// you have enough capacity in the cluster to support the workload. After you remove the worker node, you can rebalance
// the worker pool.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveClusterWorker(removeClusterWorkerOptions *RemoveClusterWorkerOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveClusterWorkerWithContext(context.Background(), removeClusterWorkerOptions)
}

// RemoveClusterWorkerWithContext is an alternate form of the RemoveClusterWorker method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveClusterWorkerWithContext(ctx context.Context, removeClusterWorkerOptions *RemoveClusterWorkerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeClusterWorkerOptions, "removeClusterWorkerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeClusterWorkerOptions, "removeClusterWorkerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *removeClusterWorkerOptions.IdOrName,
		"workerId": *removeClusterWorkerOptions.WorkerID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/clusters/{idOrName}/workers/{workerId}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeClusterWorkerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveClusterWorker")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if removeClusterWorkerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*removeClusterWorkerOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetUserConfig : View a user's ability to create free and standard clusters in a region and resource group
// View whether a user can create free and paid clusters in a region and resource group. If `"freeEnabled": true` is
// returned, you can create a free cluster in the specified region. If `"storedIaasCredentials": true` is returned, your
// IBM Cloud account uses IBM Cloud infrastructure (SoftLayer) credentials that were manually set with the `POST
// /v1/credentials` API or the `ibmcloud ks credential set` command. When you create a standard cluster in the
// specified region and resource group, these credentials are used.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetUserConfig(getUserConfigOptions *GetUserConfigOptions) (result *UserConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetUserConfigWithContext(context.Background(), getUserConfigOptions)
}

// GetUserConfigWithContext is an alternate form of the GetUserConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetUserConfigWithContext(ctx context.Context, getUserConfigOptions *GetUserConfigOptions) (result *UserConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getUserConfigOptions, "getUserConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getUserConfigOptions, "getUserConfigOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/user-config`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getUserConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetUserConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getUserConfigOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*getUserConfigOptions.XRegion))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUserConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// FetchFilterConfigs : List all logging filter configurations in the cluster
// List the logging filter configurations that you created in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) FetchFilterConfigs(fetchFilterConfigsOptions *FetchFilterConfigsOptions) (result []FilterConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.FetchFilterConfigsWithContext(context.Background(), fetchFilterConfigsOptions)
}

// FetchFilterConfigsWithContext is an alternate form of the FetchFilterConfigs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) FetchFilterConfigsWithContext(ctx context.Context, fetchFilterConfigsOptions *FetchFilterConfigsOptions) (result []FilterConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(fetchFilterConfigsOptions, "fetchFilterConfigsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(fetchFilterConfigsOptions, "fetchFilterConfigsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *fetchFilterConfigsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/filterconfigs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range fetchFilterConfigsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "FetchFilterConfigs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if fetchFilterConfigsOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*fetchFilterConfigsOptions.XAuthResourceGroupID))
	}

	if fetchFilterConfigsOptions.ShowMatches != nil {
		builder.AddQuery("showMatches", fmt.Sprint(*fetchFilterConfigsOptions.ShowMatches))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFilterConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateFilterConfig : Create a logging filter configuration
// Start filtering logs that are forwarded by your logging configuration from the given sources based on one or more
// selectors.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateFilterConfig(createFilterConfigOptions *CreateFilterConfigOptions) (result *FilterConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateFilterConfigWithContext(context.Background(), createFilterConfigOptions)
}

// CreateFilterConfigWithContext is an alternate form of the CreateFilterConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateFilterConfigWithContext(ctx context.Context, createFilterConfigOptions *CreateFilterConfigOptions) (result *FilterConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createFilterConfigOptions, "createFilterConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createFilterConfigOptions, "createFilterConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *createFilterConfigOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/filterconfigs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createFilterConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateFilterConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createFilterConfigOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*createFilterConfigOptions.XAuthResourceGroupID))
	}

	if createFilterConfigOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*createFilterConfigOptions.ForceUpdate))
	}

	body := make(map[string]interface{})
	if createFilterConfigOptions.Container != nil {
		body["container"] = createFilterConfigOptions.Container
	}
	if createFilterConfigOptions.LogLevel != nil {
		body["logLevel"] = createFilterConfigOptions.LogLevel
	}
	if createFilterConfigOptions.LoggingConfigs != nil {
		body["loggingConfigs"] = createFilterConfigOptions.LoggingConfigs
	}
	if createFilterConfigOptions.Message != nil {
		body["message"] = createFilterConfigOptions.Message
	}
	if createFilterConfigOptions.Namespace != nil {
		body["namespace"] = createFilterConfigOptions.Namespace
	}
	if createFilterConfigOptions.RegexMessageEnabled != nil {
		body["regexMessageEnabled"] = createFilterConfigOptions.RegexMessageEnabled
	}
	if createFilterConfigOptions.Type != nil {
		body["type"] = createFilterConfigOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFilterConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteFilterConfigs : Deletes all logging filter configurations for the cluster
// Stops log filtering.
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteFilterConfigs(deleteFilterConfigsOptions *DeleteFilterConfigsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteFilterConfigsWithContext(context.Background(), deleteFilterConfigsOptions)
}

// DeleteFilterConfigsWithContext is an alternate form of the DeleteFilterConfigs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteFilterConfigsWithContext(ctx context.Context, deleteFilterConfigsOptions *DeleteFilterConfigsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFilterConfigsOptions, "deleteFilterConfigsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteFilterConfigsOptions, "deleteFilterConfigsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *deleteFilterConfigsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/filterconfigs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteFilterConfigsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteFilterConfigs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteFilterConfigsOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*deleteFilterConfigsOptions.XAuthResourceGroupID))
	}

	if deleteFilterConfigsOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*deleteFilterConfigsOptions.ForceUpdate))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// FetchFilterConfig : View a logging filter configuration
// View details for a logging filter configuration.
func (kubernetesServiceApi *KubernetesServiceApiV1) FetchFilterConfig(fetchFilterConfigOptions *FetchFilterConfigOptions) (result *FilterConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.FetchFilterConfigWithContext(context.Background(), fetchFilterConfigOptions)
}

// FetchFilterConfigWithContext is an alternate form of the FetchFilterConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) FetchFilterConfigWithContext(ctx context.Context, fetchFilterConfigOptions *FetchFilterConfigOptions) (result *FilterConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(fetchFilterConfigOptions, "fetchFilterConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(fetchFilterConfigOptions, "fetchFilterConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *fetchFilterConfigOptions.IdOrName,
		"id":       *fetchFilterConfigOptions.ID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/filterconfigs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range fetchFilterConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "FetchFilterConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if fetchFilterConfigOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*fetchFilterConfigOptions.XAuthResourceGroupID))
	}

	if fetchFilterConfigOptions.ShowMatches != nil {
		builder.AddQuery("showMatches", fmt.Sprint(*fetchFilterConfigOptions.ShowMatches))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFilterConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateFilterConfig : Update a logging filter configuration
// Update a logging filter config where `id` is the UUID for the filter config.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateFilterConfig(updateFilterConfigOptions *UpdateFilterConfigOptions) (result *FilterConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateFilterConfigWithContext(context.Background(), updateFilterConfigOptions)
}

// UpdateFilterConfigWithContext is an alternate form of the UpdateFilterConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateFilterConfigWithContext(ctx context.Context, updateFilterConfigOptions *UpdateFilterConfigOptions) (result *FilterConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateFilterConfigOptions, "updateFilterConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateFilterConfigOptions, "updateFilterConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *updateFilterConfigOptions.IdOrName,
		"id":       *updateFilterConfigOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/filterconfigs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateFilterConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateFilterConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if updateFilterConfigOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*updateFilterConfigOptions.XAuthResourceGroupID))
	}

	if updateFilterConfigOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*updateFilterConfigOptions.ForceUpdate))
	}

	body := make(map[string]interface{})
	if updateFilterConfigOptions.Container != nil {
		body["container"] = updateFilterConfigOptions.Container
	}
	if updateFilterConfigOptions.LogLevel != nil {
		body["logLevel"] = updateFilterConfigOptions.LogLevel
	}
	if updateFilterConfigOptions.LoggingConfigs != nil {
		body["loggingConfigs"] = updateFilterConfigOptions.LoggingConfigs
	}
	if updateFilterConfigOptions.Message != nil {
		body["message"] = updateFilterConfigOptions.Message
	}
	if updateFilterConfigOptions.Namespace != nil {
		body["namespace"] = updateFilterConfigOptions.Namespace
	}
	if updateFilterConfigOptions.RegexMessageEnabled != nil {
		body["regexMessageEnabled"] = updateFilterConfigOptions.RegexMessageEnabled
	}
	if updateFilterConfigOptions.Type != nil {
		body["type"] = updateFilterConfigOptions.Type
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFilterConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteFilterConfig : Delete a logging filter configuration
// Delete the specified logging filter configuration for a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteFilterConfig(deleteFilterConfigOptions *DeleteFilterConfigOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteFilterConfigWithContext(context.Background(), deleteFilterConfigOptions)
}

// DeleteFilterConfigWithContext is an alternate form of the DeleteFilterConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteFilterConfigWithContext(ctx context.Context, deleteFilterConfigOptions *DeleteFilterConfigOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteFilterConfigOptions, "deleteFilterConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteFilterConfigOptions, "deleteFilterConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *deleteFilterConfigOptions.IdOrName,
		"id":       *deleteFilterConfigOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/filterconfigs/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteFilterConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteFilterConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteFilterConfigOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*deleteFilterConfigOptions.XAuthResourceGroupID))
	}

	if deleteFilterConfigOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*deleteFilterConfigOptions.ForceUpdate))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetMasterLogCollectionStatus : Show the status for the most recent master log collection request
// Show the status for the most recent master log collection request.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMasterLogCollectionStatus(getMasterLogCollectionStatusOptions *GetMasterLogCollectionStatusOptions) (result []MasterLogCollectionStatusResponseBody, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetMasterLogCollectionStatusWithContext(context.Background(), getMasterLogCollectionStatusOptions)
}

// GetMasterLogCollectionStatusWithContext is an alternate form of the GetMasterLogCollectionStatus method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMasterLogCollectionStatusWithContext(ctx context.Context, getMasterLogCollectionStatusOptions *GetMasterLogCollectionStatusOptions) (result []MasterLogCollectionStatusResponseBody, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getMasterLogCollectionStatusOptions, "getMasterLogCollectionStatusOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getMasterLogCollectionStatusOptions, "getMasterLogCollectionStatusOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getMasterLogCollectionStatusOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/log-collector/{idOrName}/masterlogs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getMasterLogCollectionStatusOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetMasterLogCollectionStatus")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getMasterLogCollectionStatusOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getMasterLogCollectionStatusOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMasterLogCollectionStatusResponseBody)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateMasterLogCollection : Create a new master log collection request
// Create a new master log collection request.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateMasterLogCollection(createMasterLogCollectionOptions *CreateMasterLogCollectionOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateMasterLogCollectionWithContext(context.Background(), createMasterLogCollectionOptions)
}

// CreateMasterLogCollectionWithContext is an alternate form of the CreateMasterLogCollection method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateMasterLogCollectionWithContext(ctx context.Context, createMasterLogCollectionOptions *CreateMasterLogCollectionOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createMasterLogCollectionOptions, "createMasterLogCollectionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createMasterLogCollectionOptions, "createMasterLogCollectionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *createMasterLogCollectionOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/log-collector/{idOrName}/masterlogs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createMasterLogCollectionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateMasterLogCollection")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if createMasterLogCollectionOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*createMasterLogCollectionOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if createMasterLogCollectionOptions.Accesskeyid != nil {
		body["accesskeyid"] = createMasterLogCollectionOptions.Accesskeyid
	}
	if createMasterLogCollectionOptions.Accesskeysecret != nil {
		body["accesskeysecret"] = createMasterLogCollectionOptions.Accesskeysecret
	}
	if createMasterLogCollectionOptions.Bucket != nil {
		body["bucket"] = createMasterLogCollectionOptions.Bucket
	}
	if createMasterLogCollectionOptions.Endpoint != nil {
		body["endpoint"] = createMasterLogCollectionOptions.Endpoint
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetClusterKeyOwner : View information about the containers-kubernetes-key API key owner
// View the name and email address for the owner of the cluster's containers-kubernetes-key API key.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterKeyOwner(getClusterKeyOwnerOptions *GetClusterKeyOwnerOptions) (result *ClusterKeyOwnerInfo, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterKeyOwnerWithContext(context.Background(), getClusterKeyOwnerOptions)
}

// GetClusterKeyOwnerWithContext is an alternate form of the GetClusterKeyOwner method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterKeyOwnerWithContext(ctx context.Context, getClusterKeyOwnerOptions *GetClusterKeyOwnerOptions) (result *ClusterKeyOwnerInfo, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterKeyOwnerOptions, "getClusterKeyOwnerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterKeyOwnerOptions, "getClusterKeyOwnerOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getClusterKeyOwnerOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/clusterkeyowner`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterKeyOwnerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetClusterKeyOwner")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterKeyOwnerOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*getClusterKeyOwnerOptions.XAuthResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterKeyOwnerInfo)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetDefaultLoggingEndpoint : View the default logging endpoint for the target region
// View the default logging endpoint for the target region.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetDefaultLoggingEndpoint(getDefaultLoggingEndpointOptions *GetDefaultLoggingEndpointOptions) (result *DefaultLoggingEndpointResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetDefaultLoggingEndpointWithContext(context.Background(), getDefaultLoggingEndpointOptions)
}

// GetDefaultLoggingEndpointWithContext is an alternate form of the GetDefaultLoggingEndpoint method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetDefaultLoggingEndpointWithContext(ctx context.Context, getDefaultLoggingEndpointOptions *GetDefaultLoggingEndpointOptions) (result *DefaultLoggingEndpointResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDefaultLoggingEndpointOptions, "getDefaultLoggingEndpointOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDefaultLoggingEndpointOptions, "getDefaultLoggingEndpointOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getDefaultLoggingEndpointOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/default`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDefaultLoggingEndpointOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetDefaultLoggingEndpoint")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getDefaultLoggingEndpointOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*getDefaultLoggingEndpointOptions.XAuthResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDefaultLoggingEndpointResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// FetchLoggingConfigs : List all log forwarding configurations in the cluster
// List the log forwarding configurations in the target cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) FetchLoggingConfigs(fetchLoggingConfigsOptions *FetchLoggingConfigsOptions) (result []LogConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.FetchLoggingConfigsWithContext(context.Background(), fetchLoggingConfigsOptions)
}

// FetchLoggingConfigsWithContext is an alternate form of the FetchLoggingConfigs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) FetchLoggingConfigsWithContext(ctx context.Context, fetchLoggingConfigsOptions *FetchLoggingConfigsOptions) (result []LogConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(fetchLoggingConfigsOptions, "fetchLoggingConfigsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(fetchLoggingConfigsOptions, "fetchLoggingConfigsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *fetchLoggingConfigsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/loggingconfig`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range fetchLoggingConfigsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "FetchLoggingConfigs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if fetchLoggingConfigsOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*fetchLoggingConfigsOptions.XAuthResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLogConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteLoggingConfigs : Delete all log forwarding configurations for a cluster
// Stops all log forwarding for a cluster by deleting all log forwarding configurations.
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteLoggingConfigs(deleteLoggingConfigsOptions *DeleteLoggingConfigsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteLoggingConfigsWithContext(context.Background(), deleteLoggingConfigsOptions)
}

// DeleteLoggingConfigsWithContext is an alternate form of the DeleteLoggingConfigs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteLoggingConfigsWithContext(ctx context.Context, deleteLoggingConfigsOptions *DeleteLoggingConfigsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoggingConfigsOptions, "deleteLoggingConfigsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoggingConfigsOptions, "deleteLoggingConfigsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *deleteLoggingConfigsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/loggingconfig`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoggingConfigsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteLoggingConfigs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteLoggingConfigsOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*deleteLoggingConfigsOptions.XAuthResourceGroupID))
	}

	if deleteLoggingConfigsOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*deleteLoggingConfigsOptions.ForceUpdate))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// FetchLoggingConfigsForSource : List all log forwarding configurations for a log source in the cluster
// List the log forwarding configurations for the specified log source in the target cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) FetchLoggingConfigsForSource(fetchLoggingConfigsForSourceOptions *FetchLoggingConfigsForSourceOptions) (result []LogConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.FetchLoggingConfigsForSourceWithContext(context.Background(), fetchLoggingConfigsForSourceOptions)
}

// FetchLoggingConfigsForSourceWithContext is an alternate form of the FetchLoggingConfigsForSource method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) FetchLoggingConfigsForSourceWithContext(ctx context.Context, fetchLoggingConfigsForSourceOptions *FetchLoggingConfigsForSourceOptions) (result []LogConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(fetchLoggingConfigsForSourceOptions, "fetchLoggingConfigsForSourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(fetchLoggingConfigsForSourceOptions, "fetchLoggingConfigsForSourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":  *fetchLoggingConfigsForSourceOptions.IdOrName,
		"logSource": *fetchLoggingConfigsForSourceOptions.LogSource,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/loggingconfig/{logSource}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range fetchLoggingConfigsForSourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "FetchLoggingConfigsForSource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if fetchLoggingConfigsForSourceOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*fetchLoggingConfigsForSourceOptions.XAuthResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLogConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateLoggingConfig : Create a log forwarding configuration
// Enable log collection for a specified log source and log forwarding to IBM Cloud Log Analysis or to an external
// syslog server. If you want to forward logs from one log source to both log collector servers, then you must create
// two logging configurations.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateLoggingConfig(createLoggingConfigOptions *CreateLoggingConfigOptions) (result *LogConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateLoggingConfigWithContext(context.Background(), createLoggingConfigOptions)
}

// CreateLoggingConfigWithContext is an alternate form of the CreateLoggingConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateLoggingConfigWithContext(ctx context.Context, createLoggingConfigOptions *CreateLoggingConfigOptions) (result *LogConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoggingConfigOptions, "createLoggingConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoggingConfigOptions, "createLoggingConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":  *createLoggingConfigOptions.IdOrName,
		"logSource": *createLoggingConfigOptions.LogSource,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/loggingconfig/{logSource}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoggingConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateLoggingConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createLoggingConfigOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*createLoggingConfigOptions.XAuthResourceGroupID))
	}

	if createLoggingConfigOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*createLoggingConfigOptions.ForceUpdate))
	}
	if createLoggingConfigOptions.SkipValidation != nil {
		builder.AddQuery("skipValidation", fmt.Sprint(*createLoggingConfigOptions.SkipValidation))
	}

	body := make(map[string]interface{})
	if createLoggingConfigOptions.AppLogContainers != nil {
		body["appLogContainers"] = createLoggingConfigOptions.AppLogContainers
	}
	if createLoggingConfigOptions.AppLogPaths != nil {
		body["appLogPaths"] = createLoggingConfigOptions.AppLogPaths
	}
	if createLoggingConfigOptions.CaCert != nil {
		body["caCert"] = createLoggingConfigOptions.CaCert
	}
	if createLoggingConfigOptions.LoggingType != nil {
		body["loggingType"] = createLoggingConfigOptions.LoggingType
	}
	if createLoggingConfigOptions.Namespace != nil {
		body["namespace"] = createLoggingConfigOptions.Namespace
	}
	if createLoggingConfigOptions.Org != nil {
		body["org"] = createLoggingConfigOptions.Org
	}
	if createLoggingConfigOptions.Protocol != nil {
		body["protocol"] = createLoggingConfigOptions.Protocol
	}
	if createLoggingConfigOptions.RemoteLogPort != nil {
		body["remoteLogPort"] = createLoggingConfigOptions.RemoteLogPort
	}
	if createLoggingConfigOptions.RemoteLogServer != nil {
		body["remoteLogServer"] = createLoggingConfigOptions.RemoteLogServer
	}
	if createLoggingConfigOptions.Space != nil {
		body["space"] = createLoggingConfigOptions.Space
	}
	if createLoggingConfigOptions.VerifyMode != nil {
		body["verifyMode"] = createLoggingConfigOptions.VerifyMode
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLogConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateLoggingConfig : Update a log forwarding configuration
// Update the details of a log forwarding configuration.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateLoggingConfig(updateLoggingConfigOptions *UpdateLoggingConfigOptions) (result *LogConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateLoggingConfigWithContext(context.Background(), updateLoggingConfigOptions)
}

// UpdateLoggingConfigWithContext is an alternate form of the UpdateLoggingConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateLoggingConfigWithContext(ctx context.Context, updateLoggingConfigOptions *UpdateLoggingConfigOptions) (result *LogConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateLoggingConfigOptions, "updateLoggingConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateLoggingConfigOptions, "updateLoggingConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":  *updateLoggingConfigOptions.IdOrName,
		"logSource": *updateLoggingConfigOptions.LogSource,
		"id":        *updateLoggingConfigOptions.ID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/loggingconfig/{logSource}/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateLoggingConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateLoggingConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if updateLoggingConfigOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*updateLoggingConfigOptions.XAuthResourceGroupID))
	}

	if updateLoggingConfigOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*updateLoggingConfigOptions.ForceUpdate))
	}
	if updateLoggingConfigOptions.SkipValidation != nil {
		builder.AddQuery("skipValidation", fmt.Sprint(*updateLoggingConfigOptions.SkipValidation))
	}

	body := make(map[string]interface{})
	if updateLoggingConfigOptions.AppLogContainers != nil {
		body["appLogContainers"] = updateLoggingConfigOptions.AppLogContainers
	}
	if updateLoggingConfigOptions.AppLogPaths != nil {
		body["appLogPaths"] = updateLoggingConfigOptions.AppLogPaths
	}
	if updateLoggingConfigOptions.CaCert != nil {
		body["caCert"] = updateLoggingConfigOptions.CaCert
	}
	if updateLoggingConfigOptions.LoggingType != nil {
		body["loggingType"] = updateLoggingConfigOptions.LoggingType
	}
	if updateLoggingConfigOptions.Namespace != nil {
		body["namespace"] = updateLoggingConfigOptions.Namespace
	}
	if updateLoggingConfigOptions.Org != nil {
		body["org"] = updateLoggingConfigOptions.Org
	}
	if updateLoggingConfigOptions.Protocol != nil {
		body["protocol"] = updateLoggingConfigOptions.Protocol
	}
	if updateLoggingConfigOptions.RemoteLogPort != nil {
		body["remoteLogPort"] = updateLoggingConfigOptions.RemoteLogPort
	}
	if updateLoggingConfigOptions.RemoteLogServer != nil {
		body["remoteLogServer"] = updateLoggingConfigOptions.RemoteLogServer
	}
	if updateLoggingConfigOptions.Space != nil {
		body["space"] = updateLoggingConfigOptions.Space
	}
	if updateLoggingConfigOptions.VerifyMode != nil {
		body["verifyMode"] = updateLoggingConfigOptions.VerifyMode
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLogConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteLoggingConfig : Delete a log forwarding configuration
// Stops log forwarding by deleting a specified logging configuration.
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteLoggingConfig(deleteLoggingConfigOptions *DeleteLoggingConfigOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteLoggingConfigWithContext(context.Background(), deleteLoggingConfigOptions)
}

// DeleteLoggingConfigWithContext is an alternate form of the DeleteLoggingConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteLoggingConfigWithContext(ctx context.Context, deleteLoggingConfigOptions *DeleteLoggingConfigOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteLoggingConfigOptions, "deleteLoggingConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteLoggingConfigOptions, "deleteLoggingConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName":  *deleteLoggingConfigOptions.IdOrName,
		"logSource": *deleteLoggingConfigOptions.LogSource,
		"id":        *deleteLoggingConfigOptions.ID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/loggingconfig/{logSource}/{id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteLoggingConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteLoggingConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if deleteLoggingConfigOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*deleteLoggingConfigOptions.XAuthResourceGroupID))
	}

	if deleteLoggingConfigOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*deleteLoggingConfigOptions.ForceUpdate))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RefreshLoggingConfig : Refresh the cluster's logging configuration
// Refresh the logging configuration for a cluster. This refreshes the logging token for any logging configuration that
// is forwarding to the space level in your cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) RefreshLoggingConfig(refreshLoggingConfigOptions *RefreshLoggingConfigOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RefreshLoggingConfigWithContext(context.Background(), refreshLoggingConfigOptions)
}

// RefreshLoggingConfigWithContext is an alternate form of the RefreshLoggingConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RefreshLoggingConfigWithContext(ctx context.Context, refreshLoggingConfigOptions *RefreshLoggingConfigOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(refreshLoggingConfigOptions, "refreshLoggingConfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(refreshLoggingConfigOptions, "refreshLoggingConfigOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *refreshLoggingConfigOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/refresh`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range refreshLoggingConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RefreshLoggingConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if refreshLoggingConfigOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*refreshLoggingConfigOptions.XAuthResourceGroupID))
	}

	if refreshLoggingConfigOptions.ForceUpdate != nil {
		builder.AddQuery("forceUpdate", fmt.Sprint(*refreshLoggingConfigOptions.ForceUpdate))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetFluentdUpdatePolicy : Check if automatic updates for the Fluentd logging add-on are enabled in the cluster
// Check if automatic updates for the Fluentd logging add-on are enabled and whether your Fluentd pods are updated to
// the latest version.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetFluentdUpdatePolicy(getFluentdUpdatePolicyOptions *GetFluentdUpdatePolicyOptions) (result *UpdatePolicy, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetFluentdUpdatePolicyWithContext(context.Background(), getFluentdUpdatePolicyOptions)
}

// GetFluentdUpdatePolicyWithContext is an alternate form of the GetFluentdUpdatePolicy method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetFluentdUpdatePolicyWithContext(ctx context.Context, getFluentdUpdatePolicyOptions *GetFluentdUpdatePolicyOptions) (result *UpdatePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getFluentdUpdatePolicyOptions, "getFluentdUpdatePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getFluentdUpdatePolicyOptions, "getFluentdUpdatePolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getFluentdUpdatePolicyOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/updatepolicy`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getFluentdUpdatePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetFluentdUpdatePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getFluentdUpdatePolicyOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*getFluentdUpdatePolicyOptions.XAuthResourceGroupID))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUpdatePolicy)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ChangeFluentdUpdatePolicy : Enable or diable automatic updates for the Fluentd logging add-on in the cluster
// By default, automatic updates to the Fluentd logging add-on are enabled. Fluentd pods are automatically updated when
// a new version is available. To instead update the add-on manually, you can use this call to disable automatic
// updates. If automatic updates for the Fluentd add-on are disabled, you can re-enable automatic updates. Whenever the
// next version becomes available, the Fluentd pods are automatically updated to the latest version.
func (kubernetesServiceApi *KubernetesServiceApiV1) ChangeFluentdUpdatePolicy(changeFluentdUpdatePolicyOptions *ChangeFluentdUpdatePolicyOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ChangeFluentdUpdatePolicyWithContext(context.Background(), changeFluentdUpdatePolicyOptions)
}

// ChangeFluentdUpdatePolicyWithContext is an alternate form of the ChangeFluentdUpdatePolicy method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ChangeFluentdUpdatePolicyWithContext(ctx context.Context, changeFluentdUpdatePolicyOptions *ChangeFluentdUpdatePolicyOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(changeFluentdUpdatePolicyOptions, "changeFluentdUpdatePolicyOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(changeFluentdUpdatePolicyOptions, "changeFluentdUpdatePolicyOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *changeFluentdUpdatePolicyOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/logging/{idOrName}/updatepolicy`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range changeFluentdUpdatePolicyOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ChangeFluentdUpdatePolicy")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if changeFluentdUpdatePolicyOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*changeFluentdUpdatePolicyOptions.XAuthResourceGroupID))
	}

	body := make(map[string]interface{})
	if changeFluentdUpdatePolicyOptions.AutoUpdate != nil {
		body["autoUpdate"] = changeFluentdUpdatePolicyOptions.AutoUpdate
	}
	if changeFluentdUpdatePolicyOptions.LatestVersion != nil {
		body["latestVersion"] = changeFluentdUpdatePolicyOptions.LatestVersion
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateLoggingInstance : Create a LogDNA logging configuration for a cluster
// Create a logging configuration for your IBM Cloud Kubernetes Service cluster to automatically collect pod logs and
// send them to IBM Cloud Log Analysis with LogDNA. This API deploys a LogDNA agent as a Kubernetes daemonset in the
// `ibm-observe` namespace of your cluster. The agent collects logs with the extension `*.log` and extensionless files
// that are stored in the `/var/log` directory of your pod from all namespaces, including `kube-system`. The agent then
// forwards the logs to your IBM Cloud Log Analysis with LogDNA service instance. </br></br><strong>Note:</strong>
// Before you use this API, make sure that you have an existing IBM Cloud Log Analysis with LogDNA service instance.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateLoggingInstance(createLoggingInstanceOptions *CreateLoggingInstanceOptions) (result *ConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateLoggingInstanceWithContext(context.Background(), createLoggingInstanceOptions)
}

// CreateLoggingInstanceWithContext is an alternate form of the CreateLoggingInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateLoggingInstanceWithContext(ctx context.Context, createLoggingInstanceOptions *CreateLoggingInstanceOptions) (result *ConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createLoggingInstanceOptions, "createLoggingInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createLoggingInstanceOptions, "createLoggingInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/logging/createConfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createLoggingInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateLoggingInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createLoggingInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*createLoggingInstanceOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if createLoggingInstanceOptions.Cluster != nil {
		body["cluster"] = createLoggingInstanceOptions.Cluster
	}
	if createLoggingInstanceOptions.IngestionKey != nil {
		body["ingestionKey"] = createLoggingInstanceOptions.IngestionKey
	}
	if createLoggingInstanceOptions.Instance != nil {
		body["instance"] = createLoggingInstanceOptions.Instance
	}
	if createLoggingInstanceOptions.PrivateEndpoint != nil {
		body["privateEndpoint"] = createLoggingInstanceOptions.PrivateEndpoint
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DiscoverLoggingInstance : Discover a LogDNA agent previously deployed in the cluster
// Discover a LogDNA agent previously deployed in the cluster and create a logging configuration for it.
func (kubernetesServiceApi *KubernetesServiceApiV1) DiscoverLoggingInstance(discoverLoggingInstanceOptions *DiscoverLoggingInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DiscoverLoggingInstanceWithContext(context.Background(), discoverLoggingInstanceOptions)
}

// DiscoverLoggingInstanceWithContext is an alternate form of the DiscoverLoggingInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DiscoverLoggingInstanceWithContext(ctx context.Context, discoverLoggingInstanceOptions *DiscoverLoggingInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(discoverLoggingInstanceOptions, "discoverLoggingInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(discoverLoggingInstanceOptions, "discoverLoggingInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/logging/discoverAgent`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range discoverLoggingInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DiscoverLoggingInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if discoverLoggingInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*discoverLoggingInstanceOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if discoverLoggingInstanceOptions.Cluster != nil {
		body["cluster"] = discoverLoggingInstanceOptions.Cluster
	}
	if discoverLoggingInstanceOptions.Instance != nil {
		body["instance"] = discoverLoggingInstanceOptions.Instance
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObsConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetLoggingInstance : Show the details of an existing LogDNA logging configuration
// Retrieve information about an existing LogDNA logging configuration for your cluster. To use this API, you must
// provide the name or ID of the cluster and the IBM Cloud Log Analysis with LogDNA service instance as query parameters
// in the format `/getConfig?cluster={idOrName}\u0026instance={idOrName}`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetLoggingInstance(getLoggingInstanceOptions *GetLoggingInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetLoggingInstanceWithContext(context.Background(), getLoggingInstanceOptions)
}

// GetLoggingInstanceWithContext is an alternate form of the GetLoggingInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetLoggingInstanceWithContext(ctx context.Context, getLoggingInstanceOptions *GetLoggingInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoggingInstanceOptions, "getLoggingInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoggingInstanceOptions, "getLoggingInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/logging/getConfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoggingInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetLoggingInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getLoggingInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*getLoggingInstanceOptions.XAuthRefreshToken))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getLoggingInstanceOptions.Cluster))
	builder.AddQuery("instance", fmt.Sprint(*getLoggingInstanceOptions.Instance))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObsConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetLoggingInstances : List all LogDNA logging configurations for a cluster
// Retrieve information about all LogDNA logging configurations that exist for a cluster. To use the API, you must
// provide the name or ID of the cluster as a query parameter in the format `/getConfigs?cluster={idOrName}`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetLoggingInstances(getLoggingInstancesOptions *GetLoggingInstancesOptions) (result []ObsConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetLoggingInstancesWithContext(context.Background(), getLoggingInstancesOptions)
}

// GetLoggingInstancesWithContext is an alternate form of the GetLoggingInstances method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetLoggingInstancesWithContext(ctx context.Context, getLoggingInstancesOptions *GetLoggingInstancesOptions) (result []ObsConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getLoggingInstancesOptions, "getLoggingInstancesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getLoggingInstancesOptions, "getLoggingInstancesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/logging/getConfigs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getLoggingInstancesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetLoggingInstances")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getLoggingInstancesOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*getLoggingInstancesOptions.XAuthRefreshToken))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getLoggingInstancesOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObsConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ModifyLoggingInstance : Update a LogDNA logging configuration in the cluster
// Update an existing LogDNA configuration in the cluster. Changes can be made to the logging instance connected to the
// cluster, ingestion key, or use of public or private endpoints for the logging instance.
func (kubernetesServiceApi *KubernetesServiceApiV1) ModifyLoggingInstance(modifyLoggingInstanceOptions *ModifyLoggingInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ModifyLoggingInstanceWithContext(context.Background(), modifyLoggingInstanceOptions)
}

// ModifyLoggingInstanceWithContext is an alternate form of the ModifyLoggingInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ModifyLoggingInstanceWithContext(ctx context.Context, modifyLoggingInstanceOptions *ModifyLoggingInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(modifyLoggingInstanceOptions, "modifyLoggingInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(modifyLoggingInstanceOptions, "modifyLoggingInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/logging/modifyConfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range modifyLoggingInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ModifyLoggingInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if modifyLoggingInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*modifyLoggingInstanceOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if modifyLoggingInstanceOptions.Cluster != nil {
		body["cluster"] = modifyLoggingInstanceOptions.Cluster
	}
	if modifyLoggingInstanceOptions.IngestionKey != nil {
		body["ingestionKey"] = modifyLoggingInstanceOptions.IngestionKey
	}
	if modifyLoggingInstanceOptions.Instance != nil {
		body["instance"] = modifyLoggingInstanceOptions.Instance
	}
	if modifyLoggingInstanceOptions.NewInstance != nil {
		body["newInstance"] = modifyLoggingInstanceOptions.NewInstance
	}
	if modifyLoggingInstanceOptions.PrivateEndpoint != nil {
		body["privateEndpoint"] = modifyLoggingInstanceOptions.PrivateEndpoint
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObsConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveLoggingInstance : Remove a LogDNA logging configuration from a cluster
// Remove an existing LogDNA logging configuration from a cluster. When you remove the logging configuration, pod logs
// are no longer sent to your IBM Cloud Log Analysis with LogDNA service instance. However, existing log data is still
// available until your selected retention period ends. To use the API, you must provide the name or ID of the cluster
// and the LogDNA service instance as query parameters in the format
// `/removeConfig?cluster={idOrName}\u0026instance={idOrName}`.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveLoggingInstance(removeLoggingInstanceOptions *RemoveLoggingInstanceOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveLoggingInstanceWithContext(context.Background(), removeLoggingInstanceOptions)
}

// RemoveLoggingInstanceWithContext is an alternate form of the RemoveLoggingInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveLoggingInstanceWithContext(ctx context.Context, removeLoggingInstanceOptions *RemoveLoggingInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeLoggingInstanceOptions, "removeLoggingInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeLoggingInstanceOptions, "removeLoggingInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/logging/removeConfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeLoggingInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveLoggingInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if removeLoggingInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*removeLoggingInstanceOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if removeLoggingInstanceOptions.Cluster != nil {
		body["cluster"] = removeLoggingInstanceOptions.Cluster
	}
	if removeLoggingInstanceOptions.Instance != nil {
		body["instance"] = removeLoggingInstanceOptions.Instance
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateMonitoringInstance : Create a Sysdig monitoring configuration for a cluster
// Create a monitoring configuration for your IBM Cloud Kubernetes Service cluster to automatically collect cluster and
// pod metrics, and send these metrics to your IBM Cloud Monitoring with Sysdig service instance. This API deploys a
// Sysdig agent as a Kubernetes daemonset in the `ibm-observe` namespace of your cluster. The agent collects cluster and
// pod metrics, such as the worker node CPU and memory usage, and the amount of incoming and outgoing network traffic
// for your pods. The agent then forwards the metrics to your IBM Cloud Monitoring with Sysdig service instance.
// </br></br><strong>Note:</strong> Before you use this API, make sure that you have an existing IBM Cloud Monitoring
// with Sysdig service instance.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateMonitoringInstance(createMonitoringInstanceOptions *CreateMonitoringInstanceOptions) (result *ConfigResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateMonitoringInstanceWithContext(context.Background(), createMonitoringInstanceOptions)
}

// CreateMonitoringInstanceWithContext is an alternate form of the CreateMonitoringInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateMonitoringInstanceWithContext(ctx context.Context, createMonitoringInstanceOptions *CreateMonitoringInstanceOptions) (result *ConfigResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createMonitoringInstanceOptions, "createMonitoringInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createMonitoringInstanceOptions, "createMonitoringInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/monitoring/createConfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createMonitoringInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateMonitoringInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createMonitoringInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*createMonitoringInstanceOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if createMonitoringInstanceOptions.Cluster != nil {
		body["cluster"] = createMonitoringInstanceOptions.Cluster
	}
	if createMonitoringInstanceOptions.IngestionKey != nil {
		body["ingestionKey"] = createMonitoringInstanceOptions.IngestionKey
	}
	if createMonitoringInstanceOptions.Instance != nil {
		body["instance"] = createMonitoringInstanceOptions.Instance
	}
	if createMonitoringInstanceOptions.PrivateEndpoint != nil {
		body["privateEndpoint"] = createMonitoringInstanceOptions.PrivateEndpoint
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalConfigResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DiscoverMonitoringInstance : Discover a Sysdig agent previously deployed in the cluster
// Discover a Sysdig agent previously deployed in the cluster and create a monitoring configuration for it.
func (kubernetesServiceApi *KubernetesServiceApiV1) DiscoverMonitoringInstance(discoverMonitoringInstanceOptions *DiscoverMonitoringInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DiscoverMonitoringInstanceWithContext(context.Background(), discoverMonitoringInstanceOptions)
}

// DiscoverMonitoringInstanceWithContext is an alternate form of the DiscoverMonitoringInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DiscoverMonitoringInstanceWithContext(ctx context.Context, discoverMonitoringInstanceOptions *DiscoverMonitoringInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(discoverMonitoringInstanceOptions, "discoverMonitoringInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(discoverMonitoringInstanceOptions, "discoverMonitoringInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/monitoring/discoverAgent`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range discoverMonitoringInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DiscoverMonitoringInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if discoverMonitoringInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*discoverMonitoringInstanceOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if discoverMonitoringInstanceOptions.Cluster != nil {
		body["cluster"] = discoverMonitoringInstanceOptions.Cluster
	}
	if discoverMonitoringInstanceOptions.Instance != nil {
		body["instance"] = discoverMonitoringInstanceOptions.Instance
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObsConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetMonitoringInstance : Show the details of an existing Sysdig monitoring configuration
// Retrieve information about an existing Sysdig monitoring configuration for your cluster. To use this API, you must
// provide the name or ID of the cluster and the IBM Cloud Monitoring with Sysdig service instance as query parameters
// in the format `/getConfig?cluster={idOrName}\u0026instance={idOrName}`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMonitoringInstance(getMonitoringInstanceOptions *GetMonitoringInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetMonitoringInstanceWithContext(context.Background(), getMonitoringInstanceOptions)
}

// GetMonitoringInstanceWithContext is an alternate form of the GetMonitoringInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMonitoringInstanceWithContext(ctx context.Context, getMonitoringInstanceOptions *GetMonitoringInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getMonitoringInstanceOptions, "getMonitoringInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getMonitoringInstanceOptions, "getMonitoringInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/monitoring/getConfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getMonitoringInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetMonitoringInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getMonitoringInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*getMonitoringInstanceOptions.XAuthRefreshToken))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getMonitoringInstanceOptions.Cluster))
	builder.AddQuery("instance", fmt.Sprint(*getMonitoringInstanceOptions.Instance))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObsConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetMonitoringInstances : List all Sysdig monitoring configurations for a cluster
// Retrieve information about all Sysdig monitoring configurations that exist for a cluster. To use the API, you must
// provide the name or ID of the cluster as a query parameter in the format `/getConfigs?cluster={idOrName}`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMonitoringInstances(getMonitoringInstancesOptions *GetMonitoringInstancesOptions) (result []ObsConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetMonitoringInstancesWithContext(context.Background(), getMonitoringInstancesOptions)
}

// GetMonitoringInstancesWithContext is an alternate form of the GetMonitoringInstances method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMonitoringInstancesWithContext(ctx context.Context, getMonitoringInstancesOptions *GetMonitoringInstancesOptions) (result []ObsConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getMonitoringInstancesOptions, "getMonitoringInstancesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getMonitoringInstancesOptions, "getMonitoringInstancesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/monitoring/getConfigs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getMonitoringInstancesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetMonitoringInstances")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getMonitoringInstancesOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*getMonitoringInstancesOptions.XAuthRefreshToken))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getMonitoringInstancesOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObsConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ModifyMonitoringInstance : Update a Sysdig monitoring configuration in the cluster
// Update an existing Sysdig monitoring configuration in the cluster.  Changes can be made to the monitoring instance
// connected to the cluster, ingestion key, or use of public or private endpoints for the monitoring instance.
func (kubernetesServiceApi *KubernetesServiceApiV1) ModifyMonitoringInstance(modifyMonitoringInstanceOptions *ModifyMonitoringInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ModifyMonitoringInstanceWithContext(context.Background(), modifyMonitoringInstanceOptions)
}

// ModifyMonitoringInstanceWithContext is an alternate form of the ModifyMonitoringInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ModifyMonitoringInstanceWithContext(ctx context.Context, modifyMonitoringInstanceOptions *ModifyMonitoringInstanceOptions) (result *ObsConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(modifyMonitoringInstanceOptions, "modifyMonitoringInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(modifyMonitoringInstanceOptions, "modifyMonitoringInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/monitoring/modifyConfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range modifyMonitoringInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ModifyMonitoringInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if modifyMonitoringInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*modifyMonitoringInstanceOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if modifyMonitoringInstanceOptions.Cluster != nil {
		body["cluster"] = modifyMonitoringInstanceOptions.Cluster
	}
	if modifyMonitoringInstanceOptions.IngestionKey != nil {
		body["ingestionKey"] = modifyMonitoringInstanceOptions.IngestionKey
	}
	if modifyMonitoringInstanceOptions.Instance != nil {
		body["instance"] = modifyMonitoringInstanceOptions.Instance
	}
	if modifyMonitoringInstanceOptions.NewInstance != nil {
		body["newInstance"] = modifyMonitoringInstanceOptions.NewInstance
	}
	if modifyMonitoringInstanceOptions.PrivateEndpoint != nil {
		body["privateEndpoint"] = modifyMonitoringInstanceOptions.PrivateEndpoint
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObsConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveMonitoringInstance : Remove a Sysdig monitoring configuration from a cluster
// Remove an existing Sysdig monitoring configuration from a cluster. When you remove the monitoring configuration, pod
// and cluster metrics are no longer sent to your IBM Cloud Monitoring with Sysdig service instance. However, existing
// metrics are still available until your selected retention period ends. To use the API, you must provide the name or
// ID of the cluster and the Sysdig service instance as query parameters in the format
// `/removeConfig?cluster={idOrName}\u0026instance={idOrName}`.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveMonitoringInstance(removeMonitoringInstanceOptions *RemoveMonitoringInstanceOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveMonitoringInstanceWithContext(context.Background(), removeMonitoringInstanceOptions)
}

// RemoveMonitoringInstanceWithContext is an alternate form of the RemoveMonitoringInstance method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveMonitoringInstanceWithContext(ctx context.Context, removeMonitoringInstanceOptions *RemoveMonitoringInstanceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeMonitoringInstanceOptions, "removeMonitoringInstanceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeMonitoringInstanceOptions, "removeMonitoringInstanceOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/observe/monitoring/removeConfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeMonitoringInstanceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveMonitoringInstance")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if removeMonitoringInstanceOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*removeMonitoringInstanceOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if removeMonitoringInstanceOptions.Cluster != nil {
		body["cluster"] = removeMonitoringInstanceOptions.Cluster
	}
	if removeMonitoringInstanceOptions.Instance != nil {
		body["instance"] = removeMonitoringInstanceOptions.Instance
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// UpdateDNSWithIP : Update a DNS record by adding an NLB IP address
// In a classic cluster, add an NLB IP address to an existing NLB subdomain that you created. For example, in a
// multizone cluster, you create an NLB in each zone to expose an app. You registered an NLB IP in one zone with a
// subdomain by using the `POST /clusters/{idOrName}/register` call, so now you can add the NLB IPs from the other zones
// to this existing subdomain.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateDNSWithIP(updateDNSWithIPOptions *UpdateDNSWithIPOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateDNSWithIPWithContext(context.Background(), updateDNSWithIPOptions)
}

// UpdateDNSWithIPWithContext is an alternate form of the UpdateDNSWithIP method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateDNSWithIPWithContext(ctx context.Context, updateDNSWithIPOptions *UpdateDNSWithIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateDNSWithIPOptions, "updateDNSWithIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateDNSWithIPOptions, "updateDNSWithIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *updateDNSWithIPOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/clusters/{idOrName}/add`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateDNSWithIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateDNSWithIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if updateDNSWithIPOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*updateDNSWithIPOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if updateDNSWithIPOptions.ClusterID != nil {
		body["clusterID"] = updateDNSWithIPOptions.ClusterID
	}
	if updateDNSWithIPOptions.NlbHost != nil {
		body["nlbHost"] = updateDNSWithIPOptions.NlbHost
	}
	if updateDNSWithIPOptions.NlbIPArray != nil {
		body["nlbIPArray"] = updateDNSWithIPOptions.NlbIPArray
	}
	if updateDNSWithIPOptions.NlbMonitorState != nil {
		body["nlbMonitorState"] = updateDNSWithIPOptions.NlbMonitorState
	}
	if updateDNSWithIPOptions.NlbSslSecretName != nil {
		body["nlbSslSecretName"] = updateDNSWithIPOptions.NlbSslSecretName
	}
	if updateDNSWithIPOptions.NlbSslSecretStatus != nil {
		body["nlbSslSecretStatus"] = updateDNSWithIPOptions.NlbSslSecretStatus
	}
	if updateDNSWithIPOptions.NlbType != nil {
		body["nlbType"] = updateDNSWithIPOptions.NlbType
	}
	if updateDNSWithIPOptions.SecretNamespace != nil {
		body["secretNamespace"] = updateDNSWithIPOptions.SecretNamespace
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// UnregisterDNSWithIP : Remove an IP address from an NLB subdomain
// In a classic cluster, remove an IP address from the DNS record for an existing NLB subdomain. If you remove all IPs
// from a hostname, the hostname still exists but no IPs are associated with it.
func (kubernetesServiceApi *KubernetesServiceApiV1) UnregisterDNSWithIP(unregisterDNSWithIPOptions *UnregisterDNSWithIPOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UnregisterDNSWithIPWithContext(context.Background(), unregisterDNSWithIPOptions)
}

// UnregisterDNSWithIPWithContext is an alternate form of the UnregisterDNSWithIP method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UnregisterDNSWithIPWithContext(ctx context.Context, unregisterDNSWithIPOptions *UnregisterDNSWithIPOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(unregisterDNSWithIPOptions, "unregisterDNSWithIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(unregisterDNSWithIPOptions, "unregisterDNSWithIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *unregisterDNSWithIPOptions.IdOrName,
		"nlbHost":  *unregisterDNSWithIPOptions.NlbHost,
		"nlbIP":    *unregisterDNSWithIPOptions.NlbIP,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/clusters/{idOrName}/host/{nlbHost}/ip/{nlbIP}/remove`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range unregisterDNSWithIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UnregisterDNSWithIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if unregisterDNSWithIPOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*unregisterDNSWithIPOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// ListNLBIPsForSubdomain : List registered NLB subdomains and NLB IP addresses
// In a classic cluster, list NLB subdomains and the NLB IP addresses registered with the DNS provider for each
// subdomain.
func (kubernetesServiceApi *KubernetesServiceApiV1) ListNLBIPsForSubdomain(listNLBIPsForSubdomainOptions *ListNLBIPsForSubdomainOptions) (result *ClusterNlbHostsList, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ListNLBIPsForSubdomainWithContext(context.Background(), listNLBIPsForSubdomainOptions)
}

// ListNLBIPsForSubdomainWithContext is an alternate form of the ListNLBIPsForSubdomain method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ListNLBIPsForSubdomainWithContext(ctx context.Context, listNLBIPsForSubdomainOptions *ListNLBIPsForSubdomainOptions) (result *ClusterNlbHostsList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listNLBIPsForSubdomainOptions, "listNLBIPsForSubdomainOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listNLBIPsForSubdomainOptions, "listNLBIPsForSubdomainOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *listNLBIPsForSubdomainOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/clusters/{idOrName}/list`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNLBIPsForSubdomainOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ListNLBIPsForSubdomain")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if listNLBIPsForSubdomainOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*listNLBIPsForSubdomainOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterNlbHostsList)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RegisterDNSWithIP : Create a new NLB subdomain and associate one or more NLB IP addresses with it
// In a classic cluster, create a new NLB subdomain and register NLB IP addresses with the DNS provider. If the
// registration fails, an error from the DNS provider is returned.
func (kubernetesServiceApi *KubernetesServiceApiV1) RegisterDNSWithIP(registerDNSWithIPOptions *RegisterDNSWithIPOptions) (result *NlbConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RegisterDNSWithIPWithContext(context.Background(), registerDNSWithIPOptions)
}

// RegisterDNSWithIPWithContext is an alternate form of the RegisterDNSWithIP method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RegisterDNSWithIPWithContext(ctx context.Context, registerDNSWithIPOptions *RegisterDNSWithIPOptions) (result *NlbConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(registerDNSWithIPOptions, "registerDNSWithIPOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(registerDNSWithIPOptions, "registerDNSWithIPOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *registerDNSWithIPOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/clusters/{idOrName}/register`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range registerDNSWithIPOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RegisterDNSWithIP")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if registerDNSWithIPOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*registerDNSWithIPOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if registerDNSWithIPOptions.ClusterID != nil {
		body["clusterID"] = registerDNSWithIPOptions.ClusterID
	}
	if registerDNSWithIPOptions.NlbHost != nil {
		body["nlbHost"] = registerDNSWithIPOptions.NlbHost
	}
	if registerDNSWithIPOptions.NlbIPArray != nil {
		body["nlbIPArray"] = registerDNSWithIPOptions.NlbIPArray
	}
	if registerDNSWithIPOptions.NlbMonitorState != nil {
		body["nlbMonitorState"] = registerDNSWithIPOptions.NlbMonitorState
	}
	if registerDNSWithIPOptions.NlbSslSecretName != nil {
		body["nlbSslSecretName"] = registerDNSWithIPOptions.NlbSslSecretName
	}
	if registerDNSWithIPOptions.NlbSslSecretStatus != nil {
		body["nlbSslSecretStatus"] = registerDNSWithIPOptions.NlbSslSecretStatus
	}
	if registerDNSWithIPOptions.NlbType != nil {
		body["nlbType"] = registerDNSWithIPOptions.NlbType
	}
	if registerDNSWithIPOptions.SecretNamespace != nil {
		body["secretNamespace"] = registerDNSWithIPOptions.SecretNamespace
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNlbConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateNlbDNSHealthMonitor : Enable or disable a health check monitor for an NLB subdomain
// Enable or disable an existing health check monitor for an NLB subdomain.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateNlbDNSHealthMonitor(updateNlbDNSHealthMonitorOptions *UpdateNlbDNSHealthMonitorOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateNlbDNSHealthMonitorWithContext(context.Background(), updateNlbDNSHealthMonitorOptions)
}

// UpdateNlbDNSHealthMonitorWithContext is an alternate form of the UpdateNlbDNSHealthMonitor method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateNlbDNSHealthMonitorWithContext(ctx context.Context, updateNlbDNSHealthMonitorOptions *UpdateNlbDNSHealthMonitorOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateNlbDNSHealthMonitorOptions, "updateNlbDNSHealthMonitorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateNlbDNSHealthMonitorOptions, "updateNlbDNSHealthMonitorOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *updateNlbDNSHealthMonitorOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/clusters/{idOrName}/health`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateNlbDNSHealthMonitorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateNlbDNSHealthMonitor")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if updateNlbDNSHealthMonitorOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*updateNlbDNSHealthMonitorOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if updateNlbDNSHealthMonitorOptions.ClusterID != nil {
		body["clusterID"] = updateNlbDNSHealthMonitorOptions.ClusterID
	}
	if updateNlbDNSHealthMonitorOptions.NlbHost != nil {
		body["nlbHost"] = updateNlbDNSHealthMonitorOptions.NlbHost
	}
	if updateNlbDNSHealthMonitorOptions.NlbIPArray != nil {
		body["nlbIPArray"] = updateNlbDNSHealthMonitorOptions.NlbIPArray
	}
	if updateNlbDNSHealthMonitorOptions.NlbMonitorState != nil {
		body["nlbMonitorState"] = updateNlbDNSHealthMonitorOptions.NlbMonitorState
	}
	if updateNlbDNSHealthMonitorOptions.NlbSslSecretName != nil {
		body["nlbSslSecretName"] = updateNlbDNSHealthMonitorOptions.NlbSslSecretName
	}
	if updateNlbDNSHealthMonitorOptions.NlbSslSecretStatus != nil {
		body["nlbSslSecretStatus"] = updateNlbDNSHealthMonitorOptions.NlbSslSecretStatus
	}
	if updateNlbDNSHealthMonitorOptions.NlbType != nil {
		body["nlbType"] = updateNlbDNSHealthMonitorOptions.NlbType
	}
	if updateNlbDNSHealthMonitorOptions.SecretNamespace != nil {
		body["secretNamespace"] = updateNlbDNSHealthMonitorOptions.SecretNamespace
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// AddNlbDNSHealthMonitor : Configure a health check monitor for an NLB subdomain
// In a classic cluster, create and optionally enable a health check monitor for an existing NLB subdomain in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) AddNlbDNSHealthMonitor(addNlbDNSHealthMonitorOptions *AddNlbDNSHealthMonitorOptions) (result *NlbHealthConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AddNlbDNSHealthMonitorWithContext(context.Background(), addNlbDNSHealthMonitorOptions)
}

// AddNlbDNSHealthMonitorWithContext is an alternate form of the AddNlbDNSHealthMonitor method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AddNlbDNSHealthMonitorWithContext(ctx context.Context, addNlbDNSHealthMonitorOptions *AddNlbDNSHealthMonitorOptions) (result *NlbHealthConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(addNlbDNSHealthMonitorOptions, "addNlbDNSHealthMonitorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(addNlbDNSHealthMonitorOptions, "addNlbDNSHealthMonitorOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *addNlbDNSHealthMonitorOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/health/clusters/{idOrName}/config`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range addNlbDNSHealthMonitorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AddNlbDNSHealthMonitor")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if addNlbDNSHealthMonitorOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*addNlbDNSHealthMonitorOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if addNlbDNSHealthMonitorOptions.AllowInsecureSet != nil {
		body["allowInsecureSet"] = addNlbDNSHealthMonitorOptions.AllowInsecureSet
	}
	if addNlbDNSHealthMonitorOptions.ClusterID != nil {
		body["clusterID"] = addNlbDNSHealthMonitorOptions.ClusterID
	}
	if addNlbDNSHealthMonitorOptions.CreatedOn != nil {
		body["createdOn"] = addNlbDNSHealthMonitorOptions.CreatedOn
	}
	if addNlbDNSHealthMonitorOptions.Desc != nil {
		body["desc"] = addNlbDNSHealthMonitorOptions.Desc
	}
	if addNlbDNSHealthMonitorOptions.FollowRedirectSet != nil {
		body["followRedirectSet"] = addNlbDNSHealthMonitorOptions.FollowRedirectSet
	}
	if addNlbDNSHealthMonitorOptions.HealtcheckPropertiesSetStatus != nil {
		body["healtcheckPropertiesSetStatus"] = addNlbDNSHealthMonitorOptions.HealtcheckPropertiesSetStatus
	}
	if addNlbDNSHealthMonitorOptions.HealthcheckProperties != nil {
		body["healthcheckProperties"] = addNlbDNSHealthMonitorOptions.HealthcheckProperties
	}
	if addNlbDNSHealthMonitorOptions.ModifiedOn != nil {
		body["modifiedOn"] = addNlbDNSHealthMonitorOptions.ModifiedOn
	}
	if addNlbDNSHealthMonitorOptions.MonitorState != nil {
		body["monitorState"] = addNlbDNSHealthMonitorOptions.MonitorState
	}
	if addNlbDNSHealthMonitorOptions.NlbHost != nil {
		body["nlbHost"] = addNlbDNSHealthMonitorOptions.NlbHost
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNlbHealthConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetNlbDNSHealthMonitor : View the health check monitor settings for an NLB subdomain
// In a classic cluster, view the health check monitor settings for an NLB subdomain.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetNlbDNSHealthMonitor(getNlbDNSHealthMonitorOptions *GetNlbDNSHealthMonitorOptions) (result *NlbHealthConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetNlbDNSHealthMonitorWithContext(context.Background(), getNlbDNSHealthMonitorOptions)
}

// GetNlbDNSHealthMonitorWithContext is an alternate form of the GetNlbDNSHealthMonitor method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetNlbDNSHealthMonitorWithContext(ctx context.Context, getNlbDNSHealthMonitorOptions *GetNlbDNSHealthMonitorOptions) (result *NlbHealthConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getNlbDNSHealthMonitorOptions, "getNlbDNSHealthMonitorOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getNlbDNSHealthMonitorOptions, "getNlbDNSHealthMonitorOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *getNlbDNSHealthMonitorOptions.IdOrName,
		"nlbHost":  *getNlbDNSHealthMonitorOptions.NlbHost,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/health/clusters/{idOrName}/host/{nlbHost}/config`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getNlbDNSHealthMonitorOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetNlbDNSHealthMonitor")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getNlbDNSHealthMonitorOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getNlbDNSHealthMonitorOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNlbHealthConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListNlbDNSHealthMonitors : List the health check monitor settings for all NLB subdomains
// In a classic cluster, list the settings for all existing health check monitors in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) ListNlbDNSHealthMonitors(listNlbDNSHealthMonitorsOptions *ListNlbDNSHealthMonitorsOptions) (result *ClusterNlbHostsList, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ListNlbDNSHealthMonitorsWithContext(context.Background(), listNlbDNSHealthMonitorsOptions)
}

// ListNlbDNSHealthMonitorsWithContext is an alternate form of the ListNlbDNSHealthMonitors method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ListNlbDNSHealthMonitorsWithContext(ctx context.Context, listNlbDNSHealthMonitorsOptions *ListNlbDNSHealthMonitorsOptions) (result *ClusterNlbHostsList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listNlbDNSHealthMonitorsOptions, "listNlbDNSHealthMonitorsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listNlbDNSHealthMonitorsOptions, "listNlbDNSHealthMonitorsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *listNlbDNSHealthMonitorsOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/health/clusters/{idOrName}/list`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNlbDNSHealthMonitorsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ListNlbDNSHealthMonitors")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if listNlbDNSHealthMonitorsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*listNlbDNSHealthMonitorsOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterNlbHostsList)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListNlbDNSHealthMonitorStatus : List the health check status for the IPs behind NLB subdomains in a cluster
// List the health check status (`healthy` or `not healthy`) that is returned by the monitors for the IPs behind all NLB
// subdomains in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) ListNlbDNSHealthMonitorStatus(listNlbDNSHealthMonitorStatusOptions *ListNlbDNSHealthMonitorStatusOptions) (result *ClusterNlbHostsList, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ListNlbDNSHealthMonitorStatusWithContext(context.Background(), listNlbDNSHealthMonitorStatusOptions)
}

// ListNlbDNSHealthMonitorStatusWithContext is an alternate form of the ListNlbDNSHealthMonitorStatus method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ListNlbDNSHealthMonitorStatusWithContext(ctx context.Context, listNlbDNSHealthMonitorStatusOptions *ListNlbDNSHealthMonitorStatusOptions) (result *ClusterNlbHostsList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listNlbDNSHealthMonitorStatusOptions, "listNlbDNSHealthMonitorStatusOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listNlbDNSHealthMonitorStatusOptions, "listNlbDNSHealthMonitorStatusOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"idOrName": *listNlbDNSHealthMonitorStatusOptions.IdOrName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/nlb-dns/health/clusters/{idOrName}/status`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listNlbDNSHealthMonitorStatusOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ListNlbDNSHealthMonitorStatus")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if listNlbDNSHealthMonitorStatusOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*listNlbDNSHealthMonitorStatusOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterNlbHostsList)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetDatacenterVLANs : List available VLANs for a zone
// List available public and private VLANs for a specified zone (data center). Before using this operation, you must
// store your IBM Cloud infrastructure (SoftLayer) credentials in each Kubernetes Service account by using the `POST
// /v1/credentials` API or by running `ibmcloud ks credential set --infrastructure-api-key <API_key>
// --infrastructure-username <API_username>`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetDatacenterVLANs(getDatacenterVLANsOptions *GetDatacenterVLANsOptions) (result []VLAN, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetDatacenterVLANsWithContext(context.Background(), getDatacenterVLANsOptions)
}

// GetDatacenterVLANsWithContext is an alternate form of the GetDatacenterVLANs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetDatacenterVLANsWithContext(ctx context.Context, getDatacenterVLANsOptions *GetDatacenterVLANsOptions) (result []VLAN, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDatacenterVLANsOptions, "getDatacenterVLANsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDatacenterVLANsOptions, "getDatacenterVLANsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"datacenter": *getDatacenterVLANsOptions.Datacenter,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/datacenters/{datacenter}/vlans`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDatacenterVLANsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetDatacenterVLANs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getDatacenterVLANsOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*getDatacenterVLANsOptions.XAuthRefreshToken))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVLAN)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListSubnets : List available IBM Cloud infrastructure (SoftLayer) subnets
// List available subnets in an IBM Cloud infrastructure (SoftLayer) account. Before using this operation, you must
// store your IBM Cloud infrastructure (SoftLayer) credentials in each Kubernetes Service account by using the `POST
// /v1/credentials` API or by running `ibmcloud ks credential set --infrastructure-api-key <API_key>
// --infrastructure-username <API_username>`.
func (kubernetesServiceApi *KubernetesServiceApiV1) ListSubnets(listSubnetsOptions *ListSubnetsOptions) (result []Subnet, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ListSubnetsWithContext(context.Background(), listSubnetsOptions)
}

// ListSubnetsWithContext is an alternate form of the ListSubnets method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ListSubnetsWithContext(ctx context.Context, listSubnetsOptions *ListSubnetsOptions) (result []Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listSubnetsOptions, "listSubnetsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listSubnetsOptions, "listSubnetsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/subnets`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listSubnetsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ListSubnets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if listSubnetsOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*listSubnetsOptions.XAuthRefreshToken))
	}
	if listSubnetsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*listSubnetsOptions.XAuthResourceGroup))
	}

	if listSubnetsOptions.Datacenters != nil {
		builder.AddQuery("datacenters", fmt.Sprint(*listSubnetsOptions.Datacenters))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnet)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateSatelliteCluster : Create an IBM Cloud Satellite cluster
// Create an OpenShift Container Platform cluster in an IBM Cloud Satellite location. Creating a cluster requires
// Administrator access to Kubernetes Service in the IBM Cloud account. After you create a Satellite cluster, assign
// hosts to the cluster to add compute capacity for your workloads.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteCluster(createSatelliteClusterOptions *CreateSatelliteClusterOptions) (result *MultishiftCreateClusterResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateSatelliteClusterWithContext(context.Background(), createSatelliteClusterOptions)
}

// CreateSatelliteClusterWithContext is an alternate form of the CreateSatelliteCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteClusterWithContext(ctx context.Context, createSatelliteClusterOptions *CreateSatelliteClusterOptions) (result *MultishiftCreateClusterResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSatelliteClusterOptions, "createSatelliteClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSatelliteClusterOptions, "createSatelliteClusterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/createCluster`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSatelliteClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateSatelliteCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSatelliteClusterOptions.AdminAgentOptIn != nil {
		body["adminAgentOptIn"] = createSatelliteClusterOptions.AdminAgentOptIn
	}
	if createSatelliteClusterOptions.Controller != nil {
		body["controller"] = createSatelliteClusterOptions.Controller
	}
	if createSatelliteClusterOptions.KubeVersion != nil {
		body["kubeVersion"] = createSatelliteClusterOptions.KubeVersion
	}
	if createSatelliteClusterOptions.Labels != nil {
		body["labels"] = createSatelliteClusterOptions.Labels
	}
	if createSatelliteClusterOptions.Name != nil {
		body["name"] = createSatelliteClusterOptions.Name
	}
	if createSatelliteClusterOptions.PodSubnet != nil {
		body["podSubnet"] = createSatelliteClusterOptions.PodSubnet
	}
	if createSatelliteClusterOptions.PullSecret != nil {
		body["pullSecret"] = createSatelliteClusterOptions.PullSecret
	}
	if createSatelliteClusterOptions.ServiceSubnet != nil {
		body["serviceSubnet"] = createSatelliteClusterOptions.ServiceSubnet
	}
	if createSatelliteClusterOptions.WorkerCount != nil {
		body["workerCount"] = createSatelliteClusterOptions.WorkerCount
	}
	if createSatelliteClusterOptions.Zone != nil {
		body["zone"] = createSatelliteClusterOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMultishiftCreateClusterResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateSatelliteWorkerPool : Create a worker pool for an IBM Cloud Satellite cluster
// Create a worker pool for the specified cluster in an IBM Cloud Satellite location. Creating a worker pool requires
// Operator access to Kubernetes Service in the IBM Cloud account. Specify the worker pool `flavor` as "upi" for user
// provided infrastructure. You can also use `hostLabels` key value pairs so that available hosts with matching labels
// in the IBM Cloud Satellite location are automatically assigned to the worker pool.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteWorkerPool(createSatelliteWorkerPoolOptions *CreateSatelliteWorkerPoolOptions) (result *CreateWorkerpoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateSatelliteWorkerPoolWithContext(context.Background(), createSatelliteWorkerPoolOptions)
}

// CreateSatelliteWorkerPoolWithContext is an alternate form of the CreateSatelliteWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteWorkerPoolWithContext(ctx context.Context, createSatelliteWorkerPoolOptions *CreateSatelliteWorkerPoolOptions) (result *CreateWorkerpoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSatelliteWorkerPoolOptions, "createSatelliteWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSatelliteWorkerPoolOptions, "createSatelliteWorkerPoolOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/createWorkerPool`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSatelliteWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateSatelliteWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSatelliteWorkerPoolOptions.Zones != nil {
		body["Zones"] = createSatelliteWorkerPoolOptions.Zones
	}
	if createSatelliteWorkerPoolOptions.Cluster != nil {
		body["cluster"] = createSatelliteWorkerPoolOptions.Cluster
	}
	if createSatelliteWorkerPoolOptions.DiskEncryption != nil {
		body["diskEncryption"] = createSatelliteWorkerPoolOptions.DiskEncryption
	}
	if createSatelliteWorkerPoolOptions.Entitlement != nil {
		body["entitlement"] = createSatelliteWorkerPoolOptions.Entitlement
	}
	if createSatelliteWorkerPoolOptions.Flavor != nil {
		body["flavor"] = createSatelliteWorkerPoolOptions.Flavor
	}
	if createSatelliteWorkerPoolOptions.HostLabels != nil {
		body["hostLabels"] = createSatelliteWorkerPoolOptions.HostLabels
	}
	if createSatelliteWorkerPoolOptions.Isolation != nil {
		body["isolation"] = createSatelliteWorkerPoolOptions.Isolation
	}
	if createSatelliteWorkerPoolOptions.Labels != nil {
		body["labels"] = createSatelliteWorkerPoolOptions.Labels
	}
	if createSatelliteWorkerPoolOptions.Name != nil {
		body["name"] = createSatelliteWorkerPoolOptions.Name
	}
	if createSatelliteWorkerPoolOptions.WorkerCount != nil {
		body["workerCount"] = createSatelliteWorkerPoolOptions.WorkerCount
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateWorkerpoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateSatelliteWorkerPoolZone : Create a zone in the specified worker pool for an IBM Cloud Satellite cluster
// Create a zone in the specified worker pool for an IBM Cloud Satellite cluster. Worker nodes are provisioned in each
// zone based on the size per zone of the worker pool.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteWorkerPoolZone(createSatelliteWorkerPoolZoneOptions *CreateSatelliteWorkerPoolZoneOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateSatelliteWorkerPoolZoneWithContext(context.Background(), createSatelliteWorkerPoolZoneOptions)
}

// CreateSatelliteWorkerPoolZoneWithContext is an alternate form of the CreateSatelliteWorkerPoolZone method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteWorkerPoolZoneWithContext(ctx context.Context, createSatelliteWorkerPoolZoneOptions *CreateSatelliteWorkerPoolZoneOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSatelliteWorkerPoolZoneOptions, "createSatelliteWorkerPoolZoneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSatelliteWorkerPoolZoneOptions, "createSatelliteWorkerPoolZoneOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/createWorkerPoolZone`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSatelliteWorkerPoolZoneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateSatelliteWorkerPoolZone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSatelliteWorkerPoolZoneOptions.Cluster != nil {
		body["cluster"] = createSatelliteWorkerPoolZoneOptions.Cluster
	}
	if createSatelliteWorkerPoolZoneOptions.ID != nil {
		body["id"] = createSatelliteWorkerPoolZoneOptions.ID
	}
	if createSatelliteWorkerPoolZoneOptions.Workerpool != nil {
		body["workerpool"] = createSatelliteWorkerPoolZoneOptions.Workerpool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetSatelliteClusters : List the IBM Cloud Satellite clusters that you have access to
// List the IBM Cloud Satellite clusters that you have access to.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteClusters(getSatelliteClustersOptions *GetSatelliteClustersOptions) (result []GetClustersResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSatelliteClustersWithContext(context.Background(), getSatelliteClustersOptions)
}

// GetSatelliteClustersWithContext is an alternate form of the GetSatelliteClusters method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteClustersWithContext(ctx context.Context, getSatelliteClustersOptions *GetSatelliteClustersOptions) (result []GetClustersResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getSatelliteClustersOptions, "getSatelliteClustersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/getClusters`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSatelliteClustersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSatelliteClusters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetClustersResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateSatelliteAssignment : Assign a host to an IBM Cloud Satellite location or cluster
// Assign a host to an IBM Cloud Satellite location or cluster. Before you can assign hosts to clusters, first assign at
// least three hosts to the Satellite location, to run control plane operations. Then, when you have Satellite clusters,
// you can assign hosts as needed to provide compute resources for your workloads. You can assign hosts by specifying a
// host ID or by providing labels to match hosts to your request.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteAssignment(createSatelliteAssignmentOptions *CreateSatelliteAssignmentOptions) (result *MultishiftCreateAssignmentResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateSatelliteAssignmentWithContext(context.Background(), createSatelliteAssignmentOptions)
}

// CreateSatelliteAssignmentWithContext is an alternate form of the CreateSatelliteAssignment method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteAssignmentWithContext(ctx context.Context, createSatelliteAssignmentOptions *CreateSatelliteAssignmentOptions) (result *MultishiftCreateAssignmentResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSatelliteAssignmentOptions, "createSatelliteAssignmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSatelliteAssignmentOptions, "createSatelliteAssignmentOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/hostqueue/createAssignment`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSatelliteAssignmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateSatelliteAssignment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSatelliteAssignmentOptions.Cluster != nil {
		body["cluster"] = createSatelliteAssignmentOptions.Cluster
	}
	if createSatelliteAssignmentOptions.Controller != nil {
		body["controller"] = createSatelliteAssignmentOptions.Controller
	}
	if createSatelliteAssignmentOptions.HostID != nil {
		body["hostID"] = createSatelliteAssignmentOptions.HostID
	}
	if createSatelliteAssignmentOptions.Labels != nil {
		body["labels"] = createSatelliteAssignmentOptions.Labels
	}
	if createSatelliteAssignmentOptions.Workerpool != nil {
		body["workerpool"] = createSatelliteAssignmentOptions.Workerpool
	}
	if createSatelliteAssignmentOptions.Zone != nil {
		body["zone"] = createSatelliteAssignmentOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMultishiftCreateAssignmentResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// AttachSatelliteHost : Attach a host to an IBM Cloud Satellite location
// Create a script to run on a Red Hat Enterprise Linux 7 host in your on-premises infrastructure. The script attaches
// the host to your IBM Cloud Satellite location. The host must have access to the public network in order for the
// script to complete.
func (kubernetesServiceApi *KubernetesServiceApiV1) AttachSatelliteHost(attachSatelliteHostOptions *AttachSatelliteHostOptions) (response []byte, err error) {
	return kubernetesServiceApi.AttachSatelliteHostWithContext(context.Background(), attachSatelliteHostOptions)
}

// AttachSatelliteHostWithContext is an alternate form of the AttachSatelliteHost method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AttachSatelliteHostWithContext(ctx context.Context, attachSatelliteHostOptions *AttachSatelliteHostOptions) (response []byte, err error) {
	err = core.ValidateNotNil(attachSatelliteHostOptions, "attachSatelliteHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(attachSatelliteHostOptions, "attachSatelliteHostOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/hostqueue/createRegistrationScript`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range attachSatelliteHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AttachSatelliteHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if attachSatelliteHostOptions.Controller != nil {
		body["controller"] = attachSatelliteHostOptions.Controller
	}
	if attachSatelliteHostOptions.Labels != nil {
		body["labels"] = attachSatelliteHostOptions.Labels
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var resultData []byte
	respBody, err := kubernetesServiceApi.Service.Request(request, &resultData)
	if err != nil {
		return
	}
	response = respBody.Result.([]byte)

	return
}

// GetSatelliteHosts : List the hosts in your IBM Cloud Satellite location
// List the hosts in your IBM Cloud Satellite location.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteHosts(getSatelliteHostsOptions *GetSatelliteHostsOptions) (result []MultishiftQueueNode, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSatelliteHostsWithContext(context.Background(), getSatelliteHostsOptions)
}

// GetSatelliteHostsWithContext is an alternate form of the GetSatelliteHosts method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteHostsWithContext(ctx context.Context, getSatelliteHostsOptions *GetSatelliteHostsOptions) (result []MultishiftQueueNode, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSatelliteHostsOptions, "getSatelliteHostsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSatelliteHostsOptions, "getSatelliteHostsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/hostqueue/getHosts`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSatelliteHostsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSatelliteHosts")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("controller", fmt.Sprint(*getSatelliteHostsOptions.Controller))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMultishiftQueueNode)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveSatelliteHost : Remove a host from an IBM Cloud Satellite location or cluster
// Remove a host from an IBM Cloud Satellite resource, such as a cluster. The host is removed from the resource and no
// longer available in IBM Cloud Satellite. However, if you want, you must still delete the host machine in the
// underlying infrastructure provider. Before you can remove a host, you must remove the worker node that runs on the
// host. To check worker nodes on the host, use the GET `/v2/satellite/hostqueue/getHosts` API or run `ibmcloud sat host
// ls`. To remove a worker node, run `ibmcloud ks worker rm -c <cluster_name_or_ID> -w <worker_ID>`.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveSatelliteHost(removeSatelliteHostOptions *RemoveSatelliteHostOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveSatelliteHostWithContext(context.Background(), removeSatelliteHostOptions)
}

// RemoveSatelliteHostWithContext is an alternate form of the RemoveSatelliteHost method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveSatelliteHostWithContext(ctx context.Context, removeSatelliteHostOptions *RemoveSatelliteHostOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeSatelliteHostOptions, "removeSatelliteHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeSatelliteHostOptions, "removeSatelliteHostOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/hostqueue/removeHost`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeSatelliteHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveSatelliteHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if removeSatelliteHostOptions.Controller != nil {
		body["controller"] = removeSatelliteHostOptions.Controller
	}
	if removeSatelliteHostOptions.HostID != nil {
		body["hostID"] = removeSatelliteHostOptions.HostID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// UpdateSatelliteHost : Update a host in your IBM Cloud Satellite location
// Update the labels of a host in your IBM Cloud Satellite location. You can apply a new set of labels only to hosts
// that are not already assigned to an IBM Cloud Satellite resource.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateSatelliteHost(updateSatelliteHostOptions *UpdateSatelliteHostOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateSatelliteHostWithContext(context.Background(), updateSatelliteHostOptions)
}

// UpdateSatelliteHostWithContext is an alternate form of the UpdateSatelliteHost method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateSatelliteHostWithContext(ctx context.Context, updateSatelliteHostOptions *UpdateSatelliteHostOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateSatelliteHostOptions, "updateSatelliteHostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateSatelliteHostOptions, "updateSatelliteHostOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/hostqueue/updateHost`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateSatelliteHostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateSatelliteHost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateSatelliteHostOptions.Controller != nil {
		body["controller"] = updateSatelliteHostOptions.Controller
	}
	if updateSatelliteHostOptions.HostID != nil {
		body["hostID"] = updateSatelliteHostOptions.HostID
	}
	if updateSatelliteHostOptions.Labels != nil {
		body["labels"] = updateSatelliteHostOptions.Labels
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateSatelliteLocation : Create an IBM Cloud Satellite location
// Create an IBM Cloud Satellite location in the IBM Cloud account that you are logged into. Creating a location
// requires Administrator access to Kubernetes Service in the IBM Cloud account.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteLocation(createSatelliteLocationOptions *CreateSatelliteLocationOptions) (result *MultishiftCreateControllerResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateSatelliteLocationWithContext(context.Background(), createSatelliteLocationOptions)
}

// CreateSatelliteLocationWithContext is an alternate form of the CreateSatelliteLocation method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteLocationWithContext(ctx context.Context, createSatelliteLocationOptions *CreateSatelliteLocationOptions) (result *MultishiftCreateControllerResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSatelliteLocationOptions, "createSatelliteLocationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSatelliteLocationOptions, "createSatelliteLocationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/createController`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSatelliteLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateSatelliteLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createSatelliteLocationOptions.CosConfig != nil {
		body["cos_config"] = createSatelliteLocationOptions.CosConfig
	}
	if createSatelliteLocationOptions.CosCredentials != nil {
		body["cos_credentials"] = createSatelliteLocationOptions.CosCredentials
	}
	if createSatelliteLocationOptions.Description != nil {
		body["description"] = createSatelliteLocationOptions.Description
	}
	if createSatelliteLocationOptions.Location != nil {
		body["location"] = createSatelliteLocationOptions.Location
	}
	if createSatelliteLocationOptions.LoggingAccountID != nil {
		body["loggingAccountID"] = createSatelliteLocationOptions.LoggingAccountID
	}
	if createSatelliteLocationOptions.Name != nil {
		body["name"] = createSatelliteLocationOptions.Name
	}
	if createSatelliteLocationOptions.Zones != nil {
		body["zones"] = createSatelliteLocationOptions.Zones
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMultishiftCreateControllerResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSatelliteLocation : Get the details for an IBM Cloud Satellite location
// Get the details for an IBM Cloud Satellite location.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteLocation(getSatelliteLocationOptions *GetSatelliteLocationOptions) (result *MultishiftGetController, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSatelliteLocationWithContext(context.Background(), getSatelliteLocationOptions)
}

// GetSatelliteLocationWithContext is an alternate form of the GetSatelliteLocation method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteLocationWithContext(ctx context.Context, getSatelliteLocationOptions *GetSatelliteLocationOptions) (result *MultishiftGetController, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSatelliteLocationOptions, "getSatelliteLocationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSatelliteLocationOptions, "getSatelliteLocationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/getController`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSatelliteLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSatelliteLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("controller", fmt.Sprint(*getSatelliteLocationOptions.Controller))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMultishiftGetController)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSatelliteLocations : List the IBM Cloud Satellite locations that you have access to
// List the IBM Cloud Satellite locations that you have access to.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteLocations(getSatelliteLocationsOptions *GetSatelliteLocationsOptions) (result []MultishiftController, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSatelliteLocationsWithContext(context.Background(), getSatelliteLocationsOptions)
}

// GetSatelliteLocationsWithContext is an alternate form of the GetSatelliteLocations method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteLocationsWithContext(ctx context.Context, getSatelliteLocationsOptions *GetSatelliteLocationsOptions) (result []MultishiftController, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getSatelliteLocationsOptions, "getSatelliteLocationsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/getControllers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSatelliteLocationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSatelliteLocations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMultishiftController)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveSatelliteLocation : Remove an IBM Cloud Satellite Location
// Remove an IBM Cloud Satellite location. Before you can remove a location, you must remove any Satellite clusters and
// the underlying host machines. To list the hosts in your location, run `ibmcloud sat hosts --location <name_or_ID>`
// and check the Cluster and Worker details in the output.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveSatelliteLocation(removeSatelliteLocationOptions *RemoveSatelliteLocationOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveSatelliteLocationWithContext(context.Background(), removeSatelliteLocationOptions)
}

// RemoveSatelliteLocationWithContext is an alternate form of the RemoveSatelliteLocation method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveSatelliteLocationWithContext(ctx context.Context, removeSatelliteLocationOptions *RemoveSatelliteLocationOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(removeSatelliteLocationOptions, "removeSatelliteLocationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/removeController`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeSatelliteLocationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveSatelliteLocation")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if removeSatelliteLocationOptions.Controller != nil {
		body["controller"] = removeSatelliteLocationOptions.Controller
	}
	if removeSatelliteLocationOptions.PullSecret != nil {
		body["pullSecret"] = removeSatelliteLocationOptions.PullSecret
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// CreateSatelliteClusterRemote : Create an IBM Cloud Satellite cluster in a location that does not belong to your account
// Create an OpenShift Container Platform cluster in an IBM Cloud Satellite location that belongs to another account.
// Creating a cluster requires service-to-service IAM authorization in the target IBM Cloud account. After you create a
// Satellite cluster, the account owner is responsible for providing hosts to run the worker nodes.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteClusterRemote(createSatelliteClusterRemoteOptions *CreateSatelliteClusterRemoteOptions) (result *MultishiftCreateClusterResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateSatelliteClusterRemoteWithContext(context.Background(), createSatelliteClusterRemoteOptions)
}

// CreateSatelliteClusterRemoteWithContext is an alternate form of the CreateSatelliteClusterRemote method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateSatelliteClusterRemoteWithContext(ctx context.Context, createSatelliteClusterRemoteOptions *CreateSatelliteClusterRemoteOptions) (result *MultishiftCreateClusterResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createSatelliteClusterRemoteOptions, "createSatelliteClusterRemoteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createSatelliteClusterRemoteOptions, "createSatelliteClusterRemoteOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/createClusterRemoteLocation`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createSatelliteClusterRemoteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateSatelliteClusterRemote")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createSatelliteClusterRemoteOptions.XAuthSupplemental != nil {
		builder.AddHeader("X-Auth-Supplemental", fmt.Sprint(*createSatelliteClusterRemoteOptions.XAuthSupplemental))
	}

	body := make(map[string]interface{})
	if createSatelliteClusterRemoteOptions.AdminAgentOptIn != nil {
		body["adminAgentOptIn"] = createSatelliteClusterRemoteOptions.AdminAgentOptIn
	}
	if createSatelliteClusterRemoteOptions.Controller != nil {
		body["controller"] = createSatelliteClusterRemoteOptions.Controller
	}
	if createSatelliteClusterRemoteOptions.KubeVersion != nil {
		body["kubeVersion"] = createSatelliteClusterRemoteOptions.KubeVersion
	}
	if createSatelliteClusterRemoteOptions.Labels != nil {
		body["labels"] = createSatelliteClusterRemoteOptions.Labels
	}
	if createSatelliteClusterRemoteOptions.Name != nil {
		body["name"] = createSatelliteClusterRemoteOptions.Name
	}
	if createSatelliteClusterRemoteOptions.PodSubnet != nil {
		body["podSubnet"] = createSatelliteClusterRemoteOptions.PodSubnet
	}
	if createSatelliteClusterRemoteOptions.PullSecret != nil {
		body["pullSecret"] = createSatelliteClusterRemoteOptions.PullSecret
	}
	if createSatelliteClusterRemoteOptions.ServiceSubnet != nil {
		body["serviceSubnet"] = createSatelliteClusterRemoteOptions.ServiceSubnet
	}
	if createSatelliteClusterRemoteOptions.WorkerCount != nil {
		body["workerCount"] = createSatelliteClusterRemoteOptions.WorkerCount
	}
	if createSatelliteClusterRemoteOptions.Zone != nil {
		body["zone"] = createSatelliteClusterRemoteOptions.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMultishiftCreateClusterResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSatelliteServiceClusters : List the clusters in an IBM Cloud Satellite location that are associated with a Satellite-enabled service instance
// List the clusters that are associated with a Satellite-enabled service that you deployed to your IBM Cloud Satellite
// location. The clusters in this list are managed by IBM Cloud to provide the cloud service in the location, but you
// still provide the hosts to run the clusters.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteServiceClusters(getSatelliteServiceClustersOptions *GetSatelliteServiceClustersOptions) (result []MultishiftClustersResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSatelliteServiceClustersWithContext(context.Background(), getSatelliteServiceClustersOptions)
}

// GetSatelliteServiceClustersWithContext is an alternate form of the GetSatelliteServiceClusters method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSatelliteServiceClustersWithContext(ctx context.Context, getSatelliteServiceClustersOptions *GetSatelliteServiceClustersOptions) (result []MultishiftClustersResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSatelliteServiceClustersOptions, "getSatelliteServiceClustersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSatelliteServiceClustersOptions, "getSatelliteServiceClustersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/satellite/getServiceClusters`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSatelliteServiceClustersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSatelliteServiceClusters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("controller", fmt.Sprint(*getSatelliteServiceClustersOptions.Controller))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMultishiftClustersResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateAttachment : The CreateAttachment operation.
// Create volume attachment for a given worker.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateAttachment(createAttachmentOptions *CreateAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateAttachmentWithContext(context.Background(), createAttachmentOptions)
}

// CreateAttachmentWithContext is an alternate form of the CreateAttachment method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateAttachmentWithContext(ctx context.Context, createAttachmentOptions *CreateAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createAttachmentOptions, "createAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createAttachmentOptions, "createAttachmentOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/createAttachment`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if createAttachmentOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*createAttachmentOptions.XAuthResourceGroupID))
	}

	body := make(map[string]interface{})
	if createAttachmentOptions.Cluster != nil {
		body["cluster"] = createAttachmentOptions.Cluster
	}
	if createAttachmentOptions.VolumeAttachmentID != nil {
		body["volumeAttachmentID"] = createAttachmentOptions.VolumeAttachmentID
	}
	if createAttachmentOptions.VolumeID != nil {
		body["volumeID"] = createAttachmentOptions.VolumeID
	}
	if createAttachmentOptions.Worker != nil {
		body["worker"] = createAttachmentOptions.Worker
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachment)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// DeleteAttachment : Detach volume from given worker
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteAttachment(deleteAttachmentOptions *DeleteAttachmentOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.DeleteAttachmentWithContext(context.Background(), deleteAttachmentOptions)
}

// DeleteAttachmentWithContext is an alternate form of the DeleteAttachment method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) DeleteAttachmentWithContext(ctx context.Context, deleteAttachmentOptions *DeleteAttachmentOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteAttachmentOptions, "deleteAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteAttachmentOptions, "deleteAttachmentOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/deleteAttachment`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "DeleteAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if deleteAttachmentOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*deleteAttachmentOptions.XAuthResourceGroupID))
	}

	body := make(map[string]interface{})
	if deleteAttachmentOptions.Cluster != nil {
		body["cluster"] = deleteAttachmentOptions.Cluster
	}
	if deleteAttachmentOptions.VolumeAttachmentID != nil {
		body["volumeAttachmentID"] = deleteAttachmentOptions.VolumeAttachmentID
	}
	if deleteAttachmentOptions.VolumeID != nil {
		body["volumeID"] = deleteAttachmentOptions.VolumeID
	}
	if deleteAttachmentOptions.Worker != nil {
		body["worker"] = deleteAttachmentOptions.Worker
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetAttachment : The GetAttachment operation.
// Get the volume attachment detail for given volume attachment ID.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAttachment(getAttachmentOptions *GetAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetAttachmentWithContext(context.Background(), getAttachmentOptions)
}

// GetAttachmentWithContext is an alternate form of the GetAttachment method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAttachmentWithContext(ctx context.Context, getAttachmentOptions *GetAttachmentOptions) (result *VolumeAttachment, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getAttachmentOptions, "getAttachmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getAttachmentOptions, "getAttachmentOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/getAttachment`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getAttachmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetAttachment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getAttachmentOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*getAttachmentOptions.XAuthResourceGroupID))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getAttachmentOptions.Cluster))
	builder.AddQuery("worker", fmt.Sprint(*getAttachmentOptions.Worker))
	builder.AddQuery("volumeAttachmentID", fmt.Sprint(*getAttachmentOptions.VolumeAttachmentID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachment)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetAttachments : The GetAttachments operation.
// Get the volume attachments detail for a given worker.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAttachments(getAttachmentsOptions *GetAttachmentsOptions) (result *VolumeAttachmentList, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetAttachmentsWithContext(context.Background(), getAttachmentsOptions)
}

// GetAttachmentsWithContext is an alternate form of the GetAttachments method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAttachmentsWithContext(ctx context.Context, getAttachmentsOptions *GetAttachmentsOptions) (result *VolumeAttachmentList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getAttachmentsOptions, "getAttachmentsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getAttachmentsOptions, "getAttachmentsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/getAttachments`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getAttachmentsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetAttachments")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getAttachmentsOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*getAttachmentsOptions.XAuthResourceGroupID))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getAttachmentsOptions.Cluster))
	builder.AddQuery("worker", fmt.Sprint(*getAttachmentsOptions.Worker))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeAttachmentList)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVolume : Get the details of a storage volume
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVolume(getVolumeOptions *GetVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetVolumeWithContext(context.Background(), getVolumeOptions)
}

// GetVolumeWithContext is an alternate form of the GetVolume method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVolumeWithContext(ctx context.Context, getVolumeOptions *GetVolumeOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumeOptions, "getVolumeOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumeOptions, "getVolumeOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/getVolume`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumeOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetVolume")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getVolumeOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*getVolumeOptions.XAuthResourceGroupID))
	}

	builder.AddQuery("volumeID", fmt.Sprint(*getVolumeOptions.VolumeID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVolumes : List storage volumes for a cluster or for the account if no cluster is provided
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVolumes(getVolumesOptions *GetVolumesOptions) (result *VolumesList, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetVolumesWithContext(context.Background(), getVolumesOptions)
}

// GetVolumesWithContext is an alternate form of the GetVolumes method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVolumesWithContext(ctx context.Context, getVolumesOptions *GetVolumesOptions) (result *VolumesList, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVolumesOptions, "getVolumesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVolumesOptions, "getVolumesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/getVolumes`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVolumesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetVolumes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getVolumesOptions.XAuthResourceGroupID != nil {
		builder.AddHeader("X-Auth-Resource-Group-ID", fmt.Sprint(*getVolumesOptions.XAuthResourceGroupID))
	}

	if getVolumesOptions.Cluster != nil {
		builder.AddQuery("cluster", fmt.Sprint(*getVolumesOptions.Cluster))
	}
	if getVolumesOptions.Provider != nil {
		builder.AddQuery("provider", fmt.Sprint(*getVolumesOptions.Provider))
	}
	if getVolumesOptions.Zone != nil {
		builder.AddQuery("zone", fmt.Sprint(*getVolumesOptions.Zone))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesList)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateAssignment : Create an assignment to a Satellite storage configuration
// Create an assignment to install the storage driver that is described by the version of the storage configuration on
// the cluster group. Then, apps that run in the clusters can use the storage.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateAssignment(createAssignmentOptions *CreateAssignmentOptions) (result *CreateSubscriptionData, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateAssignmentWithContext(context.Background(), createAssignmentOptions)
}

// CreateAssignmentWithContext is an alternate form of the CreateAssignment method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateAssignmentWithContext(ctx context.Context, createAssignmentOptions *CreateAssignmentOptions) (result *CreateSubscriptionData, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createAssignmentOptions, "createAssignmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createAssignmentOptions, "createAssignmentOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/createAssignment`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createAssignmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateAssignment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createAssignmentOptions.ChannelName != nil {
		body["channelName"] = createAssignmentOptions.ChannelName
	}
	if createAssignmentOptions.Groups != nil {
		body["groups"] = createAssignmentOptions.Groups
	}
	if createAssignmentOptions.Name != nil {
		body["name"] = createAssignmentOptions.Name
	}
	if createAssignmentOptions.Version != nil {
		body["version"] = createAssignmentOptions.Version
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateSubscriptionData)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// CreateStorageConfiguration : Create a Satellite storage configuration
// Create a Satellite storage configuration based off the storage template and custom parameters that you want to use.
// Then, assign the storage configuration to your clusters to install the storage driver so that the apps that run in
// the cluster can use the storage.
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateStorageConfiguration(createStorageConfigurationOptions *CreateStorageConfigurationOptions) (result *CreateConfigurationData, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.CreateStorageConfigurationWithContext(context.Background(), createStorageConfigurationOptions)
}

// CreateStorageConfigurationWithContext is an alternate form of the CreateStorageConfiguration method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) CreateStorageConfigurationWithContext(ctx context.Context, createStorageConfigurationOptions *CreateStorageConfigurationOptions) (result *CreateConfigurationData, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createStorageConfigurationOptions, "createStorageConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createStorageConfigurationOptions, "createStorageConfigurationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/createStorageConfiguration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range createStorageConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "CreateStorageConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if createStorageConfigurationOptions.ConfigName != nil {
		body["config-name"] = createStorageConfigurationOptions.ConfigName
	}
	if createStorageConfigurationOptions.ConfigVersion != nil {
		body["config-version"] = createStorageConfigurationOptions.ConfigVersion
	}
	if createStorageConfigurationOptions.SourceBranch != nil {
		body["source-branch"] = createStorageConfigurationOptions.SourceBranch
	}
	if createStorageConfigurationOptions.SourceOrg != nil {
		body["source-org"] = createStorageConfigurationOptions.SourceOrg
	}
	if createStorageConfigurationOptions.StorageClassParameters != nil {
		body["storage-class-parameters"] = createStorageConfigurationOptions.StorageClassParameters
	}
	if createStorageConfigurationOptions.StorageTemplateName != nil {
		body["storage-template-name"] = createStorageConfigurationOptions.StorageTemplateName
	}
	if createStorageConfigurationOptions.StorageTemplateVersion != nil {
		body["storage-template-version"] = createStorageConfigurationOptions.StorageTemplateVersion
	}
	if createStorageConfigurationOptions.UserConfigParameters != nil {
		body["user-config-parameters"] = createStorageConfigurationOptions.UserConfigParameters
	}
	if createStorageConfigurationOptions.UserSecretParameters != nil {
		body["user-secret-parameters"] = createStorageConfigurationOptions.UserSecretParameters
	}
	if createStorageConfigurationOptions.UUID != nil {
		body["uuid"] = createStorageConfigurationOptions.UUID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateConfigurationData)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetAssignment : View details for an assignment to a Satellite storage configuration
// View details for an assignment to a Satellite storage configuration by the assignment UUID.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAssignment(getAssignmentOptions *GetAssignmentOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetAssignmentWithContext(context.Background(), getAssignmentOptions)
}

// GetAssignmentWithContext is an alternate form of the GetAssignment method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAssignmentWithContext(ctx context.Context, getAssignmentOptions *GetAssignmentOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getAssignmentOptions, "getAssignmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getAssignmentOptions, "getAssignmentOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/getAssignment`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getAssignmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetAssignment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("uuid", fmt.Sprint(*getAssignmentOptions.UUID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetAssignmentByName : View details for an assignment to a Satellite storage configuration
// View details for an assignment to a Satellite storage configuration by the assignment name.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAssignmentByName(getAssignmentByNameOptions *GetAssignmentByNameOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetAssignmentByNameWithContext(context.Background(), getAssignmentByNameOptions)
}

// GetAssignmentByNameWithContext is an alternate form of the GetAssignmentByName method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAssignmentByNameWithContext(ctx context.Context, getAssignmentByNameOptions *GetAssignmentByNameOptions) (result *Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getAssignmentByNameOptions, "getAssignmentByNameOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getAssignmentByNameOptions, "getAssignmentByNameOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/getAssignmentByName`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getAssignmentByNameOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetAssignmentByName")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("name", fmt.Sprint(*getAssignmentByNameOptions.Name))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetAssignments : List assignments to Satellite storage configurations in the IBM Cloud account
// List assignments to Satellite storage configurations that you have access to in the IBM Cloud account. Returned
// details include the attachment name, UUID, and creation timestamp.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAssignments(getAssignmentsOptions *GetAssignmentsOptions) (result []Subscription, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetAssignmentsWithContext(context.Background(), getAssignmentsOptions)
}

// GetAssignmentsWithContext is an alternate form of the GetAssignments method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAssignmentsWithContext(ctx context.Context, getAssignmentsOptions *GetAssignmentsOptions) (result []Subscription, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getAssignmentsOptions, "getAssignmentsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/getAssignments`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getAssignmentsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetAssignments")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubscription)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetStorageConfiguration : View details of a Satellite storage configuration
// View the details of a Satellite storage configuration at a particular version.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStorageConfiguration(getStorageConfigurationOptions *GetStorageConfigurationOptions) (result *StorageConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetStorageConfigurationWithContext(context.Background(), getStorageConfigurationOptions)
}

// GetStorageConfigurationWithContext is an alternate form of the GetStorageConfiguration method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStorageConfigurationWithContext(ctx context.Context, getStorageConfigurationOptions *GetStorageConfigurationOptions) (result *StorageConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getStorageConfigurationOptions, "getStorageConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getStorageConfigurationOptions, "getStorageConfigurationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/getStorageConfiguration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStorageConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetStorageConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("name", fmt.Sprint(*getStorageConfigurationOptions.Name))
	builder.AddQuery("version", fmt.Sprint(*getStorageConfigurationOptions.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetStorageConfigurations : List Satellite storage configurations
// List the Satellite storage configurations that you have access to in the IBM Cloud account.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStorageConfigurations(getStorageConfigurationsOptions *GetStorageConfigurationsOptions) (result []StorageConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetStorageConfigurationsWithContext(context.Background(), getStorageConfigurationsOptions)
}

// GetStorageConfigurationsWithContext is an alternate form of the GetStorageConfigurations method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStorageConfigurationsWithContext(ctx context.Context, getStorageConfigurationsOptions *GetStorageConfigurationsOptions) (result []StorageConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getStorageConfigurationsOptions, "getStorageConfigurationsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/getStorageConfigurations`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStorageConfigurationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetStorageConfigurations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetStorageTemplate : View details of a Satellite storage template
// View the details of a registered Satellite storage template by name and version from the vendor's storage driver
// repository at `github.com/IBM/ibm-satellite-storage`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStorageTemplate(getStorageTemplateOptions *GetStorageTemplateOptions) (result *RegisteredStorageVersion, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetStorageTemplateWithContext(context.Background(), getStorageTemplateOptions)
}

// GetStorageTemplateWithContext is an alternate form of the GetStorageTemplate method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStorageTemplateWithContext(ctx context.Context, getStorageTemplateOptions *GetStorageTemplateOptions) (result *RegisteredStorageVersion, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getStorageTemplateOptions, "getStorageTemplateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getStorageTemplateOptions, "getStorageTemplateOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/getStorageTemplate`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStorageTemplateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetStorageTemplate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("name", fmt.Sprint(*getStorageTemplateOptions.Name))
	builder.AddQuery("version", fmt.Sprint(*getStorageTemplateOptions.Version))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRegisteredStorageVersion)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetStorageTemplates : List Satellite storage templates
// List the registered Satellite storage templates from the vendor's storage driver repository at
// `github.com/IBM/ibm-satellite-storage`.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStorageTemplates(getStorageTemplatesOptions *GetStorageTemplatesOptions) (result []RegisteredStorage, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetStorageTemplatesWithContext(context.Background(), getStorageTemplatesOptions)
}

// GetStorageTemplatesWithContext is an alternate form of the GetStorageTemplates method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetStorageTemplatesWithContext(ctx context.Context, getStorageTemplatesOptions *GetStorageTemplatesOptions) (result []RegisteredStorage, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getStorageTemplatesOptions, "getStorageTemplatesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/getStorageTemplates`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getStorageTemplatesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetStorageTemplates")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRegisteredStorage)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveAssignment : Remove an assignment to a Satellite storage configuration
// Remove assignment with a given UUID.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveAssignment(removeAssignmentOptions *RemoveAssignmentOptions) (result *RemoveSubscriptionData, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveAssignmentWithContext(context.Background(), removeAssignmentOptions)
}

// RemoveAssignmentWithContext is an alternate form of the RemoveAssignment method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveAssignmentWithContext(ctx context.Context, removeAssignmentOptions *RemoveAssignmentOptions) (result *RemoveSubscriptionData, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeAssignmentOptions, "removeAssignmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeAssignmentOptions, "removeAssignmentOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/removeAssignment`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeAssignmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveAssignment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("uuid", fmt.Sprint(*removeAssignmentOptions.UUID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRemoveSubscriptionData)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RemoveStorageConfiguration : Remove a Satellite storage configuration
// Remove a Satellite storage configuration with a given UUID. Note that you cannot remove Satellite storage
// configurations that are currently used in a Satellite storage assignment.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveStorageConfiguration(removeStorageConfigurationOptions *RemoveStorageConfigurationOptions) (result *ErrorResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveStorageConfigurationWithContext(context.Background(), removeStorageConfigurationOptions)
}

// RemoveStorageConfigurationWithContext is an alternate form of the RemoveStorageConfiguration method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveStorageConfigurationWithContext(ctx context.Context, removeStorageConfigurationOptions *RemoveStorageConfigurationOptions) (result *ErrorResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeStorageConfigurationOptions, "removeStorageConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeStorageConfigurationOptions, "removeStorageConfigurationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/removeStorageConfiguration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeStorageConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveStorageConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("uuid", fmt.Sprint(*removeStorageConfigurationOptions.UUID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalErrorResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateAssignment : Update an assignment to a Satellite storage configuration
// Update the details of an assignment to a Satellite storage configuration, such as the name of the assignment, the
// storage configuration or version that is uses, or the clusters that are assigned to the configuration.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateAssignment(updateAssignmentOptions *UpdateAssignmentOptions) (result *UpdateSubscriptionData, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateAssignmentWithContext(context.Background(), updateAssignmentOptions)
}

// UpdateAssignmentWithContext is an alternate form of the UpdateAssignment method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateAssignmentWithContext(ctx context.Context, updateAssignmentOptions *UpdateAssignmentOptions) (result *UpdateSubscriptionData, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateAssignmentOptions, "updateAssignmentOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateAssignmentOptions, "updateAssignmentOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/updateAssignment`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateAssignmentOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateAssignment")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateAssignmentOptions.ChannelUUID != nil {
		body["channelUuid"] = updateAssignmentOptions.ChannelUUID
	}
	if updateAssignmentOptions.Groups != nil {
		body["groups"] = updateAssignmentOptions.Groups
	}
	if updateAssignmentOptions.Name != nil {
		body["name"] = updateAssignmentOptions.Name
	}
	if updateAssignmentOptions.UUID != nil {
		body["uuid"] = updateAssignmentOptions.UUID
	}
	if updateAssignmentOptions.VersionUUID != nil {
		body["versionUuid"] = updateAssignmentOptions.VersionUUID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUpdateSubscriptionData)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateAssignmentVersion : Update the version of the Satellite storage configuration that an assignment uses
// Update the version of the Satellite storage configuration that an assignment with a given UUID uses.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateAssignmentVersion(updateAssignmentVersionOptions *UpdateAssignmentVersionOptions) (result *UpdateSubscriptionVersionData, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateAssignmentVersionWithContext(context.Background(), updateAssignmentVersionOptions)
}

// UpdateAssignmentVersionWithContext is an alternate form of the UpdateAssignmentVersion method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateAssignmentVersionWithContext(ctx context.Context, updateAssignmentVersionOptions *UpdateAssignmentVersionOptions) (result *UpdateSubscriptionVersionData, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateAssignmentVersionOptions, "updateAssignmentVersionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateAssignmentVersionOptions, "updateAssignmentVersionOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/updateAssignmentVersion`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateAssignmentVersionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateAssignmentVersion")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateAssignmentVersionOptions.UUID != nil {
		body["uuid"] = updateAssignmentVersionOptions.UUID
	}
	if updateAssignmentVersionOptions.VersionUUID != nil {
		body["versionUuid"] = updateAssignmentVersionOptions.VersionUUID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUpdateSubscriptionVersionData)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// UpdateStorageConfiguration : Update a Satellite storage configuration
// Update an existing Satellite storage configuration. Note that you cannot update Satellite storage configurations that
// are currently used in a Satellite storage assignment.
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateStorageConfiguration(updateStorageConfigurationOptions *UpdateStorageConfigurationOptions) (result *ErrorResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.UpdateStorageConfigurationWithContext(context.Background(), updateStorageConfigurationOptions)
}

// UpdateStorageConfigurationWithContext is an alternate form of the UpdateStorageConfiguration method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) UpdateStorageConfigurationWithContext(ctx context.Context, updateStorageConfigurationOptions *UpdateStorageConfigurationOptions) (result *ErrorResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(updateStorageConfigurationOptions, "updateStorageConfigurationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(updateStorageConfigurationOptions, "updateStorageConfigurationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/storage/satellite/updateStorageConfiguration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range updateStorageConfigurationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "UpdateStorageConfiguration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if updateStorageConfigurationOptions.ConfigName != nil {
		body["config-name"] = updateStorageConfigurationOptions.ConfigName
	}
	if updateStorageConfigurationOptions.ConfigVersion != nil {
		body["config-version"] = updateStorageConfigurationOptions.ConfigVersion
	}
	if updateStorageConfigurationOptions.SourceBranch != nil {
		body["source-branch"] = updateStorageConfigurationOptions.SourceBranch
	}
	if updateStorageConfigurationOptions.SourceOrg != nil {
		body["source-org"] = updateStorageConfigurationOptions.SourceOrg
	}
	if updateStorageConfigurationOptions.StorageClassParameters != nil {
		body["storage-class-parameters"] = updateStorageConfigurationOptions.StorageClassParameters
	}
	if updateStorageConfigurationOptions.StorageTemplateName != nil {
		body["storage-template-name"] = updateStorageConfigurationOptions.StorageTemplateName
	}
	if updateStorageConfigurationOptions.StorageTemplateVersion != nil {
		body["storage-template-version"] = updateStorageConfigurationOptions.StorageTemplateVersion
	}
	if updateStorageConfigurationOptions.UserConfigParameters != nil {
		body["user-config-parameters"] = updateStorageConfigurationOptions.UserConfigParameters
	}
	if updateStorageConfigurationOptions.UserSecretParameters != nil {
		body["user-secret-parameters"] = updateStorageConfigurationOptions.UserSecretParameters
	}
	if updateStorageConfigurationOptions.UUID != nil {
		body["uuid"] = updateStorageConfigurationOptions.UUID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalErrorResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetAddons : List available add-ons that you can enable in a cluster
// List available add-ons that you can enable in an IBM Cloud Kubernetes Service cluster. For each available add-on, the
// name, latest version, and minimum Kubernetes version required to run the add-on in a cluster are returned.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAddons(getAddonsOptions *GetAddonsOptions) (result []AddonCommon, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetAddonsWithContext(context.Background(), getAddonsOptions)
}

// GetAddonsWithContext is an alternate form of the GetAddons method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetAddonsWithContext(ctx context.Context, getAddonsOptions *GetAddonsOptions) (result []AddonCommon, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getAddonsOptions, "getAddonsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/addons`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getAddonsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetAddons")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAddonCommon)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetBluemixConfig : List configuration values for your IBM Cloud account
// List account configuration information that you can use when making IBM Cloud API requests.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetBluemixConfig(getBluemixConfigOptions *GetBluemixConfigOptions) (result *BluemixConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetBluemixConfigWithContext(context.Background(), getBluemixConfigOptions)
}

// GetBluemixConfigWithContext is an alternate form of the GetBluemixConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetBluemixConfigWithContext(ctx context.Context, getBluemixConfigOptions *GetBluemixConfigOptions) (result *BluemixConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getBluemixConfigOptions, "getBluemixConfigOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/config`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getBluemixConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetBluemixConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalBluemixConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetDatacenterMachineTypes : List available machine types for a zone (data center)
// List available machine types that you can use for a worker node. Machine types vary by zone. Each machine type
// includes the amount of virtual CPU, memory, and disk space that is set up for the worker node. For more information,
// see http://ibm.biz/machine_types.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetDatacenterMachineTypes(getDatacenterMachineTypesOptions *GetDatacenterMachineTypesOptions) (result []MachineType, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetDatacenterMachineTypesWithContext(context.Background(), getDatacenterMachineTypesOptions)
}

// GetDatacenterMachineTypesWithContext is an alternate form of the GetDatacenterMachineTypes method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetDatacenterMachineTypesWithContext(ctx context.Context, getDatacenterMachineTypesOptions *GetDatacenterMachineTypesOptions) (result []MachineType, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getDatacenterMachineTypesOptions, "getDatacenterMachineTypesOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getDatacenterMachineTypesOptions, "getDatacenterMachineTypesOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"datacenter": *getDatacenterMachineTypesOptions.Datacenter,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/datacenters/{datacenter}/machine-types`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getDatacenterMachineTypesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetDatacenterMachineTypes")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMachineType)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetKubeVersions : Deprecated: List available Kubernetes versions
// List available Kubernetes versions that you can use to create a cluster. Note: This API call is deprecated. Use the
// `GET /v1/versions` API instead.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetKubeVersions(getKubeVersionsOptions *GetKubeVersionsOptions) (result []KubeVersion, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetKubeVersionsWithContext(context.Background(), getKubeVersionsOptions)
}

// GetKubeVersionsWithContext is an alternate form of the GetKubeVersions method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetKubeVersionsWithContext(ctx context.Context, getKubeVersionsOptions *GetKubeVersionsOptions) (result []KubeVersion, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getKubeVersionsOptions, "getKubeVersionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/kube-versions`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getKubeVersionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetKubeVersions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKubeVersion)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ListLocations : List available locations
// List locations from the IBM Cloud catalog that are supported by the IBM Cloud Kubernetes Service.
func (kubernetesServiceApi *KubernetesServiceApiV1) ListLocations(listLocationsOptions *ListLocationsOptions) (result []IKSLocation, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ListLocationsWithContext(context.Background(), listLocationsOptions)
}

// ListLocationsWithContext is an alternate form of the ListLocations method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ListLocationsWithContext(ctx context.Context, listLocationsOptions *ListLocationsOptions) (result []IKSLocation, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listLocationsOptions, "listLocationsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/locations`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listLocationsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ListLocations")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIKSLocation)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetMessages : View the current user messages
// View the current user messages.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMessages(getMessagesOptions *GetMessagesOptions) (result []UserMessageResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetMessagesWithContext(context.Background(), getMessagesOptions)
}

// GetMessagesWithContext is an alternate form of the GetMessages method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetMessagesWithContext(ctx context.Context, getMessagesOptions *GetMessagesOptions) (result []UserMessageResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getMessagesOptions, "getMessagesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/messages`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getMessagesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetMessages")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUserMessageResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetProductConfig : List product-specific values to substitute for variables in other files
// List product-specific values to substitute for variables in other files.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetProductConfig(getProductConfigOptions *GetProductConfigOptions) (result *ProductConfig, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetProductConfigWithContext(context.Background(), getProductConfigOptions)
}

// GetProductConfigWithContext is an alternate form of the GetProductConfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetProductConfigWithContext(ctx context.Context, getProductConfigOptions *GetProductConfigOptions) (result *ProductConfig, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getProductConfigOptions, "getProductConfigOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/prodconfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getProductConfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetProductConfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalProductConfig)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetRegions : Deprecated: List available Kubernetes Service regions
// List available IBM Cloud Kubernetes Service regions. A region is a geographic area that is accessed by a container
// service endpoint.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetRegions(getRegionsOptions *GetRegionsOptions) (result *Regions, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetRegionsWithContext(context.Background(), getRegionsOptions)
}

// GetRegionsWithContext is an alternate form of the GetRegions method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetRegionsWithContext(ctx context.Context, getRegionsOptions *GetRegionsOptions) (result *Regions, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getRegionsOptions, "getRegionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/regions`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getRegionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetRegions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalRegions)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVersions : List available IBM Cloud Kubernetes Service versions
// List available IBM Cloud Kubernetes Service versions that you can use to create a cluster in a region. The container
// management platform version that you select is installed on your cluster master and worker nodes. Later, you can
// update the version but cannot roll back to a previous version or switch to a different container management platform.
// If you want to use multiple versions, create a separate cluster for each version.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVersions(getVersionsOptions *GetVersionsOptions) (result map[string][]KubeVersion, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetVersionsWithContext(context.Background(), getVersionsOptions)
}

// GetVersionsWithContext is an alternate form of the GetVersions method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVersionsWithContext(ctx context.Context, getVersionsOptions *GetVersionsOptions) (result map[string][]KubeVersion, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getVersionsOptions, "getVersionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/versions`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVersionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetVersions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalKubeVersion)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetZones : List available zones (data centers)
// List available zones (data centers) where you can create a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetZones(getZonesOptions *GetZonesOptions) (result []ZoneResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetZonesWithContext(context.Background(), getZonesOptions)
}

// GetZonesWithContext is an alternate form of the GetZones method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetZonesWithContext(ctx context.Context, getZonesOptions *GetZonesOptions) (result []ZoneResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getZonesOptions, "getZonesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v1/zones`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getZonesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetZones")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if getZonesOptions.ShowFlavors != nil {
		builder.AddQuery("showFlavors", fmt.Sprint(*getZonesOptions.ShowFlavors))
	}
	if getZonesOptions.Location != nil {
		builder.AddQuery("location", fmt.Sprint(*getZonesOptions.Location))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalZoneResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// V2GetMessages : View the current user messages
// View the current user messages.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetMessages(v2GetMessagesOptions *V2GetMessagesOptions) (result []MessageResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2GetMessagesWithContext(context.Background(), v2GetMessagesOptions)
}

// V2GetMessagesWithContext is an alternate form of the V2GetMessages method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetMessagesWithContext(ctx context.Context, v2GetMessagesOptions *V2GetMessagesOptions) (result []MessageResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(v2GetMessagesOptions, "v2GetMessagesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getMessages`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2GetMessagesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2GetMessages")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalMessageResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ApplyRBACAndGetKubeconfig : Apply IAM roles to the cluster, then retrieve the cluster's kubeconfig file. Optionally include the network configuration file
// Apply IAM roles to the cluster, then retrieve the cluster's kubeconfig file to connect to your cluster and run
// Kubernetes API calls.
func (kubernetesServiceApi *KubernetesServiceApiV1) ApplyRBACAndGetKubeconfig(applyRBACAndGetKubeconfigOptions *ApplyRBACAndGetKubeconfigOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ApplyRBACAndGetKubeconfigWithContext(context.Background(), applyRBACAndGetKubeconfigOptions)
}

// ApplyRBACAndGetKubeconfigWithContext is an alternate form of the ApplyRBACAndGetKubeconfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ApplyRBACAndGetKubeconfigWithContext(ctx context.Context, applyRBACAndGetKubeconfigOptions *ApplyRBACAndGetKubeconfigOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(applyRBACAndGetKubeconfigOptions, "applyRBACAndGetKubeconfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(applyRBACAndGetKubeconfigOptions, "applyRBACAndGetKubeconfigOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/applyRBACAndGetKubeconfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range applyRBACAndGetKubeconfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ApplyRBACAndGetKubeconfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if applyRBACAndGetKubeconfigOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*applyRBACAndGetKubeconfigOptions.XAuthRefreshToken))
	}
	if applyRBACAndGetKubeconfigOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*applyRBACAndGetKubeconfigOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if applyRBACAndGetKubeconfigOptions.Admin != nil {
		body["admin"] = applyRBACAndGetKubeconfigOptions.Admin
	}
	if applyRBACAndGetKubeconfigOptions.Cluster != nil {
		body["cluster"] = applyRBACAndGetKubeconfigOptions.Cluster
	}
	if applyRBACAndGetKubeconfigOptions.EndpointType != nil {
		body["endpointType"] = applyRBACAndGetKubeconfigOptions.EndpointType
	}
	if applyRBACAndGetKubeconfigOptions.Format != nil {
		body["format"] = applyRBACAndGetKubeconfigOptions.Format
	}
	if applyRBACAndGetKubeconfigOptions.Network != nil {
		body["network"] = applyRBACAndGetKubeconfigOptions.Network
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// AutoUpdateMaster : Set the autoupdate status of the cluster master
// Sets the autoupdate status of the cluster master. Only a limited set of users can access use this API.
func (kubernetesServiceApi *KubernetesServiceApiV1) AutoUpdateMaster(autoUpdateMasterOptions *AutoUpdateMasterOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.AutoUpdateMasterWithContext(context.Background(), autoUpdateMasterOptions)
}

// AutoUpdateMasterWithContext is an alternate form of the AutoUpdateMaster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) AutoUpdateMasterWithContext(ctx context.Context, autoUpdateMasterOptions *AutoUpdateMasterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(autoUpdateMasterOptions, "autoUpdateMasterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(autoUpdateMasterOptions, "autoUpdateMasterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/autoUpdateMaster`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range autoUpdateMasterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "AutoUpdateMaster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if autoUpdateMasterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*autoUpdateMasterOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if autoUpdateMasterOptions.AutoUpdate != nil {
		body["autoUpdate"] = autoUpdateMasterOptions.AutoUpdate
	}
	if autoUpdateMasterOptions.Cluster != nil {
		body["cluster"] = autoUpdateMasterOptions.Cluster
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// ClassicGetCluster : Detailed cluster information
// Detailed cluster information.
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetCluster(classicGetClusterOptions *ClassicGetClusterOptions) (result []GetClusterResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ClassicGetClusterWithContext(context.Background(), classicGetClusterOptions)
}

// ClassicGetClusterWithContext is an alternate form of the ClassicGetCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetClusterWithContext(ctx context.Context, classicGetClusterOptions *ClassicGetClusterOptions) (result []GetClusterResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(classicGetClusterOptions, "classicGetClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(classicGetClusterOptions, "classicGetClusterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/classic/getCluster`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range classicGetClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ClassicGetCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if classicGetClusterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*classicGetClusterOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*classicGetClusterOptions.Cluster))
	if classicGetClusterOptions.ShowResources != nil {
		builder.AddQuery("showResources", fmt.Sprint(*classicGetClusterOptions.ShowResources))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetClusterResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ClassicGetClusters : List the classic clusters that you have access to
// List the classic clusters that you have access to.
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetClusters(classicGetClustersOptions *ClassicGetClustersOptions) (result []GetClustersResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ClassicGetClustersWithContext(context.Background(), classicGetClustersOptions)
}

// ClassicGetClustersWithContext is an alternate form of the ClassicGetClusters method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetClustersWithContext(ctx context.Context, classicGetClustersOptions *ClassicGetClustersOptions) (result []GetClustersResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(classicGetClustersOptions, "classicGetClustersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/classic/getClusters`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range classicGetClustersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ClassicGetClusters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if classicGetClustersOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*classicGetClustersOptions.XAuthResourceGroup))
	}

	if classicGetClustersOptions.Location != nil {
		builder.AddQuery("location", fmt.Sprint(*classicGetClustersOptions.Location))
	}
	if classicGetClustersOptions.ShowResources != nil {
		builder.AddQuery("showResources", fmt.Sprint(*classicGetClustersOptions.ShowResources))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetClustersResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVLANs : List available classic infrastructure VLANs for a zone
// List available public and private VLANs for a specified zone (data center). Before using this operation, you must
// store your IBM Cloud infrastructure (SoftLayer) credentials in each Kubernetes Service account by using the POST
// /v1/credentials API or by running ibmcloud ks credential set --infrastructure-api-key <API_key>
// --infrastructure-username <API_username>.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVLANs(getVLANsOptions *GetVLANsOptions) (result *VLAN, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetVLANsWithContext(context.Background(), getVLANsOptions)
}

// GetVLANsWithContext is an alternate form of the GetVLANs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVLANsWithContext(ctx context.Context, getVLANsOptions *GetVLANsOptions) (result *VLAN, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVLANsOptions, "getVLANsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVLANsOptions, "getVLANsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/classic/getVLANs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVLANsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetVLANs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getVLANsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getVLANsOptions.XAuthResourceGroup))
	}

	builder.AddQuery("zone", fmt.Sprint(*getVLANsOptions.Zone))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVLAN)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ClassicGetWorker : View details of a worker node for classic cluster
// View detailed information for a worker node in a classic cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetWorker(classicGetWorkerOptions *ClassicGetWorkerOptions) (result *GetWorkerResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ClassicGetWorkerWithContext(context.Background(), classicGetWorkerOptions)
}

// ClassicGetWorkerWithContext is an alternate form of the ClassicGetWorker method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetWorkerWithContext(ctx context.Context, classicGetWorkerOptions *ClassicGetWorkerOptions) (result *GetWorkerResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(classicGetWorkerOptions, "classicGetWorkerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(classicGetWorkerOptions, "classicGetWorkerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/classic/getWorker`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range classicGetWorkerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ClassicGetWorker")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if classicGetWorkerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*classicGetWorkerOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*classicGetWorkerOptions.Cluster))
	builder.AddQuery("worker", fmt.Sprint(*classicGetWorkerOptions.Worker))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ClassicGetWorkerPool : View details of a worker pool for a classic cluster
// View detailed information for a worker pool in a classic cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetWorkerPool(classicGetWorkerPoolOptions *ClassicGetWorkerPoolOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ClassicGetWorkerPoolWithContext(context.Background(), classicGetWorkerPoolOptions)
}

// ClassicGetWorkerPoolWithContext is an alternate form of the ClassicGetWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetWorkerPoolWithContext(ctx context.Context, classicGetWorkerPoolOptions *ClassicGetWorkerPoolOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(classicGetWorkerPoolOptions, "classicGetWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(classicGetWorkerPoolOptions, "classicGetWorkerPoolOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/classic/getWorkerPool`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range classicGetWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ClassicGetWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if classicGetWorkerPoolOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*classicGetWorkerPoolOptions.XRegion))
	}
	if classicGetWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*classicGetWorkerPoolOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*classicGetWorkerPoolOptions.Cluster))
	builder.AddQuery("workerpool", fmt.Sprint(*classicGetWorkerPoolOptions.Workerpool))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ClassicGetWorkerPools : View details of a worker pool for a classic cluster
// View detailed information for a worker pool in a classic cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetWorkerPools(classicGetWorkerPoolsOptions *ClassicGetWorkerPoolsOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ClassicGetWorkerPoolsWithContext(context.Background(), classicGetWorkerPoolsOptions)
}

// ClassicGetWorkerPoolsWithContext is an alternate form of the ClassicGetWorkerPools method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetWorkerPoolsWithContext(ctx context.Context, classicGetWorkerPoolsOptions *ClassicGetWorkerPoolsOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(classicGetWorkerPoolsOptions, "classicGetWorkerPoolsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(classicGetWorkerPoolsOptions, "classicGetWorkerPoolsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/classic/getWorkerPools`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range classicGetWorkerPoolsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ClassicGetWorkerPools")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if classicGetWorkerPoolsOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*classicGetWorkerPoolsOptions.XRegion))
	}
	if classicGetWorkerPoolsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*classicGetWorkerPoolsOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*classicGetWorkerPoolsOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// ClassicGetWorkers : View all workers for a classic cluster
// View detailed information for all worker nodes in a classic cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetWorkers(classicGetWorkersOptions *ClassicGetWorkersOptions) (result []GetWorkerResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.ClassicGetWorkersWithContext(context.Background(), classicGetWorkersOptions)
}

// ClassicGetWorkersWithContext is an alternate form of the ClassicGetWorkers method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) ClassicGetWorkersWithContext(ctx context.Context, classicGetWorkersOptions *ClassicGetWorkersOptions) (result []GetWorkerResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(classicGetWorkersOptions, "classicGetWorkersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(classicGetWorkersOptions, "classicGetWorkersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/classic/getWorkers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range classicGetWorkersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "ClassicGetWorkers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if classicGetWorkersOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*classicGetWorkersOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*classicGetWorkersOptions.Cluster))
	if classicGetWorkersOptions.ShowDeleted != nil {
		builder.AddQuery("showDeleted", fmt.Sprint(*classicGetWorkersOptions.ShowDeleted))
	}
	if classicGetWorkersOptions.Pool != nil {
		builder.AddQuery("pool", fmt.Sprint(*classicGetWorkersOptions.Pool))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// KmsEnableCluster : Enables KMS on a given cluster
// Enables KMS on a given cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) KmsEnableCluster(kmsEnableClusterOptions *KmsEnableClusterOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.KmsEnableClusterWithContext(context.Background(), kmsEnableClusterOptions)
}

// KmsEnableClusterWithContext is an alternate form of the KmsEnableCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) KmsEnableClusterWithContext(ctx context.Context, kmsEnableClusterOptions *KmsEnableClusterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(kmsEnableClusterOptions, "kmsEnableClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(kmsEnableClusterOptions, "kmsEnableClusterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/enableKMS`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range kmsEnableClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "KmsEnableCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if kmsEnableClusterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*kmsEnableClusterOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if kmsEnableClusterOptions.Cluster != nil {
		body["cluster"] = kmsEnableClusterOptions.Cluster
	}
	if kmsEnableClusterOptions.CrkID != nil {
		body["crk_id"] = kmsEnableClusterOptions.CrkID
	}
	if kmsEnableClusterOptions.InstanceID != nil {
		body["instance_id"] = kmsEnableClusterOptions.InstanceID
	}
	if kmsEnableClusterOptions.PrivateEndpoint != nil {
		body["private_endpoint"] = kmsEnableClusterOptions.PrivateEndpoint
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// KmsGetCRKs : List the root keys for a Key Management Service instance
// List all the customer root keys (CRKs) for a Key Management Service (KMS) instance, such as a Key Protect service
// instance, in your IBM Cloud account.
func (kubernetesServiceApi *KubernetesServiceApiV1) KmsGetCRKs(kmsGetCRKsOptions *KmsGetCRKsOptions) (result []GetCRKResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.KmsGetCRKsWithContext(context.Background(), kmsGetCRKsOptions)
}

// KmsGetCRKsWithContext is an alternate form of the KmsGetCRKs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) KmsGetCRKsWithContext(ctx context.Context, kmsGetCRKsOptions *KmsGetCRKsOptions) (result []GetCRKResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(kmsGetCRKsOptions, "kmsGetCRKsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(kmsGetCRKsOptions, "kmsGetCRKsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getCRKs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range kmsGetCRKsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "KmsGetCRKs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if kmsGetCRKsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*kmsGetCRKsOptions.XAuthResourceGroup))
	}

	builder.AddQuery("kms_instance", fmt.Sprint(*kmsGetCRKsOptions.KmsInstance))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetCRKResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetCluster : View details for a cluster
// View detailed information for a cluster, including a VPC cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetCluster(getClusterOptions *GetClusterOptions) (result *GetClusterResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetClusterWithContext(context.Background(), getClusterOptions)
}

// GetClusterWithContext is an alternate form of the GetCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetClusterWithContext(ctx context.Context, getClusterOptions *GetClusterOptions) (result *GetClusterResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getClusterOptions, "getClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getClusterOptions, "getClusterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getCluster`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getClusterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getClusterOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getClusterOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetClusterResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// V2GetClusterAddons : View details of the add-ons that are enabled in a cluster
// View details of the add-ons that are enabled in a cluster, including the add-on versions.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetClusterAddons(v2GetClusterAddonsOptions *V2GetClusterAddonsOptions) (result []ClusterAddon, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2GetClusterAddonsWithContext(context.Background(), v2GetClusterAddonsOptions)
}

// V2GetClusterAddonsWithContext is an alternate form of the V2GetClusterAddons method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetClusterAddonsWithContext(ctx context.Context, v2GetClusterAddonsOptions *V2GetClusterAddonsOptions) (result []ClusterAddon, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2GetClusterAddonsOptions, "v2GetClusterAddonsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2GetClusterAddonsOptions, "v2GetClusterAddonsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getClusterAddons`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2GetClusterAddonsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2GetClusterAddons")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if v2GetClusterAddonsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2GetClusterAddonsOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*v2GetClusterAddonsOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalClusterAddon)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// V2GetFlavors : List available flavors types for a VPC zone (data center)
// List available flavors that you can use for a worker node. Flavors are specific to a location and a provider in an
// IBM Cloud Kubernetes Service zone. Each flavor includes the amount of virtual CPU, memory, and disk space that is set
// up for the worker node.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetFlavors(v2GetFlavorsOptions *V2GetFlavorsOptions) (result []Flavor, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2GetFlavorsWithContext(context.Background(), v2GetFlavorsOptions)
}

// V2GetFlavorsWithContext is an alternate form of the V2GetFlavors method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2GetFlavorsWithContext(ctx context.Context, v2GetFlavorsOptions *V2GetFlavorsOptions) (result []Flavor, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2GetFlavorsOptions, "v2GetFlavorsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2GetFlavorsOptions, "v2GetFlavorsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getFlavors`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2GetFlavorsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2GetFlavors")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("zone", fmt.Sprint(*v2GetFlavorsOptions.Zone))
	if v2GetFlavorsOptions.Provider != nil {
		builder.AddQuery("provider", fmt.Sprint(*v2GetFlavorsOptions.Provider))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlavor)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// KmsGetInstances : Gets KMS instances tied to an account
// Retrieves all available KMS instances in your IBM Cloud Account.
func (kubernetesServiceApi *KubernetesServiceApiV1) KmsGetInstances(kmsGetInstancesOptions *KmsGetInstancesOptions) (result []GetKMSInstanceResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.KmsGetInstancesWithContext(context.Background(), kmsGetInstancesOptions)
}

// KmsGetInstancesWithContext is an alternate form of the KmsGetInstances method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) KmsGetInstancesWithContext(ctx context.Context, kmsGetInstancesOptions *KmsGetInstancesOptions) (result []GetKMSInstanceResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(kmsGetInstancesOptions, "kmsGetInstancesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getKMSInstances`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range kmsGetInstancesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "KmsGetInstances")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if kmsGetInstancesOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*kmsGetInstancesOptions.XAuthResourceGroup))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetKMSInstanceResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetKubeconfig : Get the cluster's kubeconfig file. Optionally include the network configuration file
// Get the cluster's kubeconfig file to connect to your cluster and run Kubernetes API calls.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetKubeconfig(getKubeconfigOptions *GetKubeconfigOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetKubeconfigWithContext(context.Background(), getKubeconfigOptions)
}

// GetKubeconfigWithContext is an alternate form of the GetKubeconfig method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetKubeconfigWithContext(ctx context.Context, getKubeconfigOptions *GetKubeconfigOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getKubeconfigOptions, "getKubeconfigOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getKubeconfigOptions, "getKubeconfigOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getKubeconfig`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getKubeconfigOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetKubeconfig")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if getKubeconfigOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*getKubeconfigOptions.XAuthRefreshToken))
	}
	if getKubeconfigOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getKubeconfigOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getKubeconfigOptions.Cluster))
	if getKubeconfigOptions.Format != nil {
		builder.AddQuery("format", fmt.Sprint(*getKubeconfigOptions.Format))
	}
	if getKubeconfigOptions.Admin != nil {
		builder.AddQuery("admin", fmt.Sprint(*getKubeconfigOptions.Admin))
	}
	if getKubeconfigOptions.Network != nil {
		builder.AddQuery("network", fmt.Sprint(*getKubeconfigOptions.Network))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// GetQuota : View the quota for resources per region in the account
// View the quota for IBM Cloud Kubernetes Service resources such as clusters and worker nodes. The quota is per region
// and applies across resource groups in the account. To increase your quota, contact IBM Support and include the new
// quota limit that you want for the region, resource, and infrastructure provider such as classic or VPC.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetQuota(getQuotaOptions *GetQuotaOptions) (result []GetQuotaResource, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetQuotaWithContext(context.Background(), getQuotaOptions)
}

// GetQuotaWithContext is an alternate form of the GetQuota method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetQuotaWithContext(ctx context.Context, getQuotaOptions *GetQuotaOptions) (result []GetQuotaResource, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(getQuotaOptions, "getQuotaOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getQuota`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getQuotaOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetQuota")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetQuotaResource)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetWorker : View details of a worker node for cluster
// View detailed information for a worker node in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorker(getWorkerOptions *GetWorkerOptions) (result *GetWorkerResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetWorkerWithContext(context.Background(), getWorkerOptions)
}

// GetWorkerWithContext is an alternate form of the GetWorker method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerWithContext(ctx context.Context, getWorkerOptions *GetWorkerOptions) (result *GetWorkerResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getWorkerOptions, "getWorkerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getWorkerOptions, "getWorkerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getWorker`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getWorkerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetWorker")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getWorkerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getWorkerOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getWorkerOptions.Cluster))
	builder.AddQuery("worker", fmt.Sprint(*getWorkerOptions.Worker))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetWorkerPool : View details of a worker pool for a cluster
// View detailed information for a worker pool in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerPool(getWorkerPoolOptions *GetWorkerPoolOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetWorkerPoolWithContext(context.Background(), getWorkerPoolOptions)
}

// GetWorkerPoolWithContext is an alternate form of the GetWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerPoolWithContext(ctx context.Context, getWorkerPoolOptions *GetWorkerPoolOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getWorkerPoolOptions, "getWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getWorkerPoolOptions, "getWorkerPoolOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getWorkerPool`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getWorkerPoolOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*getWorkerPoolOptions.XRegion))
	}
	if getWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getWorkerPoolOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getWorkerPoolOptions.Cluster))
	builder.AddQuery("workerpool", fmt.Sprint(*getWorkerPoolOptions.Workerpool))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetWorkerPools1 : View details of a worker pool for a cluster
// View detailed information for a worker pool in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerPools1(getWorkerPools1Options *GetWorkerPools1Options) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetWorkerPools1WithContext(context.Background(), getWorkerPools1Options)
}

// GetWorkerPools1WithContext is an alternate form of the GetWorkerPools1 method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkerPools1WithContext(ctx context.Context, getWorkerPools1Options *GetWorkerPools1Options) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getWorkerPools1Options, "getWorkerPools1Options cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getWorkerPools1Options, "getWorkerPools1Options")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getWorkerPools`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getWorkerPools1Options.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetWorkerPools1")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getWorkerPools1Options.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*getWorkerPools1Options.XRegion))
	}
	if getWorkerPools1Options.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getWorkerPools1Options.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getWorkerPools1Options.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetWorkers1 : View all workers for cluster
// View detailed information for all worker nodes in a cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkers1(getWorkers1Options *GetWorkers1Options) (result []GetWorkerResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetWorkers1WithContext(context.Background(), getWorkers1Options)
}

// GetWorkers1WithContext is an alternate form of the GetWorkers1 method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetWorkers1WithContext(ctx context.Context, getWorkers1Options *GetWorkers1Options) (result []GetWorkerResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getWorkers1Options, "getWorkers1Options cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getWorkers1Options, "getWorkers1Options")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/getWorkers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getWorkers1Options.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetWorkers1")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getWorkers1Options.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getWorkers1Options.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*getWorkers1Options.Cluster))
	if getWorkers1Options.ShowDeleted != nil {
		builder.AddQuery("showDeleted", fmt.Sprint(*getWorkers1Options.ShowDeleted))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// RebalanceWorkerPool : Rebalance workers in a worker pool
// When you rebalance the worker pool, you return the number of worker nodes in the worker pool to a balanced state. For
// example, if you remove some worker nodes such as to troubleshoot an issue, you might have an uneven number of nodes
// across zones. You might delete 2 worker nodes in zone dal13 but still have 3 worker nodes each in zones dal10 and
// dal12 for a total of 7 worker nodes. To fix this unbalanced state, rebalance the worker pool. After rebalancing, the
// worker pool has 9 worker nodes again. Rebalancing does not change the size per zone of the worker pool, even if you
// specify a different size per zone.
func (kubernetesServiceApi *KubernetesServiceApiV1) RebalanceWorkerPool(rebalanceWorkerPoolOptions *RebalanceWorkerPoolOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RebalanceWorkerPoolWithContext(context.Background(), rebalanceWorkerPoolOptions)
}

// RebalanceWorkerPoolWithContext is an alternate form of the RebalanceWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RebalanceWorkerPoolWithContext(ctx context.Context, rebalanceWorkerPoolOptions *RebalanceWorkerPoolOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(rebalanceWorkerPoolOptions, "rebalanceWorkerPoolOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/rebalanceWorkerPool`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range rebalanceWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RebalanceWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if rebalanceWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*rebalanceWorkerPoolOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if rebalanceWorkerPoolOptions.Cluster != nil {
		body["cluster"] = rebalanceWorkerPoolOptions.Cluster
	}
	if rebalanceWorkerPoolOptions.Workerpool != nil {
		body["workerpool"] = rebalanceWorkerPoolOptions.Workerpool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// VpcRefreshMaster : Refresh the Kubernetes master
// Restart the Kubernetes master in the cluster to apply changes to the API server configuration.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcRefreshMaster(vpcRefreshMasterOptions *VpcRefreshMasterOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcRefreshMasterWithContext(context.Background(), vpcRefreshMasterOptions)
}

// VpcRefreshMasterWithContext is an alternate form of the VpcRefreshMaster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcRefreshMasterWithContext(ctx context.Context, vpcRefreshMasterOptions *VpcRefreshMasterOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcRefreshMasterOptions, "vpcRefreshMasterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcRefreshMasterOptions, "vpcRefreshMasterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/refreshMaster`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcRefreshMasterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcRefreshMaster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if vpcRefreshMasterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcRefreshMasterOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if vpcRefreshMasterOptions.Cluster != nil {
		body["cluster"] = vpcRefreshMasterOptions.Cluster
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2RemoveWorker : Delete a worker node from a cluster
// Delete a worker node from a cluster. This action cannot be undone. When you delete the worker node, the worker node
// is cordoned and drained so that its pods are rescheduled onto remaining worker nodes in the cluster. Make sure that
// you have enough capacity in the cluster to support the workload. After you remove the worker node, you can rebalance
// the worker pool.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2RemoveWorker(v2RemoveWorkerOptions *V2RemoveWorkerOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2RemoveWorkerWithContext(context.Background(), v2RemoveWorkerOptions)
}

// V2RemoveWorkerWithContext is an alternate form of the V2RemoveWorker method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2RemoveWorkerWithContext(ctx context.Context, v2RemoveWorkerOptions *V2RemoveWorkerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2RemoveWorkerOptions, "v2RemoveWorkerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2RemoveWorkerOptions, "v2RemoveWorkerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/removeWorker`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2RemoveWorkerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2RemoveWorker")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2RemoveWorkerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2RemoveWorkerOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2RemoveWorkerOptions.Cluster != nil {
		body["cluster"] = v2RemoveWorkerOptions.Cluster
	}
	if v2RemoveWorkerOptions.WorkerID != nil {
		body["workerID"] = v2RemoveWorkerOptions.WorkerID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RemoveWorkerPool1 : Removes a worker pool
// Remove a worker pool from a cluster. All worker nodes in the pool are deleted. Your pods are rescheduled when you
// delete. To avoid downtime, be sure that you have enough workers to run your workload.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveWorkerPool1(removeWorkerPool1Options *RemoveWorkerPool1Options) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveWorkerPool1WithContext(context.Background(), removeWorkerPool1Options)
}

// RemoveWorkerPool1WithContext is an alternate form of the RemoveWorkerPool1 method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveWorkerPool1WithContext(ctx context.Context, removeWorkerPool1Options *RemoveWorkerPool1Options) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeWorkerPool1Options, "removeWorkerPool1Options cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeWorkerPool1Options, "removeWorkerPool1Options")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/removeWorkerPool`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeWorkerPool1Options.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveWorkerPool1")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if removeWorkerPool1Options.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*removeWorkerPool1Options.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if removeWorkerPool1Options.Cluster != nil {
		body["cluster"] = removeWorkerPool1Options.Cluster
	}
	if removeWorkerPool1Options.Workerpool != nil {
		body["workerpool"] = removeWorkerPool1Options.Workerpool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// RemoveWorkerPoolZone1 : Remove a zone from a worker pool
// Remove a zone from a worker pool in your cluster. All worker nodes that are deployed to that zone in the worker pool
// are deleted. The app pods from the deleted worker nodes are rescheduled to other worker nodes when the zone is
// removed. To avoid downtime, be sure that you have enough worker nodes to handle your workload.
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveWorkerPoolZone1(removeWorkerPoolZone1Options *RemoveWorkerPoolZone1Options) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.RemoveWorkerPoolZone1WithContext(context.Background(), removeWorkerPoolZone1Options)
}

// RemoveWorkerPoolZone1WithContext is an alternate form of the RemoveWorkerPoolZone1 method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) RemoveWorkerPoolZone1WithContext(ctx context.Context, removeWorkerPoolZone1Options *RemoveWorkerPoolZone1Options) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(removeWorkerPoolZone1Options, "removeWorkerPoolZone1Options cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(removeWorkerPoolZone1Options, "removeWorkerPoolZone1Options")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/removeWorkerPoolZone`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range removeWorkerPoolZone1Options.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "RemoveWorkerPoolZone1")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if removeWorkerPoolZone1Options.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*removeWorkerPoolZone1Options.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if removeWorkerPoolZone1Options.Cluster != nil {
		body["cluster"] = removeWorkerPoolZone1Options.Cluster
	}
	if removeWorkerPoolZone1Options.Workerpool != nil {
		body["workerpool"] = removeWorkerPoolZone1Options.Workerpool
	}
	if removeWorkerPoolZone1Options.Zone != nil {
		body["zone"] = removeWorkerPoolZone1Options.Zone
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2ResizeWorkerPool : Resize an existing worker pool
// Resize a worker pool for the specified cluster. Resizing a worker pool requires Operator access to Kubernetes Service
// in the IBM Cloud account.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2ResizeWorkerPool(v2ResizeWorkerPoolOptions *V2ResizeWorkerPoolOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2ResizeWorkerPoolWithContext(context.Background(), v2ResizeWorkerPoolOptions)
}

// V2ResizeWorkerPoolWithContext is an alternate form of the V2ResizeWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2ResizeWorkerPoolWithContext(ctx context.Context, v2ResizeWorkerPoolOptions *V2ResizeWorkerPoolOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2ResizeWorkerPoolOptions, "v2ResizeWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2ResizeWorkerPoolOptions, "v2ResizeWorkerPoolOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/resizeWorkerPool`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2ResizeWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2ResizeWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2ResizeWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2ResizeWorkerPoolOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2ResizeWorkerPoolOptions.AllowSingleOpenShiftWorker != nil {
		body["allowSingleOpenShiftWorker"] = v2ResizeWorkerPoolOptions.AllowSingleOpenShiftWorker
	}
	if v2ResizeWorkerPoolOptions.Cluster != nil {
		body["cluster"] = v2ResizeWorkerPoolOptions.Cluster
	}
	if v2ResizeWorkerPoolOptions.Size != nil {
		body["size"] = v2ResizeWorkerPoolOptions.Size
	}
	if v2ResizeWorkerPoolOptions.Workerpool != nil {
		body["workerpool"] = v2ResizeWorkerPoolOptions.Workerpool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2SetWorkerPoolLabels : Set custom labels for a worker pool
// Set custom labels for a worker pool and each of its worker nodes. You might use labels to restrict a workload to run
// on only this worker pool, or to apply a taint so that workloads do not run on the worker pool. To confirm that your
// custom labels are applied, run `ibmcloud ks worker-pool get -c <cluster_name_or_ID>`. To check the labels of the
// worker nodes, get the private IP address of the worker node (`ibmcloud ks worker ls -c <cluster_name_or_ID>`) and run
// `kubectl describe node <worker_private_IP>`. Note that you must not edit the system-provided labels that that come
// with the worker pool and worker nodes by default, or you might experience unexpected results.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2SetWorkerPoolLabels(v2SetWorkerPoolLabelsOptions *V2SetWorkerPoolLabelsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2SetWorkerPoolLabelsWithContext(context.Background(), v2SetWorkerPoolLabelsOptions)
}

// V2SetWorkerPoolLabelsWithContext is an alternate form of the V2SetWorkerPoolLabels method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2SetWorkerPoolLabelsWithContext(ctx context.Context, v2SetWorkerPoolLabelsOptions *V2SetWorkerPoolLabelsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2SetWorkerPoolLabelsOptions, "v2SetWorkerPoolLabelsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2SetWorkerPoolLabelsOptions, "v2SetWorkerPoolLabelsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/setWorkerPoolLabels`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2SetWorkerPoolLabelsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2SetWorkerPoolLabels")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2SetWorkerPoolLabelsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2SetWorkerPoolLabelsOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2SetWorkerPoolLabelsOptions.Cluster != nil {
		body["cluster"] = v2SetWorkerPoolLabelsOptions.Cluster
	}
	if v2SetWorkerPoolLabelsOptions.Labels != nil {
		body["labels"] = v2SetWorkerPoolLabelsOptions.Labels
	}
	if v2SetWorkerPoolLabelsOptions.Workerpool != nil {
		body["workerpool"] = v2SetWorkerPoolLabelsOptions.Workerpool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// V2SetWorkerPoolTaints : Set custom taints for a worker pool
// Set custom taints for a worker pool and each of its worker nodes. You might use taints so that workloads do not run
// on the worker pool. To confirm that your custom taints are applied, check the taints of the worker nodes by getting
// the private IP address of the worker node (`ibmcloud ks worker ls -c <cluster_name_or_ID>`) and run `kubectl describe
// node <worker_private_IP>`.
func (kubernetesServiceApi *KubernetesServiceApiV1) V2SetWorkerPoolTaints(v2SetWorkerPoolTaintsOptions *V2SetWorkerPoolTaintsOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.V2SetWorkerPoolTaintsWithContext(context.Background(), v2SetWorkerPoolTaintsOptions)
}

// V2SetWorkerPoolTaintsWithContext is an alternate form of the V2SetWorkerPoolTaints method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) V2SetWorkerPoolTaintsWithContext(ctx context.Context, v2SetWorkerPoolTaintsOptions *V2SetWorkerPoolTaintsOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v2SetWorkerPoolTaintsOptions, "v2SetWorkerPoolTaintsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v2SetWorkerPoolTaintsOptions, "v2SetWorkerPoolTaintsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/setWorkerPoolTaints`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v2SetWorkerPoolTaintsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "V2SetWorkerPoolTaints")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if v2SetWorkerPoolTaintsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*v2SetWorkerPoolTaintsOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if v2SetWorkerPoolTaintsOptions.Cluster != nil {
		body["cluster"] = v2SetWorkerPoolTaintsOptions.Cluster
	}
	if v2SetWorkerPoolTaintsOptions.Taints != nil {
		body["taints"] = v2SetWorkerPoolTaintsOptions.Taints
	}
	if v2SetWorkerPoolTaintsOptions.Workerpool != nil {
		body["workerpool"] = v2SetWorkerPoolTaintsOptions.Workerpool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// VpcCreateCluster : Create a vpc cluster
// Create a vpc cluster in the IBM Cloud account that you are logged into. Creating a cluster requires Administrator
// access to Kubernetes Service in the IBM Cloud account.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcCreateCluster(vpcCreateClusterOptions *VpcCreateClusterOptions) (result *CreateClusterResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcCreateClusterWithContext(context.Background(), vpcCreateClusterOptions)
}

// VpcCreateClusterWithContext is an alternate form of the VpcCreateCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcCreateClusterWithContext(ctx context.Context, vpcCreateClusterOptions *VpcCreateClusterOptions) (result *CreateClusterResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcCreateClusterOptions, "vpcCreateClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcCreateClusterOptions, "vpcCreateClusterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/createCluster`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcCreateClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcCreateCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if vpcCreateClusterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcCreateClusterOptions.XAuthResourceGroup))
	}
	if vpcCreateClusterOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*vpcCreateClusterOptions.XAuthRefreshToken))
	}

	body := make(map[string]interface{})
	if vpcCreateClusterOptions.CosInstanceCRN != nil {
		body["cosInstanceCRN"] = vpcCreateClusterOptions.CosInstanceCRN
	}
	if vpcCreateClusterOptions.CseACLEnabled != nil {
		body["cseACLEnabled"] = vpcCreateClusterOptions.CseACLEnabled
	}
	if vpcCreateClusterOptions.DefaultWorkerPoolEntitlement != nil {
		body["defaultWorkerPoolEntitlement"] = vpcCreateClusterOptions.DefaultWorkerPoolEntitlement
	}
	if vpcCreateClusterOptions.DisablePublicServiceEndpoint != nil {
		body["disablePublicServiceEndpoint"] = vpcCreateClusterOptions.DisablePublicServiceEndpoint
	}
	if vpcCreateClusterOptions.KubeVersion != nil {
		body["kubeVersion"] = vpcCreateClusterOptions.KubeVersion
	}
	if vpcCreateClusterOptions.Name != nil {
		body["name"] = vpcCreateClusterOptions.Name
	}
	if vpcCreateClusterOptions.PodSubnet != nil {
		body["podSubnet"] = vpcCreateClusterOptions.PodSubnet
	}
	if vpcCreateClusterOptions.Provider != nil {
		body["provider"] = vpcCreateClusterOptions.Provider
	}
	if vpcCreateClusterOptions.ServiceSubnet != nil {
		body["serviceSubnet"] = vpcCreateClusterOptions.ServiceSubnet
	}
	if vpcCreateClusterOptions.WorkerPool != nil {
		body["workerPool"] = vpcCreateClusterOptions.WorkerPool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateClusterResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcCreateWorkerPool : Create a worker pool for a VPC cluster
// Create a worker pool for the specified VPC cluster. Creating a worker pool requires Operator access to Kubernetes
// Service in the IBM Cloud account.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcCreateWorkerPool(vpcCreateWorkerPoolOptions *VpcCreateWorkerPoolOptions) (result *CreateWorkerpoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcCreateWorkerPoolWithContext(context.Background(), vpcCreateWorkerPoolOptions)
}

// VpcCreateWorkerPoolWithContext is an alternate form of the VpcCreateWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcCreateWorkerPoolWithContext(ctx context.Context, vpcCreateWorkerPoolOptions *VpcCreateWorkerPoolOptions) (result *CreateWorkerpoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcCreateWorkerPoolOptions, "vpcCreateWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcCreateWorkerPoolOptions, "vpcCreateWorkerPoolOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/createWorkerPool`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcCreateWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcCreateWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if vpcCreateWorkerPoolOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*vpcCreateWorkerPoolOptions.XAuthRefreshToken))
	}
	if vpcCreateWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcCreateWorkerPoolOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if vpcCreateWorkerPoolOptions.Cluster != nil {
		body["cluster"] = vpcCreateWorkerPoolOptions.Cluster
	}
	if vpcCreateWorkerPoolOptions.DiskEncryption != nil {
		body["diskEncryption"] = vpcCreateWorkerPoolOptions.DiskEncryption
	}
	if vpcCreateWorkerPoolOptions.Entitlement != nil {
		body["entitlement"] = vpcCreateWorkerPoolOptions.Entitlement
	}
	if vpcCreateWorkerPoolOptions.Flavor != nil {
		body["flavor"] = vpcCreateWorkerPoolOptions.Flavor
	}
	if vpcCreateWorkerPoolOptions.Isolation != nil {
		body["isolation"] = vpcCreateWorkerPoolOptions.Isolation
	}
	if vpcCreateWorkerPoolOptions.Labels != nil {
		body["labels"] = vpcCreateWorkerPoolOptions.Labels
	}
	if vpcCreateWorkerPoolOptions.Name != nil {
		body["name"] = vpcCreateWorkerPoolOptions.Name
	}
	if vpcCreateWorkerPoolOptions.VpcID != nil {
		body["vpcID"] = vpcCreateWorkerPoolOptions.VpcID
	}
	if vpcCreateWorkerPoolOptions.WorkerCount != nil {
		body["workerCount"] = vpcCreateWorkerPoolOptions.WorkerCount
	}
	if vpcCreateWorkerPoolOptions.Zones != nil {
		body["zones"] = vpcCreateWorkerPoolOptions.Zones
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCreateWorkerpoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcCreateWorkerPoolZone : Create a zone in the specified worker pool for a VPC cluster
// Create a zone in the specified worker pool for a VPC cluster. Workers will be provisioned in each provided zone based
// on the size of the pool.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcCreateWorkerPoolZone(vpcCreateWorkerPoolZoneOptions *VpcCreateWorkerPoolZoneOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcCreateWorkerPoolZoneWithContext(context.Background(), vpcCreateWorkerPoolZoneOptions)
}

// VpcCreateWorkerPoolZoneWithContext is an alternate form of the VpcCreateWorkerPoolZone method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcCreateWorkerPoolZoneWithContext(ctx context.Context, vpcCreateWorkerPoolZoneOptions *VpcCreateWorkerPoolZoneOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcCreateWorkerPoolZoneOptions, "vpcCreateWorkerPoolZoneOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcCreateWorkerPoolZoneOptions, "vpcCreateWorkerPoolZoneOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/createWorkerPoolZone`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcCreateWorkerPoolZoneOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcCreateWorkerPoolZone")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if vpcCreateWorkerPoolZoneOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*vpcCreateWorkerPoolZoneOptions.XAuthRefreshToken))
	}
	if vpcCreateWorkerPoolZoneOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcCreateWorkerPoolZoneOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if vpcCreateWorkerPoolZoneOptions.Cluster != nil {
		body["cluster"] = vpcCreateWorkerPoolZoneOptions.Cluster
	}
	if vpcCreateWorkerPoolZoneOptions.ID != nil {
		body["id"] = vpcCreateWorkerPoolZoneOptions.ID
	}
	if vpcCreateWorkerPoolZoneOptions.SubnetID != nil {
		body["subnetID"] = vpcCreateWorkerPoolZoneOptions.SubnetID
	}
	if vpcCreateWorkerPoolZoneOptions.Workerpool != nil {
		body["workerpool"] = vpcCreateWorkerPoolZoneOptions.Workerpool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// VpcGetCluster : Detailed cluster information
// Detailed cluster information.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetCluster(vpcGetClusterOptions *VpcGetClusterOptions) (result []GetClusterResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcGetClusterWithContext(context.Background(), vpcGetClusterOptions)
}

// VpcGetClusterWithContext is an alternate form of the VpcGetCluster method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetClusterWithContext(ctx context.Context, vpcGetClusterOptions *VpcGetClusterOptions) (result []GetClusterResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcGetClusterOptions, "vpcGetClusterOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcGetClusterOptions, "vpcGetClusterOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getCluster`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcGetClusterOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcGetCluster")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vpcGetClusterOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcGetClusterOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*vpcGetClusterOptions.Cluster))
	if vpcGetClusterOptions.ShowResources != nil {
		builder.AddQuery("showResources", fmt.Sprint(*vpcGetClusterOptions.ShowResources))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetClusterResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcGetClusters : List the VPC clusters that you have access to
// List the VPC clusters that you have access to.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetClusters(vpcGetClustersOptions *VpcGetClustersOptions) (result []GetClustersResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcGetClustersWithContext(context.Background(), vpcGetClustersOptions)
}

// VpcGetClustersWithContext is an alternate form of the VpcGetClusters method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetClustersWithContext(ctx context.Context, vpcGetClustersOptions *VpcGetClustersOptions) (result []GetClustersResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(vpcGetClustersOptions, "vpcGetClustersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getClusters`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcGetClustersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcGetClusters")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vpcGetClustersOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcGetClustersOptions.XAuthResourceGroup))
	}

	if vpcGetClustersOptions.Location != nil {
		builder.AddQuery("location", fmt.Sprint(*vpcGetClustersOptions.Location))
	}
	if vpcGetClustersOptions.Provider != nil {
		builder.AddQuery("provider", fmt.Sprint(*vpcGetClustersOptions.Provider))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetClustersResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetSubnets : View subnets for a given VPC
// View details for subnets in a VPC for the given region and provider.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSubnets(getSubnetsOptions *GetSubnetsOptions) (result []Subnet, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetSubnetsWithContext(context.Background(), getSubnetsOptions)
}

// GetSubnetsWithContext is an alternate form of the GetSubnets method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetSubnetsWithContext(ctx context.Context, getSubnetsOptions *GetSubnetsOptions) (result []Subnet, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getSubnetsOptions, "getSubnetsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getSubnetsOptions, "getSubnetsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getSubnets`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getSubnetsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetSubnets")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getSubnetsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getSubnetsOptions.XAuthResourceGroup))
	}

	builder.AddQuery("provider", fmt.Sprint(*getSubnetsOptions.Provider))
	builder.AddQuery("zone", fmt.Sprint(*getSubnetsOptions.Zone))
	builder.AddQuery("vpc", fmt.Sprint(*getSubnetsOptions.Vpc))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSubnet)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVPC : View details of a VPC
// View details of a virtual private cloud (VPC).
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVPC(getVPCOptions *GetVPCOptions) (result *GetVPCResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetVPCWithContext(context.Background(), getVPCOptions)
}

// GetVPCWithContext is an alternate form of the GetVPC method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVPCWithContext(ctx context.Context, getVPCOptions *GetVPCOptions) (result *GetVPCResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCOptions, "getVPCOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCOptions, "getVPCOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getVPC`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetVPC")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getVPCOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*getVPCOptions.XRegion))
	}
	if getVPCOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getVPCOptions.XAuthResourceGroup))
	}

	builder.AddQuery("provider", fmt.Sprint(*getVPCOptions.Provider))
	builder.AddQuery("vpcID", fmt.Sprint(*getVPCOptions.VpcID))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetVPCResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// GetVPCs : View VPCs for the given provider
// View details for all VPCs in the given provider.
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVPCs(getVPCsOptions *GetVPCsOptions) (result []VirtualPrivateCloudResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.GetVPCsWithContext(context.Background(), getVPCsOptions)
}

// GetVPCsWithContext is an alternate form of the GetVPCs method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) GetVPCsWithContext(ctx context.Context, getVPCsOptions *GetVPCsOptions) (result []VirtualPrivateCloudResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getVPCsOptions, "getVPCsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getVPCsOptions, "getVPCsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getVPCs`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range getVPCsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "GetVPCs")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if getVPCsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*getVPCsOptions.XAuthResourceGroup))
	}

	builder.AddQuery("provider", fmt.Sprint(*getVPCsOptions.Provider))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVirtualPrivateCloudResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcGetWorker : View details of a worker node for VPC cluster
// View detailed information for a worker node in a VPC cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetWorker(vpcGetWorkerOptions *VpcGetWorkerOptions) (result *GetWorkerResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcGetWorkerWithContext(context.Background(), vpcGetWorkerOptions)
}

// VpcGetWorkerWithContext is an alternate form of the VpcGetWorker method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetWorkerWithContext(ctx context.Context, vpcGetWorkerOptions *VpcGetWorkerOptions) (result *GetWorkerResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcGetWorkerOptions, "vpcGetWorkerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcGetWorkerOptions, "vpcGetWorkerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getWorker`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcGetWorkerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcGetWorker")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vpcGetWorkerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcGetWorkerOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*vpcGetWorkerOptions.Cluster))
	builder.AddQuery("worker", fmt.Sprint(*vpcGetWorkerOptions.Worker))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcGetWorkerPool : View details of a worker pool for a VPC cluster
// View detailed information for a worker pool in a VPC cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetWorkerPool(vpcGetWorkerPoolOptions *VpcGetWorkerPoolOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcGetWorkerPoolWithContext(context.Background(), vpcGetWorkerPoolOptions)
}

// VpcGetWorkerPoolWithContext is an alternate form of the VpcGetWorkerPool method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetWorkerPoolWithContext(ctx context.Context, vpcGetWorkerPoolOptions *VpcGetWorkerPoolOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcGetWorkerPoolOptions, "vpcGetWorkerPoolOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcGetWorkerPoolOptions, "vpcGetWorkerPoolOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getWorkerPool`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcGetWorkerPoolOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcGetWorkerPool")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vpcGetWorkerPoolOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*vpcGetWorkerPoolOptions.XRegion))
	}
	if vpcGetWorkerPoolOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcGetWorkerPoolOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*vpcGetWorkerPoolOptions.Cluster))
	builder.AddQuery("workerpool", fmt.Sprint(*vpcGetWorkerPoolOptions.Workerpool))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcGetWorkerPools : View details of a worker pool for a VPC cluster
// View detailed information for a worker pool in a VPC cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetWorkerPools(vpcGetWorkerPoolsOptions *VpcGetWorkerPoolsOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcGetWorkerPoolsWithContext(context.Background(), vpcGetWorkerPoolsOptions)
}

// VpcGetWorkerPoolsWithContext is an alternate form of the VpcGetWorkerPools method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetWorkerPoolsWithContext(ctx context.Context, vpcGetWorkerPoolsOptions *VpcGetWorkerPoolsOptions) (result *GetWorkerPoolResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcGetWorkerPoolsOptions, "vpcGetWorkerPoolsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcGetWorkerPoolsOptions, "vpcGetWorkerPoolsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getWorkerPools`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcGetWorkerPoolsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcGetWorkerPools")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vpcGetWorkerPoolsOptions.XRegion != nil {
		builder.AddHeader("X-Region", fmt.Sprint(*vpcGetWorkerPoolsOptions.XRegion))
	}
	if vpcGetWorkerPoolsOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcGetWorkerPoolsOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*vpcGetWorkerPoolsOptions.Cluster))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerPoolResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcGetWorkers : View all workers for VPC cluster
// View detailed information for all worker nodes in a VPC cluster.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetWorkers(vpcGetWorkersOptions *VpcGetWorkersOptions) (result []GetWorkerResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcGetWorkersWithContext(context.Background(), vpcGetWorkersOptions)
}

// VpcGetWorkersWithContext is an alternate form of the VpcGetWorkers method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetWorkersWithContext(ctx context.Context, vpcGetWorkersOptions *VpcGetWorkersOptions) (result []GetWorkerResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcGetWorkersOptions, "vpcGetWorkersOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcGetWorkersOptions, "vpcGetWorkersOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getWorkers`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcGetWorkersOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcGetWorkers")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vpcGetWorkersOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcGetWorkersOptions.XAuthResourceGroup))
	}

	builder.AddQuery("cluster", fmt.Sprint(*vpcGetWorkersOptions.Cluster))
	if vpcGetWorkersOptions.ShowDeleted != nil {
		builder.AddQuery("showDeleted", fmt.Sprint(*vpcGetWorkersOptions.ShowDeleted))
	}
	if vpcGetWorkersOptions.Pool != nil {
		builder.AddQuery("pool", fmt.Sprint(*vpcGetWorkersOptions.Pool))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalGetWorkerResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcGetZones : List available zones in a region
// List available zones that you can use to create a cluster in an IBM Cloud Kubernetes Service region.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetZones(vpcGetZonesOptions *VpcGetZonesOptions) (result [][]ZoneResponse, response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcGetZonesWithContext(context.Background(), vpcGetZonesOptions)
}

// VpcGetZonesWithContext is an alternate form of the VpcGetZones method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcGetZonesWithContext(ctx context.Context, vpcGetZonesOptions *VpcGetZonesOptions) (result [][]ZoneResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(vpcGetZonesOptions, "vpcGetZonesOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/getZones`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcGetZonesOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcGetZones")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vpcGetZonesOptions.XAuthRefreshToken != nil {
		builder.AddHeader("X-Auth-Refresh-Token", fmt.Sprint(*vpcGetZonesOptions.XAuthRefreshToken))
	}

	if vpcGetZonesOptions.Provider != nil {
		builder.AddQuery("provider", fmt.Sprint(*vpcGetZonesOptions.Provider))
	}
	if vpcGetZonesOptions.ShowFlavors != nil {
		builder.AddQuery("showFlavors", fmt.Sprint(*vpcGetZonesOptions.ShowFlavors))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = kubernetesServiceApi.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalZoneResponse)
	if err != nil {
		return
	}
	response.Result = result

	return
}

// VpcReplaceWorker : Replace a worker node with a new worker node
// Delete the specified worker node from the cluster and provision a new worker node to replace the deleted worker node.
// You might replace a worker node if you cannot reload it, such as if it enters a troubled state. You can also replace
// the worker node to include an update to the same major and minor version of the master. The replacement worker node
// is created in the same zone, same worker pool, and with the same flavor as the deleted worker node. However, the
// replacement worker node is assigned a new private IP address, and loses any custom labels that you applied to the old
// worker node (worker pool labels are still applied to the replacement worker node). Before you replace the worker
// node, consider adding more worker nodes to the cluster and draining the worker node to help avoid downtime for your
// apps.
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcReplaceWorker(vpcReplaceWorkerOptions *VpcReplaceWorkerOptions) (response *core.DetailedResponse, err error) {
	return kubernetesServiceApi.VpcReplaceWorkerWithContext(context.Background(), vpcReplaceWorkerOptions)
}

// VpcReplaceWorkerWithContext is an alternate form of the VpcReplaceWorker method which supports a Context parameter
func (kubernetesServiceApi *KubernetesServiceApiV1) VpcReplaceWorkerWithContext(ctx context.Context, vpcReplaceWorkerOptions *VpcReplaceWorkerOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(vpcReplaceWorkerOptions, "vpcReplaceWorkerOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(vpcReplaceWorkerOptions, "vpcReplaceWorkerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = kubernetesServiceApi.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(kubernetesServiceApi.Service.Options.URL, `/v2/vpc/replaceWorker`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range vpcReplaceWorkerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("kubernetes_service_api", "V1", "VpcReplaceWorker")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Content-Type", "application/json")
	if vpcReplaceWorkerOptions.XAuthResourceGroup != nil {
		builder.AddHeader("X-Auth-Resource-Group", fmt.Sprint(*vpcReplaceWorkerOptions.XAuthResourceGroup))
	}

	body := make(map[string]interface{})
	if vpcReplaceWorkerOptions.Cluster != nil {
		body["cluster"] = vpcReplaceWorkerOptions.Cluster
	}
	if vpcReplaceWorkerOptions.Update != nil {
		body["update"] = vpcReplaceWorkerOptions.Update
	}
	if vpcReplaceWorkerOptions.WorkerID != nil {
		body["workerID"] = vpcReplaceWorkerOptions.WorkerID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = kubernetesServiceApi.Service.Request(request, nil)

	return
}

// ACLResponse : ACLResponse response for GET request.
type ACLResponse struct {
	// CSEACLList actual and desired.
	ActualCSEACLList *CSEACLList `json:"actualCSEACLList,omitempty"`

	// CSEACLList actual and desired.
	DesiredCSEACLList *CSEACLList `json:"desiredCSEACLList,omitempty"`
}

// UnmarshalACLResponse unmarshals an instance of ACLResponse from the specified map of raw messages.
func UnmarshalACLResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ACLResponse)
	err = core.UnmarshalModel(m, "actualCSEACLList", &obj.ActualCSEACLList, UnmarshalCSEACLList)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "desiredCSEACLList", &obj.DesiredCSEACLList, UnmarshalCSEACLList)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ALBConfig : ALBConfig struct
type ALBConfig struct {
	// The build number of the ALB.
	AlbBuild *string `json:"albBuild,omitempty"`

	// The ID of the application load balancer (ALB).
	AlbID *string `json:"albID,omitempty"`

	// The type of ALB.
	AlbType *string `json:"albType,omitempty"`

	// The public IP address that exposes the ALB.
	Albip *string `json:"albip,omitempty"`

	// The auth build of the ALB.
	AuthBuild *string `json:"authBuild,omitempty"`

	// The ID of the cluster that the ALB belongs to.
	ClusterID *string `json:"clusterID,omitempty"`

	// The date the ALB was created.
	CreatedDate *string `json:"createdDate,omitempty"`

	// If set to true, the deployment of the ALB is disabled.
	DisableDeployment *bool `json:"disableDeployment,omitempty"`

	// Set to true to enable the ALB, or false to disable the ALB for the cluster.
	Enable *bool `json:"enable,omitempty"`

	// The name of the cluster that the ALB belongs to.
	Name *string `json:"name,omitempty"`

	// The version of network load balancer that the ALB uses.
	NlbVersion *string `json:"nlbVersion,omitempty"`

	// Desired number of ALB replicas that you want in your cluster.
	NumOfInstances *string `json:"numOfInstances,omitempty"`

	// If set to true, resizing of the ALB is done.
	Resize *bool `json:"resize,omitempty"`

	// The state of the ALB.
	State *string `json:"state,omitempty"`

	// The status of the ALB.
	Status *string `json:"status,omitempty"`

	// The VLAN ID that the ALB is attached to.
	VlanID *string `json:"vlanID,omitempty"`

	// The zone where you want to add ALBs.
	Zone *string `json:"zone,omitempty"`
}

// UnmarshalALBConfig unmarshals an instance of ALBConfig from the specified map of raw messages.
func UnmarshalALBConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ALBConfig)
	err = core.UnmarshalPrimitive(m, "albBuild", &obj.AlbBuild)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "albID", &obj.AlbID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "albType", &obj.AlbType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "albip", &obj.Albip)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "authBuild", &obj.AuthBuild)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterID", &obj.ClusterID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdDate", &obj.CreatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "disableDeployment", &obj.DisableDeployment)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable", &obj.Enable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbVersion", &obj.NlbVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "numOfInstances", &obj.NumOfInstances)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resize", &obj.Resize)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlanID", &obj.VlanID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "zone", &obj.Zone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ALBSecretConfig : ALBSecretConfig struct
type ALBSecretConfig struct {
	// The CRN of the Certificate Manager instance where the TLS certificate is downloaded from.
	CertCrn *string `json:"certCrn,omitempty"`

	// The Certificate Manager instance ID where the TLS certificate is downloaded from.
	CloudCertInstanceID *string `json:"cloudCertInstanceID,omitempty"`

	// The CRN of the cluster where the ALB secret was created.
	ClusterCrn *string `json:"clusterCrn,omitempty"`

	// The ID of the cluster where the ALB secret was created.
	ClusterID *string `json:"clusterID,omitempty"`

	// The domain name of the TLS certficate that the ALB uses.
	DomainName *string `json:"domainName,omitempty"`

	// The expiration date of the certficate.
	ExpiresOn *string `json:"expiresOn,omitempty"`

	// The name of the issuer of the certficate.
	IssuerName *string `json:"issuerName,omitempty"`

	// The name of the ALB secret.
	SecretName *string `json:"secretName,omitempty"`

	// The state of ALB secret.
	State *string `json:"state,omitempty"`

	// The status of ALB secret.
	Status *string `json:"status,omitempty"`
}

// UnmarshalALBSecretConfig unmarshals an instance of ALBSecretConfig from the specified map of raw messages.
func UnmarshalALBSecretConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ALBSecretConfig)
	err = core.UnmarshalPrimitive(m, "certCrn", &obj.CertCrn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cloudCertInstanceID", &obj.CloudCertInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterCrn", &obj.ClusterCrn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterID", &obj.ClusterID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domainName", &obj.DomainName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expiresOn", &obj.ExpiresOn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "issuerName", &obj.IssuerName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secretName", &obj.SecretName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AccountStatus : AccountStatus summarises the IaaS user's view of the provider account.
type AccountStatus struct {
	// ProviderAccountID may contain personally identifiable information.
	Account *string `json:"account,omitempty"`

	// AccountType returns if the account information pertains to a linked or an IaaS account.
	AccountType *string `json:"accountType,omitempty"`

	// Permissions describes the result of checking granted permissions
	// Note: the default zero/empty value implies sufficient permissions.
	NetworkManagerPermissions *Permissions `json:"networkManagerPermissions,omitempty"`

	// Permissions describes the result of checking granted permissions
	// Note: the default zero/empty value implies sufficient permissions.
	PhysicalWorkerManagerPermissions *Permissions `json:"physicalWorkerManagerPermissions,omitempty"`

	// Permissions describes the result of checking granted permissions
	// Note: the default zero/empty value implies sufficient permissions.
	StorageManagerPermissions *Permissions `json:"storageManagerPermissions,omitempty"`

	// Permissions describes the result of checking granted permissions
	// Note: the default zero/empty value implies sufficient permissions.
	VirtualWorkerManagerPermissions *Permissions `json:"virtualWorkerManagerPermissions,omitempty"`
}

// UnmarshalAccountStatus unmarshals an instance of AccountStatus from the specified map of raw messages.
func UnmarshalAccountStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AccountStatus)
	err = core.UnmarshalPrimitive(m, "account", &obj.Account)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "accountType", &obj.AccountType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "networkManagerPermissions", &obj.NetworkManagerPermissions, UnmarshalPermissions)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "physicalWorkerManagerPermissions", &obj.PhysicalWorkerManagerPermissions, UnmarshalPermissions)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storageManagerPermissions", &obj.StorageManagerPermissions, UnmarshalPermissions)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "virtualWorkerManagerPermissions", &obj.VirtualWorkerManagerPermissions, UnmarshalPermissions)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddClusterACLsOptions : The AddClusterACLs options.
type AddClusterACLsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ACL list to patch.
	AclList []string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddClusterACLsOptions : Instantiate AddClusterACLsOptions
func (*KubernetesServiceApiV1) NewAddClusterACLsOptions(idOrName string) *AddClusterACLsOptions {
	return &AddClusterACLsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *AddClusterACLsOptions) SetIdOrName(idOrName string) *AddClusterACLsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAclList : Allow user to set AclList
func (options *AddClusterACLsOptions) SetAclList(aclList []string) *AddClusterACLsOptions {
	options.AclList = aclList
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AddClusterACLsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AddClusterACLsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddClusterACLsOptions) SetHeaders(param map[string]string) *AddClusterACLsOptions {
	options.Headers = param
	return options
}

// AddClusterSubnetOptions : The AddClusterSubnet options.
type AddClusterSubnetOptions struct {
	// The name or ID of the cluster that you want to make an existing subnet available to. To list the clusters that you
	// have access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the subnet in your IBM Cloud infrastructure account that you want to add to your cluster. To list
	// available subnets, run `ibmcloud ks subnets`.
	SubnetID *string `validate:"required,ne="`

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddClusterSubnetOptions : Instantiate AddClusterSubnetOptions
func (*KubernetesServiceApiV1) NewAddClusterSubnetOptions(idOrName string, subnetID string) *AddClusterSubnetOptions {
	return &AddClusterSubnetOptions{
		IdOrName: core.StringPtr(idOrName),
		SubnetID: core.StringPtr(subnetID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *AddClusterSubnetOptions) SetIdOrName(idOrName string) *AddClusterSubnetOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetSubnetID : Allow user to set SubnetID
func (options *AddClusterSubnetOptions) SetSubnetID(subnetID string) *AddClusterSubnetOptions {
	options.SubnetID = core.StringPtr(subnetID)
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *AddClusterSubnetOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *AddClusterSubnetOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AddClusterSubnetOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AddClusterSubnetOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddClusterSubnetOptions) SetHeaders(param map[string]string) *AddClusterSubnetOptions {
	options.Headers = param
	return options
}

// AddClusterUserSubnetOptions : The AddClusterUserSubnet options.
type AddClusterUserSubnetOptions struct {
	// The name or ID of the cluster that you want to make your user-managed subnet available to. To list the clusters that
	// you have access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The subnet and the CIDR that you want to add to the cluster in the format 12.34.45.78/24.
	Cidr *string

	// The private VLAN ID that the subnet CIDR belongs to.
	VlanID *string

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddClusterUserSubnetOptions : Instantiate AddClusterUserSubnetOptions
func (*KubernetesServiceApiV1) NewAddClusterUserSubnetOptions(idOrName string) *AddClusterUserSubnetOptions {
	return &AddClusterUserSubnetOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *AddClusterUserSubnetOptions) SetIdOrName(idOrName string) *AddClusterUserSubnetOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetCidr : Allow user to set Cidr
func (options *AddClusterUserSubnetOptions) SetCidr(cidr string) *AddClusterUserSubnetOptions {
	options.Cidr = core.StringPtr(cidr)
	return options
}

// SetVlanID : Allow user to set VlanID
func (options *AddClusterUserSubnetOptions) SetVlanID(vlanID string) *AddClusterUserSubnetOptions {
	options.VlanID = core.StringPtr(vlanID)
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *AddClusterUserSubnetOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *AddClusterUserSubnetOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AddClusterUserSubnetOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AddClusterUserSubnetOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddClusterUserSubnetOptions) SetHeaders(param map[string]string) *AddClusterUserSubnetOptions {
	options.Headers = param
	return options
}

// AddClusterWebhooksOptions : The AddClusterWebhooks options.
type AddClusterWebhooksOptions struct {
	// The name or ID of the cluster that you want to add a webhook to. To list the clusters that you have access to, use
	// the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The notification level that you want to use for the webhook.
	Level *string

	// The webhook service type.
	Type *string

	// The webhook URL.
	URL *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddClusterWebhooksOptions : Instantiate AddClusterWebhooksOptions
func (*KubernetesServiceApiV1) NewAddClusterWebhooksOptions(idOrName string) *AddClusterWebhooksOptions {
	return &AddClusterWebhooksOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *AddClusterWebhooksOptions) SetIdOrName(idOrName string) *AddClusterWebhooksOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetLevel : Allow user to set Level
func (options *AddClusterWebhooksOptions) SetLevel(level string) *AddClusterWebhooksOptions {
	options.Level = core.StringPtr(level)
	return options
}

// SetType : Allow user to set Type
func (options *AddClusterWebhooksOptions) SetType(typeVar string) *AddClusterWebhooksOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetURL : Allow user to set URL
func (options *AddClusterWebhooksOptions) SetURL(url string) *AddClusterWebhooksOptions {
	options.URL = core.StringPtr(url)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AddClusterWebhooksOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AddClusterWebhooksOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddClusterWebhooksOptions) SetHeaders(param map[string]string) *AddClusterWebhooksOptions {
	options.Headers = param
	return options
}

// AddClusterWorkersOptions : The AddClusterWorkers options.
type AddClusterWorkersOptions struct {
	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string `validate:"required"`

	// The name or ID of the cluster to which you want to add additional worker nodes. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The data center where the worker node is created.
	DataCenter *string

	DiskEncryption *bool

	Isolation *string

	// The machine type of the worker node.
	MachineType *string

	Prefix *string

	// The private VLAN ID that the worker node is attached to.
	PrivateVlan *string

	// The public VLAN ID that the worker node is attached to.
	PublicVlan *string

	WorkerNum *int64

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddClusterWorkersOptions : Instantiate AddClusterWorkersOptions
func (*KubernetesServiceApiV1) NewAddClusterWorkersOptions(xAuthResourceGroup string, idOrName string) *AddClusterWorkersOptions {
	return &AddClusterWorkersOptions{
		XAuthResourceGroup: core.StringPtr(xAuthResourceGroup),
		IdOrName:           core.StringPtr(idOrName),
	}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AddClusterWorkersOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AddClusterWorkersOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetIdOrName : Allow user to set IdOrName
func (options *AddClusterWorkersOptions) SetIdOrName(idOrName string) *AddClusterWorkersOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetDataCenter : Allow user to set DataCenter
func (options *AddClusterWorkersOptions) SetDataCenter(dataCenter string) *AddClusterWorkersOptions {
	options.DataCenter = core.StringPtr(dataCenter)
	return options
}

// SetDiskEncryption : Allow user to set DiskEncryption
func (options *AddClusterWorkersOptions) SetDiskEncryption(diskEncryption bool) *AddClusterWorkersOptions {
	options.DiskEncryption = core.BoolPtr(diskEncryption)
	return options
}

// SetIsolation : Allow user to set Isolation
func (options *AddClusterWorkersOptions) SetIsolation(isolation string) *AddClusterWorkersOptions {
	options.Isolation = core.StringPtr(isolation)
	return options
}

// SetMachineType : Allow user to set MachineType
func (options *AddClusterWorkersOptions) SetMachineType(machineType string) *AddClusterWorkersOptions {
	options.MachineType = core.StringPtr(machineType)
	return options
}

// SetPrefix : Allow user to set Prefix
func (options *AddClusterWorkersOptions) SetPrefix(prefix string) *AddClusterWorkersOptions {
	options.Prefix = core.StringPtr(prefix)
	return options
}

// SetPrivateVlan : Allow user to set PrivateVlan
func (options *AddClusterWorkersOptions) SetPrivateVlan(privateVlan string) *AddClusterWorkersOptions {
	options.PrivateVlan = core.StringPtr(privateVlan)
	return options
}

// SetPublicVlan : Allow user to set PublicVlan
func (options *AddClusterWorkersOptions) SetPublicVlan(publicVlan string) *AddClusterWorkersOptions {
	options.PublicVlan = core.StringPtr(publicVlan)
	return options
}

// SetWorkerNum : Allow user to set WorkerNum
func (options *AddClusterWorkersOptions) SetWorkerNum(workerNum int64) *AddClusterWorkersOptions {
	options.WorkerNum = core.Int64Ptr(workerNum)
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *AddClusterWorkersOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *AddClusterWorkersOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddClusterWorkersOptions) SetHeaders(param map[string]string) *AddClusterWorkersOptions {
	options.Headers = param
	return options
}

// AddNlbDNSHealthMonitorOptions : The AddNlbDNSHealthMonitor options.
type AddNlbDNSHealthMonitorOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	AllowInsecureSet *string

	ClusterID *string

	CreatedOn *string

	Desc *string

	FollowRedirectSet *string

	HealtcheckPropertiesSetStatus *string

	HealthcheckProperties map[string]interface{}

	ModifiedOn *string

	MonitorState *string

	NlbHost *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddNlbDNSHealthMonitorOptions : Instantiate AddNlbDNSHealthMonitorOptions
func (*KubernetesServiceApiV1) NewAddNlbDNSHealthMonitorOptions(idOrName string) *AddNlbDNSHealthMonitorOptions {
	return &AddNlbDNSHealthMonitorOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *AddNlbDNSHealthMonitorOptions) SetIdOrName(idOrName string) *AddNlbDNSHealthMonitorOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAllowInsecureSet : Allow user to set AllowInsecureSet
func (options *AddNlbDNSHealthMonitorOptions) SetAllowInsecureSet(allowInsecureSet string) *AddNlbDNSHealthMonitorOptions {
	options.AllowInsecureSet = core.StringPtr(allowInsecureSet)
	return options
}

// SetClusterID : Allow user to set ClusterID
func (options *AddNlbDNSHealthMonitorOptions) SetClusterID(clusterID string) *AddNlbDNSHealthMonitorOptions {
	options.ClusterID = core.StringPtr(clusterID)
	return options
}

// SetCreatedOn : Allow user to set CreatedOn
func (options *AddNlbDNSHealthMonitorOptions) SetCreatedOn(createdOn string) *AddNlbDNSHealthMonitorOptions {
	options.CreatedOn = core.StringPtr(createdOn)
	return options
}

// SetDesc : Allow user to set Desc
func (options *AddNlbDNSHealthMonitorOptions) SetDesc(desc string) *AddNlbDNSHealthMonitorOptions {
	options.Desc = core.StringPtr(desc)
	return options
}

// SetFollowRedirectSet : Allow user to set FollowRedirectSet
func (options *AddNlbDNSHealthMonitorOptions) SetFollowRedirectSet(followRedirectSet string) *AddNlbDNSHealthMonitorOptions {
	options.FollowRedirectSet = core.StringPtr(followRedirectSet)
	return options
}

// SetHealtcheckPropertiesSetStatus : Allow user to set HealtcheckPropertiesSetStatus
func (options *AddNlbDNSHealthMonitorOptions) SetHealtcheckPropertiesSetStatus(healtcheckPropertiesSetStatus string) *AddNlbDNSHealthMonitorOptions {
	options.HealtcheckPropertiesSetStatus = core.StringPtr(healtcheckPropertiesSetStatus)
	return options
}

// SetHealthcheckProperties : Allow user to set HealthcheckProperties
func (options *AddNlbDNSHealthMonitorOptions) SetHealthcheckProperties(healthcheckProperties map[string]interface{}) *AddNlbDNSHealthMonitorOptions {
	options.HealthcheckProperties = healthcheckProperties
	return options
}

// SetModifiedOn : Allow user to set ModifiedOn
func (options *AddNlbDNSHealthMonitorOptions) SetModifiedOn(modifiedOn string) *AddNlbDNSHealthMonitorOptions {
	options.ModifiedOn = core.StringPtr(modifiedOn)
	return options
}

// SetMonitorState : Allow user to set MonitorState
func (options *AddNlbDNSHealthMonitorOptions) SetMonitorState(monitorState string) *AddNlbDNSHealthMonitorOptions {
	options.MonitorState = core.StringPtr(monitorState)
	return options
}

// SetNlbHost : Allow user to set NlbHost
func (options *AddNlbDNSHealthMonitorOptions) SetNlbHost(nlbHost string) *AddNlbDNSHealthMonitorOptions {
	options.NlbHost = core.StringPtr(nlbHost)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AddNlbDNSHealthMonitorOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AddNlbDNSHealthMonitorOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddNlbDNSHealthMonitorOptions) SetHeaders(param map[string]string) *AddNlbDNSHealthMonitorOptions {
	options.Headers = param
	return options
}

// AddSubscriptionType : AddSubscriptionType struct
type AddSubscriptionType struct {
	UUID *string `json:"uuid,omitempty"`
}

// UnmarshalAddSubscriptionType unmarshals an instance of AddSubscriptionType from the specified map of raw messages.
func UnmarshalAddSubscriptionType(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddSubscriptionType)
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddWorkerPoolZoneNetworkOptions : The AddWorkerPoolZoneNetwork options.
type AddWorkerPoolZoneNetworkOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker pool. To list all worker pools for a cluster, use the `GET /v1/clusters/{idOrName}/workerpools`
	// API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	PoolidOrName *string `validate:"required,ne="`

	// The ID of the worker pool zone. To list all worker pools for a cluster, use the `GET /v1/zones` API or run `ibmcloud
	// ks zone ls`.
	Zoneid *string `validate:"required,ne="`

	PrivateVlan *string

	PublicVlan *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddWorkerPoolZoneNetworkOptions : Instantiate AddWorkerPoolZoneNetworkOptions
func (*KubernetesServiceApiV1) NewAddWorkerPoolZoneNetworkOptions(idOrName string, poolidOrName string, zoneid string) *AddWorkerPoolZoneNetworkOptions {
	return &AddWorkerPoolZoneNetworkOptions{
		IdOrName:     core.StringPtr(idOrName),
		PoolidOrName: core.StringPtr(poolidOrName),
		Zoneid:       core.StringPtr(zoneid),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *AddWorkerPoolZoneNetworkOptions) SetIdOrName(idOrName string) *AddWorkerPoolZoneNetworkOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetPoolidOrName : Allow user to set PoolidOrName
func (options *AddWorkerPoolZoneNetworkOptions) SetPoolidOrName(poolidOrName string) *AddWorkerPoolZoneNetworkOptions {
	options.PoolidOrName = core.StringPtr(poolidOrName)
	return options
}

// SetZoneid : Allow user to set Zoneid
func (options *AddWorkerPoolZoneNetworkOptions) SetZoneid(zoneid string) *AddWorkerPoolZoneNetworkOptions {
	options.Zoneid = core.StringPtr(zoneid)
	return options
}

// SetPrivateVlan : Allow user to set PrivateVlan
func (options *AddWorkerPoolZoneNetworkOptions) SetPrivateVlan(privateVlan string) *AddWorkerPoolZoneNetworkOptions {
	options.PrivateVlan = core.StringPtr(privateVlan)
	return options
}

// SetPublicVlan : Allow user to set PublicVlan
func (options *AddWorkerPoolZoneNetworkOptions) SetPublicVlan(publicVlan string) *AddWorkerPoolZoneNetworkOptions {
	options.PublicVlan = core.StringPtr(publicVlan)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AddWorkerPoolZoneNetworkOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AddWorkerPoolZoneNetworkOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddWorkerPoolZoneNetworkOptions) SetHeaders(param map[string]string) *AddWorkerPoolZoneNetworkOptions {
	options.Headers = param
	return options
}

// AddWorkerPoolZoneOptions : The AddWorkerPoolZone options.
type AddWorkerPoolZoneOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker pool. To list all worker pools for a cluster, use the `GET /v1/clusters/{idOrName}/workerpools`
	// API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	PoolidOrName *string `validate:"required,ne="`

	ID *string

	PrivateVlan *string

	PublicVlan *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAddWorkerPoolZoneOptions : Instantiate AddWorkerPoolZoneOptions
func (*KubernetesServiceApiV1) NewAddWorkerPoolZoneOptions(idOrName string, poolidOrName string) *AddWorkerPoolZoneOptions {
	return &AddWorkerPoolZoneOptions{
		IdOrName:     core.StringPtr(idOrName),
		PoolidOrName: core.StringPtr(poolidOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *AddWorkerPoolZoneOptions) SetIdOrName(idOrName string) *AddWorkerPoolZoneOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetPoolidOrName : Allow user to set PoolidOrName
func (options *AddWorkerPoolZoneOptions) SetPoolidOrName(poolidOrName string) *AddWorkerPoolZoneOptions {
	options.PoolidOrName = core.StringPtr(poolidOrName)
	return options
}

// SetID : Allow user to set ID
func (options *AddWorkerPoolZoneOptions) SetID(id string) *AddWorkerPoolZoneOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetPrivateVlan : Allow user to set PrivateVlan
func (options *AddWorkerPoolZoneOptions) SetPrivateVlan(privateVlan string) *AddWorkerPoolZoneOptions {
	options.PrivateVlan = core.StringPtr(privateVlan)
	return options
}

// SetPublicVlan : Allow user to set PublicVlan
func (options *AddWorkerPoolZoneOptions) SetPublicVlan(publicVlan string) *AddWorkerPoolZoneOptions {
	options.PublicVlan = core.StringPtr(publicVlan)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AddWorkerPoolZoneOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AddWorkerPoolZoneOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AddWorkerPoolZoneOptions) SetHeaders(param map[string]string) *AddWorkerPoolZoneOptions {
	options.Headers = param
	return options
}

// Addon : Addon properties.
type Addon struct {
	Enabled *bool `json:"enabled,omitempty"`

	Name *string `json:"name,omitempty"`

	State *string `json:"state,omitempty"`

	Status *string `json:"status,omitempty"`
}

// UnmarshalAddon unmarshals an instance of Addon from the specified map of raw messages.
func UnmarshalAddon(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Addon)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddonCommon : AddonCommon represents common properties of an addon.
type AddonCommon struct {
	// The minimum kubernetes version for this addon.
	MinKubeVersion *string `json:"minKubeVersion,omitempty"`

	// The minimum OpenShift version for this addon.
	MinOCPVersion *string `json:"minOCPVersion,omitempty"`

	// The addon name such as 'istio'.
	Name *string `json:"name" validate:"required"`

	// The supported kubernetes version range for this addon.
	SupportedKubeRange *string `json:"supportedKubeRange,omitempty"`

	// The supported Openshift version range for this addon.
	SupportedOCPRange *string `json:"supportedOCPRange,omitempty"`

	// The addon target version.
	TargetVersion *string `json:"targetVersion,omitempty"`

	// The addon version, omit the version if you wish to use the default version.
	Version *string `json:"version,omitempty"`

	// VLAN spanning required for multi-zone clusters.
	VlanSpanningRequired *bool `json:"vlan_spanning_required,omitempty"`
}

// UnmarshalAddonCommon unmarshals an instance of AddonCommon from the specified map of raw messages.
func UnmarshalAddonCommon(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddonCommon)
	err = core.UnmarshalPrimitive(m, "minKubeVersion", &obj.MinKubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minOCPVersion", &obj.MinOCPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supportedKubeRange", &obj.SupportedKubeRange)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supportedOCPRange", &obj.SupportedOCPRange)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVersion", &obj.TargetVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan_spanning_required", &obj.VlanSpanningRequired)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddonOptionsTemplate : AddonOptionsTemplate represents the options for an addon.
type AddonOptionsTemplate struct {
	Content *string `json:"content,omitempty"`

	Immutable *bool `json:"immutable,omitempty"`
}

// UnmarshalAddonOptionsTemplate unmarshals an instance of AddonOptionsTemplate from the specified map of raw messages.
func UnmarshalAddonOptionsTemplate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddonOptionsTemplate)
	err = core.UnmarshalPrimitive(m, "content", &obj.Content)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "immutable", &obj.Immutable)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AddonResponse : AddonResponse represents an addon response.
type AddonResponse struct {
	// The addon enable request would result in an invalid configuration. Install missing addons to continue.
	MissingDeps []ClusterAddon `json:"missingDeps,omitempty"`

	// The addon disable request would result in an invalid configuration. Inspect the map to determine why the
	// configuration is invalid.
	OrphanedAddons map[string][]ClusterAddon `json:"orphanedAddons,omitempty"`
}

// UnmarshalAddonResponse unmarshals an instance of AddonResponse from the specified map of raw messages.
func UnmarshalAddonResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AddonResponse)
	err = core.UnmarshalModel(m, "missingDeps", &obj.MissingDeps, UnmarshalClusterAddon)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "orphanedAddons", &obj.OrphanedAddons, UnmarshalClusterAddon)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AlbCreateResp : AlbCreateResp used to send back the albid on a create request.
type AlbCreateResp struct {
	Alb *string `json:"alb,omitempty"`

	Cluster *string `json:"cluster,omitempty"`
}

// UnmarshalAlbCreateResp unmarshals an instance of AlbCreateResp from the specified map of raw messages.
func UnmarshalAlbCreateResp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AlbCreateResp)
	err = core.UnmarshalPrimitive(m, "alb", &obj.Alb)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cluster", &obj.Cluster)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ApplyRBACAndGetKubeconfigOptions : The ApplyRBACAndGetKubeconfig options.
type ApplyRBACAndGetKubeconfigOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string `validate:"required"`

	Admin *bool

	Cluster *string

	EndpointType *string

	Format *string

	Network *bool

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewApplyRBACAndGetKubeconfigOptions : Instantiate ApplyRBACAndGetKubeconfigOptions
func (*KubernetesServiceApiV1) NewApplyRBACAndGetKubeconfigOptions(xAuthRefreshToken string) *ApplyRBACAndGetKubeconfigOptions {
	return &ApplyRBACAndGetKubeconfigOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *ApplyRBACAndGetKubeconfigOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *ApplyRBACAndGetKubeconfigOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetAdmin : Allow user to set Admin
func (options *ApplyRBACAndGetKubeconfigOptions) SetAdmin(admin bool) *ApplyRBACAndGetKubeconfigOptions {
	options.Admin = core.BoolPtr(admin)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *ApplyRBACAndGetKubeconfigOptions) SetCluster(cluster string) *ApplyRBACAndGetKubeconfigOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetEndpointType : Allow user to set EndpointType
func (options *ApplyRBACAndGetKubeconfigOptions) SetEndpointType(endpointType string) *ApplyRBACAndGetKubeconfigOptions {
	options.EndpointType = core.StringPtr(endpointType)
	return options
}

// SetFormat : Allow user to set Format
func (options *ApplyRBACAndGetKubeconfigOptions) SetFormat(format string) *ApplyRBACAndGetKubeconfigOptions {
	options.Format = core.StringPtr(format)
	return options
}

// SetNetwork : Allow user to set Network
func (options *ApplyRBACAndGetKubeconfigOptions) SetNetwork(network bool) *ApplyRBACAndGetKubeconfigOptions {
	options.Network = core.BoolPtr(network)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ApplyRBACAndGetKubeconfigOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ApplyRBACAndGetKubeconfigOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ApplyRBACAndGetKubeconfigOptions) SetHeaders(param map[string]string) *ApplyRBACAndGetKubeconfigOptions {
	options.Headers = param
	return options
}

// Assignment : Assignment is information about the host assignment.
type Assignment struct {
	// The cluster ID that the host is assigned to.
	ClusterID *string `json:"clusterID,omitempty"`

	// The cluster name that the host is assigned to.
	ClusterName *string `json:"clusterName,omitempty"`

	// The IP address assigned to the host.
	IpAddress *string `json:"ipAddress,omitempty"`

	// The timestamp when assignment request was received and began to execute resources on the host.
	ReceivedDate *string `json:"receivedDate,omitempty"`

	// The timestamp of the request to assign the host.
	RequestedDate *string `json:"requestedDate,omitempty"`

	// The worker node ID that the host is assigned to.
	WorkerID *string `json:"workerID,omitempty"`

	// The worker pool ID within the cluster that the host is assigned to.
	WorkerPoolID *string `json:"workerPoolID,omitempty"`

	// The worker pool name within the cluster that the host is assigned to.
	WorkerPoolName *string `json:"workerPoolName,omitempty"`

	// The zone within the cluster that the host is assigned to.
	Zone *string `json:"zone,omitempty"`
}

// UnmarshalAssignment unmarshals an instance of Assignment from the specified map of raw messages.
func UnmarshalAssignment(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Assignment)
	err = core.UnmarshalPrimitive(m, "clusterID", &obj.ClusterID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterName", &obj.ClusterName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipAddress", &obj.IpAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "receivedDate", &obj.ReceivedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "requestedDate", &obj.RequestedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerID", &obj.WorkerID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerPoolID", &obj.WorkerPoolID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerPoolName", &obj.WorkerPoolName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "zone", &obj.Zone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AttachSatelliteHostOptions : The AttachSatelliteHost options.
type AttachSatelliteHostOptions struct {
	// The name or ID of the Satellite location.
	Controller *string

	// Key-value pairs to label the host, such as cpu=4 to describe the host capabilities.
	Labels map[string]string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAttachSatelliteHostOptions : Instantiate AttachSatelliteHostOptions
func (*KubernetesServiceApiV1) NewAttachSatelliteHostOptions() *AttachSatelliteHostOptions {
	return &AttachSatelliteHostOptions{}
}

// SetController : Allow user to set Controller
func (options *AttachSatelliteHostOptions) SetController(controller string) *AttachSatelliteHostOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetLabels : Allow user to set Labels
func (options *AttachSatelliteHostOptions) SetLabels(labels map[string]string) *AttachSatelliteHostOptions {
	options.Labels = labels
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AttachSatelliteHostOptions) SetHeaders(param map[string]string) *AttachSatelliteHostOptions {
	options.Headers = param
	return options
}

// AuditWebhookConfig : AuditWebhookConfig struct
type AuditWebhookConfig struct {
	// The URL of the server to send audit logs to.
	AuditServer *string `json:"auditServer,omitempty"`

	// The Certificate Authority certificate that is used to connect to the audit server.
	CaCertificate *string `json:"caCertificate,omitempty"`

	// The client certificate that is used to connect to the audit server.
	ClientCertificate *string `json:"clientCertificate,omitempty"`

	// The client key that is used to connect to the audit server.
	ClientKey *string `json:"clientKey,omitempty"`
}

// UnmarshalAuditWebhookConfig unmarshals an instance of AuditWebhookConfig from the specified map of raw messages.
func UnmarshalAuditWebhookConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuditWebhookConfig)
	err = core.UnmarshalPrimitive(m, "auditServer", &obj.AuditServer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "caCertificate", &obj.CaCertificate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "clientCertificate", &obj.ClientCertificate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "clientKey", &obj.ClientKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AutoUpdateMasterOptions : The AutoUpdateMaster options.
type AutoUpdateMasterOptions struct {
	AutoUpdate *bool

	Cluster *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAutoUpdateMasterOptions : Instantiate AutoUpdateMasterOptions
func (*KubernetesServiceApiV1) NewAutoUpdateMasterOptions() *AutoUpdateMasterOptions {
	return &AutoUpdateMasterOptions{}
}

// SetAutoUpdate : Allow user to set AutoUpdate
func (options *AutoUpdateMasterOptions) SetAutoUpdate(autoUpdate bool) *AutoUpdateMasterOptions {
	options.AutoUpdate = core.BoolPtr(autoUpdate)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *AutoUpdateMasterOptions) SetCluster(cluster string) *AutoUpdateMasterOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *AutoUpdateMasterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *AutoUpdateMasterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *AutoUpdateMasterOptions) SetHeaders(param map[string]string) *AutoUpdateMasterOptions {
	options.Headers = param
	return options
}

// BindServiceToNamespaceOptions : The BindServiceToNamespace options.
type BindServiceToNamespaceOptions struct {
	// The name or ID of the cluster where you want to bind your service. To list the clusters that you have access to, use
	// the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the IBM Cloud service instance that you want to bind. To find the ID of the service instance, use the `GET
	// /v1/clusters/{idOrName}/services` API or run `{[bxcs]} cluster-services <cluster_name_or_ID>`.
	ServiceBindRequest *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewBindServiceToNamespaceOptions : Instantiate BindServiceToNamespaceOptions
func (*KubernetesServiceApiV1) NewBindServiceToNamespaceOptions(idOrName string, serviceBindRequest string) *BindServiceToNamespaceOptions {
	return &BindServiceToNamespaceOptions{
		IdOrName:           core.StringPtr(idOrName),
		ServiceBindRequest: core.StringPtr(serviceBindRequest),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *BindServiceToNamespaceOptions) SetIdOrName(idOrName string) *BindServiceToNamespaceOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetServiceBindRequest : Allow user to set ServiceBindRequest
func (options *BindServiceToNamespaceOptions) SetServiceBindRequest(serviceBindRequest string) *BindServiceToNamespaceOptions {
	options.ServiceBindRequest = core.StringPtr(serviceBindRequest)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *BindServiceToNamespaceOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *BindServiceToNamespaceOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *BindServiceToNamespaceOptions) SetHeaders(param map[string]string) *BindServiceToNamespaceOptions {
	options.Headers = param
	return options
}

// BluemixConfig : BluemixConfig struct
type BluemixConfig struct {
	AcctURL *string `json:"acct_url,omitempty"`

	BluemixURL *string `json:"bluemix_url,omitempty"`

	EnvName *string `json:"env_name,omitempty"`

	IamBaseURL *string `json:"iam_base_url,omitempty"`

	IamClientID *string `json:"iam_client_id,omitempty"`

	IamClientSecret *string `json:"iam_client_secret,omitempty"`

	IamIssuer *string `json:"iam_issuer,omitempty"`

	IamPapurl *string `json:"iam_papurl,omitempty"`

	IamPdpurl *string `json:"iam_pdpurl,omitempty"`

	IamURL *string `json:"iam_url,omitempty"`

	UaaURL *string `json:"uaa_url,omitempty"`
}

// UnmarshalBluemixConfig unmarshals an instance of BluemixConfig from the specified map of raw messages.
func UnmarshalBluemixConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BluemixConfig)
	err = core.UnmarshalPrimitive(m, "acct_url", &obj.AcctURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bluemix_url", &obj.BluemixURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "env_name", &obj.EnvName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iam_base_url", &obj.IamBaseURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iam_client_id", &obj.IamClientID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iam_client_secret", &obj.IamClientSecret)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iam_issuer", &obj.IamIssuer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iam_papurl", &obj.IamPapurl)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iam_pdpurl", &obj.IamPdpurl)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iam_url", &obj.IamURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uaa_url", &obj.UaaURL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BoundService : BoundService properties.
type BoundService struct {
	Namespace *string `json:"namespace,omitempty"`

	Serviceid *string `json:"serviceid,omitempty"`

	Servicekeyname *string `json:"servicekeyname,omitempty"`

	Servicename *string `json:"servicename,omitempty"`
}

// UnmarshalBoundService unmarshals an instance of BoundService from the specified map of raw messages.
func UnmarshalBoundService(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(BoundService)
	err = core.UnmarshalPrimitive(m, "namespace", &obj.Namespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceid", &obj.Serviceid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "servicekeyname", &obj.Servicekeyname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "servicename", &obj.Servicename)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// COSAuthorization : COSAuthorization Optional: IBM Cloud Object Storage authorization keys.
type COSAuthorization struct {
	// The HMAC secret access key ID.
	AccessKeyID *string `json:"access_key-id,omitempty"`

	// The HMAC secret access key.
	SecretAccessKey *string `json:"secret_access_key,omitempty"`
}

// UnmarshalCOSAuthorization unmarshals an instance of COSAuthorization from the specified map of raw messages.
func UnmarshalCOSAuthorization(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(COSAuthorization)
	err = core.UnmarshalPrimitive(m, "access_key-id", &obj.AccessKeyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secret_access_key", &obj.SecretAccessKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// COSBucket : COSBucket Optional: IBM Cloud Object Storage bucket configuration details.
type COSBucket struct {
	Bucket *string `json:"bucket,omitempty"`

	Endpoint *string `json:"endpoint,omitempty"`

	Region *string `json:"region,omitempty"`
}

// UnmarshalCOSBucket unmarshals an instance of COSBucket from the specified map of raw messages.
func UnmarshalCOSBucket(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(COSBucket)
	err = core.UnmarshalPrimitive(m, "bucket", &obj.Bucket)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CSEACLList : CSEACLList actual and desired.
type CSEACLList struct {
	CustomAclEntries []string `json:"customAclEntries,omitempty"`

	SystemAclEntries []string `json:"systemAclEntries,omitempty"`
}

// UnmarshalCSEACLList unmarshals an instance of CSEACLList from the specified map of raw messages.
func UnmarshalCSEACLList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CSEACLList)
	err = core.UnmarshalPrimitive(m, "customAclEntries", &obj.CustomAclEntries)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "systemAclEntries", &obj.SystemAclEntries)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ChangeFluentdUpdatePolicyOptions : The ChangeFluentdUpdatePolicy options.
type ChangeFluentdUpdatePolicyOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// If set to true, automatic updates for the ALBs are enabled.
	AutoUpdate *bool

	// If set to true, all ALBs in the cluster run the latest ALB version.
	LatestVersion *bool

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewChangeFluentdUpdatePolicyOptions : Instantiate ChangeFluentdUpdatePolicyOptions
func (*KubernetesServiceApiV1) NewChangeFluentdUpdatePolicyOptions(idOrName string) *ChangeFluentdUpdatePolicyOptions {
	return &ChangeFluentdUpdatePolicyOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ChangeFluentdUpdatePolicyOptions) SetIdOrName(idOrName string) *ChangeFluentdUpdatePolicyOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAutoUpdate : Allow user to set AutoUpdate
func (options *ChangeFluentdUpdatePolicyOptions) SetAutoUpdate(autoUpdate bool) *ChangeFluentdUpdatePolicyOptions {
	options.AutoUpdate = core.BoolPtr(autoUpdate)
	return options
}

// SetLatestVersion : Allow user to set LatestVersion
func (options *ChangeFluentdUpdatePolicyOptions) SetLatestVersion(latestVersion bool) *ChangeFluentdUpdatePolicyOptions {
	options.LatestVersion = core.BoolPtr(latestVersion)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *ChangeFluentdUpdatePolicyOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *ChangeFluentdUpdatePolicyOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ChangeFluentdUpdatePolicyOptions) SetHeaders(param map[string]string) *ChangeFluentdUpdatePolicyOptions {
	options.Headers = param
	return options
}

// ChangeUpdatePolicyOptions : The ChangeUpdatePolicy options.
type ChangeUpdatePolicyOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// If set to true, automatic updates for the ALBs are enabled.
	AutoUpdate *bool

	// If set to true, all ALBs in the cluster run the latest ALB version.
	LatestVersion *bool

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewChangeUpdatePolicyOptions : Instantiate ChangeUpdatePolicyOptions
func (*KubernetesServiceApiV1) NewChangeUpdatePolicyOptions(idOrName string) *ChangeUpdatePolicyOptions {
	return &ChangeUpdatePolicyOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ChangeUpdatePolicyOptions) SetIdOrName(idOrName string) *ChangeUpdatePolicyOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAutoUpdate : Allow user to set AutoUpdate
func (options *ChangeUpdatePolicyOptions) SetAutoUpdate(autoUpdate bool) *ChangeUpdatePolicyOptions {
	options.AutoUpdate = core.BoolPtr(autoUpdate)
	return options
}

// SetLatestVersion : Allow user to set LatestVersion
func (options *ChangeUpdatePolicyOptions) SetLatestVersion(latestVersion bool) *ChangeUpdatePolicyOptions {
	options.LatestVersion = core.BoolPtr(latestVersion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ChangeUpdatePolicyOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ChangeUpdatePolicyOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ChangeUpdatePolicyOptions) SetHeaders(param map[string]string) *ChangeUpdatePolicyOptions {
	options.Headers = param
	return options
}

// ClassicGetClusterOptions : The ClassicGetCluster options.
type ClassicGetClusterOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The resource group that you want to list clusters for. To list available resource groups, run `ibmcloud resource
	// groups`. If you don't include this header, all the clusters in the account that you have access to are listed.
	XAuthResourceGroup *string

	// To view additional cluster resources like addons, VLANs, subnets, and storage, pass `true`.
	ShowResources *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewClassicGetClusterOptions : Instantiate ClassicGetClusterOptions
func (*KubernetesServiceApiV1) NewClassicGetClusterOptions(cluster string) *ClassicGetClusterOptions {
	return &ClassicGetClusterOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *ClassicGetClusterOptions) SetCluster(cluster string) *ClassicGetClusterOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ClassicGetClusterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ClassicGetClusterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetShowResources : Allow user to set ShowResources
func (options *ClassicGetClusterOptions) SetShowResources(showResources string) *ClassicGetClusterOptions {
	options.ShowResources = core.StringPtr(showResources)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ClassicGetClusterOptions) SetHeaders(param map[string]string) *ClassicGetClusterOptions {
	options.Headers = param
	return options
}

// ClassicGetClustersOptions : The ClassicGetClusters options.
type ClassicGetClustersOptions struct {
	// The resource group that you want to list clusters for. To list available resource groups, run `ibmcloud resource
	// groups`. If you don't include this header, all the clusters in the account that you have access to are listed.
	XAuthResourceGroup *string

	// Specify a location to filter clusters for. To see supported locations, use the `GET /v1/locations` API or run
	// `ibmcloud ks locations`.
	Location *string

	// To view additional cluster resources like addons, VLANs, subnets, and storage, pass `true`.
	ShowResources *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewClassicGetClustersOptions : Instantiate ClassicGetClustersOptions
func (*KubernetesServiceApiV1) NewClassicGetClustersOptions() *ClassicGetClustersOptions {
	return &ClassicGetClustersOptions{}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ClassicGetClustersOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ClassicGetClustersOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetLocation : Allow user to set Location
func (options *ClassicGetClustersOptions) SetLocation(location string) *ClassicGetClustersOptions {
	options.Location = core.StringPtr(location)
	return options
}

// SetShowResources : Allow user to set ShowResources
func (options *ClassicGetClustersOptions) SetShowResources(showResources string) *ClassicGetClustersOptions {
	options.ShowResources = core.StringPtr(showResources)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ClassicGetClustersOptions) SetHeaders(param map[string]string) *ClassicGetClustersOptions {
	options.Headers = param
	return options
}

// ClassicGetWorkerOptions : The ClassicGetWorker options.
type ClassicGetWorkerOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The ID of the worker node that you want details for. To list all worker nodes for a cluster, use the `GET
	// /v1/clusters/{idOrName}/workers` API or run `ibmcloud ks workers <cluster_name_or_ID>`.
	Worker *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewClassicGetWorkerOptions : Instantiate ClassicGetWorkerOptions
func (*KubernetesServiceApiV1) NewClassicGetWorkerOptions(cluster string, worker string) *ClassicGetWorkerOptions {
	return &ClassicGetWorkerOptions{
		Cluster: core.StringPtr(cluster),
		Worker:  core.StringPtr(worker),
	}
}

// SetCluster : Allow user to set Cluster
func (options *ClassicGetWorkerOptions) SetCluster(cluster string) *ClassicGetWorkerOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorker : Allow user to set Worker
func (options *ClassicGetWorkerOptions) SetWorker(worker string) *ClassicGetWorkerOptions {
	options.Worker = core.StringPtr(worker)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ClassicGetWorkerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ClassicGetWorkerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ClassicGetWorkerOptions) SetHeaders(param map[string]string) *ClassicGetWorkerOptions {
	options.Headers = param
	return options
}

// ClassicGetWorkerPoolOptions : The ClassicGetWorkerPool options.
type ClassicGetWorkerPoolOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The ID of the worker pool that you want details for. To list all worker pools for a cluster, use the `GET
	// /v1/clusters/{idOrName}/workerpools` API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	Workerpool *string `validate:"required"`

	// If you are using the global endpoint, target the Kubernetes Service region. To list available regions, use the `GET
	// /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewClassicGetWorkerPoolOptions : Instantiate ClassicGetWorkerPoolOptions
func (*KubernetesServiceApiV1) NewClassicGetWorkerPoolOptions(cluster string, workerpool string) *ClassicGetWorkerPoolOptions {
	return &ClassicGetWorkerPoolOptions{
		Cluster:    core.StringPtr(cluster),
		Workerpool: core.StringPtr(workerpool),
	}
}

// SetCluster : Allow user to set Cluster
func (options *ClassicGetWorkerPoolOptions) SetCluster(cluster string) *ClassicGetWorkerPoolOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *ClassicGetWorkerPoolOptions) SetWorkerpool(workerpool string) *ClassicGetWorkerPoolOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXRegion : Allow user to set XRegion
func (options *ClassicGetWorkerPoolOptions) SetXRegion(xRegion string) *ClassicGetWorkerPoolOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ClassicGetWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ClassicGetWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ClassicGetWorkerPoolOptions) SetHeaders(param map[string]string) *ClassicGetWorkerPoolOptions {
	options.Headers = param
	return options
}

// ClassicGetWorkerPoolsOptions : The ClassicGetWorkerPools options.
type ClassicGetWorkerPoolsOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// If you are using the global endpoint, target the Kubernetes Service region. To list available regions, use the `GET
	// /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewClassicGetWorkerPoolsOptions : Instantiate ClassicGetWorkerPoolsOptions
func (*KubernetesServiceApiV1) NewClassicGetWorkerPoolsOptions(cluster string) *ClassicGetWorkerPoolsOptions {
	return &ClassicGetWorkerPoolsOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *ClassicGetWorkerPoolsOptions) SetCluster(cluster string) *ClassicGetWorkerPoolsOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXRegion : Allow user to set XRegion
func (options *ClassicGetWorkerPoolsOptions) SetXRegion(xRegion string) *ClassicGetWorkerPoolsOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ClassicGetWorkerPoolsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ClassicGetWorkerPoolsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ClassicGetWorkerPoolsOptions) SetHeaders(param map[string]string) *ClassicGetWorkerPoolsOptions {
	options.Headers = param
	return options
}

// ClassicGetWorkersOptions : The ClassicGetWorkers options.
type ClassicGetWorkersOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks clusters`.
	Cluster *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// true|false Shows deleted workers.
	ShowDeleted *string

	// The name or ID of the worker pool to filter results for. Run `ibmcloud ks worker-pool ls --cluster <cluster name>`.
	Pool *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewClassicGetWorkersOptions : Instantiate ClassicGetWorkersOptions
func (*KubernetesServiceApiV1) NewClassicGetWorkersOptions(cluster string) *ClassicGetWorkersOptions {
	return &ClassicGetWorkersOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *ClassicGetWorkersOptions) SetCluster(cluster string) *ClassicGetWorkersOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ClassicGetWorkersOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ClassicGetWorkersOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetShowDeleted : Allow user to set ShowDeleted
func (options *ClassicGetWorkersOptions) SetShowDeleted(showDeleted string) *ClassicGetWorkersOptions {
	options.ShowDeleted = core.StringPtr(showDeleted)
	return options
}

// SetPool : Allow user to set Pool
func (options *ClassicGetWorkersOptions) SetPool(pool string) *ClassicGetWorkersOptions {
	options.Pool = core.StringPtr(pool)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ClassicGetWorkersOptions) SetHeaders(param map[string]string) *ClassicGetWorkersOptions {
	options.Headers = param
	return options
}

// CleanupMigrationOptions : The CleanupMigration options.
type CleanupMigrationOptions struct {
	Cluster *string

	Options []string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCleanupMigrationOptions : Instantiate CleanupMigrationOptions
func (*KubernetesServiceApiV1) NewCleanupMigrationOptions() *CleanupMigrationOptions {
	return &CleanupMigrationOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *CleanupMigrationOptions) SetCluster(cluster string) *CleanupMigrationOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CleanupMigrationOptions) SetHeaders(param map[string]string) *CleanupMigrationOptions {
	options.Headers = param
	return options
}

// Cluster : Cluster properties.
type Cluster struct {
	ImageSecurityEnabled *bool `json:"ImageSecurityEnabled,omitempty"`

	Addons []Addon `json:"addons,omitempty"`

	ApiUser *string `json:"apiUser,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty"`

	Crn *string `json:"crn,omitempty"`

	DataCenter *string `json:"dataCenter,omitempty"`

	DisableAutoUpdate *bool `json:"disableAutoUpdate,omitempty"`

	EtcdPort *string `json:"etcdPort,omitempty"`

	ID *string `json:"id,omitempty"`

	IngressHostname *string `json:"ingressHostname,omitempty"`

	IngressMessage *string `json:"ingressMessage,omitempty"`

	IngressSecretName *string `json:"ingressSecretName,omitempty"`

	IngressStatus *string `json:"ingressStatus,omitempty"`

	IsPaid *bool `json:"isPaid,omitempty"`

	KeyProtectEnabled *bool `json:"keyProtectEnabled,omitempty"`

	Location *string `json:"location,omitempty"`

	LogOrg *string `json:"logOrg,omitempty"`

	LogOrgName *string `json:"logOrgName,omitempty"`

	LogSpace *string `json:"logSpace,omitempty"`

	LogSpaceName *string `json:"logSpaceName,omitempty"`

	MasterHealth *string `json:"masterHealth,omitempty"`

	MasterKubeVersion *string `json:"masterKubeVersion,omitempty"`

	MasterState *string `json:"masterState,omitempty"`

	MasterStatus *string `json:"masterStatus,omitempty"`

	MasterStatusModifiedDate *string `json:"masterStatusModifiedDate,omitempty"`

	ModifiedDate *string `json:"modifiedDate,omitempty"`

	MonitoringURL *string `json:"monitoringURL,omitempty"`

	MultiAzCapable *bool `json:"multiAzCapable,omitempty"`

	Name *string `json:"name,omitempty"`

	PodSubnet *string `json:"podSubnet,omitempty"`

	PrivateServiceEndpointEnabled *bool `json:"privateServiceEndpointEnabled,omitempty"`

	PrivateServiceEndpointURL *string `json:"privateServiceEndpointURL,omitempty"`

	PublicServiceEndpointEnabled *bool `json:"publicServiceEndpointEnabled,omitempty"`

	PublicServiceEndpointURL *string `json:"publicServiceEndpointURL,omitempty"`

	PullSecretApplied *bool `json:"pullSecretApplied,omitempty"`

	Region *string `json:"region,omitempty"`

	ResourceGroup *string `json:"resourceGroup,omitempty"`

	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	ServerURL *string `json:"serverURL,omitempty"`

	ServiceSubnet *string `json:"serviceSubnet,omitempty"`

	State *string `json:"state,omitempty"`

	Status *string `json:"status,omitempty"`

	TargetVersion *string `json:"targetVersion,omitempty"`

	Type *string `json:"type,omitempty"`

	VersionEOS *string `json:"versionEOS,omitempty"`

	Vlans []VlanConfigField `json:"vlans,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`

	WorkerZones []string `json:"workerZones,omitempty"`

	// VLANS is a helper type to sort an api.VLAN list. The VLANS will sort the list in order of the
	// Properties.PrimaryRouter value so that VLAN's of a common router are listed consecutively.
	WorkerVlans []VLAN `json:"worker_vlans,omitempty"`
}

// UnmarshalCluster unmarshals an instance of Cluster from the specified map of raw messages.
func UnmarshalCluster(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Cluster)
	err = core.UnmarshalPrimitive(m, "ImageSecurityEnabled", &obj.ImageSecurityEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "addons", &obj.Addons, UnmarshalAddon)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "apiUser", &obj.ApiUser)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdDate", &obj.CreatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dataCenter", &obj.DataCenter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "disableAutoUpdate", &obj.DisableAutoUpdate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "etcdPort", &obj.EtcdPort)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ingressHostname", &obj.IngressHostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ingressMessage", &obj.IngressMessage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ingressSecretName", &obj.IngressSecretName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ingressStatus", &obj.IngressStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaid", &obj.IsPaid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "keyProtectEnabled", &obj.KeyProtectEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "logOrg", &obj.LogOrg)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "logOrgName", &obj.LogOrgName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "logSpace", &obj.LogSpace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "logSpaceName", &obj.LogSpaceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterHealth", &obj.MasterHealth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterKubeVersion", &obj.MasterKubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterState", &obj.MasterState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterStatus", &obj.MasterStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterStatusModifiedDate", &obj.MasterStatusModifiedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "modifiedDate", &obj.ModifiedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "monitoringURL", &obj.MonitoringURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "multiAzCapable", &obj.MultiAzCapable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "podSubnet", &obj.PodSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateServiceEndpointEnabled", &obj.PrivateServiceEndpointEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateServiceEndpointURL", &obj.PrivateServiceEndpointURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicServiceEndpointEnabled", &obj.PublicServiceEndpointEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicServiceEndpointURL", &obj.PublicServiceEndpointURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pullSecretApplied", &obj.PullSecretApplied)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroup", &obj.ResourceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupName", &obj.ResourceGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serverURL", &obj.ServerURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceSubnet", &obj.ServiceSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVersion", &obj.TargetVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "versionEOS", &obj.VersionEOS)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vlans", &obj.Vlans, UnmarshalVlanConfigField)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerZones", &obj.WorkerZones)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "worker_vlans", &obj.WorkerVlans, UnmarshalVLAN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterALB : ClusterALB alb related information for cluster.
type ClusterALB struct {
	Alb []ALBConfig `json:"alb,omitempty"`

	DataCenter *string `json:"dataCenter,omitempty"`

	ID *string `json:"id,omitempty"`

	IngressHostname *string `json:"ingressHostname,omitempty"`

	IngressSecretName *string `json:"ingressSecretName,omitempty"`

	IsPaid *bool `json:"isPaid,omitempty"`

	Region *string `json:"region,omitempty"`
}

// UnmarshalClusterALB unmarshals an instance of ClusterALB from the specified map of raw messages.
func UnmarshalClusterALB(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterALB)
	err = core.UnmarshalModel(m, "alb", &obj.Alb, UnmarshalALBConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dataCenter", &obj.DataCenter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ingressHostname", &obj.IngressHostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ingressSecretName", &obj.IngressSecretName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaid", &obj.IsPaid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterALBSecret : ClusterALBSecret struct
type ClusterALBSecret struct {
	// A list of ALB secrets that were created for a cluster.
	AlbSecrets []ALBSecretConfig `json:"albSecrets,omitempty"`

	DataCenter *string `json:"dataCenter,omitempty"`

	ID *string `json:"id,omitempty"`

	IsPaid *bool `json:"isPaid,omitempty"`

	Region *string `json:"region,omitempty"`
}

// UnmarshalClusterALBSecret unmarshals an instance of ClusterALBSecret from the specified map of raw messages.
func UnmarshalClusterALBSecret(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterALBSecret)
	err = core.UnmarshalModel(m, "albSecrets", &obj.AlbSecrets, UnmarshalALBSecretConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dataCenter", &obj.DataCenter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaid", &obj.IsPaid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterAddon : ClusterAddon represents one add on.
type ClusterAddon struct {
	// The versions that the addon can be upgraded to.
	AllowedUpgradeVersions []string `json:"allowed_upgrade_versions,omitempty"`

	// Determines if this addon version is deprecated.
	Deprecated *bool `json:"deprecated,omitempty"`

	// The health state for this addon, a short indication (e.g. critical, pending).
	HealthState *string `json:"healthState,omitempty"`

	// The health status for this addon, provides a description of the state (e.g. error message).
	HealthStatus *string `json:"healthStatus,omitempty"`

	// AddonOptionsTemplate represents the options for an addon.
	InstallOptionsTemplate *AddonOptionsTemplate `json:"install_options_template,omitempty"`

	// The minimum kubernetes version for this addon.
	MinKubeVersion *string `json:"minKubeVersion,omitempty"`

	// The minimum OpenShift version for this addon.
	MinOCPVersion *string `json:"minOCPVersion,omitempty"`

	// The addon name such as 'istio'.
	Name *string `json:"name" validate:"required"`

	// The addon options. Should be a yaml for a kube resource.
	Options []string `json:"options,omitempty"`

	// The supported kubernetes version range for this addon.
	SupportedKubeRange *string `json:"supportedKubeRange,omitempty"`

	// The supported Openshift version range for this addon.
	SupportedOCPRange *string `json:"supportedOCPRange,omitempty"`

	// The addon target version.
	TargetVersion *string `json:"targetVersion,omitempty"`

	// The addon version, omit the version if you wish to use the default version.
	Version *string `json:"version,omitempty"`

	// VLAN spanning required for multi-zone clusters.
	VlanSpanningRequired *bool `json:"vlan_spanning_required,omitempty"`
}

// NewClusterAddon : Instantiate ClusterAddon (Generic Model Constructor)
func (*KubernetesServiceApiV1) NewClusterAddon(name string) (model *ClusterAddon, err error) {
	model = &ClusterAddon{
		Name: core.StringPtr(name),
	}
	err = core.ValidateStruct(model, "required parameters")
	return
}

// UnmarshalClusterAddon unmarshals an instance of ClusterAddon from the specified map of raw messages.
func UnmarshalClusterAddon(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterAddon)
	err = core.UnmarshalPrimitive(m, "allowed_upgrade_versions", &obj.AllowedUpgradeVersions)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deprecated", &obj.Deprecated)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "healthState", &obj.HealthState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "healthStatus", &obj.HealthStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "install_options_template", &obj.InstallOptionsTemplate, UnmarshalAddonOptionsTemplate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minKubeVersion", &obj.MinKubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minOCPVersion", &obj.MinOCPVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "options", &obj.Options)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supportedKubeRange", &obj.SupportedKubeRange)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supportedOCPRange", &obj.SupportedOCPRange)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVersion", &obj.TargetVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan_spanning_required", &obj.VlanSpanningRequired)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterCreateResponse : ClusterCreateResponse is returned during a successful create cluster command.
type ClusterCreateResponse struct {
	ID *string `json:"id,omitempty"`

	// ResponseErrors are used to communicate to non-critical errors to end users.
	NonCriticalErrors *ResponseErrors `json:"non_critical_errors,omitempty"`
}

// UnmarshalClusterCreateResponse unmarshals an instance of ClusterCreateResponse from the specified map of raw messages.
func UnmarshalClusterCreateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterCreateResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "non_critical_errors", &obj.NonCriticalErrors, UnmarshalResponseErrors)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterKeyOwnerInfo : ClusterKeyOwnerInfo stores the token owner's information.
type ClusterKeyOwnerInfo struct {
	Email *string `json:"email,omitempty"`

	ID *string `json:"id,omitempty"`

	Name *string `json:"name,omitempty"`
}

// UnmarshalClusterKeyOwnerInfo unmarshals an instance of ClusterKeyOwnerInfo from the specified map of raw messages.
func UnmarshalClusterKeyOwnerInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterKeyOwnerInfo)
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterNlbHostsList : ClusterNlbHostsList used for storing Nlbs, NlbMonitor, NlbHealthCheckStatus.
type ClusterNlbHostsList struct {
	Clusterid *string `json:"clusterid,omitempty"`

	NlbHealthCheckConfigs []NlbHealthCheckConfig `json:"nlbHealthCheckConfigs,omitempty"`

	NlbHealthCheckStatus []NlbHealthCheckStatus `json:"nlbHealthCheckStatus,omitempty"`

	Nlbs []NlbConfig `json:"nlbs,omitempty"`
}

// UnmarshalClusterNlbHostsList unmarshals an instance of ClusterNlbHostsList from the specified map of raw messages.
func UnmarshalClusterNlbHostsList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterNlbHostsList)
	err = core.UnmarshalPrimitive(m, "clusterid", &obj.Clusterid)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "nlbHealthCheckConfigs", &obj.NlbHealthCheckConfigs, UnmarshalNlbHealthCheckConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "nlbHealthCheckStatus", &obj.NlbHealthCheckStatus, UnmarshalNlbHealthCheckStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "nlbs", &obj.Nlbs, UnmarshalNlbConfig)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClusterWebhook : ClusterWebhook webhook info.
type ClusterWebhook struct {
	// The notification level that you want to use for the webhook.
	Level *string `json:"level,omitempty"`

	// The webhook service type.
	Type *string `json:"type,omitempty"`

	// The webhook URL.
	URL *string `json:"url,omitempty"`
}

// UnmarshalClusterWebhook unmarshals an instance of ClusterWebhook from the specified map of raw messages.
func UnmarshalClusterWebhook(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClusterWebhook)
	err = core.UnmarshalPrimitive(m, "level", &obj.Level)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonClusterAddon : CommonClusterAddon properties.
type CommonClusterAddon struct {
	Name *string `json:"name,omitempty"`

	Version *string `json:"version,omitempty"`
}

// UnmarshalCommonClusterAddon unmarshals an instance of CommonClusterAddon from the specified map of raw messages.
func UnmarshalCommonClusterAddon(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonClusterAddon)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonClusterCACertRotation : CommonClusterCACertRotation CA cert rotation properties.
type CommonClusterCACertRotation struct {
	ActionCompletedDate *string `json:"actionCompletedDate,omitempty"`

	ActionTriggerDate *string `json:"actionTriggerDate,omitempty"`

	Status *string `json:"status,omitempty"`
}

// UnmarshalCommonClusterCACertRotation unmarshals an instance of CommonClusterCACertRotation from the specified map of raw messages.
func UnmarshalCommonClusterCACertRotation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonClusterCACertRotation)
	err = core.UnmarshalPrimitive(m, "actionCompletedDate", &obj.ActionCompletedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "actionTriggerDate", &obj.ActionTriggerDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonClusterFeatures : CommonClusterFeatures struct
type CommonClusterFeatures struct {
	KeyProtectEnabled *bool `json:"keyProtectEnabled,omitempty"`

	PullSecretApplied *bool `json:"pullSecretApplied,omitempty"`
}

// UnmarshalCommonClusterFeatures unmarshals an instance of CommonClusterFeatures from the specified map of raw messages.
func UnmarshalCommonClusterFeatures(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonClusterFeatures)
	err = core.UnmarshalPrimitive(m, "keyProtectEnabled", &obj.KeyProtectEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pullSecretApplied", &obj.PullSecretApplied)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonClusterIngress : CommonClusterIngress struct
type CommonClusterIngress struct {
	Hostname *string `json:"hostname,omitempty"`

	Message *string `json:"message,omitempty"`

	SecretName *string `json:"secretName,omitempty"`

	Status *string `json:"status,omitempty"`
}

// UnmarshalCommonClusterIngress unmarshals an instance of CommonClusterIngress from the specified map of raw messages.
func UnmarshalCommonClusterIngress(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonClusterIngress)
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secretName", &obj.SecretName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonClusterLifecycle : CommonClusterLifecycle struct
type CommonClusterLifecycle struct {
	// The health of the cluster master. Possible values include error, normal, unavailable, and unsupported. For more
	// information, see the docs 'http://ibm.biz/cluster-master-health'.
	MasterHealth *string `json:"masterHealth,omitempty"`

	// The lifecycle state of the cluster master. Possible values include deployed, deploying, deploy_failed, deleting,
	// delete_failed, updating, update_cancelled, and update_failed. For more information, see the docs
	// 'http://ibm.biz/cluster-master-health'.
	MasterState *string `json:"masterState,omitempty"`

	MasterStatus *string `json:"masterStatus,omitempty"`

	MasterStatusModifiedDate *string `json:"masterStatusModifiedDate,omitempty"`

	ModifiedDate *string `json:"modifiedDate,omitempty"`
}

// UnmarshalCommonClusterLifecycle unmarshals an instance of CommonClusterLifecycle from the specified map of raw messages.
func UnmarshalCommonClusterLifecycle(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonClusterLifecycle)
	err = core.UnmarshalPrimitive(m, "masterHealth", &obj.MasterHealth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterState", &obj.MasterState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterStatus", &obj.MasterStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterStatusModifiedDate", &obj.MasterStatusModifiedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "modifiedDate", &obj.ModifiedDate)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CommonClusterServiceEndpoint : CommonClusterServiceEndpoint struct
type CommonClusterServiceEndpoint struct {
	PrivateServiceEndpointEnabled *bool `json:"privateServiceEndpointEnabled,omitempty"`

	PrivateServiceEndpointURL *string `json:"privateServiceEndpointURL,omitempty"`

	PublicServiceEndpointEnabled *bool `json:"publicServiceEndpointEnabled,omitempty"`

	PublicServiceEndpointURL *string `json:"publicServiceEndpointURL,omitempty"`
}

// UnmarshalCommonClusterServiceEndpoint unmarshals an instance of CommonClusterServiceEndpoint from the specified map of raw messages.
func UnmarshalCommonClusterServiceEndpoint(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CommonClusterServiceEndpoint)
	err = core.UnmarshalPrimitive(m, "privateServiceEndpointEnabled", &obj.PrivateServiceEndpointEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateServiceEndpointURL", &obj.PrivateServiceEndpointURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicServiceEndpointEnabled", &obj.PublicServiceEndpointEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicServiceEndpointURL", &obj.PublicServiceEndpointURL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ComponentStatus : ComponentStatus status of individual ingress component.
type ComponentStatus struct {
	Component *string `json:"component,omitempty"`

	Status *string `json:"status,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalComponentStatus unmarshals an instance of ComponentStatus from the specified map of raw messages.
func UnmarshalComponentStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ComponentStatus)
	err = core.UnmarshalPrimitive(m, "component", &obj.Component)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConfigMapKeySelector : ConfigMapKeySelector struct
type ConfigMapKeySelector struct {
	// The key to select.
	Key *string `json:"key,omitempty"`

	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// +optional.
	Name *string `json:"name,omitempty"`

	// Specify whether the ConfigMap or it's key must be defined
	// +optional.
	Optional *bool `json:"optional,omitempty"`
}

// UnmarshalConfigMapKeySelector unmarshals an instance of ConfigMapKeySelector from the specified map of raw messages.
func UnmarshalConfigMapKeySelector(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConfigMapKeySelector)
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "optional", &obj.Optional)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConfigResponse : ConfigResponse struct
type ConfigResponse struct {
	DaemonsetName *string `json:"daemonsetName,omitempty"`

	IngestionKey *string `json:"ingestionKey,omitempty"`

	InstanceID *string `json:"instanceId,omitempty"`

	InstanceName *string `json:"instanceName,omitempty"`

	PrivateEndpoint *bool `json:"privateEndpoint,omitempty"`
}

// UnmarshalConfigResponse unmarshals an instance of ConfigResponse from the specified map of raw messages.
func UnmarshalConfigResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConfigResponse)
	err = core.UnmarshalPrimitive(m, "daemonsetName", &obj.DaemonsetName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ingestionKey", &obj.IngestionKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instanceId", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instanceName", &obj.InstanceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateEndpoint", &obj.PrivateEndpoint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateALBOptions : The CreateALB options.
type CreateALBOptions struct {
	// The name or ID of the cluster that you want to see ALB information for. To list the clusters that you have access
	// to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The zone in which you want to create an ALB. To see the zones where you can create an ALB, run `ibmcloud ks
	// cluster-get --cluster <cluster_name_or_ID>` and look for the `Worker Zones` field in the output.
	ZoneID *string `validate:"required,ne="`

	// If set to true, the ALB is enabled by default. \.
	EnableByDefault *bool

	// The type of Ingress image that you want to use for your ALB deployment.
	IngressImage *string

	// Optional: The IP address that you want to assign to the ALB.
	Ip *string

	// The version of the network load balancer that you want to use for the ALB.
	NlbVersion *string

	// The type of ALB that you want to create.
	Type *string

	// The VLAN ID that you want to use for your ALBs.
	VlanID *string

	// The zone where you want to deploy the ALB.
	Zone *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateALBOptions : Instantiate CreateALBOptions
func (*KubernetesServiceApiV1) NewCreateALBOptions(idOrName string, zoneID string) *CreateALBOptions {
	return &CreateALBOptions{
		IdOrName: core.StringPtr(idOrName),
		ZoneID:   core.StringPtr(zoneID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *CreateALBOptions) SetIdOrName(idOrName string) *CreateALBOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetZoneID : Allow user to set ZoneID
func (options *CreateALBOptions) SetZoneID(zoneID string) *CreateALBOptions {
	options.ZoneID = core.StringPtr(zoneID)
	return options
}

// SetEnableByDefault : Allow user to set EnableByDefault
func (options *CreateALBOptions) SetEnableByDefault(enableByDefault bool) *CreateALBOptions {
	options.EnableByDefault = core.BoolPtr(enableByDefault)
	return options
}

// SetIngressImage : Allow user to set IngressImage
func (options *CreateALBOptions) SetIngressImage(ingressImage string) *CreateALBOptions {
	options.IngressImage = core.StringPtr(ingressImage)
	return options
}

// SetIp : Allow user to set Ip
func (options *CreateALBOptions) SetIp(ip string) *CreateALBOptions {
	options.Ip = core.StringPtr(ip)
	return options
}

// SetNlbVersion : Allow user to set NlbVersion
func (options *CreateALBOptions) SetNlbVersion(nlbVersion string) *CreateALBOptions {
	options.NlbVersion = core.StringPtr(nlbVersion)
	return options
}

// SetType : Allow user to set Type
func (options *CreateALBOptions) SetType(typeVar string) *CreateALBOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetVlanID : Allow user to set VlanID
func (options *CreateALBOptions) SetVlanID(vlanID string) *CreateALBOptions {
	options.VlanID = core.StringPtr(vlanID)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateALBOptions) SetZone(zone string) *CreateALBOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *CreateALBOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *CreateALBOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateALBOptions) SetHeaders(param map[string]string) *CreateALBOptions {
	options.Headers = param
	return options
}

// CreateALBSecretOptions : The CreateALBSecret options.
type CreateALBSecretOptions struct {
	// The CRN of the Certificate Manager instance where the TLS certificate is downloaded from.
	CertCrn *string

	// The Certificate Manager instance ID where the TLS certificate is downloaded from.
	CloudCertInstanceID *string

	// The CRN of the cluster where the ALB secret was created.
	ClusterCrn *string

	// The ID of the cluster where the ALB secret was created.
	ClusterID *string

	// The domain name of the TLS certficate that the ALB uses.
	DomainName *string

	// The expiration date of the certficate.
	ExpiresOn *string

	// The name of the issuer of the certficate.
	IssuerName *string

	// The name of the ALB secret.
	SecretName *string

	// The state of ALB secret.
	State *string

	// The status of ALB secret.
	Status *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateALBSecretOptions : Instantiate CreateALBSecretOptions
func (*KubernetesServiceApiV1) NewCreateALBSecretOptions() *CreateALBSecretOptions {
	return &CreateALBSecretOptions{}
}

// SetCertCrn : Allow user to set CertCrn
func (options *CreateALBSecretOptions) SetCertCrn(certCrn string) *CreateALBSecretOptions {
	options.CertCrn = core.StringPtr(certCrn)
	return options
}

// SetCloudCertInstanceID : Allow user to set CloudCertInstanceID
func (options *CreateALBSecretOptions) SetCloudCertInstanceID(cloudCertInstanceID string) *CreateALBSecretOptions {
	options.CloudCertInstanceID = core.StringPtr(cloudCertInstanceID)
	return options
}

// SetClusterCrn : Allow user to set ClusterCrn
func (options *CreateALBSecretOptions) SetClusterCrn(clusterCrn string) *CreateALBSecretOptions {
	options.ClusterCrn = core.StringPtr(clusterCrn)
	return options
}

// SetClusterID : Allow user to set ClusterID
func (options *CreateALBSecretOptions) SetClusterID(clusterID string) *CreateALBSecretOptions {
	options.ClusterID = core.StringPtr(clusterID)
	return options
}

// SetDomainName : Allow user to set DomainName
func (options *CreateALBSecretOptions) SetDomainName(domainName string) *CreateALBSecretOptions {
	options.DomainName = core.StringPtr(domainName)
	return options
}

// SetExpiresOn : Allow user to set ExpiresOn
func (options *CreateALBSecretOptions) SetExpiresOn(expiresOn string) *CreateALBSecretOptions {
	options.ExpiresOn = core.StringPtr(expiresOn)
	return options
}

// SetIssuerName : Allow user to set IssuerName
func (options *CreateALBSecretOptions) SetIssuerName(issuerName string) *CreateALBSecretOptions {
	options.IssuerName = core.StringPtr(issuerName)
	return options
}

// SetSecretName : Allow user to set SecretName
func (options *CreateALBSecretOptions) SetSecretName(secretName string) *CreateALBSecretOptions {
	options.SecretName = core.StringPtr(secretName)
	return options
}

// SetState : Allow user to set State
func (options *CreateALBSecretOptions) SetState(state string) *CreateALBSecretOptions {
	options.State = core.StringPtr(state)
	return options
}

// SetStatus : Allow user to set Status
func (options *CreateALBSecretOptions) SetStatus(status string) *CreateALBSecretOptions {
	options.Status = core.StringPtr(status)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateALBSecretOptions) SetHeaders(param map[string]string) *CreateALBSecretOptions {
	options.Headers = param
	return options
}

// CreateAssignmentOptions : The CreateAssignment options.
type CreateAssignmentOptions struct {
	ChannelName *string

	Groups []string

	Name *string

	Version *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateAssignmentOptions : Instantiate CreateAssignmentOptions
func (*KubernetesServiceApiV1) NewCreateAssignmentOptions() *CreateAssignmentOptions {
	return &CreateAssignmentOptions{}
}

// SetChannelName : Allow user to set ChannelName
func (options *CreateAssignmentOptions) SetChannelName(channelName string) *CreateAssignmentOptions {
	options.ChannelName = core.StringPtr(channelName)
	return options
}

// SetGroups : Allow user to set Groups
func (options *CreateAssignmentOptions) SetGroups(groups []string) *CreateAssignmentOptions {
	options.Groups = groups
	return options
}

// SetName : Allow user to set Name
func (options *CreateAssignmentOptions) SetName(name string) *CreateAssignmentOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetVersion : Allow user to set Version
func (options *CreateAssignmentOptions) SetVersion(version string) *CreateAssignmentOptions {
	options.Version = core.StringPtr(version)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateAssignmentOptions) SetHeaders(param map[string]string) *CreateAssignmentOptions {
	options.Headers = param
	return options
}

// CreateAttachmentOptions : The CreateAttachment options.
type CreateAttachmentOptions struct {
	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster-get <cluster>`.
	XAuthResourceGroupID *string `validate:"required"`

	Cluster *string

	VolumeAttachmentID *string

	VolumeID *string

	Worker *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateAttachmentOptions : Instantiate CreateAttachmentOptions
func (*KubernetesServiceApiV1) NewCreateAttachmentOptions(xAuthResourceGroupID string) *CreateAttachmentOptions {
	return &CreateAttachmentOptions{
		XAuthResourceGroupID: core.StringPtr(xAuthResourceGroupID),
	}
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *CreateAttachmentOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *CreateAttachmentOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *CreateAttachmentOptions) SetCluster(cluster string) *CreateAttachmentOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetVolumeAttachmentID : Allow user to set VolumeAttachmentID
func (options *CreateAttachmentOptions) SetVolumeAttachmentID(volumeAttachmentID string) *CreateAttachmentOptions {
	options.VolumeAttachmentID = core.StringPtr(volumeAttachmentID)
	return options
}

// SetVolumeID : Allow user to set VolumeID
func (options *CreateAttachmentOptions) SetVolumeID(volumeID string) *CreateAttachmentOptions {
	options.VolumeID = core.StringPtr(volumeID)
	return options
}

// SetWorker : Allow user to set Worker
func (options *CreateAttachmentOptions) SetWorker(worker string) *CreateAttachmentOptions {
	options.Worker = core.StringPtr(worker)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateAttachmentOptions) SetHeaders(param map[string]string) *CreateAttachmentOptions {
	options.Headers = param
	return options
}

// CreateClusterOptions : The CreateCluster options.
type CreateClusterOptions struct {
	// The resource group that you want to create the cluster in. To list available resource groups, run `ibmcloud resource
	// groups`. If you don't include this header, the cluster is created in the default resource group. After you create a
	// cluster, you cannot change the resource group. Note that if you plan to integrate IBM Cloud services with the
	// cluster, all the resources must be in the same group.
	XAuthResourceGroup *string `validate:"required"`

	CseAclEnabled *bool

	// The data center where the worker node is created.
	DataCenter *string

	DefaultWorkerPoolEntitlement *string

	DefaultWorkerPoolName *string

	DisableAutoUpdate *bool

	DiskEncryption *bool

	GatewayEnabled *bool

	Isolation *string

	// The machine type of the worker node.
	MachineType *string

	MasterVersion *string

	Name *string

	NoSubnet *bool

	PodSubnet *string

	Prefix *string

	PrivateSeviceEndpoint *bool

	// The private VLAN ID that the worker node is attached to.
	PrivateVlan *string

	PublicServiceEndpoint *bool

	// The public VLAN ID that the worker node is attached to.
	PublicVlan *string

	ServiceSubnet *string

	SkipPermPrecheck *bool

	WorkerNum *int64

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateClusterOptions : Instantiate CreateClusterOptions
func (*KubernetesServiceApiV1) NewCreateClusterOptions(xAuthResourceGroup string) *CreateClusterOptions {
	return &CreateClusterOptions{
		XAuthResourceGroup: core.StringPtr(xAuthResourceGroup),
	}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *CreateClusterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *CreateClusterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetCseAclEnabled : Allow user to set CseAclEnabled
func (options *CreateClusterOptions) SetCseAclEnabled(cseAclEnabled bool) *CreateClusterOptions {
	options.CseAclEnabled = core.BoolPtr(cseAclEnabled)
	return options
}

// SetDataCenter : Allow user to set DataCenter
func (options *CreateClusterOptions) SetDataCenter(dataCenter string) *CreateClusterOptions {
	options.DataCenter = core.StringPtr(dataCenter)
	return options
}

// SetDefaultWorkerPoolEntitlement : Allow user to set DefaultWorkerPoolEntitlement
func (options *CreateClusterOptions) SetDefaultWorkerPoolEntitlement(defaultWorkerPoolEntitlement string) *CreateClusterOptions {
	options.DefaultWorkerPoolEntitlement = core.StringPtr(defaultWorkerPoolEntitlement)
	return options
}

// SetDefaultWorkerPoolName : Allow user to set DefaultWorkerPoolName
func (options *CreateClusterOptions) SetDefaultWorkerPoolName(defaultWorkerPoolName string) *CreateClusterOptions {
	options.DefaultWorkerPoolName = core.StringPtr(defaultWorkerPoolName)
	return options
}

// SetDisableAutoUpdate : Allow user to set DisableAutoUpdate
func (options *CreateClusterOptions) SetDisableAutoUpdate(disableAutoUpdate bool) *CreateClusterOptions {
	options.DisableAutoUpdate = core.BoolPtr(disableAutoUpdate)
	return options
}

// SetDiskEncryption : Allow user to set DiskEncryption
func (options *CreateClusterOptions) SetDiskEncryption(diskEncryption bool) *CreateClusterOptions {
	options.DiskEncryption = core.BoolPtr(diskEncryption)
	return options
}

// SetGatewayEnabled : Allow user to set GatewayEnabled
func (options *CreateClusterOptions) SetGatewayEnabled(gatewayEnabled bool) *CreateClusterOptions {
	options.GatewayEnabled = core.BoolPtr(gatewayEnabled)
	return options
}

// SetIsolation : Allow user to set Isolation
func (options *CreateClusterOptions) SetIsolation(isolation string) *CreateClusterOptions {
	options.Isolation = core.StringPtr(isolation)
	return options
}

// SetMachineType : Allow user to set MachineType
func (options *CreateClusterOptions) SetMachineType(machineType string) *CreateClusterOptions {
	options.MachineType = core.StringPtr(machineType)
	return options
}

// SetMasterVersion : Allow user to set MasterVersion
func (options *CreateClusterOptions) SetMasterVersion(masterVersion string) *CreateClusterOptions {
	options.MasterVersion = core.StringPtr(masterVersion)
	return options
}

// SetName : Allow user to set Name
func (options *CreateClusterOptions) SetName(name string) *CreateClusterOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNoSubnet : Allow user to set NoSubnet
func (options *CreateClusterOptions) SetNoSubnet(noSubnet bool) *CreateClusterOptions {
	options.NoSubnet = core.BoolPtr(noSubnet)
	return options
}

// SetPodSubnet : Allow user to set PodSubnet
func (options *CreateClusterOptions) SetPodSubnet(podSubnet string) *CreateClusterOptions {
	options.PodSubnet = core.StringPtr(podSubnet)
	return options
}

// SetPrefix : Allow user to set Prefix
func (options *CreateClusterOptions) SetPrefix(prefix string) *CreateClusterOptions {
	options.Prefix = core.StringPtr(prefix)
	return options
}

// SetPrivateSeviceEndpoint : Allow user to set PrivateSeviceEndpoint
func (options *CreateClusterOptions) SetPrivateSeviceEndpoint(privateSeviceEndpoint bool) *CreateClusterOptions {
	options.PrivateSeviceEndpoint = core.BoolPtr(privateSeviceEndpoint)
	return options
}

// SetPrivateVlan : Allow user to set PrivateVlan
func (options *CreateClusterOptions) SetPrivateVlan(privateVlan string) *CreateClusterOptions {
	options.PrivateVlan = core.StringPtr(privateVlan)
	return options
}

// SetPublicServiceEndpoint : Allow user to set PublicServiceEndpoint
func (options *CreateClusterOptions) SetPublicServiceEndpoint(publicServiceEndpoint bool) *CreateClusterOptions {
	options.PublicServiceEndpoint = core.BoolPtr(publicServiceEndpoint)
	return options
}

// SetPublicVlan : Allow user to set PublicVlan
func (options *CreateClusterOptions) SetPublicVlan(publicVlan string) *CreateClusterOptions {
	options.PublicVlan = core.StringPtr(publicVlan)
	return options
}

// SetServiceSubnet : Allow user to set ServiceSubnet
func (options *CreateClusterOptions) SetServiceSubnet(serviceSubnet string) *CreateClusterOptions {
	options.ServiceSubnet = core.StringPtr(serviceSubnet)
	return options
}

// SetSkipPermPrecheck : Allow user to set SkipPermPrecheck
func (options *CreateClusterOptions) SetSkipPermPrecheck(skipPermPrecheck bool) *CreateClusterOptions {
	options.SkipPermPrecheck = core.BoolPtr(skipPermPrecheck)
	return options
}

// SetWorkerNum : Allow user to set WorkerNum
func (options *CreateClusterOptions) SetWorkerNum(workerNum int64) *CreateClusterOptions {
	options.WorkerNum = core.Int64Ptr(workerNum)
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *CreateClusterOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *CreateClusterOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateClusterOptions) SetHeaders(param map[string]string) *CreateClusterOptions {
	options.Headers = param
	return options
}

// CreateClusterResponse : CreateClusterResponse struct
type CreateClusterResponse struct {
	ClusterID *string `json:"clusterID,omitempty"`

	Messages []UserMessage `json:"messages,omitempty"`

	// ResponseErrors are used to communicate to non-critical errors to end users.
	NonCriticalErrors *ResponseErrors `json:"non_critical_errors,omitempty"`
}

// UnmarshalCreateClusterResponse unmarshals an instance of CreateClusterResponse from the specified map of raw messages.
func UnmarshalCreateClusterResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateClusterResponse)
	err = core.UnmarshalPrimitive(m, "clusterID", &obj.ClusterID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "messages", &obj.Messages, UnmarshalUserMessage)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "non_critical_errors", &obj.NonCriticalErrors, UnmarshalResponseErrors)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateClusterSubnetOptions : The CreateClusterSubnet options.
type CreateClusterSubnetOptions struct {
	// The name or ID of the cluster for which you want to make an existing subnet from your IBM Cloud infrastructure
	// account available. To list the clusters that you have access to, use the `GET /v1/clusters` API or run `ibmcloud ks
	// cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The VLAN in which to create the subnet. To list available VLANs, use the `GET /v1/datacenters/{datacenter}/vlans`
	// API or run `ibmcloud ks vlan ls <zone>`.
	VlanID *string `validate:"required,ne="`

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// The number of subnet IP addresses. The default value is 8. Accepted values are 8, 16, 32, 64.
	Size *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateClusterSubnetOptions : Instantiate CreateClusterSubnetOptions
func (*KubernetesServiceApiV1) NewCreateClusterSubnetOptions(idOrName string, vlanID string) *CreateClusterSubnetOptions {
	return &CreateClusterSubnetOptions{
		IdOrName: core.StringPtr(idOrName),
		VlanID:   core.StringPtr(vlanID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *CreateClusterSubnetOptions) SetIdOrName(idOrName string) *CreateClusterSubnetOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetVlanID : Allow user to set VlanID
func (options *CreateClusterSubnetOptions) SetVlanID(vlanID string) *CreateClusterSubnetOptions {
	options.VlanID = core.StringPtr(vlanID)
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *CreateClusterSubnetOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *CreateClusterSubnetOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetSize : Allow user to set Size
func (options *CreateClusterSubnetOptions) SetSize(size string) *CreateClusterSubnetOptions {
	options.Size = core.StringPtr(size)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *CreateClusterSubnetOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *CreateClusterSubnetOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateClusterSubnetOptions) SetHeaders(param map[string]string) *CreateClusterSubnetOptions {
	options.Headers = param
	return options
}

// CreateConfigurationData : CreateConfigurationData - a single return struct.
type CreateConfigurationData struct {
	AddChannel *CreateConfigurationDataAddChannel `json:"addChannel,omitempty"`
}

// UnmarshalCreateConfigurationData unmarshals an instance of CreateConfigurationData from the specified map of raw messages.
func UnmarshalCreateConfigurationData(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateConfigurationData)
	err = core.UnmarshalModel(m, "addChannel", &obj.AddChannel, UnmarshalCreateConfigurationDataAddChannel)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateConfigurationDataAddChannel : CreateConfigurationDataAddChannel struct
type CreateConfigurationDataAddChannel struct {
	UUID *string `json:"uuid,omitempty"`
}

// UnmarshalCreateConfigurationDataAddChannel unmarshals an instance of CreateConfigurationDataAddChannel from the specified map of raw messages.
func UnmarshalCreateConfigurationDataAddChannel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateConfigurationDataAddChannel)
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateFilterConfigOptions : The CreateFilterConfig options.
type CreateFilterConfigOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The name of the container where you want to apply the logging filter.
	Container *string

	// The log level that you want to apply to your logging filter.
	LogLevel *string

	// A list of logging configuration IDs where you want to apply the logging filter.
	LoggingConfigs []string

	// A string in a message to which you want to apply the logging filter.
	Message *string

	// The Kubernetes namespace where you want to apply the logging filter.
	Namespace *string

	// Set this value to `true` if you want the message field to be interpreted as a regular expression.
	RegexMessageEnabled *bool

	// The type of the logging filter.
	Type *string

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateFilterConfigOptions : Instantiate CreateFilterConfigOptions
func (*KubernetesServiceApiV1) NewCreateFilterConfigOptions(idOrName string) *CreateFilterConfigOptions {
	return &CreateFilterConfigOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *CreateFilterConfigOptions) SetIdOrName(idOrName string) *CreateFilterConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetContainer : Allow user to set Container
func (options *CreateFilterConfigOptions) SetContainer(container string) *CreateFilterConfigOptions {
	options.Container = core.StringPtr(container)
	return options
}

// SetLogLevel : Allow user to set LogLevel
func (options *CreateFilterConfigOptions) SetLogLevel(logLevel string) *CreateFilterConfigOptions {
	options.LogLevel = core.StringPtr(logLevel)
	return options
}

// SetLoggingConfigs : Allow user to set LoggingConfigs
func (options *CreateFilterConfigOptions) SetLoggingConfigs(loggingConfigs []string) *CreateFilterConfigOptions {
	options.LoggingConfigs = loggingConfigs
	return options
}

// SetMessage : Allow user to set Message
func (options *CreateFilterConfigOptions) SetMessage(message string) *CreateFilterConfigOptions {
	options.Message = core.StringPtr(message)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *CreateFilterConfigOptions) SetNamespace(namespace string) *CreateFilterConfigOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetRegexMessageEnabled : Allow user to set RegexMessageEnabled
func (options *CreateFilterConfigOptions) SetRegexMessageEnabled(regexMessageEnabled bool) *CreateFilterConfigOptions {
	options.RegexMessageEnabled = core.BoolPtr(regexMessageEnabled)
	return options
}

// SetType : Allow user to set Type
func (options *CreateFilterConfigOptions) SetType(typeVar string) *CreateFilterConfigOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *CreateFilterConfigOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *CreateFilterConfigOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *CreateFilterConfigOptions) SetForceUpdate(forceUpdate bool) *CreateFilterConfigOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateFilterConfigOptions) SetHeaders(param map[string]string) *CreateFilterConfigOptions {
	options.Headers = param
	return options
}

// CreateKMSConfigOptions : The CreateKMSConfig options.
type CreateKMSConfigOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// CRK is a Key Protect customer root key. To get the CRK, see http://ibm.biz/kp-viewcrk.
	CrkID *string `validate:"required"`

	// InstanceID is a Key Protect instance ID. To get the instance ID, run 'ibmcloud resource service-instance
	// <kp_service> --id' and copy the second value (not the full CRN).
	InstanceID *string `validate:"required"`

	// URL is a Key Protect endpoint. To get the endpoint, see http://ibm.biz/kp-endpoints.
	URL *string `validate:"required"`

	// ServiceToService indicates the KP information in this record was enabled via service-to-service integration, so an
	// associated registration was created.
	ServiceToService *bool

	// The resource group that the cluster is in. To check the resource group of the cluster, use the `GET
	// /v1/clusters/{idOrName}` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateKMSConfigOptions : Instantiate CreateKMSConfigOptions
func (*KubernetesServiceApiV1) NewCreateKMSConfigOptions(idOrName string, crkID string, instanceID string, url string) *CreateKMSConfigOptions {
	return &CreateKMSConfigOptions{
		IdOrName:   core.StringPtr(idOrName),
		CrkID:      core.StringPtr(crkID),
		InstanceID: core.StringPtr(instanceID),
		URL:        core.StringPtr(url),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *CreateKMSConfigOptions) SetIdOrName(idOrName string) *CreateKMSConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetCrkID : Allow user to set CrkID
func (options *CreateKMSConfigOptions) SetCrkID(crkID string) *CreateKMSConfigOptions {
	options.CrkID = core.StringPtr(crkID)
	return options
}

// SetInstanceID : Allow user to set InstanceID
func (options *CreateKMSConfigOptions) SetInstanceID(instanceID string) *CreateKMSConfigOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetURL : Allow user to set URL
func (options *CreateKMSConfigOptions) SetURL(url string) *CreateKMSConfigOptions {
	options.URL = core.StringPtr(url)
	return options
}

// SetServiceToService : Allow user to set ServiceToService
func (options *CreateKMSConfigOptions) SetServiceToService(serviceToService bool) *CreateKMSConfigOptions {
	options.ServiceToService = core.BoolPtr(serviceToService)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *CreateKMSConfigOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *CreateKMSConfigOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateKMSConfigOptions) SetHeaders(param map[string]string) *CreateKMSConfigOptions {
	options.Headers = param
	return options
}

// CreateLoggingConfigOptions : The CreateLoggingConfig options.
type CreateLoggingConfigOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The log source from which you want to forward logs. Accepted values are `container`, `worker`, `kubernetes`,
	// `ingress`, and `application`. If you do not provide a namespace for log source `container`, then all namespaces use
	// this configuration.
	LogSource *string `validate:"required,ne="`

	// A list of container names that you want to collect logs for.
	AppLogContainers []string

	// A list of app paths that you want to collect logs for.
	AppLogPaths []string

	// The name of the Kubernetes secret that holds the Certificate Authority certificate that you want to use for the
	// syslog TLS termination.
	CaCert *string

	// The logging type that you want to use. Supported values are `syslog` and `ibm`.
	LoggingType *string

	// The Kubernetes namespace where the logging configuration is applied.
	Namespace *string

	// The name of the Cloud Foundry organization where the logging configuration is created.
	Org *string

	// The protocol that you want to use for syslog forwarding. Supported values are TCP, TLS and UDP. If no value is
	// provided, the protocol is set to UDP by default.
	Protocol *string

	// The port that the logging server uses. This value is required only when `LoggingType` is set to `syslog`.
	RemoteLogPort *int64

	// The hostname or IP address of the logging server. This values is required only if `LoggingType` is set to `syslog`.
	RemoteLogServer *string

	// The name of the Cloud Foundry space where the logging configuration is created.
	Space *string

	// The verification mode that you want to use for the syslog TLS protocol. By default, `verify-none` is used. Other
	// supported values include `verify-peer`, `verify-client-once`, and `verify-if-no-peer-cert`.
	VerifyMode *string

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Set to `true` to skip validation of the space and org Cloud Foundry properties. Skipping validation decreases
	// processing time, but an invalid logging configuration will not correctly forward logs.
	SkipValidation *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateLoggingConfigOptions : Instantiate CreateLoggingConfigOptions
func (*KubernetesServiceApiV1) NewCreateLoggingConfigOptions(idOrName string, logSource string) *CreateLoggingConfigOptions {
	return &CreateLoggingConfigOptions{
		IdOrName:  core.StringPtr(idOrName),
		LogSource: core.StringPtr(logSource),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *CreateLoggingConfigOptions) SetIdOrName(idOrName string) *CreateLoggingConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetLogSource : Allow user to set LogSource
func (options *CreateLoggingConfigOptions) SetLogSource(logSource string) *CreateLoggingConfigOptions {
	options.LogSource = core.StringPtr(logSource)
	return options
}

// SetAppLogContainers : Allow user to set AppLogContainers
func (options *CreateLoggingConfigOptions) SetAppLogContainers(appLogContainers []string) *CreateLoggingConfigOptions {
	options.AppLogContainers = appLogContainers
	return options
}

// SetAppLogPaths : Allow user to set AppLogPaths
func (options *CreateLoggingConfigOptions) SetAppLogPaths(appLogPaths []string) *CreateLoggingConfigOptions {
	options.AppLogPaths = appLogPaths
	return options
}

// SetCaCert : Allow user to set CaCert
func (options *CreateLoggingConfigOptions) SetCaCert(caCert string) *CreateLoggingConfigOptions {
	options.CaCert = core.StringPtr(caCert)
	return options
}

// SetLoggingType : Allow user to set LoggingType
func (options *CreateLoggingConfigOptions) SetLoggingType(loggingType string) *CreateLoggingConfigOptions {
	options.LoggingType = core.StringPtr(loggingType)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *CreateLoggingConfigOptions) SetNamespace(namespace string) *CreateLoggingConfigOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetOrg : Allow user to set Org
func (options *CreateLoggingConfigOptions) SetOrg(org string) *CreateLoggingConfigOptions {
	options.Org = core.StringPtr(org)
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *CreateLoggingConfigOptions) SetProtocol(protocol string) *CreateLoggingConfigOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetRemoteLogPort : Allow user to set RemoteLogPort
func (options *CreateLoggingConfigOptions) SetRemoteLogPort(remoteLogPort int64) *CreateLoggingConfigOptions {
	options.RemoteLogPort = core.Int64Ptr(remoteLogPort)
	return options
}

// SetRemoteLogServer : Allow user to set RemoteLogServer
func (options *CreateLoggingConfigOptions) SetRemoteLogServer(remoteLogServer string) *CreateLoggingConfigOptions {
	options.RemoteLogServer = core.StringPtr(remoteLogServer)
	return options
}

// SetSpace : Allow user to set Space
func (options *CreateLoggingConfigOptions) SetSpace(space string) *CreateLoggingConfigOptions {
	options.Space = core.StringPtr(space)
	return options
}

// SetVerifyMode : Allow user to set VerifyMode
func (options *CreateLoggingConfigOptions) SetVerifyMode(verifyMode string) *CreateLoggingConfigOptions {
	options.VerifyMode = core.StringPtr(verifyMode)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *CreateLoggingConfigOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *CreateLoggingConfigOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *CreateLoggingConfigOptions) SetForceUpdate(forceUpdate bool) *CreateLoggingConfigOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetSkipValidation : Allow user to set SkipValidation
func (options *CreateLoggingConfigOptions) SetSkipValidation(skipValidation bool) *CreateLoggingConfigOptions {
	options.SkipValidation = core.BoolPtr(skipValidation)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoggingConfigOptions) SetHeaders(param map[string]string) *CreateLoggingConfigOptions {
	options.Headers = param
	return options
}

// CreateLoggingInstanceOptions : The CreateLoggingInstance options.
type CreateLoggingInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. Required only in the absense of an IAM cookie and when the API is invoked through a CURL
	// command.
	XAuthRefreshToken *string `validate:"required"`

	Cluster *string

	IngestionKey *string

	Instance *string

	PrivateEndpoint *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateLoggingInstanceOptions : Instantiate CreateLoggingInstanceOptions
func (*KubernetesServiceApiV1) NewCreateLoggingInstanceOptions(xAuthRefreshToken string) *CreateLoggingInstanceOptions {
	return &CreateLoggingInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *CreateLoggingInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *CreateLoggingInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *CreateLoggingInstanceOptions) SetCluster(cluster string) *CreateLoggingInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetIngestionKey : Allow user to set IngestionKey
func (options *CreateLoggingInstanceOptions) SetIngestionKey(ingestionKey string) *CreateLoggingInstanceOptions {
	options.IngestionKey = core.StringPtr(ingestionKey)
	return options
}

// SetInstance : Allow user to set Instance
func (options *CreateLoggingInstanceOptions) SetInstance(instance string) *CreateLoggingInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetPrivateEndpoint : Allow user to set PrivateEndpoint
func (options *CreateLoggingInstanceOptions) SetPrivateEndpoint(privateEndpoint bool) *CreateLoggingInstanceOptions {
	options.PrivateEndpoint = core.BoolPtr(privateEndpoint)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateLoggingInstanceOptions) SetHeaders(param map[string]string) *CreateLoggingInstanceOptions {
	options.Headers = param
	return options
}

// CreateMasterLogCollectionOptions : The CreateMasterLogCollection options.
type CreateMasterLogCollectionOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the HMAC key that you want to use to authenticate with IBM Cloud Object Storage when master logs are
	// uploaded.
	Accesskeyid *string

	// The secret of the HMAC credentials that you want to use to authenticate with IBM Cloud Object Storage when master
	// logs are uploaded.
	Accesskeysecret *string

	// The IBM Cloud Object Storage bucket that you want to use to upload master logs.
	Bucket *string

	// The IBM Cloud Object Storage API endpoint that you want to use to send master logs to.
	Endpoint *string

	// The IBM Cloud resource group to which the cluster belongs.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateMasterLogCollectionOptions : Instantiate CreateMasterLogCollectionOptions
func (*KubernetesServiceApiV1) NewCreateMasterLogCollectionOptions(idOrName string) *CreateMasterLogCollectionOptions {
	return &CreateMasterLogCollectionOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *CreateMasterLogCollectionOptions) SetIdOrName(idOrName string) *CreateMasterLogCollectionOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAccesskeyid : Allow user to set Accesskeyid
func (options *CreateMasterLogCollectionOptions) SetAccesskeyid(accesskeyid string) *CreateMasterLogCollectionOptions {
	options.Accesskeyid = core.StringPtr(accesskeyid)
	return options
}

// SetAccesskeysecret : Allow user to set Accesskeysecret
func (options *CreateMasterLogCollectionOptions) SetAccesskeysecret(accesskeysecret string) *CreateMasterLogCollectionOptions {
	options.Accesskeysecret = core.StringPtr(accesskeysecret)
	return options
}

// SetBucket : Allow user to set Bucket
func (options *CreateMasterLogCollectionOptions) SetBucket(bucket string) *CreateMasterLogCollectionOptions {
	options.Bucket = core.StringPtr(bucket)
	return options
}

// SetEndpoint : Allow user to set Endpoint
func (options *CreateMasterLogCollectionOptions) SetEndpoint(endpoint string) *CreateMasterLogCollectionOptions {
	options.Endpoint = core.StringPtr(endpoint)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *CreateMasterLogCollectionOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *CreateMasterLogCollectionOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateMasterLogCollectionOptions) SetHeaders(param map[string]string) *CreateMasterLogCollectionOptions {
	options.Headers = param
	return options
}

// CreateMonitoringInstanceOptions : The CreateMonitoringInstance options.
type CreateMonitoringInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`.
	XAuthRefreshToken *string `validate:"required"`

	Cluster *string

	IngestionKey *string

	Instance *string

	PrivateEndpoint *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateMonitoringInstanceOptions : Instantiate CreateMonitoringInstanceOptions
func (*KubernetesServiceApiV1) NewCreateMonitoringInstanceOptions(xAuthRefreshToken string) *CreateMonitoringInstanceOptions {
	return &CreateMonitoringInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *CreateMonitoringInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *CreateMonitoringInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *CreateMonitoringInstanceOptions) SetCluster(cluster string) *CreateMonitoringInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetIngestionKey : Allow user to set IngestionKey
func (options *CreateMonitoringInstanceOptions) SetIngestionKey(ingestionKey string) *CreateMonitoringInstanceOptions {
	options.IngestionKey = core.StringPtr(ingestionKey)
	return options
}

// SetInstance : Allow user to set Instance
func (options *CreateMonitoringInstanceOptions) SetInstance(instance string) *CreateMonitoringInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetPrivateEndpoint : Allow user to set PrivateEndpoint
func (options *CreateMonitoringInstanceOptions) SetPrivateEndpoint(privateEndpoint bool) *CreateMonitoringInstanceOptions {
	options.PrivateEndpoint = core.BoolPtr(privateEndpoint)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateMonitoringInstanceOptions) SetHeaders(param map[string]string) *CreateMonitoringInstanceOptions {
	options.Headers = param
	return options
}

// CreateNlbDNSOptions : The CreateNlbDNS options.
type CreateNlbDNSOptions struct {
	Cluster *string

	LbHostname *string

	NlbSubdomain *string

	SecretNamespace *string

	Type *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateNlbDNSOptions : Instantiate CreateNlbDNSOptions
func (*KubernetesServiceApiV1) NewCreateNlbDNSOptions() *CreateNlbDNSOptions {
	return &CreateNlbDNSOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *CreateNlbDNSOptions) SetCluster(cluster string) *CreateNlbDNSOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetLbHostname : Allow user to set LbHostname
func (options *CreateNlbDNSOptions) SetLbHostname(lbHostname string) *CreateNlbDNSOptions {
	options.LbHostname = core.StringPtr(lbHostname)
	return options
}

// SetNlbSubdomain : Allow user to set NlbSubdomain
func (options *CreateNlbDNSOptions) SetNlbSubdomain(nlbSubdomain string) *CreateNlbDNSOptions {
	options.NlbSubdomain = core.StringPtr(nlbSubdomain)
	return options
}

// SetSecretNamespace : Allow user to set SecretNamespace
func (options *CreateNlbDNSOptions) SetSecretNamespace(secretNamespace string) *CreateNlbDNSOptions {
	options.SecretNamespace = core.StringPtr(secretNamespace)
	return options
}

// SetType : Allow user to set Type
func (options *CreateNlbDNSOptions) SetType(typeVar string) *CreateNlbDNSOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateNlbDNSOptions) SetHeaders(param map[string]string) *CreateNlbDNSOptions {
	options.Headers = param
	return options
}

// CreateSatelliteAssignmentOptions : The CreateSatelliteAssignment options.
type CreateSatelliteAssignmentOptions struct {
	// The name or ID of a Satellite location or cluster to assign the host to.
	Cluster *string

	// The name or ID of the Satellite location.
	Controller *string

	// Optional: The specific host ID to assign to a Satellite location or cluster.
	HostID *string

	// Key-value pairs to label the host, such as cpu=4 to describe the host capabilities.
	Labels map[string]string

	// Optional: The name or ID of the worker pool within the cluster to assign the host to.
	Workerpool *string

	// Optional: The zone within the cluster to assign the host to.
	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSatelliteAssignmentOptions : Instantiate CreateSatelliteAssignmentOptions
func (*KubernetesServiceApiV1) NewCreateSatelliteAssignmentOptions() *CreateSatelliteAssignmentOptions {
	return &CreateSatelliteAssignmentOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *CreateSatelliteAssignmentOptions) SetCluster(cluster string) *CreateSatelliteAssignmentOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetController : Allow user to set Controller
func (options *CreateSatelliteAssignmentOptions) SetController(controller string) *CreateSatelliteAssignmentOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetHostID : Allow user to set HostID
func (options *CreateSatelliteAssignmentOptions) SetHostID(hostID string) *CreateSatelliteAssignmentOptions {
	options.HostID = core.StringPtr(hostID)
	return options
}

// SetLabels : Allow user to set Labels
func (options *CreateSatelliteAssignmentOptions) SetLabels(labels map[string]string) *CreateSatelliteAssignmentOptions {
	options.Labels = labels
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *CreateSatelliteAssignmentOptions) SetWorkerpool(workerpool string) *CreateSatelliteAssignmentOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateSatelliteAssignmentOptions) SetZone(zone string) *CreateSatelliteAssignmentOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSatelliteAssignmentOptions) SetHeaders(param map[string]string) *CreateSatelliteAssignmentOptions {
	options.Headers = param
	return options
}

// CreateSatelliteClusterOptions : The CreateSatelliteCluster options.
type CreateSatelliteClusterOptions struct {
	// Optional: User provided value to indicate opt-in agreement to SatCon admin agent.
	AdminAgentOptIn *bool

	// The name or ID of the Satellite location.
	Controller *string

	// Optional: The OpenShift Container Platform version.
	KubeVersion *string

	// Key-value pairs to label the host, such as cpu=4 to describe the host capabilities.
	Labels map[string]string

	// The unique name for the new IBM Cloud Satellite cluster.
	Name *string

	// Optional: User provided value for the pod subnet.
	PodSubnet *string

	// Optional: The RedHat pull secret to create the OpenShift cluster.
	PullSecret *string

	// Optional: User provided value for service subnet.
	ServiceSubnet *string

	// Optional: The number of worker nodes to create per zone in the default worker pool.
	WorkerCount *int64

	// Optional: The name of the zone to create the default worker pool in.
	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSatelliteClusterOptions : Instantiate CreateSatelliteClusterOptions
func (*KubernetesServiceApiV1) NewCreateSatelliteClusterOptions() *CreateSatelliteClusterOptions {
	return &CreateSatelliteClusterOptions{}
}

// SetAdminAgentOptIn : Allow user to set AdminAgentOptIn
func (options *CreateSatelliteClusterOptions) SetAdminAgentOptIn(adminAgentOptIn bool) *CreateSatelliteClusterOptions {
	options.AdminAgentOptIn = core.BoolPtr(adminAgentOptIn)
	return options
}

// SetController : Allow user to set Controller
func (options *CreateSatelliteClusterOptions) SetController(controller string) *CreateSatelliteClusterOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetKubeVersion : Allow user to set KubeVersion
func (options *CreateSatelliteClusterOptions) SetKubeVersion(kubeVersion string) *CreateSatelliteClusterOptions {
	options.KubeVersion = core.StringPtr(kubeVersion)
	return options
}

// SetLabels : Allow user to set Labels
func (options *CreateSatelliteClusterOptions) SetLabels(labels map[string]string) *CreateSatelliteClusterOptions {
	options.Labels = labels
	return options
}

// SetName : Allow user to set Name
func (options *CreateSatelliteClusterOptions) SetName(name string) *CreateSatelliteClusterOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPodSubnet : Allow user to set PodSubnet
func (options *CreateSatelliteClusterOptions) SetPodSubnet(podSubnet string) *CreateSatelliteClusterOptions {
	options.PodSubnet = core.StringPtr(podSubnet)
	return options
}

// SetPullSecret : Allow user to set PullSecret
func (options *CreateSatelliteClusterOptions) SetPullSecret(pullSecret string) *CreateSatelliteClusterOptions {
	options.PullSecret = core.StringPtr(pullSecret)
	return options
}

// SetServiceSubnet : Allow user to set ServiceSubnet
func (options *CreateSatelliteClusterOptions) SetServiceSubnet(serviceSubnet string) *CreateSatelliteClusterOptions {
	options.ServiceSubnet = core.StringPtr(serviceSubnet)
	return options
}

// SetWorkerCount : Allow user to set WorkerCount
func (options *CreateSatelliteClusterOptions) SetWorkerCount(workerCount int64) *CreateSatelliteClusterOptions {
	options.WorkerCount = core.Int64Ptr(workerCount)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateSatelliteClusterOptions) SetZone(zone string) *CreateSatelliteClusterOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSatelliteClusterOptions) SetHeaders(param map[string]string) *CreateSatelliteClusterOptions {
	options.Headers = param
	return options
}

// CreateSatelliteClusterRemoteOptions : The CreateSatelliteClusterRemote options.
type CreateSatelliteClusterRemoteOptions struct {
	// The IBM Cloud Identity and Access Management (IAM) service CRN token for the service that creates the cluster. For
	// the service CRN token to work for this API request, the user must previously authorize the service with the
	// "Satellite Cluster Creator" action for Satellite in IAM for the IBM Cloud account where the Satellite location
	// exists.
	XAuthSupplemental *string `validate:"required"`

	// Optional: User provided value to indicate opt-in agreement to SatCon admin agent.
	AdminAgentOptIn *bool

	// The name or ID of the Satellite location.
	Controller *string

	// Optional: The OpenShift Container Platform version.
	KubeVersion *string

	// Key-value pairs to label the host, such as cpu=4 to describe the host capabilities.
	Labels map[string]string

	// The unique name for the new IBM Cloud Satellite cluster.
	Name *string

	// Optional: User provided value for the pod subnet.
	PodSubnet *string

	// Optional: The RedHat pull secret to create the OpenShift cluster.
	PullSecret *string

	// Optional: User provided value for service subnet.
	ServiceSubnet *string

	// Optional: The number of worker nodes to create per zone in the default worker pool.
	WorkerCount *int64

	// Optional: The name of the zone to create the default worker pool in.
	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSatelliteClusterRemoteOptions : Instantiate CreateSatelliteClusterRemoteOptions
func (*KubernetesServiceApiV1) NewCreateSatelliteClusterRemoteOptions(xAuthSupplemental string) *CreateSatelliteClusterRemoteOptions {
	return &CreateSatelliteClusterRemoteOptions{
		XAuthSupplemental: core.StringPtr(xAuthSupplemental),
	}
}

// SetXAuthSupplemental : Allow user to set XAuthSupplemental
func (options *CreateSatelliteClusterRemoteOptions) SetXAuthSupplemental(xAuthSupplemental string) *CreateSatelliteClusterRemoteOptions {
	options.XAuthSupplemental = core.StringPtr(xAuthSupplemental)
	return options
}

// SetAdminAgentOptIn : Allow user to set AdminAgentOptIn
func (options *CreateSatelliteClusterRemoteOptions) SetAdminAgentOptIn(adminAgentOptIn bool) *CreateSatelliteClusterRemoteOptions {
	options.AdminAgentOptIn = core.BoolPtr(adminAgentOptIn)
	return options
}

// SetController : Allow user to set Controller
func (options *CreateSatelliteClusterRemoteOptions) SetController(controller string) *CreateSatelliteClusterRemoteOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetKubeVersion : Allow user to set KubeVersion
func (options *CreateSatelliteClusterRemoteOptions) SetKubeVersion(kubeVersion string) *CreateSatelliteClusterRemoteOptions {
	options.KubeVersion = core.StringPtr(kubeVersion)
	return options
}

// SetLabels : Allow user to set Labels
func (options *CreateSatelliteClusterRemoteOptions) SetLabels(labels map[string]string) *CreateSatelliteClusterRemoteOptions {
	options.Labels = labels
	return options
}

// SetName : Allow user to set Name
func (options *CreateSatelliteClusterRemoteOptions) SetName(name string) *CreateSatelliteClusterRemoteOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPodSubnet : Allow user to set PodSubnet
func (options *CreateSatelliteClusterRemoteOptions) SetPodSubnet(podSubnet string) *CreateSatelliteClusterRemoteOptions {
	options.PodSubnet = core.StringPtr(podSubnet)
	return options
}

// SetPullSecret : Allow user to set PullSecret
func (options *CreateSatelliteClusterRemoteOptions) SetPullSecret(pullSecret string) *CreateSatelliteClusterRemoteOptions {
	options.PullSecret = core.StringPtr(pullSecret)
	return options
}

// SetServiceSubnet : Allow user to set ServiceSubnet
func (options *CreateSatelliteClusterRemoteOptions) SetServiceSubnet(serviceSubnet string) *CreateSatelliteClusterRemoteOptions {
	options.ServiceSubnet = core.StringPtr(serviceSubnet)
	return options
}

// SetWorkerCount : Allow user to set WorkerCount
func (options *CreateSatelliteClusterRemoteOptions) SetWorkerCount(workerCount int64) *CreateSatelliteClusterRemoteOptions {
	options.WorkerCount = core.Int64Ptr(workerCount)
	return options
}

// SetZone : Allow user to set Zone
func (options *CreateSatelliteClusterRemoteOptions) SetZone(zone string) *CreateSatelliteClusterRemoteOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSatelliteClusterRemoteOptions) SetHeaders(param map[string]string) *CreateSatelliteClusterRemoteOptions {
	options.Headers = param
	return options
}

// CreateSatelliteLocationOptions : The CreateSatelliteLocation options.
type CreateSatelliteLocationOptions struct {
	// COSBucket Optional: IBM Cloud Object Storage bucket configuration details.
	CosConfig *COSBucket

	// COSAuthorization Optional: IBM Cloud Object Storage authorization keys.
	CosCredentials *COSAuthorization

	// A description of the new Satellite location.
	Description *string

	// The IBM Cloud metro from which the Satellite location is managed.
	Location *string

	// The account ID for IBM Log Analysis with LogDNA log forwarding.
	LoggingAccountID *string

	// A unique name for the new Satellite location.
	Name *string

	// The names of at least three high availability zones to use for the location (e.g. cloud-zone-1, cloud-zone-2,
	// cloud-zone-3).
	Zones []string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSatelliteLocationOptions : Instantiate CreateSatelliteLocationOptions
func (*KubernetesServiceApiV1) NewCreateSatelliteLocationOptions() *CreateSatelliteLocationOptions {
	return &CreateSatelliteLocationOptions{}
}

// SetCosConfig : Allow user to set CosConfig
func (options *CreateSatelliteLocationOptions) SetCosConfig(cosConfig *COSBucket) *CreateSatelliteLocationOptions {
	options.CosConfig = cosConfig
	return options
}

// SetCosCredentials : Allow user to set CosCredentials
func (options *CreateSatelliteLocationOptions) SetCosCredentials(cosCredentials *COSAuthorization) *CreateSatelliteLocationOptions {
	options.CosCredentials = cosCredentials
	return options
}

// SetDescription : Allow user to set Description
func (options *CreateSatelliteLocationOptions) SetDescription(description string) *CreateSatelliteLocationOptions {
	options.Description = core.StringPtr(description)
	return options
}

// SetLocation : Allow user to set Location
func (options *CreateSatelliteLocationOptions) SetLocation(location string) *CreateSatelliteLocationOptions {
	options.Location = core.StringPtr(location)
	return options
}

// SetLoggingAccountID : Allow user to set LoggingAccountID
func (options *CreateSatelliteLocationOptions) SetLoggingAccountID(loggingAccountID string) *CreateSatelliteLocationOptions {
	options.LoggingAccountID = core.StringPtr(loggingAccountID)
	return options
}

// SetName : Allow user to set Name
func (options *CreateSatelliteLocationOptions) SetName(name string) *CreateSatelliteLocationOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetZones : Allow user to set Zones
func (options *CreateSatelliteLocationOptions) SetZones(zones []string) *CreateSatelliteLocationOptions {
	options.Zones = zones
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSatelliteLocationOptions) SetHeaders(param map[string]string) *CreateSatelliteLocationOptions {
	options.Headers = param
	return options
}

// CreateSatelliteWorkerPoolOptions : The CreateSatelliteWorkerPool options.
type CreateSatelliteWorkerPoolOptions struct {
	Zones []SatelliteCreateWorkerPoolZone

	Cluster *string

	DiskEncryption *bool

	Entitlement *string

	Flavor *string

	HostLabels map[string]string

	Isolation *string

	Labels map[string]string

	Name *string

	WorkerCount *int64

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSatelliteWorkerPoolOptions : Instantiate CreateSatelliteWorkerPoolOptions
func (*KubernetesServiceApiV1) NewCreateSatelliteWorkerPoolOptions() *CreateSatelliteWorkerPoolOptions {
	return &CreateSatelliteWorkerPoolOptions{}
}

// SetZones : Allow user to set Zones
func (options *CreateSatelliteWorkerPoolOptions) SetZones(zones []SatelliteCreateWorkerPoolZone) *CreateSatelliteWorkerPoolOptions {
	options.Zones = zones
	return options
}

// SetCluster : Allow user to set Cluster
func (options *CreateSatelliteWorkerPoolOptions) SetCluster(cluster string) *CreateSatelliteWorkerPoolOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetDiskEncryption : Allow user to set DiskEncryption
func (options *CreateSatelliteWorkerPoolOptions) SetDiskEncryption(diskEncryption bool) *CreateSatelliteWorkerPoolOptions {
	options.DiskEncryption = core.BoolPtr(diskEncryption)
	return options
}

// SetEntitlement : Allow user to set Entitlement
func (options *CreateSatelliteWorkerPoolOptions) SetEntitlement(entitlement string) *CreateSatelliteWorkerPoolOptions {
	options.Entitlement = core.StringPtr(entitlement)
	return options
}

// SetFlavor : Allow user to set Flavor
func (options *CreateSatelliteWorkerPoolOptions) SetFlavor(flavor string) *CreateSatelliteWorkerPoolOptions {
	options.Flavor = core.StringPtr(flavor)
	return options
}

// SetHostLabels : Allow user to set HostLabels
func (options *CreateSatelliteWorkerPoolOptions) SetHostLabels(hostLabels map[string]string) *CreateSatelliteWorkerPoolOptions {
	options.HostLabels = hostLabels
	return options
}

// SetIsolation : Allow user to set Isolation
func (options *CreateSatelliteWorkerPoolOptions) SetIsolation(isolation string) *CreateSatelliteWorkerPoolOptions {
	options.Isolation = core.StringPtr(isolation)
	return options
}

// SetLabels : Allow user to set Labels
func (options *CreateSatelliteWorkerPoolOptions) SetLabels(labels map[string]string) *CreateSatelliteWorkerPoolOptions {
	options.Labels = labels
	return options
}

// SetName : Allow user to set Name
func (options *CreateSatelliteWorkerPoolOptions) SetName(name string) *CreateSatelliteWorkerPoolOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetWorkerCount : Allow user to set WorkerCount
func (options *CreateSatelliteWorkerPoolOptions) SetWorkerCount(workerCount int64) *CreateSatelliteWorkerPoolOptions {
	options.WorkerCount = core.Int64Ptr(workerCount)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSatelliteWorkerPoolOptions) SetHeaders(param map[string]string) *CreateSatelliteWorkerPoolOptions {
	options.Headers = param
	return options
}

// CreateSatelliteWorkerPoolZoneOptions : The CreateSatelliteWorkerPoolZone options.
type CreateSatelliteWorkerPoolZoneOptions struct {
	Cluster *string

	ID *string

	Workerpool *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSatelliteWorkerPoolZoneOptions : Instantiate CreateSatelliteWorkerPoolZoneOptions
func (*KubernetesServiceApiV1) NewCreateSatelliteWorkerPoolZoneOptions() *CreateSatelliteWorkerPoolZoneOptions {
	return &CreateSatelliteWorkerPoolZoneOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *CreateSatelliteWorkerPoolZoneOptions) SetCluster(cluster string) *CreateSatelliteWorkerPoolZoneOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetID : Allow user to set ID
func (options *CreateSatelliteWorkerPoolZoneOptions) SetID(id string) *CreateSatelliteWorkerPoolZoneOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *CreateSatelliteWorkerPoolZoneOptions) SetWorkerpool(workerpool string) *CreateSatelliteWorkerPoolZoneOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSatelliteWorkerPoolZoneOptions) SetHeaders(param map[string]string) *CreateSatelliteWorkerPoolZoneOptions {
	options.Headers = param
	return options
}

// CreateSecretOptions : The CreateSecret options.
type CreateSecretOptions struct {
	Cluster *string

	Crn *string

	Name *string

	Namespace *string

	Persistence *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateSecretOptions : Instantiate CreateSecretOptions
func (*KubernetesServiceApiV1) NewCreateSecretOptions() *CreateSecretOptions {
	return &CreateSecretOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *CreateSecretOptions) SetCluster(cluster string) *CreateSecretOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetCrn : Allow user to set Crn
func (options *CreateSecretOptions) SetCrn(crn string) *CreateSecretOptions {
	options.Crn = core.StringPtr(crn)
	return options
}

// SetName : Allow user to set Name
func (options *CreateSecretOptions) SetName(name string) *CreateSecretOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *CreateSecretOptions) SetNamespace(namespace string) *CreateSecretOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetPersistence : Allow user to set Persistence
func (options *CreateSecretOptions) SetPersistence(persistence bool) *CreateSecretOptions {
	options.Persistence = core.BoolPtr(persistence)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateSecretOptions) SetHeaders(param map[string]string) *CreateSecretOptions {
	options.Headers = param
	return options
}

// CreateStorageConfigurationOptions : The CreateStorageConfiguration options.
type CreateStorageConfigurationOptions struct {
	ConfigName *string

	ConfigVersion *string

	SourceBranch *string

	SourceOrg *string

	StorageClassParameters []map[string]string

	StorageTemplateName *string

	StorageTemplateVersion *string

	UserConfigParameters map[string]string

	UserSecretParameters map[string]string

	UUID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateStorageConfigurationOptions : Instantiate CreateStorageConfigurationOptions
func (*KubernetesServiceApiV1) NewCreateStorageConfigurationOptions() *CreateStorageConfigurationOptions {
	return &CreateStorageConfigurationOptions{}
}

// SetConfigName : Allow user to set ConfigName
func (options *CreateStorageConfigurationOptions) SetConfigName(configName string) *CreateStorageConfigurationOptions {
	options.ConfigName = core.StringPtr(configName)
	return options
}

// SetConfigVersion : Allow user to set ConfigVersion
func (options *CreateStorageConfigurationOptions) SetConfigVersion(configVersion string) *CreateStorageConfigurationOptions {
	options.ConfigVersion = core.StringPtr(configVersion)
	return options
}

// SetSourceBranch : Allow user to set SourceBranch
func (options *CreateStorageConfigurationOptions) SetSourceBranch(sourceBranch string) *CreateStorageConfigurationOptions {
	options.SourceBranch = core.StringPtr(sourceBranch)
	return options
}

// SetSourceOrg : Allow user to set SourceOrg
func (options *CreateStorageConfigurationOptions) SetSourceOrg(sourceOrg string) *CreateStorageConfigurationOptions {
	options.SourceOrg = core.StringPtr(sourceOrg)
	return options
}

// SetStorageClassParameters : Allow user to set StorageClassParameters
func (options *CreateStorageConfigurationOptions) SetStorageClassParameters(storageClassParameters []map[string]string) *CreateStorageConfigurationOptions {
	options.StorageClassParameters = storageClassParameters
	return options
}

// SetStorageTemplateName : Allow user to set StorageTemplateName
func (options *CreateStorageConfigurationOptions) SetStorageTemplateName(storageTemplateName string) *CreateStorageConfigurationOptions {
	options.StorageTemplateName = core.StringPtr(storageTemplateName)
	return options
}

// SetStorageTemplateVersion : Allow user to set StorageTemplateVersion
func (options *CreateStorageConfigurationOptions) SetStorageTemplateVersion(storageTemplateVersion string) *CreateStorageConfigurationOptions {
	options.StorageTemplateVersion = core.StringPtr(storageTemplateVersion)
	return options
}

// SetUserConfigParameters : Allow user to set UserConfigParameters
func (options *CreateStorageConfigurationOptions) SetUserConfigParameters(userConfigParameters map[string]string) *CreateStorageConfigurationOptions {
	options.UserConfigParameters = userConfigParameters
	return options
}

// SetUserSecretParameters : Allow user to set UserSecretParameters
func (options *CreateStorageConfigurationOptions) SetUserSecretParameters(userSecretParameters map[string]string) *CreateStorageConfigurationOptions {
	options.UserSecretParameters = userSecretParameters
	return options
}

// SetUUID : Allow user to set UUID
func (options *CreateStorageConfigurationOptions) SetUUID(uuid string) *CreateStorageConfigurationOptions {
	options.UUID = core.StringPtr(uuid)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateStorageConfigurationOptions) SetHeaders(param map[string]string) *CreateStorageConfigurationOptions {
	options.Headers = param
	return options
}

// CreateSubscriptionData : CreateSubscriptionData struct
type CreateSubscriptionData struct {
	AddSubscription *AddSubscriptionType `json:"addSubscription,omitempty"`
}

// UnmarshalCreateSubscriptionData unmarshals an instance of CreateSubscriptionData from the specified map of raw messages.
func UnmarshalCreateSubscriptionData(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateSubscriptionData)
	err = core.UnmarshalModel(m, "addSubscription", &obj.AddSubscription, UnmarshalAddSubscriptionType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CreateWorkerPoolOptions : The CreateWorkerPool options.
type CreateWorkerPoolOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// If set to true, the secondary disk of the worker node is encrypted. If set to false, no encryption is set up.
	DiskEncryption *bool

	Entitlement *string

	Isolation *string

	Labels map[string]string

	MachineType *string

	Name *string

	SizePerZone *int64

	Zones []WorkerPoolZone

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateWorkerPoolOptions : Instantiate CreateWorkerPoolOptions
func (*KubernetesServiceApiV1) NewCreateWorkerPoolOptions(idOrName string) *CreateWorkerPoolOptions {
	return &CreateWorkerPoolOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *CreateWorkerPoolOptions) SetIdOrName(idOrName string) *CreateWorkerPoolOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetDiskEncryption : Allow user to set DiskEncryption
func (options *CreateWorkerPoolOptions) SetDiskEncryption(diskEncryption bool) *CreateWorkerPoolOptions {
	options.DiskEncryption = core.BoolPtr(diskEncryption)
	return options
}

// SetEntitlement : Allow user to set Entitlement
func (options *CreateWorkerPoolOptions) SetEntitlement(entitlement string) *CreateWorkerPoolOptions {
	options.Entitlement = core.StringPtr(entitlement)
	return options
}

// SetIsolation : Allow user to set Isolation
func (options *CreateWorkerPoolOptions) SetIsolation(isolation string) *CreateWorkerPoolOptions {
	options.Isolation = core.StringPtr(isolation)
	return options
}

// SetLabels : Allow user to set Labels
func (options *CreateWorkerPoolOptions) SetLabels(labels map[string]string) *CreateWorkerPoolOptions {
	options.Labels = labels
	return options
}

// SetMachineType : Allow user to set MachineType
func (options *CreateWorkerPoolOptions) SetMachineType(machineType string) *CreateWorkerPoolOptions {
	options.MachineType = core.StringPtr(machineType)
	return options
}

// SetName : Allow user to set Name
func (options *CreateWorkerPoolOptions) SetName(name string) *CreateWorkerPoolOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetSizePerZone : Allow user to set SizePerZone
func (options *CreateWorkerPoolOptions) SetSizePerZone(sizePerZone int64) *CreateWorkerPoolOptions {
	options.SizePerZone = core.Int64Ptr(sizePerZone)
	return options
}

// SetZones : Allow user to set Zones
func (options *CreateWorkerPoolOptions) SetZones(zones []WorkerPoolZone) *CreateWorkerPoolOptions {
	options.Zones = zones
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *CreateWorkerPoolOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *CreateWorkerPoolOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *CreateWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *CreateWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *CreateWorkerPoolOptions) SetHeaders(param map[string]string) *CreateWorkerPoolOptions {
	options.Headers = param
	return options
}

// CreateWorkerpoolResponse : CreateWorkerpoolResponse struct
type CreateWorkerpoolResponse struct {
	WorkerPoolID *string `json:"workerPoolID,omitempty"`
}

// UnmarshalCreateWorkerpoolResponse unmarshals an instance of CreateWorkerpoolResponse from the specified map of raw messages.
func UnmarshalCreateWorkerpoolResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CreateWorkerpoolResponse)
	err = core.UnmarshalPrimitive(m, "workerPoolID", &obj.WorkerPoolID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Credentials : Credentials provides information about user infrastructure credentials.
type Credentials struct {
	ApiUser *string `json:"apiUser,omitempty"`
}

// UnmarshalCredentials unmarshals an instance of Credentials from the specified map of raw messages.
func UnmarshalCredentials(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Credentials)
	err = core.UnmarshalPrimitive(m, "apiUser", &obj.ApiUser)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CustomParameter : CustomParameter struct
type CustomParameter struct {
	Default *string `json:"default,omitempty"`

	Description *string `json:"description,omitempty"`

	Displayname *string `json:"displayname,omitempty"`

	Name *string `json:"name,omitempty"`

	Required *string `json:"required,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalCustomParameter unmarshals an instance of CustomParameter from the specified map of raw messages.
func UnmarshalCustomParameter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CustomParameter)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "displayname", &obj.Displayname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "required", &obj.Required)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DNSRegistration : type DNSRegistrations.
type DNSRegistration struct {
	Ips []string `json:"ips,omitempty"`

	Subdomain *string `json:"subdomain,omitempty"`
}

// UnmarshalDNSRegistration unmarshals an instance of DNSRegistration from the specified map of raw messages.
func UnmarshalDNSRegistration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DNSRegistration)
	err = core.UnmarshalPrimitive(m, "ips", &obj.Ips)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subdomain", &obj.Subdomain)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DefaultLoggingEndpointResponse : DefaultLoggingEndpointResponse is the ibm logging service endpoint where logs will be sent by default clusters in the
// target region.
type DefaultLoggingEndpointResponse struct {
	// The IBM Cloud Log Analysis with LogDNA API endpoint that the hostname uses.
	Endpoint *string `json:"endpoint,omitempty"`

	// The hostname for the ibm logging service.
	Hostname *string `json:"hostname,omitempty"`

	// The port for the ibm logging service.
	Port *int64 `json:"port,omitempty"`
}

// UnmarshalDefaultLoggingEndpointResponse unmarshals an instance of DefaultLoggingEndpointResponse from the specified map of raw messages.
func UnmarshalDefaultLoggingEndpointResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DefaultLoggingEndpointResponse)
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeleteAttachmentOptions : The DeleteAttachment options.
type DeleteAttachmentOptions struct {
	Cluster *string

	VolumeAttachmentID *string

	VolumeID *string

	Worker *string

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster-get <cluster>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteAttachmentOptions : Instantiate DeleteAttachmentOptions
func (*KubernetesServiceApiV1) NewDeleteAttachmentOptions() *DeleteAttachmentOptions {
	return &DeleteAttachmentOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *DeleteAttachmentOptions) SetCluster(cluster string) *DeleteAttachmentOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetVolumeAttachmentID : Allow user to set VolumeAttachmentID
func (options *DeleteAttachmentOptions) SetVolumeAttachmentID(volumeAttachmentID string) *DeleteAttachmentOptions {
	options.VolumeAttachmentID = core.StringPtr(volumeAttachmentID)
	return options
}

// SetVolumeID : Allow user to set VolumeID
func (options *DeleteAttachmentOptions) SetVolumeID(volumeID string) *DeleteAttachmentOptions {
	options.VolumeID = core.StringPtr(volumeID)
	return options
}

// SetWorker : Allow user to set Worker
func (options *DeleteAttachmentOptions) SetWorker(worker string) *DeleteAttachmentOptions {
	options.Worker = core.StringPtr(worker)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *DeleteAttachmentOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *DeleteAttachmentOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteAttachmentOptions) SetHeaders(param map[string]string) *DeleteAttachmentOptions {
	options.Headers = param
	return options
}

// DeleteAuditWebhookOptions : The DeleteAuditWebhook options.
type DeleteAuditWebhookOptions struct {
	// The name or ID of the cluster for which you want to change the audit config. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteAuditWebhookOptions : Instantiate DeleteAuditWebhookOptions
func (*KubernetesServiceApiV1) NewDeleteAuditWebhookOptions(idOrName string) *DeleteAuditWebhookOptions {
	return &DeleteAuditWebhookOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *DeleteAuditWebhookOptions) SetIdOrName(idOrName string) *DeleteAuditWebhookOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *DeleteAuditWebhookOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *DeleteAuditWebhookOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteAuditWebhookOptions) SetHeaders(param map[string]string) *DeleteAuditWebhookOptions {
	options.Headers = param
	return options
}

// DeleteClusterALBSecretsOptions : The DeleteClusterALBSecrets options.
type DeleteClusterALBSecretsOptions struct {
	// The name or ID of the cluster that you want to remove the secret from. To list the clusters that you have access to,
	// run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// The name of the ALB secret that you want to delete. To list the ALB secrets available in the cluster, use the `GET
	// /clusters/{idOrName}/albsecrets` API or run `ibmcloud ks alb cert ls --cluster <cluster_name_or_ID>`.
	AlbSecretName *string

	// The CRN of the certificate that you want to remove.
	CertCrn *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteClusterALBSecretsOptions : Instantiate DeleteClusterALBSecretsOptions
func (*KubernetesServiceApiV1) NewDeleteClusterALBSecretsOptions(idOrName string) *DeleteClusterALBSecretsOptions {
	return &DeleteClusterALBSecretsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *DeleteClusterALBSecretsOptions) SetIdOrName(idOrName string) *DeleteClusterALBSecretsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *DeleteClusterALBSecretsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *DeleteClusterALBSecretsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetAlbSecretName : Allow user to set AlbSecretName
func (options *DeleteClusterALBSecretsOptions) SetAlbSecretName(albSecretName string) *DeleteClusterALBSecretsOptions {
	options.AlbSecretName = core.StringPtr(albSecretName)
	return options
}

// SetCertCrn : Allow user to set CertCrn
func (options *DeleteClusterALBSecretsOptions) SetCertCrn(certCrn string) *DeleteClusterALBSecretsOptions {
	options.CertCrn = core.StringPtr(certCrn)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteClusterALBSecretsOptions) SetHeaders(param map[string]string) *DeleteClusterALBSecretsOptions {
	options.Headers = param
	return options
}

// DeleteFilterConfigOptions : The DeleteFilterConfig options.
type DeleteFilterConfigOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The UUID for the filterConfig that you want to delete.
	ID *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteFilterConfigOptions : Instantiate DeleteFilterConfigOptions
func (*KubernetesServiceApiV1) NewDeleteFilterConfigOptions(idOrName string, id string) *DeleteFilterConfigOptions {
	return &DeleteFilterConfigOptions{
		IdOrName: core.StringPtr(idOrName),
		ID:       core.StringPtr(id),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *DeleteFilterConfigOptions) SetIdOrName(idOrName string) *DeleteFilterConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteFilterConfigOptions) SetID(id string) *DeleteFilterConfigOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *DeleteFilterConfigOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *DeleteFilterConfigOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *DeleteFilterConfigOptions) SetForceUpdate(forceUpdate bool) *DeleteFilterConfigOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFilterConfigOptions) SetHeaders(param map[string]string) *DeleteFilterConfigOptions {
	options.Headers = param
	return options
}

// DeleteFilterConfigsOptions : The DeleteFilterConfigs options.
type DeleteFilterConfigsOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteFilterConfigsOptions : Instantiate DeleteFilterConfigsOptions
func (*KubernetesServiceApiV1) NewDeleteFilterConfigsOptions(idOrName string) *DeleteFilterConfigsOptions {
	return &DeleteFilterConfigsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *DeleteFilterConfigsOptions) SetIdOrName(idOrName string) *DeleteFilterConfigsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *DeleteFilterConfigsOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *DeleteFilterConfigsOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *DeleteFilterConfigsOptions) SetForceUpdate(forceUpdate bool) *DeleteFilterConfigsOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteFilterConfigsOptions) SetHeaders(param map[string]string) *DeleteFilterConfigsOptions {
	options.Headers = param
	return options
}

// DeleteIngressSecretOptions : The DeleteIngressSecret options.
type DeleteIngressSecretOptions struct {
	Cluster *string

	DeleteCert *bool

	Name *string

	Namespace *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteIngressSecretOptions : Instantiate DeleteIngressSecretOptions
func (*KubernetesServiceApiV1) NewDeleteIngressSecretOptions() *DeleteIngressSecretOptions {
	return &DeleteIngressSecretOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *DeleteIngressSecretOptions) SetCluster(cluster string) *DeleteIngressSecretOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetDeleteCert : Allow user to set DeleteCert
func (options *DeleteIngressSecretOptions) SetDeleteCert(deleteCert bool) *DeleteIngressSecretOptions {
	options.DeleteCert = core.BoolPtr(deleteCert)
	return options
}

// SetName : Allow user to set Name
func (options *DeleteIngressSecretOptions) SetName(name string) *DeleteIngressSecretOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *DeleteIngressSecretOptions) SetNamespace(namespace string) *DeleteIngressSecretOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteIngressSecretOptions) SetHeaders(param map[string]string) *DeleteIngressSecretOptions {
	options.Headers = param
	return options
}

// DeleteLoggingConfigOptions : The DeleteLoggingConfig options.
type DeleteLoggingConfigOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The log source that you want to stop forwarding logs for.
	LogSource *string `validate:"required,ne="`

	// The UUID of the logging configuration that you want to delete.
	ID *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoggingConfigOptions : Instantiate DeleteLoggingConfigOptions
func (*KubernetesServiceApiV1) NewDeleteLoggingConfigOptions(idOrName string, logSource string, id string) *DeleteLoggingConfigOptions {
	return &DeleteLoggingConfigOptions{
		IdOrName:  core.StringPtr(idOrName),
		LogSource: core.StringPtr(logSource),
		ID:        core.StringPtr(id),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *DeleteLoggingConfigOptions) SetIdOrName(idOrName string) *DeleteLoggingConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetLogSource : Allow user to set LogSource
func (options *DeleteLoggingConfigOptions) SetLogSource(logSource string) *DeleteLoggingConfigOptions {
	options.LogSource = core.StringPtr(logSource)
	return options
}

// SetID : Allow user to set ID
func (options *DeleteLoggingConfigOptions) SetID(id string) *DeleteLoggingConfigOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *DeleteLoggingConfigOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *DeleteLoggingConfigOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *DeleteLoggingConfigOptions) SetForceUpdate(forceUpdate bool) *DeleteLoggingConfigOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoggingConfigOptions) SetHeaders(param map[string]string) *DeleteLoggingConfigOptions {
	options.Headers = param
	return options
}

// DeleteLoggingConfigsOptions : The DeleteLoggingConfigs options.
type DeleteLoggingConfigsOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteLoggingConfigsOptions : Instantiate DeleteLoggingConfigsOptions
func (*KubernetesServiceApiV1) NewDeleteLoggingConfigsOptions(idOrName string) *DeleteLoggingConfigsOptions {
	return &DeleteLoggingConfigsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *DeleteLoggingConfigsOptions) SetIdOrName(idOrName string) *DeleteLoggingConfigsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *DeleteLoggingConfigsOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *DeleteLoggingConfigsOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *DeleteLoggingConfigsOptions) SetForceUpdate(forceUpdate bool) *DeleteLoggingConfigsOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteLoggingConfigsOptions) SetHeaders(param map[string]string) *DeleteLoggingConfigsOptions {
	options.Headers = param
	return options
}

// DeleteSecretOptions : The DeleteSecret options.
type DeleteSecretOptions struct {
	Cluster *string

	Subdomain *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteSecretOptions : Instantiate DeleteSecretOptions
func (*KubernetesServiceApiV1) NewDeleteSecretOptions() *DeleteSecretOptions {
	return &DeleteSecretOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *DeleteSecretOptions) SetCluster(cluster string) *DeleteSecretOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetSubdomain : Allow user to set Subdomain
func (options *DeleteSecretOptions) SetSubdomain(subdomain string) *DeleteSecretOptions {
	options.Subdomain = core.StringPtr(subdomain)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteSecretOptions) SetHeaders(param map[string]string) *DeleteSecretOptions {
	options.Headers = param
	return options
}

// Deployments : Deployments reports status of deployments on the IBM Cloud Satellite location.
type Deployments struct {
	// Value is true when the location is ready to deploy new clusters.
	Enabled *bool `json:"enabled,omitempty"`

	// Contains troubleshooting messages when the location is not able to deploy a cluster.
	Message *string `json:"message,omitempty"`
}

// UnmarshalDeployments unmarshals an instance of Deployments from the specified map of raw messages.
func UnmarshalDeployments(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Deployments)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DetachClusterSubnetOptions : The DetachClusterSubnet options.
type DetachClusterSubnetOptions struct {
	// The name or ID of the cluster that you want to remove the subnet from. To list the clusters that you have access to,
	// use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the subnet that you want to remove from your cluster.
	SubnetID *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDetachClusterSubnetOptions : Instantiate DetachClusterSubnetOptions
func (*KubernetesServiceApiV1) NewDetachClusterSubnetOptions(idOrName string, subnetID string) *DetachClusterSubnetOptions {
	return &DetachClusterSubnetOptions{
		IdOrName: core.StringPtr(idOrName),
		SubnetID: core.StringPtr(subnetID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *DetachClusterSubnetOptions) SetIdOrName(idOrName string) *DetachClusterSubnetOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetSubnetID : Allow user to set SubnetID
func (options *DetachClusterSubnetOptions) SetSubnetID(subnetID string) *DetachClusterSubnetOptions {
	options.SubnetID = core.StringPtr(subnetID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *DetachClusterSubnetOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *DetachClusterSubnetOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DetachClusterSubnetOptions) SetHeaders(param map[string]string) *DetachClusterSubnetOptions {
	options.Headers = param
	return options
}

// Device : Device struct
type Device struct {
	ID *string `json:"id,omitempty"`
}

// UnmarshalDevice unmarshals an instance of Device from the specified map of raw messages.
func UnmarshalDevice(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Device)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DisableALBOptions : The DisableALB options.
type DisableALBOptions struct {
	// The ID of the ALB that you want to disable. To list the IDs for the ALBs in a cluster, use the `GET
	// /v1/alb/clusters/{idOrName}` API or run `ibmcloud ks alb ls --cluster <cluster_name_or_ID>`.
	AlbID *string `validate:"required,ne="`

	// To bring your own Ingress controller, disable the IBM-provided ALB deployment. This parameter doesn't remove the DNS
	// registration for the IBM-provided Ingress subdomain or the load balancer service that is used to expose the Ingress
	// controller.
	DisableDeployment *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDisableALBOptions : Instantiate DisableALBOptions
func (*KubernetesServiceApiV1) NewDisableALBOptions(albID string) *DisableALBOptions {
	return &DisableALBOptions{
		AlbID: core.StringPtr(albID),
	}
}

// SetAlbID : Allow user to set AlbID
func (options *DisableALBOptions) SetAlbID(albID string) *DisableALBOptions {
	options.AlbID = core.StringPtr(albID)
	return options
}

// SetDisableDeployment : Allow user to set DisableDeployment
func (options *DisableALBOptions) SetDisableDeployment(disableDeployment string) *DisableALBOptions {
	options.DisableDeployment = core.StringPtr(disableDeployment)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DisableALBOptions) SetHeaders(param map[string]string) *DisableALBOptions {
	options.Headers = param
	return options
}

// DisableClusterACLsOptions : The DisableClusterACLs options.
type DisableClusterACLsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDisableClusterACLsOptions : Instantiate DisableClusterACLsOptions
func (*KubernetesServiceApiV1) NewDisableClusterACLsOptions(idOrName string) *DisableClusterACLsOptions {
	return &DisableClusterACLsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *DisableClusterACLsOptions) SetIdOrName(idOrName string) *DisableClusterACLsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *DisableClusterACLsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *DisableClusterACLsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DisableClusterACLsOptions) SetHeaders(param map[string]string) *DisableClusterACLsOptions {
	options.Headers = param
	return options
}

// DiscoverLoggingInstanceOptions : The DiscoverLoggingInstance options.
type DiscoverLoggingInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. Required when the API is invoked through a CURL command.
	XAuthRefreshToken *string `validate:"required"`

	Cluster *string

	Instance *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDiscoverLoggingInstanceOptions : Instantiate DiscoverLoggingInstanceOptions
func (*KubernetesServiceApiV1) NewDiscoverLoggingInstanceOptions(xAuthRefreshToken string) *DiscoverLoggingInstanceOptions {
	return &DiscoverLoggingInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *DiscoverLoggingInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *DiscoverLoggingInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *DiscoverLoggingInstanceOptions) SetCluster(cluster string) *DiscoverLoggingInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetInstance : Allow user to set Instance
func (options *DiscoverLoggingInstanceOptions) SetInstance(instance string) *DiscoverLoggingInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DiscoverLoggingInstanceOptions) SetHeaders(param map[string]string) *DiscoverLoggingInstanceOptions {
	options.Headers = param
	return options
}

// DiscoverMonitoringInstanceOptions : The DiscoverMonitoringInstance options.
type DiscoverMonitoringInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. Required when the API is invoked through a CURL command.
	XAuthRefreshToken *string `validate:"required"`

	Cluster *string

	Instance *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDiscoverMonitoringInstanceOptions : Instantiate DiscoverMonitoringInstanceOptions
func (*KubernetesServiceApiV1) NewDiscoverMonitoringInstanceOptions(xAuthRefreshToken string) *DiscoverMonitoringInstanceOptions {
	return &DiscoverMonitoringInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *DiscoverMonitoringInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *DiscoverMonitoringInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *DiscoverMonitoringInstanceOptions) SetCluster(cluster string) *DiscoverMonitoringInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetInstance : Allow user to set Instance
func (options *DiscoverMonitoringInstanceOptions) SetInstance(instance string) *DiscoverMonitoringInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *DiscoverMonitoringInstanceOptions) SetHeaders(param map[string]string) *DiscoverMonitoringInstanceOptions {
	options.Headers = param
	return options
}

// DiskConfigResp : DiskConfigResp response type for describing a disk configuration.
type DiskConfigResp struct {
	Count *int64 `json:"Count,omitempty"`

	DeviceType *string `json:"DeviceType,omitempty"`

	RAIDConfiguration *string `json:"RAIDConfiguration,omitempty"`

	// the size of each individual device in GB.
	Size *int64 `json:"Size,omitempty"`
}

// UnmarshalDiskConfigResp unmarshals an instance of DiskConfigResp from the specified map of raw messages.
func UnmarshalDiskConfigResp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DiskConfigResp)
	err = core.UnmarshalPrimitive(m, "Count", &obj.Count)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "DeviceType", &obj.DeviceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "RAIDConfiguration", &obj.RAIDConfiguration)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "Size", &obj.Size)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EnableALBOptions : The EnableALB options.
type EnableALBOptions struct {
	// The build number of the ALB.
	AlbBuild *string

	// The ID of the application load balancer (ALB).
	AlbID *string

	// The type of ALB.
	AlbType *string

	// The public IP address that exposes the ALB.
	Albip *string

	// The auth build of the ALB.
	AuthBuild *string

	// The ID of the cluster that the ALB belongs to.
	ClusterID *string

	// The date the ALB was created.
	CreatedDate *string

	// If set to true, the deployment of the ALB is disabled.
	DisableDeployment *bool

	// Set to true to enable the ALB, or false to disable the ALB for the cluster.
	Enable *bool

	// The name of the cluster that the ALB belongs to.
	Name *string

	// The version of network load balancer that the ALB uses.
	NlbVersion *string

	// Desired number of ALB replicas that you want in your cluster.
	NumOfInstances *string

	// If set to true, resizing of the ALB is done.
	Resize *bool

	// The state of the ALB.
	State *string

	// The status of the ALB.
	Status *string

	// The VLAN ID that the ALB is attached to.
	VlanID *string

	// The zone where you want to add ALBs.
	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewEnableALBOptions : Instantiate EnableALBOptions
func (*KubernetesServiceApiV1) NewEnableALBOptions() *EnableALBOptions {
	return &EnableALBOptions{}
}

// SetAlbBuild : Allow user to set AlbBuild
func (options *EnableALBOptions) SetAlbBuild(albBuild string) *EnableALBOptions {
	options.AlbBuild = core.StringPtr(albBuild)
	return options
}

// SetAlbID : Allow user to set AlbID
func (options *EnableALBOptions) SetAlbID(albID string) *EnableALBOptions {
	options.AlbID = core.StringPtr(albID)
	return options
}

// SetAlbType : Allow user to set AlbType
func (options *EnableALBOptions) SetAlbType(albType string) *EnableALBOptions {
	options.AlbType = core.StringPtr(albType)
	return options
}

// SetAlbip : Allow user to set Albip
func (options *EnableALBOptions) SetAlbip(albip string) *EnableALBOptions {
	options.Albip = core.StringPtr(albip)
	return options
}

// SetAuthBuild : Allow user to set AuthBuild
func (options *EnableALBOptions) SetAuthBuild(authBuild string) *EnableALBOptions {
	options.AuthBuild = core.StringPtr(authBuild)
	return options
}

// SetClusterID : Allow user to set ClusterID
func (options *EnableALBOptions) SetClusterID(clusterID string) *EnableALBOptions {
	options.ClusterID = core.StringPtr(clusterID)
	return options
}

// SetCreatedDate : Allow user to set CreatedDate
func (options *EnableALBOptions) SetCreatedDate(createdDate string) *EnableALBOptions {
	options.CreatedDate = core.StringPtr(createdDate)
	return options
}

// SetDisableDeployment : Allow user to set DisableDeployment
func (options *EnableALBOptions) SetDisableDeployment(disableDeployment bool) *EnableALBOptions {
	options.DisableDeployment = core.BoolPtr(disableDeployment)
	return options
}

// SetEnable : Allow user to set Enable
func (options *EnableALBOptions) SetEnable(enable bool) *EnableALBOptions {
	options.Enable = core.BoolPtr(enable)
	return options
}

// SetName : Allow user to set Name
func (options *EnableALBOptions) SetName(name string) *EnableALBOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNlbVersion : Allow user to set NlbVersion
func (options *EnableALBOptions) SetNlbVersion(nlbVersion string) *EnableALBOptions {
	options.NlbVersion = core.StringPtr(nlbVersion)
	return options
}

// SetNumOfInstances : Allow user to set NumOfInstances
func (options *EnableALBOptions) SetNumOfInstances(numOfInstances string) *EnableALBOptions {
	options.NumOfInstances = core.StringPtr(numOfInstances)
	return options
}

// SetResize : Allow user to set Resize
func (options *EnableALBOptions) SetResize(resize bool) *EnableALBOptions {
	options.Resize = core.BoolPtr(resize)
	return options
}

// SetState : Allow user to set State
func (options *EnableALBOptions) SetState(state string) *EnableALBOptions {
	options.State = core.StringPtr(state)
	return options
}

// SetStatus : Allow user to set Status
func (options *EnableALBOptions) SetStatus(status string) *EnableALBOptions {
	options.Status = core.StringPtr(status)
	return options
}

// SetVlanID : Allow user to set VlanID
func (options *EnableALBOptions) SetVlanID(vlanID string) *EnableALBOptions {
	options.VlanID = core.StringPtr(vlanID)
	return options
}

// SetZone : Allow user to set Zone
func (options *EnableALBOptions) SetZone(zone string) *EnableALBOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *EnableALBOptions) SetHeaders(param map[string]string) *EnableALBOptions {
	options.Headers = param
	return options
}

// EnableClusterACLsOptions : The EnableClusterACLs options.
type EnableClusterACLsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewEnableClusterACLsOptions : Instantiate EnableClusterACLsOptions
func (*KubernetesServiceApiV1) NewEnableClusterACLsOptions(idOrName string) *EnableClusterACLsOptions {
	return &EnableClusterACLsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *EnableClusterACLsOptions) SetIdOrName(idOrName string) *EnableClusterACLsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *EnableClusterACLsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *EnableClusterACLsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *EnableClusterACLsOptions) SetHeaders(param map[string]string) *EnableClusterACLsOptions {
	options.Headers = param
	return options
}

// EnvVar : EnvVar struct
type EnvVar struct {
	// Name of the environment variable. Must be a C_IDENTIFIER.
	Name *string `json:"name,omitempty"`

	// Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and
	// any service environment variables. If a variable cannot be resolved, the reference in the input string will be
	// unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never
	// be expanded, regardless of whether the variable exists or not. Defaults to "".
	// +optional.
	Value *string `json:"value,omitempty"`

	ValueFrom *EnvVarSource `json:"valueFrom,omitempty"`
}

// UnmarshalEnvVar unmarshals an instance of EnvVar from the specified map of raw messages.
func UnmarshalEnvVar(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EnvVar)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "valueFrom", &obj.ValueFrom, UnmarshalEnvVarSource)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EnvVarSource : EnvVarSource struct
type EnvVarSource struct {
	ConfigMapKeyRef *ConfigMapKeySelector `json:"configMapKeyRef,omitempty"`

	FieldRef *ObjectFieldSelector `json:"fieldRef,omitempty"`

	// ResourceFieldSelector represents container resources (cpu, memory) and their output format.
	ResourceFieldRef *ResourceFieldSelector `json:"resourceFieldRef,omitempty"`

	SecretKeyRef *SecretKeySelector `json:"secretKeyRef,omitempty"`
}

// UnmarshalEnvVarSource unmarshals an instance of EnvVarSource from the specified map of raw messages.
func UnmarshalEnvVarSource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EnvVarSource)
	err = core.UnmarshalModel(m, "configMapKeyRef", &obj.ConfigMapKeyRef, UnmarshalConfigMapKeySelector)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "fieldRef", &obj.FieldRef, UnmarshalObjectFieldSelector)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "resourceFieldRef", &obj.ResourceFieldRef, UnmarshalResourceFieldSelector)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "secretKeyRef", &obj.SecretKeyRef, UnmarshalSecretKeySelector)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ErrorResponse : ErrorResponse error response to end users.
type ErrorResponse struct {
	Code *string `json:"code,omitempty"`

	Description *string `json:"description,omitempty"`

	IncidentID *string `json:"incidentID,omitempty"`

	RecoveryCLI *string `json:"recoveryCLI,omitempty"`

	TerseDescription *string `json:"terseDescription,omitempty"`

	// ErrorType error type.
	Type *string `json:"type,omitempty"`
}

// UnmarshalErrorResponse unmarshals an instance of ErrorResponse from the specified map of raw messages.
func UnmarshalErrorResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ErrorResponse)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "incidentID", &obj.IncidentID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "recoveryCLI", &obj.RecoveryCLI)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "terseDescription", &obj.TerseDescription)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FetchFilterConfigOptions : The FetchFilterConfig options.
type FetchFilterConfigOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The UUID of the logging filter that you want to fetch.
	ID *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// To show matching logging configurations for global filters, set to `true`.
	ShowMatches *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewFetchFilterConfigOptions : Instantiate FetchFilterConfigOptions
func (*KubernetesServiceApiV1) NewFetchFilterConfigOptions(idOrName string, id string) *FetchFilterConfigOptions {
	return &FetchFilterConfigOptions{
		IdOrName: core.StringPtr(idOrName),
		ID:       core.StringPtr(id),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *FetchFilterConfigOptions) SetIdOrName(idOrName string) *FetchFilterConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetID : Allow user to set ID
func (options *FetchFilterConfigOptions) SetID(id string) *FetchFilterConfigOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *FetchFilterConfigOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *FetchFilterConfigOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetShowMatches : Allow user to set ShowMatches
func (options *FetchFilterConfigOptions) SetShowMatches(showMatches bool) *FetchFilterConfigOptions {
	options.ShowMatches = core.BoolPtr(showMatches)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *FetchFilterConfigOptions) SetHeaders(param map[string]string) *FetchFilterConfigOptions {
	options.Headers = param
	return options
}

// FetchFilterConfigsOptions : The FetchFilterConfigs options.
type FetchFilterConfigsOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Set to true to populate global filters with all matching logging configurations.
	ShowMatches *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewFetchFilterConfigsOptions : Instantiate FetchFilterConfigsOptions
func (*KubernetesServiceApiV1) NewFetchFilterConfigsOptions(idOrName string) *FetchFilterConfigsOptions {
	return &FetchFilterConfigsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *FetchFilterConfigsOptions) SetIdOrName(idOrName string) *FetchFilterConfigsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *FetchFilterConfigsOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *FetchFilterConfigsOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetShowMatches : Allow user to set ShowMatches
func (options *FetchFilterConfigsOptions) SetShowMatches(showMatches bool) *FetchFilterConfigsOptions {
	options.ShowMatches = core.BoolPtr(showMatches)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *FetchFilterConfigsOptions) SetHeaders(param map[string]string) *FetchFilterConfigsOptions {
	options.Headers = param
	return options
}

// FetchLoggingConfigsForSourceOptions : The FetchLoggingConfigsForSource options.
type FetchLoggingConfigsForSourceOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The type of log source that you want to list configurations for.
	LogSource *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewFetchLoggingConfigsForSourceOptions : Instantiate FetchLoggingConfigsForSourceOptions
func (*KubernetesServiceApiV1) NewFetchLoggingConfigsForSourceOptions(idOrName string, logSource string) *FetchLoggingConfigsForSourceOptions {
	return &FetchLoggingConfigsForSourceOptions{
		IdOrName:  core.StringPtr(idOrName),
		LogSource: core.StringPtr(logSource),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *FetchLoggingConfigsForSourceOptions) SetIdOrName(idOrName string) *FetchLoggingConfigsForSourceOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetLogSource : Allow user to set LogSource
func (options *FetchLoggingConfigsForSourceOptions) SetLogSource(logSource string) *FetchLoggingConfigsForSourceOptions {
	options.LogSource = core.StringPtr(logSource)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *FetchLoggingConfigsForSourceOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *FetchLoggingConfigsForSourceOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *FetchLoggingConfigsForSourceOptions) SetHeaders(param map[string]string) *FetchLoggingConfigsForSourceOptions {
	options.Headers = param
	return options
}

// FetchLoggingConfigsOptions : The FetchLoggingConfigs options.
type FetchLoggingConfigsOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewFetchLoggingConfigsOptions : Instantiate FetchLoggingConfigsOptions
func (*KubernetesServiceApiV1) NewFetchLoggingConfigsOptions(idOrName string) *FetchLoggingConfigsOptions {
	return &FetchLoggingConfigsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *FetchLoggingConfigsOptions) SetIdOrName(idOrName string) *FetchLoggingConfigsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *FetchLoggingConfigsOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *FetchLoggingConfigsOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *FetchLoggingConfigsOptions) SetHeaders(param map[string]string) *FetchLoggingConfigsOptions {
	options.Headers = param
	return options
}

// FilterConfigResponse : FilterConfigResponse is how users will see their logging filter configs from API responses.
type FilterConfigResponse struct {
	// The name of the container that you want to exclude from your logs.
	Container *string `json:"container,omitempty"`

	// A list of logging filter IDs that the filter covers.
	CoveringFilters []string `json:"coveringFilters,omitempty"`

	// The unique identifier of the logging configuration.
	ID *string `json:"id,omitempty"`

	// The pod label that you want to exclude from your logs.
	Label *string `json:"label,omitempty"`

	// The log level that you want to apply to your logs. Supported values are `debug` or `info`.
	LogLevel *string `json:"logLevel,omitempty"`

	// A list of logging configuration IDs where you want to apply the log filter.
	LoggingConfigs []string `json:"loggingConfigs,omitempty"`

	// A string in a log message that you want to exclude from your logs.
	Message *string `json:"message,omitempty"`

	// The Kubernetes namespace that you want to exclude from your logs.
	Namespace *string `json:"namespace,omitempty"`

	// Set this value to `true` if you want to interpret the message field as a regular expression.
	RegexMessageEnabled *bool `json:"regexMessageEnabled,omitempty"`

	// The type of filter that you want to apply to your logs. Supported values are `container` and `non-container`.
	Type *string `json:"type,omitempty"`

	// Internal use only.
	Version *string `json:"version,omitempty"`
}

// UnmarshalFilterConfigResponse unmarshals an instance of FilterConfigResponse from the specified map of raw messages.
func UnmarshalFilterConfigResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FilterConfigResponse)
	err = core.UnmarshalPrimitive(m, "container", &obj.Container)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "coveringFilters", &obj.CoveringFilters)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "label", &obj.Label)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "logLevel", &obj.LogLevel)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "loggingConfigs", &obj.LoggingConfigs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "namespace", &obj.Namespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "regexMessageEnabled", &obj.RegexMessageEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Flavor : Flavor Definition of a flavor / machine type that can be deployed.
type Flavor struct {
	// The type of CPU architecture that the flavor uses.
	Architecture *string `json:"architecture,omitempty"`

	CorrespondingFlavor *string `json:"correspondingFlavor,omitempty"`

	Deprecated *bool `json:"deprecated,omitempty"`

	// The ID of the worker node flavor.
	ID *string `json:"id,omitempty"`

	IsTrusted *bool `json:"isTrusted,omitempty"`

	// The name of the worker node flavor.
	Name *string `json:"name,omitempty"`

	// The name of the provider.
	Provider *string `json:"provider,omitempty"`

	SecondaryStorage *string `json:"secondaryStorage,omitempty"`

	SecondaryStorageEncrypted *bool `json:"secondaryStorageEncrypted,omitempty"`

	Storage *string `json:"storage,omitempty"`
}

// UnmarshalFlavor unmarshals an instance of Flavor from the specified map of raw messages.
func UnmarshalFlavor(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Flavor)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "correspondingFlavor", &obj.CorrespondingFlavor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deprecated", &obj.Deprecated)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isTrusted", &obj.IsTrusted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secondaryStorage", &obj.SecondaryStorage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secondaryStorageEncrypted", &obj.SecondaryStorageEncrypted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage", &obj.Storage)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlavorResponse : FlavorResponse response type for retrieving a flavor.
type FlavorResponse struct {
	AdditionalStorage []DiskConfigResp `json:"additionalStorage,omitempty"`

	Cores *int64 `json:"cores,omitempty"`

	Deprecated *bool `json:"deprecated,omitempty"`

	Gpus []GPUConfigResp `json:"gpus,omitempty"`

	ID *string `json:"id,omitempty"`

	Memory *string `json:"memory,omitempty"`

	Name *string `json:"name,omitempty"`

	NetworkSpeed *string `json:"networkSpeed,omitempty"`

	OcpUnsupported *bool `json:"ocp_unsupported,omitempty"`

	Os *string `json:"os,omitempty"`

	// DiskConfigResp response type for describing a disk configuration.
	PrimaryStorage *DiskConfigResp `json:"primaryStorage,omitempty"`

	Provider *string `json:"provider,omitempty"`

	// DiskConfigResp response type for describing a disk configuration.
	SecondaryStorage *DiskConfigResp `json:"secondaryStorage,omitempty"`

	SecondaryStorageEncrypted *bool `json:"secondaryStorageEncrypted,omitempty"`

	ServerType *string `json:"serverType,omitempty"`

	SgxEnabled *bool `json:"sgxEnabled,omitempty"`

	SupportedIsolation []string `json:"supported_isolation,omitempty"`
}

// UnmarshalFlavorResponse unmarshals an instance of FlavorResponse from the specified map of raw messages.
func UnmarshalFlavorResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlavorResponse)
	err = core.UnmarshalModel(m, "additionalStorage", &obj.AdditionalStorage, UnmarshalDiskConfigResp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cores", &obj.Cores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deprecated", &obj.Deprecated)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gpus", &obj.Gpus, UnmarshalGPUConfigResp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkSpeed", &obj.NetworkSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ocp_unsupported", &obj.OcpUnsupported)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "os", &obj.Os)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "primaryStorage", &obj.PrimaryStorage, UnmarshalDiskConfigResp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "secondaryStorage", &obj.SecondaryStorage, UnmarshalDiskConfigResp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secondaryStorageEncrypted", &obj.SecondaryStorageEncrypted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serverType", &obj.ServerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sgxEnabled", &obj.SgxEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supported_isolation", &obj.SupportedIsolation)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GPUConfigResp : GPUConfigResp response type for describing a GPU configuration.
type GPUConfigResp struct {
	Count *int64 `json:"Count,omitempty"`

	Type *string `json:"Type,omitempty"`
}

// UnmarshalGPUConfigResp unmarshals an instance of GPUConfigResp from the specified map of raw messages.
func UnmarshalGPUConfigResp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GPUConfigResp)
	err = core.UnmarshalPrimitive(m, "Count", &obj.Count)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "Type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetAddonsOptions : The GetAddons options.
type GetAddonsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetAddonsOptions : Instantiate GetAddonsOptions
func (*KubernetesServiceApiV1) NewGetAddonsOptions() *GetAddonsOptions {
	return &GetAddonsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetAddonsOptions) SetHeaders(param map[string]string) *GetAddonsOptions {
	options.Headers = param
	return options
}

// GetAssignmentByNameOptions : The GetAssignmentByName options.
type GetAssignmentByNameOptions struct {
	// The name of the assignment. To list the assignments that you have access to, run `ibmcloud sat storage assignment
	// ls`.
	Name *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetAssignmentByNameOptions : Instantiate GetAssignmentByNameOptions
func (*KubernetesServiceApiV1) NewGetAssignmentByNameOptions(name string) *GetAssignmentByNameOptions {
	return &GetAssignmentByNameOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (options *GetAssignmentByNameOptions) SetName(name string) *GetAssignmentByNameOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetAssignmentByNameOptions) SetHeaders(param map[string]string) *GetAssignmentByNameOptions {
	options.Headers = param
	return options
}

// GetAssignmentOptions : The GetAssignment options.
type GetAssignmentOptions struct {
	// The UUID of the assignment. To list the assignments that you have access to, run `ibmcloud sat storage assignment
	// ls`.
	UUID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetAssignmentOptions : Instantiate GetAssignmentOptions
func (*KubernetesServiceApiV1) NewGetAssignmentOptions(uuid string) *GetAssignmentOptions {
	return &GetAssignmentOptions{
		UUID: core.StringPtr(uuid),
	}
}

// SetUUID : Allow user to set UUID
func (options *GetAssignmentOptions) SetUUID(uuid string) *GetAssignmentOptions {
	options.UUID = core.StringPtr(uuid)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetAssignmentOptions) SetHeaders(param map[string]string) *GetAssignmentOptions {
	options.Headers = param
	return options
}

// GetAssignmentsOptions : The GetAssignments options.
type GetAssignmentsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetAssignmentsOptions : Instantiate GetAssignmentsOptions
func (*KubernetesServiceApiV1) NewGetAssignmentsOptions() *GetAssignmentsOptions {
	return &GetAssignmentsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetAssignmentsOptions) SetHeaders(param map[string]string) *GetAssignmentsOptions {
	options.Headers = param
	return options
}

// GetAttachmentOptions : The GetAttachment options.
type GetAttachmentOptions struct {
	// The ID or name of the cluster. To list the clusters that you have access to, run `ibmcloud ks clusters`.
	Cluster *string `validate:"required"`

	// The ID of the worker node, whose volume attachments needs to be listed. To list all worker nodes for a cluster, run
	// `ibmcloud ks workers <cluster_name_or_ID>`.
	Worker *string `validate:"required"`

	// The unique volume attachment ID for the attached volume.
	VolumeAttachmentID *string `validate:"required"`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster-get <cluster>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetAttachmentOptions : Instantiate GetAttachmentOptions
func (*KubernetesServiceApiV1) NewGetAttachmentOptions(cluster string, worker string, volumeAttachmentID string) *GetAttachmentOptions {
	return &GetAttachmentOptions{
		Cluster:            core.StringPtr(cluster),
		Worker:             core.StringPtr(worker),
		VolumeAttachmentID: core.StringPtr(volumeAttachmentID),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetAttachmentOptions) SetCluster(cluster string) *GetAttachmentOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorker : Allow user to set Worker
func (options *GetAttachmentOptions) SetWorker(worker string) *GetAttachmentOptions {
	options.Worker = core.StringPtr(worker)
	return options
}

// SetVolumeAttachmentID : Allow user to set VolumeAttachmentID
func (options *GetAttachmentOptions) SetVolumeAttachmentID(volumeAttachmentID string) *GetAttachmentOptions {
	options.VolumeAttachmentID = core.StringPtr(volumeAttachmentID)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *GetAttachmentOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *GetAttachmentOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetAttachmentOptions) SetHeaders(param map[string]string) *GetAttachmentOptions {
	options.Headers = param
	return options
}

// GetAttachmentsOptions : The GetAttachments options.
type GetAttachmentsOptions struct {
	// The ID or name of the cluster. To list the clusters that you have access to, run `ibmcloud ks clusters`.
	Cluster *string `validate:"required"`

	// The ID of the worker node, whose volume attachments needs to be listed.
	Worker *string `validate:"required"`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster-get <cluster>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetAttachmentsOptions : Instantiate GetAttachmentsOptions
func (*KubernetesServiceApiV1) NewGetAttachmentsOptions(cluster string, worker string) *GetAttachmentsOptions {
	return &GetAttachmentsOptions{
		Cluster: core.StringPtr(cluster),
		Worker:  core.StringPtr(worker),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetAttachmentsOptions) SetCluster(cluster string) *GetAttachmentsOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorker : Allow user to set Worker
func (options *GetAttachmentsOptions) SetWorker(worker string) *GetAttachmentsOptions {
	options.Worker = core.StringPtr(worker)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *GetAttachmentsOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *GetAttachmentsOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetAttachmentsOptions) SetHeaders(param map[string]string) *GetAttachmentsOptions {
	options.Headers = param
	return options
}

// GetAuditWebhookOptions : The GetAuditWebhook options.
type GetAuditWebhookOptions struct {
	// The name or ID of the cluster that you want audit configuration details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetAuditWebhookOptions : Instantiate GetAuditWebhookOptions
func (*KubernetesServiceApiV1) NewGetAuditWebhookOptions(idOrName string) *GetAuditWebhookOptions {
	return &GetAuditWebhookOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetAuditWebhookOptions) SetIdOrName(idOrName string) *GetAuditWebhookOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetAuditWebhookOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetAuditWebhookOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetAuditWebhookOptions) SetHeaders(param map[string]string) *GetAuditWebhookOptions {
	options.Headers = param
	return options
}

// GetAvailableALBTypesOptions : The GetAvailableALBTypes options.
type GetAvailableALBTypesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetAvailableALBTypesOptions : Instantiate GetAvailableALBTypesOptions
func (*KubernetesServiceApiV1) NewGetAvailableALBTypesOptions() *GetAvailableALBTypesOptions {
	return &GetAvailableALBTypesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetAvailableALBTypesOptions) SetHeaders(param map[string]string) *GetAvailableALBTypesOptions {
	options.Headers = param
	return options
}

// GetBluemixConfigOptions : The GetBluemixConfig options.
type GetBluemixConfigOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetBluemixConfigOptions : Instantiate GetBluemixConfigOptions
func (*KubernetesServiceApiV1) NewGetBluemixConfigOptions() *GetBluemixConfigOptions {
	return &GetBluemixConfigOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetBluemixConfigOptions) SetHeaders(param map[string]string) *GetBluemixConfigOptions {
	options.Headers = param
	return options
}

// GetCRKResponse : GetCRKResponse is data returned by a getCRKs request call.
type GetCRKResponse struct {
	CrkID *string `json:"crk_id,omitempty"`

	Name *string `json:"name,omitempty"`
}

// UnmarshalGetCRKResponse unmarshals an instance of GetCRKResponse from the specified map of raw messages.
func UnmarshalGetCRKResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetCRKResponse)
	err = core.UnmarshalPrimitive(m, "crk_id", &obj.CrkID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetCluster1Options : The GetCluster1 options.
type GetCluster1Options struct {
	// The name or ID of the cluster that you want information about. To list the clusters that you have access to, use the
	// `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// To view additional cluster resources like addons, VLANs, subnets, and storage, pass `true`.
	ShowResources *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetCluster1Options : Instantiate GetCluster1Options
func (*KubernetesServiceApiV1) NewGetCluster1Options(idOrName string) *GetCluster1Options {
	return &GetCluster1Options{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetCluster1Options) SetIdOrName(idOrName string) *GetCluster1Options {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetCluster1Options) SetXAuthResourceGroup(xAuthResourceGroup string) *GetCluster1Options {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetShowResources : Allow user to set ShowResources
func (options *GetCluster1Options) SetShowResources(showResources string) *GetCluster1Options {
	options.ShowResources = core.StringPtr(showResources)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetCluster1Options) SetHeaders(param map[string]string) *GetCluster1Options {
	options.Headers = param
	return options
}

// GetClusterACLsOptions : The GetClusterACLs options.
type GetClusterACLsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterACLsOptions : Instantiate GetClusterACLsOptions
func (*KubernetesServiceApiV1) NewGetClusterACLsOptions(idOrName string) *GetClusterACLsOptions {
	return &GetClusterACLsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterACLsOptions) SetIdOrName(idOrName string) *GetClusterACLsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterACLsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterACLsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterACLsOptions) SetHeaders(param map[string]string) *GetClusterACLsOptions {
	options.Headers = param
	return options
}

// GetClusterALBOptions : The GetClusterALB options.
type GetClusterALBOptions struct {
	// The ID of the ALB that you want details for. To list the IDs for the ALBs in a cluster, use the `GET
	// /clusters/{idOrName}` API or run `ibmcloud ks alb ls --cluster <cluster_name_or_ID>`.
	AlbID *string `validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterALBOptions : Instantiate GetClusterALBOptions
func (*KubernetesServiceApiV1) NewGetClusterALBOptions(albID string) *GetClusterALBOptions {
	return &GetClusterALBOptions{
		AlbID: core.StringPtr(albID),
	}
}

// SetAlbID : Allow user to set AlbID
func (options *GetClusterALBOptions) SetAlbID(albID string) *GetClusterALBOptions {
	options.AlbID = core.StringPtr(albID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterALBOptions) SetHeaders(param map[string]string) *GetClusterALBOptions {
	options.Headers = param
	return options
}

// GetClusterALBsOptions : The GetClusterALBs options.
type GetClusterALBsOptions struct {
	// The name or ID of the cluster that you want to see ALB information for. To list the clusters that you have access
	// to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterALBsOptions : Instantiate GetClusterALBsOptions
func (*KubernetesServiceApiV1) NewGetClusterALBsOptions(idOrName string) *GetClusterALBsOptions {
	return &GetClusterALBsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterALBsOptions) SetIdOrName(idOrName string) *GetClusterALBsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterALBsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterALBsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterALBsOptions) SetHeaders(param map[string]string) *GetClusterALBsOptions {
	options.Headers = param
	return options
}

// GetClusterAddonsOptions : The GetClusterAddons options.
type GetClusterAddonsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group of the cluster, use the `GET
	// /v1/clusters/{idOrName}` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterAddonsOptions : Instantiate GetClusterAddonsOptions
func (*KubernetesServiceApiV1) NewGetClusterAddonsOptions(idOrName string) *GetClusterAddonsOptions {
	return &GetClusterAddonsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterAddonsOptions) SetIdOrName(idOrName string) *GetClusterAddonsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterAddonsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterAddonsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterAddonsOptions) SetHeaders(param map[string]string) *GetClusterAddonsOptions {
	options.Headers = param
	return options
}

// GetClusterConfigOptions : The GetClusterConfig options.
type GetClusterConfigOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string `validate:"required"`

	// The name or ID of the cluster for which you want to download the Kubernetes configuration file and certificates. To
	// list the clusters that you have access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// The format of the user identity to use in the Kubernetes configuration and policies. Must match the IAM provided
	// user email, up to letter case.
	Sub *string

	// To format the output in a single YAML file, pass `yaml`.
	Format *string

	// Retrieve the Calico network config with the Admin config. This only works against the admin
	// endpoint('/config/admin').
	CreateNetworkConfig *bool

	// Skip adding the RBAC roles based on user's access in IAM.
	SkipRBAC *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterConfigOptions : Instantiate GetClusterConfigOptions
func (*KubernetesServiceApiV1) NewGetClusterConfigOptions(xAuthRefreshToken string, idOrName string) *GetClusterConfigOptions {
	return &GetClusterConfigOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
		IdOrName:          core.StringPtr(idOrName),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *GetClusterConfigOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *GetClusterConfigOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterConfigOptions) SetIdOrName(idOrName string) *GetClusterConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterConfigOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterConfigOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetSub : Allow user to set Sub
func (options *GetClusterConfigOptions) SetSub(sub string) *GetClusterConfigOptions {
	options.Sub = core.StringPtr(sub)
	return options
}

// SetFormat : Allow user to set Format
func (options *GetClusterConfigOptions) SetFormat(format string) *GetClusterConfigOptions {
	options.Format = core.StringPtr(format)
	return options
}

// SetCreateNetworkConfig : Allow user to set CreateNetworkConfig
func (options *GetClusterConfigOptions) SetCreateNetworkConfig(createNetworkConfig bool) *GetClusterConfigOptions {
	options.CreateNetworkConfig = core.BoolPtr(createNetworkConfig)
	return options
}

// SetSkipRBAC : Allow user to set SkipRBAC
func (options *GetClusterConfigOptions) SetSkipRBAC(skipRBAC bool) *GetClusterConfigOptions {
	options.SkipRBAC = core.BoolPtr(skipRBAC)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterConfigOptions) SetHeaders(param map[string]string) *GetClusterConfigOptions {
	options.Headers = param
	return options
}

// GetClusterKeyOwnerOptions : The GetClusterKeyOwner options.
type GetClusterKeyOwnerOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterKeyOwnerOptions : Instantiate GetClusterKeyOwnerOptions
func (*KubernetesServiceApiV1) NewGetClusterKeyOwnerOptions(idOrName string) *GetClusterKeyOwnerOptions {
	return &GetClusterKeyOwnerOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterKeyOwnerOptions) SetIdOrName(idOrName string) *GetClusterKeyOwnerOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *GetClusterKeyOwnerOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *GetClusterKeyOwnerOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterKeyOwnerOptions) SetHeaders(param map[string]string) *GetClusterKeyOwnerOptions {
	options.Headers = param
	return options
}

// GetClusterOptions : The GetCluster options.
type GetClusterOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the VPC clusters that you
	// have access to, use the `GET /v2/vpc/getClusters` API or run `ibmcloud ks cluster ls --provider vpc-classic`.
	Cluster *string `validate:"required"`

	// The resource group that you want to list clusters for. To list available resource groups, run `ibmcloud resource
	// groups`. If you don't include this header, all the clusters in the account that you have access to are listed.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterOptions : Instantiate GetClusterOptions
func (*KubernetesServiceApiV1) NewGetClusterOptions(cluster string) *GetClusterOptions {
	return &GetClusterOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetClusterOptions) SetCluster(cluster string) *GetClusterOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterOptions) SetHeaders(param map[string]string) *GetClusterOptions {
	options.Headers = param
	return options
}

// GetClusterResponse : GetClusterResponse struct
type GetClusterResponse struct {
	Addons []CommonClusterAddon `json:"addons,omitempty"`

	// CommonClusterCACertRotation CA cert rotation properties.
	CaCertRotationStatus *CommonClusterCACertRotation `json:"caCertRotationStatus,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty"`

	Crn *string `json:"crn,omitempty"`

	Datacenter *string `json:"datacenter,omitempty"`

	DisableAutoUpdate *bool `json:"disableAutoUpdate,omitempty"`

	Entitlement *string `json:"entitlement,omitempty"`

	EtcdPort *string `json:"etcdPort,omitempty"`

	Features *CommonClusterFeatures `json:"features,omitempty"`

	ID *string `json:"id,omitempty"`

	ImageSecurityEnabled *bool `json:"imageSecurityEnabled,omitempty"`

	Ingress *CommonClusterIngress `json:"ingress,omitempty"`

	IsPaid *bool `json:"isPaid,omitempty"`

	Lifecycle *CommonClusterLifecycle `json:"lifecycle,omitempty"`

	Location *string `json:"location,omitempty"`

	LocationZones []string `json:"locationZones,omitempty"`

	MasterKubeVersion *string `json:"masterKubeVersion,omitempty"`

	MasterURL *string `json:"masterURL,omitempty"`

	MultiAzCapable *bool `json:"multiAzCapable,omitempty"`

	Name *string `json:"name,omitempty"`

	PodSubnet *string `json:"podSubnet,omitempty"`

	Provider *string `json:"provider,omitempty"`

	Region *string `json:"region,omitempty"`

	ResourceGroup *string `json:"resourceGroup,omitempty"`

	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	ServiceEndpoints *CommonClusterServiceEndpoint `json:"serviceEndpoints,omitempty"`

	ServiceSubnet *string `json:"serviceSubnet,omitempty"`

	// The lifecycle state of the cluster. Possible values include aborted, critical, delete_failed, deleted, deleting,
	// deploy_failed, deploying, normal, pending, requested, updating, unsupported, and warning. For more information, see
	// the docs 'http://ibm.biz/cluster-health-states'.
	State *string `json:"state,omitempty"`

	Status *string `json:"status,omitempty"`

	TargetVersion *string `json:"targetVersion,omitempty"`

	Type *string `json:"type,omitempty"`

	VersionEOS *string `json:"versionEOS,omitempty"`

	Vpcs []string `json:"vpcs,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`

	WorkerZones []string `json:"workerZones,omitempty"`
}

// UnmarshalGetClusterResponse unmarshals an instance of GetClusterResponse from the specified map of raw messages.
func UnmarshalGetClusterResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetClusterResponse)
	err = core.UnmarshalModel(m, "addons", &obj.Addons, UnmarshalCommonClusterAddon)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "caCertRotationStatus", &obj.CaCertRotationStatus, UnmarshalCommonClusterCACertRotation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdDate", &obj.CreatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "datacenter", &obj.Datacenter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "disableAutoUpdate", &obj.DisableAutoUpdate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "entitlement", &obj.Entitlement)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "etcdPort", &obj.EtcdPort)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "features", &obj.Features, UnmarshalCommonClusterFeatures)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageSecurityEnabled", &obj.ImageSecurityEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ingress", &obj.Ingress, UnmarshalCommonClusterIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaid", &obj.IsPaid)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle", &obj.Lifecycle, UnmarshalCommonClusterLifecycle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locationZones", &obj.LocationZones)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterKubeVersion", &obj.MasterKubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterURL", &obj.MasterURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "multiAzCapable", &obj.MultiAzCapable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "podSubnet", &obj.PodSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroup", &obj.ResourceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupName", &obj.ResourceGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "serviceEndpoints", &obj.ServiceEndpoints, UnmarshalCommonClusterServiceEndpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceSubnet", &obj.ServiceSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVersion", &obj.TargetVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "versionEOS", &obj.VersionEOS)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcs", &obj.Vpcs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerZones", &obj.WorkerZones)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetClusterSubnetsOptions : The GetClusterSubnets options.
type GetClusterSubnetsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterSubnetsOptions : Instantiate GetClusterSubnetsOptions
func (*KubernetesServiceApiV1) NewGetClusterSubnetsOptions(idOrName string) *GetClusterSubnetsOptions {
	return &GetClusterSubnetsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterSubnetsOptions) SetIdOrName(idOrName string) *GetClusterSubnetsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterSubnetsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterSubnetsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterSubnetsOptions) SetHeaders(param map[string]string) *GetClusterSubnetsOptions {
	options.Headers = param
	return options
}

// GetClusterUserSubnetOptions : The GetClusterUserSubnet options.
type GetClusterUserSubnetOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterUserSubnetOptions : Instantiate GetClusterUserSubnetOptions
func (*KubernetesServiceApiV1) NewGetClusterUserSubnetOptions(idOrName string) *GetClusterUserSubnetOptions {
	return &GetClusterUserSubnetOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterUserSubnetOptions) SetIdOrName(idOrName string) *GetClusterUserSubnetOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterUserSubnetOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterUserSubnetOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterUserSubnetOptions) SetHeaders(param map[string]string) *GetClusterUserSubnetOptions {
	options.Headers = param
	return options
}

// GetClusterWebhooksOptions : The GetClusterWebhooks options.
type GetClusterWebhooksOptions struct {
	// The name or ID of the cluster for which you want to list available webhooks. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterWebhooksOptions : Instantiate GetClusterWebhooksOptions
func (*KubernetesServiceApiV1) NewGetClusterWebhooksOptions(idOrName string) *GetClusterWebhooksOptions {
	return &GetClusterWebhooksOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterWebhooksOptions) SetIdOrName(idOrName string) *GetClusterWebhooksOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterWebhooksOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterWebhooksOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterWebhooksOptions) SetHeaders(param map[string]string) *GetClusterWebhooksOptions {
	options.Headers = param
	return options
}

// GetClusterWorkersOptions : The GetClusterWorkers options.
type GetClusterWorkersOptions struct {
	// The name or ID of the cluster for which you want to list all worker nodes. To list the clusters that you have access
	// to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// The name or ID of the worker pool to filter results for. Run `ibmcloud ks worker-pool ls --cluster <cluster name>`.
	Pool *string

	// true|false Shows deleted workers.
	ShowDeleted *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClusterWorkersOptions : Instantiate GetClusterWorkersOptions
func (*KubernetesServiceApiV1) NewGetClusterWorkersOptions(idOrName string) *GetClusterWorkersOptions {
	return &GetClusterWorkersOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetClusterWorkersOptions) SetIdOrName(idOrName string) *GetClusterWorkersOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClusterWorkersOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClusterWorkersOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetPool : Allow user to set Pool
func (options *GetClusterWorkersOptions) SetPool(pool string) *GetClusterWorkersOptions {
	options.Pool = core.StringPtr(pool)
	return options
}

// SetShowDeleted : Allow user to set ShowDeleted
func (options *GetClusterWorkersOptions) SetShowDeleted(showDeleted string) *GetClusterWorkersOptions {
	options.ShowDeleted = core.StringPtr(showDeleted)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClusterWorkersOptions) SetHeaders(param map[string]string) *GetClusterWorkersOptions {
	options.Headers = param
	return options
}

// GetClustersOptions : The GetClusters options.
type GetClustersOptions struct {
	// The resource group that you want to list clusters for. To list available resource groups, run `ibmcloud resource
	// groups`. If you don't include this header, all the clusters in the account that you have access to are listed.
	XAuthResourceGroup *string

	// Specify a location to filter clusters for. To see supported locations, use the `GET /v1/locations` API or run
	// `ibmcloud ks locations`.
	Location *string

	// To view additional cluster resources like addons, VLANs, subnets, and storage, pass `true`.
	ShowResources *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetClustersOptions : Instantiate GetClustersOptions
func (*KubernetesServiceApiV1) NewGetClustersOptions() *GetClustersOptions {
	return &GetClustersOptions{}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetClustersOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetClustersOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetLocation : Allow user to set Location
func (options *GetClustersOptions) SetLocation(location string) *GetClustersOptions {
	options.Location = core.StringPtr(location)
	return options
}

// SetShowResources : Allow user to set ShowResources
func (options *GetClustersOptions) SetShowResources(showResources string) *GetClustersOptions {
	options.ShowResources = core.StringPtr(showResources)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetClustersOptions) SetHeaders(param map[string]string) *GetClustersOptions {
	options.Headers = param
	return options
}

// GetClustersResponse : GetClustersResponse cluster response for cluster list.
type GetClustersResponse struct {
	Addons []CommonClusterAddon `json:"addons,omitempty"`

	// CommonClusterCACertRotation CA cert rotation properties.
	CaCertRotationStatus *CommonClusterCACertRotation `json:"caCertRotationStatus,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty"`

	Datacenter *string `json:"datacenter,omitempty"`

	Entitlement *string `json:"entitlement,omitempty"`

	EtcdPort *string `json:"etcdPort,omitempty"`

	ID *string `json:"id,omitempty"`

	ImageSecurityEnabled *bool `json:"imageSecurityEnabled,omitempty"`

	Ingress *CommonClusterIngress `json:"ingress,omitempty"`

	IsPaid *bool `json:"isPaid,omitempty"`

	Location *string `json:"location,omitempty"`

	MasterKubeVersion *string `json:"masterKubeVersion,omitempty"`

	MasterURL *string `json:"masterURL,omitempty"`

	MultiAzCapable *bool `json:"multiAzCapable,omitempty"`

	Name *string `json:"name,omitempty"`

	PodSubnet *string `json:"podSubnet,omitempty"`

	Provider *string `json:"provider,omitempty"`

	Region *string `json:"region,omitempty"`

	ResourceGroup *string `json:"resourceGroup,omitempty"`

	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	ServiceSubnet *string `json:"serviceSubnet,omitempty"`

	// The lifecycle state of the cluster. Possible values include aborted, critical, delete_failed, deleted, deleting,
	// deploy_failed, deploying, normal, pending, requested, updating, unsupported, and warning. For more information, see
	// the docs 'http://ibm.biz/cluster-health-states'.
	State *string `json:"state,omitempty"`

	Status *string `json:"status,omitempty"`

	TargetVersion *string `json:"targetVersion,omitempty"`

	Type *string `json:"type,omitempty"`

	VersionEOS *string `json:"versionEOS,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`
}

// UnmarshalGetClustersResponse unmarshals an instance of GetClustersResponse from the specified map of raw messages.
func UnmarshalGetClustersResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetClustersResponse)
	err = core.UnmarshalModel(m, "addons", &obj.Addons, UnmarshalCommonClusterAddon)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "caCertRotationStatus", &obj.CaCertRotationStatus, UnmarshalCommonClusterCACertRotation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdDate", &obj.CreatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "datacenter", &obj.Datacenter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "entitlement", &obj.Entitlement)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "etcdPort", &obj.EtcdPort)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageSecurityEnabled", &obj.ImageSecurityEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ingress", &obj.Ingress, UnmarshalCommonClusterIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaid", &obj.IsPaid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterKubeVersion", &obj.MasterKubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterURL", &obj.MasterURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "multiAzCapable", &obj.MultiAzCapable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "podSubnet", &obj.PodSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroup", &obj.ResourceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupName", &obj.ResourceGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceSubnet", &obj.ServiceSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVersion", &obj.TargetVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "versionEOS", &obj.VersionEOS)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetDatacenterMachineTypesOptions : The GetDatacenterMachineTypes options.
type GetDatacenterMachineTypesOptions struct {
	// The zone ID where you want to list available machine types. To list available zones, run `ibmcloud ks zone ls` or
	// use the `GET /v1/datacenters` API.
	Datacenter *string `validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDatacenterMachineTypesOptions : Instantiate GetDatacenterMachineTypesOptions
func (*KubernetesServiceApiV1) NewGetDatacenterMachineTypesOptions(datacenter string) *GetDatacenterMachineTypesOptions {
	return &GetDatacenterMachineTypesOptions{
		Datacenter: core.StringPtr(datacenter),
	}
}

// SetDatacenter : Allow user to set Datacenter
func (options *GetDatacenterMachineTypesOptions) SetDatacenter(datacenter string) *GetDatacenterMachineTypesOptions {
	options.Datacenter = core.StringPtr(datacenter)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDatacenterMachineTypesOptions) SetHeaders(param map[string]string) *GetDatacenterMachineTypesOptions {
	options.Headers = param
	return options
}

// GetDatacenterVLANsOptions : The GetDatacenterVLANs options.
type GetDatacenterVLANsOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string `validate:"required"`

	// The ID of the zone where you want to list available public and private VLANs. To list available zones, run `ibmcloud
	// ks zone ls` or use the `GET /v1/datacenters` API.
	Datacenter *string `validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDatacenterVLANsOptions : Instantiate GetDatacenterVLANsOptions
func (*KubernetesServiceApiV1) NewGetDatacenterVLANsOptions(xAuthRefreshToken string, datacenter string) *GetDatacenterVLANsOptions {
	return &GetDatacenterVLANsOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
		Datacenter:        core.StringPtr(datacenter),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *GetDatacenterVLANsOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *GetDatacenterVLANsOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetDatacenter : Allow user to set Datacenter
func (options *GetDatacenterVLANsOptions) SetDatacenter(datacenter string) *GetDatacenterVLANsOptions {
	options.Datacenter = core.StringPtr(datacenter)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDatacenterVLANsOptions) SetHeaders(param map[string]string) *GetDatacenterVLANsOptions {
	options.Headers = param
	return options
}

// GetDefaultLoggingEndpointOptions : The GetDefaultLoggingEndpoint options.
type GetDefaultLoggingEndpointOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetDefaultLoggingEndpointOptions : Instantiate GetDefaultLoggingEndpointOptions
func (*KubernetesServiceApiV1) NewGetDefaultLoggingEndpointOptions(idOrName string) *GetDefaultLoggingEndpointOptions {
	return &GetDefaultLoggingEndpointOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetDefaultLoggingEndpointOptions) SetIdOrName(idOrName string) *GetDefaultLoggingEndpointOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *GetDefaultLoggingEndpointOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *GetDefaultLoggingEndpointOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetDefaultLoggingEndpointOptions) SetHeaders(param map[string]string) *GetDefaultLoggingEndpointOptions {
	options.Headers = param
	return options
}

// GetFluentdUpdatePolicyOptions : The GetFluentdUpdatePolicy options.
type GetFluentdUpdatePolicyOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetFluentdUpdatePolicyOptions : Instantiate GetFluentdUpdatePolicyOptions
func (*KubernetesServiceApiV1) NewGetFluentdUpdatePolicyOptions(idOrName string) *GetFluentdUpdatePolicyOptions {
	return &GetFluentdUpdatePolicyOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetFluentdUpdatePolicyOptions) SetIdOrName(idOrName string) *GetFluentdUpdatePolicyOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *GetFluentdUpdatePolicyOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *GetFluentdUpdatePolicyOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetFluentdUpdatePolicyOptions) SetHeaders(param map[string]string) *GetFluentdUpdatePolicyOptions {
	options.Headers = param
	return options
}

// GetInfraPermissionsOptions : The GetInfraPermissions options.
type GetInfraPermissionsOptions struct {
	// Target the IBM Cloud Kubernetes Service region where you want to check the infrastructure permissions. To list
	// available regions, use the `GET /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string `validate:"required"`

	// The ID of the resource group. To list available resource group IDs, run `ibmcloud resource groups`.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetInfraPermissionsOptions : Instantiate GetInfraPermissionsOptions
func (*KubernetesServiceApiV1) NewGetInfraPermissionsOptions(xRegion string) *GetInfraPermissionsOptions {
	return &GetInfraPermissionsOptions{
		XRegion: core.StringPtr(xRegion),
	}
}

// SetXRegion : Allow user to set XRegion
func (options *GetInfraPermissionsOptions) SetXRegion(xRegion string) *GetInfraPermissionsOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetInfraPermissionsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetInfraPermissionsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetInfraPermissionsOptions) SetHeaders(param map[string]string) *GetInfraPermissionsOptions {
	options.Headers = param
	return options
}

// GetKMSInstanceResponse : GetKMSInstanceResponse struct
type GetKMSInstanceResponse struct {
	InstanceID *string `json:"instance_id,omitempty"`

	Name *string `json:"name,omitempty"`

	Region *string `json:"region,omitempty"`

	Service *string `json:"service,omitempty"`
}

// UnmarshalGetKMSInstanceResponse unmarshals an instance of GetKMSInstanceResponse from the specified map of raw messages.
func UnmarshalGetKMSInstanceResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetKMSInstanceResponse)
	err = core.UnmarshalPrimitive(m, "instance_id", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service", &obj.Service)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetKubeVersionsOptions : The GetKubeVersions options.
type GetKubeVersionsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetKubeVersionsOptions : Instantiate GetKubeVersionsOptions
func (*KubernetesServiceApiV1) NewGetKubeVersionsOptions() *GetKubeVersionsOptions {
	return &GetKubeVersionsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetKubeVersionsOptions) SetHeaders(param map[string]string) *GetKubeVersionsOptions {
	options.Headers = param
	return options
}

// GetKubeconfigOptions : The GetKubeconfig options.
type GetKubeconfigOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string `validate:"required"`

	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v2/getClusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string

	// Default format is json. Other options include yaml, and zip.
	Format *string

	// Retrieve the admin kubeconfig file.
	Admin *bool

	// Retrieve the Calico network config. Requires admin=true and format=zip.
	Network *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetKubeconfigOptions : Instantiate GetKubeconfigOptions
func (*KubernetesServiceApiV1) NewGetKubeconfigOptions(xAuthRefreshToken string, cluster string) *GetKubeconfigOptions {
	return &GetKubeconfigOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
		Cluster:           core.StringPtr(cluster),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *GetKubeconfigOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *GetKubeconfigOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *GetKubeconfigOptions) SetCluster(cluster string) *GetKubeconfigOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetKubeconfigOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetKubeconfigOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetFormat : Allow user to set Format
func (options *GetKubeconfigOptions) SetFormat(format string) *GetKubeconfigOptions {
	options.Format = core.StringPtr(format)
	return options
}

// SetAdmin : Allow user to set Admin
func (options *GetKubeconfigOptions) SetAdmin(admin bool) *GetKubeconfigOptions {
	options.Admin = core.BoolPtr(admin)
	return options
}

// SetNetwork : Allow user to set Network
func (options *GetKubeconfigOptions) SetNetwork(network bool) *GetKubeconfigOptions {
	options.Network = core.BoolPtr(network)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetKubeconfigOptions) SetHeaders(param map[string]string) *GetKubeconfigOptions {
	options.Headers = param
	return options
}

// GetLBConfigOptions : The GetLBConfig options.
type GetLBConfigOptions struct {
	// The name or ID of the cluster.
	Cluster *string `validate:"required"`

	// Type of load balancer configuration to return. Possible options are `public` and `private`.
	Type *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLBConfigOptions : Instantiate GetLBConfigOptions
func (*KubernetesServiceApiV1) NewGetLBConfigOptions(cluster string, typeVar string) *GetLBConfigOptions {
	return &GetLBConfigOptions{
		Cluster: core.StringPtr(cluster),
		Type:    core.StringPtr(typeVar),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetLBConfigOptions) SetCluster(cluster string) *GetLBConfigOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetType : Allow user to set Type
func (options *GetLBConfigOptions) SetType(typeVar string) *GetLBConfigOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLBConfigOptions) SetHeaders(param map[string]string) *GetLBConfigOptions {
	options.Headers = param
	return options
}

// GetLoggingInstanceOptions : The GetLoggingInstance options.
type GetLoggingInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. Required only in the absense of an IAM cookie and when the API is invoked through a CURL
	// command.
	XAuthRefreshToken *string `validate:"required"`

	// The name or ID of the cluster for which you want to show details of an existing LogDNA logging configuration. To
	// list available clusters, run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The name or ID of the LogDNA service instance that you configured for the cluster. To list available LogDNA service
	// instances, run `ibmcloud resource service-instances`.
	Instance *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoggingInstanceOptions : Instantiate GetLoggingInstanceOptions
func (*KubernetesServiceApiV1) NewGetLoggingInstanceOptions(xAuthRefreshToken string, cluster string, instance string) *GetLoggingInstanceOptions {
	return &GetLoggingInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
		Cluster:           core.StringPtr(cluster),
		Instance:          core.StringPtr(instance),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *GetLoggingInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *GetLoggingInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *GetLoggingInstanceOptions) SetCluster(cluster string) *GetLoggingInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetInstance : Allow user to set Instance
func (options *GetLoggingInstanceOptions) SetInstance(instance string) *GetLoggingInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoggingInstanceOptions) SetHeaders(param map[string]string) *GetLoggingInstanceOptions {
	options.Headers = param
	return options
}

// GetLoggingInstancesOptions : The GetLoggingInstances options.
type GetLoggingInstancesOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`.
	XAuthRefreshToken *string `validate:"required"`

	// The name or ID of the cluster for which you want to list existing LogDNA logging configurations. To list available
	// clusters, run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetLoggingInstancesOptions : Instantiate GetLoggingInstancesOptions
func (*KubernetesServiceApiV1) NewGetLoggingInstancesOptions(xAuthRefreshToken string, cluster string) *GetLoggingInstancesOptions {
	return &GetLoggingInstancesOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
		Cluster:           core.StringPtr(cluster),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *GetLoggingInstancesOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *GetLoggingInstancesOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *GetLoggingInstancesOptions) SetCluster(cluster string) *GetLoggingInstancesOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetLoggingInstancesOptions) SetHeaders(param map[string]string) *GetLoggingInstancesOptions {
	options.Headers = param
	return options
}

// GetMasterLogCollectionStatusOptions : The GetMasterLogCollectionStatus options.
type GetMasterLogCollectionStatusOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The IBM Cloud resource group to which the cluster belongs.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetMasterLogCollectionStatusOptions : Instantiate GetMasterLogCollectionStatusOptions
func (*KubernetesServiceApiV1) NewGetMasterLogCollectionStatusOptions(idOrName string) *GetMasterLogCollectionStatusOptions {
	return &GetMasterLogCollectionStatusOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetMasterLogCollectionStatusOptions) SetIdOrName(idOrName string) *GetMasterLogCollectionStatusOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetMasterLogCollectionStatusOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetMasterLogCollectionStatusOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetMasterLogCollectionStatusOptions) SetHeaders(param map[string]string) *GetMasterLogCollectionStatusOptions {
	options.Headers = param
	return options
}

// GetMessagesOptions : The GetMessages options.
type GetMessagesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetMessagesOptions : Instantiate GetMessagesOptions
func (*KubernetesServiceApiV1) NewGetMessagesOptions() *GetMessagesOptions {
	return &GetMessagesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetMessagesOptions) SetHeaders(param map[string]string) *GetMessagesOptions {
	options.Headers = param
	return options
}

// GetMigrationStatusOptions : The GetMigrationStatus options.
type GetMigrationStatusOptions struct {
	// The name or ID of the cluster.
	Cluster *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetMigrationStatusOptions : Instantiate GetMigrationStatusOptions
func (*KubernetesServiceApiV1) NewGetMigrationStatusOptions(cluster string) *GetMigrationStatusOptions {
	return &GetMigrationStatusOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetMigrationStatusOptions) SetCluster(cluster string) *GetMigrationStatusOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetMigrationStatusOptions) SetHeaders(param map[string]string) *GetMigrationStatusOptions {
	options.Headers = param
	return options
}

// GetMonitoringInstanceOptions : The GetMonitoringInstance options.
type GetMonitoringInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`.
	XAuthRefreshToken *string `validate:"required"`

	// The name or ID of the cluster for which you want to show details of an existing Sysdig monitoring configuration. To
	// list available clusters, run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The name or ID of the Sysdig service instance that you configured for the cluster. To list available Sysdig service
	// instances, run `ibmcloud resource service-instances`.
	Instance *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetMonitoringInstanceOptions : Instantiate GetMonitoringInstanceOptions
func (*KubernetesServiceApiV1) NewGetMonitoringInstanceOptions(xAuthRefreshToken string, cluster string, instance string) *GetMonitoringInstanceOptions {
	return &GetMonitoringInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
		Cluster:           core.StringPtr(cluster),
		Instance:          core.StringPtr(instance),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *GetMonitoringInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *GetMonitoringInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *GetMonitoringInstanceOptions) SetCluster(cluster string) *GetMonitoringInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetInstance : Allow user to set Instance
func (options *GetMonitoringInstanceOptions) SetInstance(instance string) *GetMonitoringInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetMonitoringInstanceOptions) SetHeaders(param map[string]string) *GetMonitoringInstanceOptions {
	options.Headers = param
	return options
}

// GetMonitoringInstancesOptions : The GetMonitoringInstances options.
type GetMonitoringInstancesOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`.
	XAuthRefreshToken *string `validate:"required"`

	// The name or ID of the cluster for which you want to list existing Sysdig monitoring configurations. To list
	// available clusters, run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetMonitoringInstancesOptions : Instantiate GetMonitoringInstancesOptions
func (*KubernetesServiceApiV1) NewGetMonitoringInstancesOptions(xAuthRefreshToken string, cluster string) *GetMonitoringInstancesOptions {
	return &GetMonitoringInstancesOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
		Cluster:           core.StringPtr(cluster),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *GetMonitoringInstancesOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *GetMonitoringInstancesOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *GetMonitoringInstancesOptions) SetCluster(cluster string) *GetMonitoringInstancesOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetMonitoringInstancesOptions) SetHeaders(param map[string]string) *GetMonitoringInstancesOptions {
	options.Headers = param
	return options
}

// GetNlbDNSHealthMonitorOptions : The GetNlbDNSHealthMonitor options.
type GetNlbDNSHealthMonitorOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The NLB subdomain that you want health check monitor settings for. To list existing NLB subdomains, use the `GET
	// /clusters/{idOrName}/list` API or run `ibmcloud ks nlb-dns ls --cluster <cluster_name_or_ID>`.
	NlbHost *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNlbDNSHealthMonitorOptions : Instantiate GetNlbDNSHealthMonitorOptions
func (*KubernetesServiceApiV1) NewGetNlbDNSHealthMonitorOptions(idOrName string, nlbHost string) *GetNlbDNSHealthMonitorOptions {
	return &GetNlbDNSHealthMonitorOptions{
		IdOrName: core.StringPtr(idOrName),
		NlbHost:  core.StringPtr(nlbHost),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetNlbDNSHealthMonitorOptions) SetIdOrName(idOrName string) *GetNlbDNSHealthMonitorOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetNlbHost : Allow user to set NlbHost
func (options *GetNlbDNSHealthMonitorOptions) SetNlbHost(nlbHost string) *GetNlbDNSHealthMonitorOptions {
	options.NlbHost = core.StringPtr(nlbHost)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetNlbDNSHealthMonitorOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetNlbDNSHealthMonitorOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetNlbDNSHealthMonitorOptions) SetHeaders(param map[string]string) *GetNlbDNSHealthMonitorOptions {
	options.Headers = param
	return options
}

// GetNlbDNSListOptions : The GetNlbDNSList options.
type GetNlbDNSListOptions struct {
	// To list the classic clusters that you have access to, use the `GET /v1/clusters API` or run `ibmcloud ks cluster ls
	// --provider classic`. To list the VPC clusters that you have access to, use the `GET /v2/vpc/getClusters` API or run
	// `ibmcloud ks cluster ls --provider vpc-classic`.
	Cluster *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetNlbDNSListOptions : Instantiate GetNlbDNSListOptions
func (*KubernetesServiceApiV1) NewGetNlbDNSListOptions(cluster string) *GetNlbDNSListOptions {
	return &GetNlbDNSListOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetNlbDNSListOptions) SetCluster(cluster string) *GetNlbDNSListOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetNlbDNSListOptions) SetHeaders(param map[string]string) *GetNlbDNSListOptions {
	options.Headers = param
	return options
}

// GetProductConfigOptions : The GetProductConfig options.
type GetProductConfigOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetProductConfigOptions : Instantiate GetProductConfigOptions
func (*KubernetesServiceApiV1) NewGetProductConfigOptions() *GetProductConfigOptions {
	return &GetProductConfigOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetProductConfigOptions) SetHeaders(param map[string]string) *GetProductConfigOptions {
	options.Headers = param
	return options
}

// GetQuotaOptions : The GetQuota options.
type GetQuotaOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetQuotaOptions : Instantiate GetQuotaOptions
func (*KubernetesServiceApiV1) NewGetQuotaOptions() *GetQuotaOptions {
	return &GetQuotaOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetQuotaOptions) SetHeaders(param map[string]string) *GetQuotaOptions {
	options.Headers = param
	return options
}

// GetQuotaResource : GetQuotaResource struct
type GetQuotaResource struct {
	Infrastructure *string `json:"infrastructure,omitempty"`

	Regions []GetQuotaResourceRegion `json:"regions,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalGetQuotaResource unmarshals an instance of GetQuotaResource from the specified map of raw messages.
func UnmarshalGetQuotaResource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetQuotaResource)
	err = core.UnmarshalPrimitive(m, "infrastructure", &obj.Infrastructure)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "regions", &obj.Regions, UnmarshalGetQuotaResourceRegion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetQuotaResourceRegion : GetQuotaResourceRegion struct
type GetQuotaResourceRegion struct {
	ID *string `json:"id,omitempty"`

	Quota *int64 `json:"quota,omitempty"`
}

// UnmarshalGetQuotaResourceRegion unmarshals an instance of GetQuotaResourceRegion from the specified map of raw messages.
func UnmarshalGetQuotaResourceRegion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetQuotaResourceRegion)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "quota", &obj.Quota)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetRegionsOptions : The GetRegions options.
type GetRegionsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetRegionsOptions : Instantiate GetRegionsOptions
func (*KubernetesServiceApiV1) NewGetRegionsOptions() *GetRegionsOptions {
	return &GetRegionsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetRegionsOptions) SetHeaders(param map[string]string) *GetRegionsOptions {
	options.Headers = param
	return options
}

// GetSatLocationNlbDNSListOptions : The GetSatLocationNlbDNSList options.
type GetSatLocationNlbDNSListOptions struct {
	// To list available locations, use the GET `/v2/satellite/getControllers` API, or run `ibmcloud sat location ls`.
	Controller *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSatLocationNlbDNSListOptions : Instantiate GetSatLocationNlbDNSListOptions
func (*KubernetesServiceApiV1) NewGetSatLocationNlbDNSListOptions(controller string) *GetSatLocationNlbDNSListOptions {
	return &GetSatLocationNlbDNSListOptions{
		Controller: core.StringPtr(controller),
	}
}

// SetController : Allow user to set Controller
func (options *GetSatLocationNlbDNSListOptions) SetController(controller string) *GetSatLocationNlbDNSListOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSatLocationNlbDNSListOptions) SetHeaders(param map[string]string) *GetSatLocationNlbDNSListOptions {
	options.Headers = param
	return options
}

// GetSatelliteClustersOptions : The GetSatelliteClusters options.
type GetSatelliteClustersOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSatelliteClustersOptions : Instantiate GetSatelliteClustersOptions
func (*KubernetesServiceApiV1) NewGetSatelliteClustersOptions() *GetSatelliteClustersOptions {
	return &GetSatelliteClustersOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetSatelliteClustersOptions) SetHeaders(param map[string]string) *GetSatelliteClustersOptions {
	options.Headers = param
	return options
}

// GetSatelliteHostsOptions : The GetSatelliteHosts options.
type GetSatelliteHostsOptions struct {
	// The ID of the location to to retrieve hosts from.
	Controller *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSatelliteHostsOptions : Instantiate GetSatelliteHostsOptions
func (*KubernetesServiceApiV1) NewGetSatelliteHostsOptions(controller string) *GetSatelliteHostsOptions {
	return &GetSatelliteHostsOptions{
		Controller: core.StringPtr(controller),
	}
}

// SetController : Allow user to set Controller
func (options *GetSatelliteHostsOptions) SetController(controller string) *GetSatelliteHostsOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSatelliteHostsOptions) SetHeaders(param map[string]string) *GetSatelliteHostsOptions {
	options.Headers = param
	return options
}

// GetSatelliteLocationOptions : The GetSatelliteLocation options.
type GetSatelliteLocationOptions struct {
	// The ID of the location to get information about.
	Controller *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSatelliteLocationOptions : Instantiate GetSatelliteLocationOptions
func (*KubernetesServiceApiV1) NewGetSatelliteLocationOptions(controller string) *GetSatelliteLocationOptions {
	return &GetSatelliteLocationOptions{
		Controller: core.StringPtr(controller),
	}
}

// SetController : Allow user to set Controller
func (options *GetSatelliteLocationOptions) SetController(controller string) *GetSatelliteLocationOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSatelliteLocationOptions) SetHeaders(param map[string]string) *GetSatelliteLocationOptions {
	options.Headers = param
	return options
}

// GetSatelliteLocationsOptions : The GetSatelliteLocations options.
type GetSatelliteLocationsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSatelliteLocationsOptions : Instantiate GetSatelliteLocationsOptions
func (*KubernetesServiceApiV1) NewGetSatelliteLocationsOptions() *GetSatelliteLocationsOptions {
	return &GetSatelliteLocationsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetSatelliteLocationsOptions) SetHeaders(param map[string]string) *GetSatelliteLocationsOptions {
	options.Headers = param
	return options
}

// GetSatelliteServiceClustersOptions : The GetSatelliteServiceClusters options.
type GetSatelliteServiceClustersOptions struct {
	// The ID of the location to list services.
	Controller *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSatelliteServiceClustersOptions : Instantiate GetSatelliteServiceClustersOptions
func (*KubernetesServiceApiV1) NewGetSatelliteServiceClustersOptions(controller string) *GetSatelliteServiceClustersOptions {
	return &GetSatelliteServiceClustersOptions{
		Controller: core.StringPtr(controller),
	}
}

// SetController : Allow user to set Controller
func (options *GetSatelliteServiceClustersOptions) SetController(controller string) *GetSatelliteServiceClustersOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSatelliteServiceClustersOptions) SetHeaders(param map[string]string) *GetSatelliteServiceClustersOptions {
	options.Headers = param
	return options
}

// GetSecretOptions : The GetSecret options.
type GetSecretOptions struct {
	// The name or ID of the cluster that you want information about. To list the clusters that you have access to, use the
	// `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The name of the secret that you want information about. To list the secrets that you have access to, use the `GET
	// /ingress/v2/secret/getSecrets` API or run `ibmcloud ks ingress secret ls`.
	Name *string `validate:"required"`

	// The namespace of the secret that you want information about. To list the secrets that you have access to, use the
	// `GET /ingress/v2/secret/getSecrets` API or run `ibmcloud ks ingress secret ls`.
	Namespace *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecretOptions : Instantiate GetSecretOptions
func (*KubernetesServiceApiV1) NewGetSecretOptions(cluster string, name string, namespace string) *GetSecretOptions {
	return &GetSecretOptions{
		Cluster:   core.StringPtr(cluster),
		Name:      core.StringPtr(name),
		Namespace: core.StringPtr(namespace),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetSecretOptions) SetCluster(cluster string) *GetSecretOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetName : Allow user to set Name
func (options *GetSecretOptions) SetName(name string) *GetSecretOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *GetSecretOptions) SetNamespace(namespace string) *GetSecretOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecretOptions) SetHeaders(param map[string]string) *GetSecretOptions {
	options.Headers = param
	return options
}

// GetSecretsOptions : The GetSecrets options.
type GetSecretsOptions struct {
	// The name or ID of the cluster that you want information about. To list the clusters that you have access to, use the
	// `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// To view previously deleted secrets, pass `true`.
	ShowDeleted *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSecretsOptions : Instantiate GetSecretsOptions
func (*KubernetesServiceApiV1) NewGetSecretsOptions(cluster string) *GetSecretsOptions {
	return &GetSecretsOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetSecretsOptions) SetCluster(cluster string) *GetSecretsOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetShowDeleted : Allow user to set ShowDeleted
func (options *GetSecretsOptions) SetShowDeleted(showDeleted string) *GetSecretsOptions {
	options.ShowDeleted = core.StringPtr(showDeleted)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSecretsOptions) SetHeaders(param map[string]string) *GetSecretsOptions {
	options.Headers = param
	return options
}

// GetStatusOptions : The GetStatus options.
type GetStatusOptions struct {
	// The name or ID of the cluster that you want information about.
	Cluster *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStatusOptions : Instantiate GetStatusOptions
func (*KubernetesServiceApiV1) NewGetStatusOptions(cluster string) *GetStatusOptions {
	return &GetStatusOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetStatusOptions) SetCluster(cluster string) *GetStatusOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetStatusOptions) SetHeaders(param map[string]string) *GetStatusOptions {
	options.Headers = param
	return options
}

// GetStorageConfigurationOptions : The GetStorageConfiguration options.
type GetStorageConfigurationOptions struct {
	// The name of the storage configuration. To list the storage configurations that you have access to, run `ibmcloud sat
	// storage config ls`.
	Name *string `validate:"required"`

	// The version of the storage configuration. To list the storage configurations that you have access to, run `ibmcloud
	// sat storage config ls`.
	Version *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStorageConfigurationOptions : Instantiate GetStorageConfigurationOptions
func (*KubernetesServiceApiV1) NewGetStorageConfigurationOptions(name string, version string) *GetStorageConfigurationOptions {
	return &GetStorageConfigurationOptions{
		Name:    core.StringPtr(name),
		Version: core.StringPtr(version),
	}
}

// SetName : Allow user to set Name
func (options *GetStorageConfigurationOptions) SetName(name string) *GetStorageConfigurationOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetVersion : Allow user to set Version
func (options *GetStorageConfigurationOptions) SetVersion(version string) *GetStorageConfigurationOptions {
	options.Version = core.StringPtr(version)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetStorageConfigurationOptions) SetHeaders(param map[string]string) *GetStorageConfigurationOptions {
	options.Headers = param
	return options
}

// GetStorageConfigurationsOptions : The GetStorageConfigurations options.
type GetStorageConfigurationsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStorageConfigurationsOptions : Instantiate GetStorageConfigurationsOptions
func (*KubernetesServiceApiV1) NewGetStorageConfigurationsOptions() *GetStorageConfigurationsOptions {
	return &GetStorageConfigurationsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetStorageConfigurationsOptions) SetHeaders(param map[string]string) *GetStorageConfigurationsOptions {
	options.Headers = param
	return options
}

// GetStorageTemplateOptions : The GetStorageTemplate options.
type GetStorageTemplateOptions struct {
	// The name of the storage template. To list the storage templates (name and version) that you have access to, run
	// `ibmcloud sat storage template ls`.
	Name *string `validate:"required"`

	// The version of the storage template. To list the storage templates (name and version) that you have access to, run
	// `ibmcloud sat storage template ls`.
	Version *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStorageTemplateOptions : Instantiate GetStorageTemplateOptions
func (*KubernetesServiceApiV1) NewGetStorageTemplateOptions(name string, version string) *GetStorageTemplateOptions {
	return &GetStorageTemplateOptions{
		Name:    core.StringPtr(name),
		Version: core.StringPtr(version),
	}
}

// SetName : Allow user to set Name
func (options *GetStorageTemplateOptions) SetName(name string) *GetStorageTemplateOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetVersion : Allow user to set Version
func (options *GetStorageTemplateOptions) SetVersion(version string) *GetStorageTemplateOptions {
	options.Version = core.StringPtr(version)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetStorageTemplateOptions) SetHeaders(param map[string]string) *GetStorageTemplateOptions {
	options.Headers = param
	return options
}

// GetStorageTemplatesOptions : The GetStorageTemplates options.
type GetStorageTemplatesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetStorageTemplatesOptions : Instantiate GetStorageTemplatesOptions
func (*KubernetesServiceApiV1) NewGetStorageTemplatesOptions() *GetStorageTemplatesOptions {
	return &GetStorageTemplatesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetStorageTemplatesOptions) SetHeaders(param map[string]string) *GetStorageTemplatesOptions {
	options.Headers = param
	return options
}

// GetSubnetsOptions : The GetSubnets options.
type GetSubnetsOptions struct {
	// The name of the VPC provider.
	Provider *string `validate:"required"`

	// The name of the zone in which to list subnets.
	Zone *string `validate:"required"`

	// The ID of the VPC.
	Vpc *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSubnetsOptions : Instantiate GetSubnetsOptions
func (*KubernetesServiceApiV1) NewGetSubnetsOptions(provider string, zone string, vpc string) *GetSubnetsOptions {
	return &GetSubnetsOptions{
		Provider: core.StringPtr(provider),
		Zone:     core.StringPtr(zone),
		Vpc:      core.StringPtr(vpc),
	}
}

// SetProvider : Allow user to set Provider
func (options *GetSubnetsOptions) SetProvider(provider string) *GetSubnetsOptions {
	options.Provider = core.StringPtr(provider)
	return options
}

// SetZone : Allow user to set Zone
func (options *GetSubnetsOptions) SetZone(zone string) *GetSubnetsOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetVpc : Allow user to set Vpc
func (options *GetSubnetsOptions) SetVpc(vpc string) *GetSubnetsOptions {
	options.Vpc = core.StringPtr(vpc)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetSubnetsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetSubnetsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetSubnetsOptions) SetHeaders(param map[string]string) *GetSubnetsOptions {
	options.Headers = param
	return options
}

// GetSupportedImagesOptions : The GetSupportedImages options.
type GetSupportedImagesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetSupportedImagesOptions : Instantiate GetSupportedImagesOptions
func (*KubernetesServiceApiV1) NewGetSupportedImagesOptions() *GetSupportedImagesOptions {
	return &GetSupportedImagesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetSupportedImagesOptions) SetHeaders(param map[string]string) *GetSupportedImagesOptions {
	options.Headers = param
	return options
}

// GetUpdatePolicyOptions : The GetUpdatePolicy options.
type GetUpdatePolicyOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetUpdatePolicyOptions : Instantiate GetUpdatePolicyOptions
func (*KubernetesServiceApiV1) NewGetUpdatePolicyOptions(idOrName string) *GetUpdatePolicyOptions {
	return &GetUpdatePolicyOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetUpdatePolicyOptions) SetIdOrName(idOrName string) *GetUpdatePolicyOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetUpdatePolicyOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetUpdatePolicyOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetUpdatePolicyOptions) SetHeaders(param map[string]string) *GetUpdatePolicyOptions {
	options.Headers = param
	return options
}

// GetUserConfigOptions : The GetUserConfig options.
type GetUserConfigOptions struct {
	// Target the IBM Cloud Kubernetes Service region where you want to check the ability to create free and standard
	// clusters. To list available regions, use the `GET /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetUserConfigOptions : Instantiate GetUserConfigOptions
func (*KubernetesServiceApiV1) NewGetUserConfigOptions(xRegion string) *GetUserConfigOptions {
	return &GetUserConfigOptions{
		XRegion: core.StringPtr(xRegion),
	}
}

// SetXRegion : Allow user to set XRegion
func (options *GetUserConfigOptions) SetXRegion(xRegion string) *GetUserConfigOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetUserConfigOptions) SetHeaders(param map[string]string) *GetUserConfigOptions {
	options.Headers = param
	return options
}

// GetUserCredentialsOptions : The GetUserCredentials options.
type GetUserCredentialsOptions struct {
	// Target the IBM Cloud Kubernetes Service region where you want to get infrastructure credential details. To list
	// available regions, use the `GET /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetUserCredentialsOptions : Instantiate GetUserCredentialsOptions
func (*KubernetesServiceApiV1) NewGetUserCredentialsOptions(xRegion string) *GetUserCredentialsOptions {
	return &GetUserCredentialsOptions{
		XRegion: core.StringPtr(xRegion),
	}
}

// SetXRegion : Allow user to set XRegion
func (options *GetUserCredentialsOptions) SetXRegion(xRegion string) *GetUserCredentialsOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetUserCredentialsOptions) SetHeaders(param map[string]string) *GetUserCredentialsOptions {
	options.Headers = param
	return options
}

// GetVLANsOptions : The GetVLANs options.
type GetVLANsOptions struct {
	// The ID of the zone where you want to list available public and private VLANs. To list available zones, run `ibmcloud
	// ks zone ls` or use the `GET /v1/datacenters` API.
	Zone *string `validate:"required"`

	// The resource group to target.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVLANsOptions : Instantiate GetVLANsOptions
func (*KubernetesServiceApiV1) NewGetVLANsOptions(zone string) *GetVLANsOptions {
	return &GetVLANsOptions{
		Zone: core.StringPtr(zone),
	}
}

// SetZone : Allow user to set Zone
func (options *GetVLANsOptions) SetZone(zone string) *GetVLANsOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetVLANsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetVLANsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVLANsOptions) SetHeaders(param map[string]string) *GetVLANsOptions {
	options.Headers = param
	return options
}

// GetVPCOptions : The GetVPC options.
type GetVPCOptions struct {
	// The region of the VPC. To list regions, run `ibmcloud ks regions`.
	XRegion *string `validate:"required"`

	// The name of the infrastructure provider that the VPC is created in. To list infrastructure providers of a VPC, run
	// `ibmcloud ks vpcs` or use the `GET /v2/vpc/getVPCs` API.
	Provider *string `validate:"required"`

	// The ID of the VPC. To list the ID of a VPC, run `ibmcloud ks vpcs` or use the `GET /v2/vpc/getVPCs` API.
	VpcID *string `validate:"required"`

	// Optional, specify a resource group ID to use its API key to list VPCs that the API key of the resource group has
	// access to. To list available resource group IDs, run `ibmcloud resource groups`.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCOptions : Instantiate GetVPCOptions
func (*KubernetesServiceApiV1) NewGetVPCOptions(xRegion string, provider string, vpcID string) *GetVPCOptions {
	return &GetVPCOptions{
		XRegion:  core.StringPtr(xRegion),
		Provider: core.StringPtr(provider),
		VpcID:    core.StringPtr(vpcID),
	}
}

// SetXRegion : Allow user to set XRegion
func (options *GetVPCOptions) SetXRegion(xRegion string) *GetVPCOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetProvider : Allow user to set Provider
func (options *GetVPCOptions) SetProvider(provider string) *GetVPCOptions {
	options.Provider = core.StringPtr(provider)
	return options
}

// SetVpcID : Allow user to set VpcID
func (options *GetVPCOptions) SetVpcID(vpcID string) *GetVPCOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetVPCOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetVPCOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCOptions) SetHeaders(param map[string]string) *GetVPCOptions {
	options.Headers = param
	return options
}

// GetVPCResponse : GetVPC defines a response when getting a VPC.
type GetVPCResponse struct {
	ID *string `json:"id,omitempty"`

	Messages []UserMessage `json:"messages,omitempty"`

	Name *string `json:"name,omitempty"`

	ResourceGroup *string `json:"resourceGroup,omitempty"`
}

// UnmarshalGetVPCResponse unmarshals an instance of GetVPCResponse from the specified map of raw messages.
func UnmarshalGetVPCResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetVPCResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "messages", &obj.Messages, UnmarshalUserMessage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroup", &obj.ResourceGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetVPCsOptions : The GetVPCs options.
type GetVPCsOptions struct {
	// The name of the provider in which to list VPCs.
	Provider *string `validate:"required"`

	// Optional, specify a resource group ID to use its API key to list VPCs that the API key of the resource group has
	// access to. To list available resource group IDs, run `ibmcloud resource groups`.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVPCsOptions : Instantiate GetVPCsOptions
func (*KubernetesServiceApiV1) NewGetVPCsOptions(provider string) *GetVPCsOptions {
	return &GetVPCsOptions{
		Provider: core.StringPtr(provider),
	}
}

// SetProvider : Allow user to set Provider
func (options *GetVPCsOptions) SetProvider(provider string) *GetVPCsOptions {
	options.Provider = core.StringPtr(provider)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetVPCsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetVPCsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVPCsOptions) SetHeaders(param map[string]string) *GetVPCsOptions {
	options.Headers = param
	return options
}

// GetVersionsOptions : The GetVersions options.
type GetVersionsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVersionsOptions : Instantiate GetVersionsOptions
func (*KubernetesServiceApiV1) NewGetVersionsOptions() *GetVersionsOptions {
	return &GetVersionsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *GetVersionsOptions) SetHeaders(param map[string]string) *GetVersionsOptions {
	options.Headers = param
	return options
}

// GetVlanSpanningOptions : The GetVlanSpanning options.
type GetVlanSpanningOptions struct {
	// Target the IBM Cloud Kubernetes Service region where you want to check the VLAN spanning status. To list available
	// regions, use the `GET /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string `validate:"required"`

	// The ID of the resource group. To list available resource group IDs, run `ibmcloud resource groups`.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVlanSpanningOptions : Instantiate GetVlanSpanningOptions
func (*KubernetesServiceApiV1) NewGetVlanSpanningOptions(xRegion string) *GetVlanSpanningOptions {
	return &GetVlanSpanningOptions{
		XRegion: core.StringPtr(xRegion),
	}
}

// SetXRegion : Allow user to set XRegion
func (options *GetVlanSpanningOptions) SetXRegion(xRegion string) *GetVlanSpanningOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetVlanSpanningOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetVlanSpanningOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVlanSpanningOptions) SetHeaders(param map[string]string) *GetVlanSpanningOptions {
	options.Headers = param
	return options
}

// GetVolumeOptions : The GetVolume options.
type GetVolumeOptions struct {
	// The unique volume ID. To list the volume ID, use the `GET /v2/storage/classic/getVolumes` API or run `ibmcloud ks
	// storage volume ls classic`.
	VolumeID *string `validate:"required"`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster-get <cluster>`.
	XAuthResourceGroupID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumeOptions : Instantiate GetVolumeOptions
func (*KubernetesServiceApiV1) NewGetVolumeOptions(volumeID string) *GetVolumeOptions {
	return &GetVolumeOptions{
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetVolumeID : Allow user to set VolumeID
func (options *GetVolumeOptions) SetVolumeID(volumeID string) *GetVolumeOptions {
	options.VolumeID = core.StringPtr(volumeID)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *GetVolumeOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *GetVolumeOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumeOptions) SetHeaders(param map[string]string) *GetVolumeOptions {
	options.Headers = param
	return options
}

// GetVolumesOptions : The GetVolumes options.
type GetVolumesOptions struct {
	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster-get <cluster>`.
	XAuthResourceGroupID *string `validate:"required"`

	// The ID or name of the classic cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls
	// --provider classic`.
	Cluster *string

	// Filter the list for a specific infrastructure provider. Supported values are classic, vpc-classic, and vpc-gen2.
	Provider *string

	// The zone to filter volume results by. To list available zones, run `ibmcloud ks locations`.
	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetVolumesOptions : Instantiate GetVolumesOptions
func (*KubernetesServiceApiV1) NewGetVolumesOptions(xAuthResourceGroupID string) *GetVolumesOptions {
	return &GetVolumesOptions{
		XAuthResourceGroupID: core.StringPtr(xAuthResourceGroupID),
	}
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *GetVolumesOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *GetVolumesOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *GetVolumesOptions) SetCluster(cluster string) *GetVolumesOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetProvider : Allow user to set Provider
func (options *GetVolumesOptions) SetProvider(provider string) *GetVolumesOptions {
	options.Provider = core.StringPtr(provider)
	return options
}

// SetZone : Allow user to set Zone
func (options *GetVolumesOptions) SetZone(zone string) *GetVolumesOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetVolumesOptions) SetHeaders(param map[string]string) *GetVolumesOptions {
	options.Headers = param
	return options
}

// GetWorkerOptions : The GetWorker options.
type GetWorkerOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the VPC clusters that you
	// have access to, use the `GET /v2/vpc/getClusters` API or run `ibmcloud ks cluster ls --provider vpc-classic`.
	Cluster *string `validate:"required"`

	// The ID of the worker node that you want details for. To list all worker nodes for a cluster, use the `GET
	// /v2/getWorkers?cluster=idOrName` API or run `ibmcloud ks worker ls --cluster <cluster_name_or_ID>`.
	Worker *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster?cluster=idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetWorkerOptions : Instantiate GetWorkerOptions
func (*KubernetesServiceApiV1) NewGetWorkerOptions(cluster string, worker string) *GetWorkerOptions {
	return &GetWorkerOptions{
		Cluster: core.StringPtr(cluster),
		Worker:  core.StringPtr(worker),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetWorkerOptions) SetCluster(cluster string) *GetWorkerOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorker : Allow user to set Worker
func (options *GetWorkerOptions) SetWorker(worker string) *GetWorkerOptions {
	options.Worker = core.StringPtr(worker)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetWorkerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetWorkerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetWorkerOptions) SetHeaders(param map[string]string) *GetWorkerOptions {
	options.Headers = param
	return options
}

// GetWorkerPool1Options : The GetWorkerPool1 options.
type GetWorkerPool1Options struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker pool. To list all worker pools for a cluster, use the `GET /v1/clusters/{idOrName}/workerpools`
	// API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	PoolidOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetWorkerPool1Options : Instantiate GetWorkerPool1Options
func (*KubernetesServiceApiV1) NewGetWorkerPool1Options(idOrName string, poolidOrName string) *GetWorkerPool1Options {
	return &GetWorkerPool1Options{
		IdOrName:     core.StringPtr(idOrName),
		PoolidOrName: core.StringPtr(poolidOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetWorkerPool1Options) SetIdOrName(idOrName string) *GetWorkerPool1Options {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetPoolidOrName : Allow user to set PoolidOrName
func (options *GetWorkerPool1Options) SetPoolidOrName(poolidOrName string) *GetWorkerPool1Options {
	options.PoolidOrName = core.StringPtr(poolidOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetWorkerPool1Options) SetXAuthResourceGroup(xAuthResourceGroup string) *GetWorkerPool1Options {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetWorkerPool1Options) SetHeaders(param map[string]string) *GetWorkerPool1Options {
	options.Headers = param
	return options
}

// GetWorkerPoolOptions : The GetWorkerPool options.
type GetWorkerPoolOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the VPC clusters that you
	// have access to, use the `GET /v2/vpc/getClusters` API or run `ibmcloud ks cluster ls --provider vpc-classic`.
	Cluster *string `validate:"required"`

	// The ID of the worker pool that you want details for. To list all worker pools for a cluster, use the `GET
	// /v2/getWorkerPools?cluster=idOrName` API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	Workerpool *string `validate:"required"`

	// If you are using the global endpoint, target the Kubernetes Service region. To list available regions, use the `GET
	// /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster?cluster=idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetWorkerPoolOptions : Instantiate GetWorkerPoolOptions
func (*KubernetesServiceApiV1) NewGetWorkerPoolOptions(cluster string, workerpool string) *GetWorkerPoolOptions {
	return &GetWorkerPoolOptions{
		Cluster:    core.StringPtr(cluster),
		Workerpool: core.StringPtr(workerpool),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetWorkerPoolOptions) SetCluster(cluster string) *GetWorkerPoolOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *GetWorkerPoolOptions) SetWorkerpool(workerpool string) *GetWorkerPoolOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXRegion : Allow user to set XRegion
func (options *GetWorkerPoolOptions) SetXRegion(xRegion string) *GetWorkerPoolOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetWorkerPoolOptions) SetHeaders(param map[string]string) *GetWorkerPoolOptions {
	options.Headers = param
	return options
}

// GetWorkerPoolResponse : GetWorkerPoolResponse struct
type GetWorkerPoolResponse struct {
	AutoscaleEnabled *bool `json:"autoscaleEnabled,omitempty"`

	Flavor *string `json:"flavor,omitempty"`

	HostLabels map[string]string `json:"hostLabels,omitempty"`

	ID *string `json:"id,omitempty"`

	IsBalanced *bool `json:"isBalanced,omitempty"`

	Isolation *string `json:"isolation,omitempty"`

	Labels map[string]string `json:"labels,omitempty"`

	Lifecycle *GetWorkerPoolResponseLifecycle `json:"lifecycle,omitempty"`

	OpenshiftLicense *string `json:"openshiftLicense,omitempty"`

	PoolName *string `json:"poolName,omitempty"`

	Provider *string `json:"provider,omitempty"`

	Taints map[string]string `json:"taints,omitempty"`

	VpcID *string `json:"vpcID,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`

	Zones []GetWorkerPoolResponseZone `json:"zones,omitempty"`
}

// UnmarshalGetWorkerPoolResponse unmarshals an instance of GetWorkerPoolResponse from the specified map of raw messages.
func UnmarshalGetWorkerPoolResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerPoolResponse)
	err = core.UnmarshalPrimitive(m, "autoscaleEnabled", &obj.AutoscaleEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "flavor", &obj.Flavor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostLabels", &obj.HostLabels)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isBalanced", &obj.IsBalanced)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isolation", &obj.Isolation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "labels", &obj.Labels)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle", &obj.Lifecycle, UnmarshalGetWorkerPoolResponseLifecycle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "openshiftLicense", &obj.OpenshiftLicense)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "poolName", &obj.PoolName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "taints", &obj.Taints)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcID", &obj.VpcID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalGetWorkerPoolResponseZone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkerPoolResponseLifecycle : GetWorkerPoolResponseLifecycle struct
type GetWorkerPoolResponseLifecycle struct {
	ActualState *string `json:"actualState,omitempty"`

	DesiredState *string `json:"desiredState,omitempty"`
}

// UnmarshalGetWorkerPoolResponseLifecycle unmarshals an instance of GetWorkerPoolResponseLifecycle from the specified map of raw messages.
func UnmarshalGetWorkerPoolResponseLifecycle(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerPoolResponseLifecycle)
	err = core.UnmarshalPrimitive(m, "actualState", &obj.ActualState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "desiredState", &obj.DesiredState)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkerPoolResponseZone : GetWorkerPoolResponseZone provides information about a zone belonging to the worker pool.
type GetWorkerPoolResponseZone struct {
	AutobalanceEnabled *bool `json:"autobalanceEnabled,omitempty"`

	ID *string `json:"id,omitempty"`

	Messages []string `json:"messages,omitempty"`

	Subnets []GetWorkerPoolResponseZoneSubnet `json:"subnets,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`
}

// UnmarshalGetWorkerPoolResponseZone unmarshals an instance of GetWorkerPoolResponseZone from the specified map of raw messages.
func UnmarshalGetWorkerPoolResponseZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerPoolResponseZone)
	err = core.UnmarshalPrimitive(m, "autobalanceEnabled", &obj.AutobalanceEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "messages", &obj.Messages)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalGetWorkerPoolResponseZoneSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkerPoolResponseZoneSubnet : GetWorkerPoolResponseZoneSubnet provides information about a subnet in the worker pool's zone.
type GetWorkerPoolResponseZoneSubnet struct {
	ID *string `json:"id,omitempty"`

	Primary *bool `json:"primary,omitempty"`
}

// UnmarshalGetWorkerPoolResponseZoneSubnet unmarshals an instance of GetWorkerPoolResponseZoneSubnet from the specified map of raw messages.
func UnmarshalGetWorkerPoolResponseZoneSubnet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerPoolResponseZoneSubnet)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primary", &obj.Primary)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkerPools1Options : The GetWorkerPools1 options.
type GetWorkerPools1Options struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the VPC clusters that you
	// have access to, use the `GET /v2/vpc/getClusters` API or run `ibmcloud ks cluster ls --provider vpc-classic`.
	Cluster *string `validate:"required"`

	// If you are using the global endpoint, target the Kubernetes Service region. To list available regions, use the `GET
	// /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster?cluster=idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetWorkerPools1Options : Instantiate GetWorkerPools1Options
func (*KubernetesServiceApiV1) NewGetWorkerPools1Options(cluster string) *GetWorkerPools1Options {
	return &GetWorkerPools1Options{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetWorkerPools1Options) SetCluster(cluster string) *GetWorkerPools1Options {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXRegion : Allow user to set XRegion
func (options *GetWorkerPools1Options) SetXRegion(xRegion string) *GetWorkerPools1Options {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetWorkerPools1Options) SetXAuthResourceGroup(xAuthResourceGroup string) *GetWorkerPools1Options {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetWorkerPools1Options) SetHeaders(param map[string]string) *GetWorkerPools1Options {
	options.Headers = param
	return options
}

// GetWorkerPoolsOptions : The GetWorkerPools options.
type GetWorkerPoolsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetWorkerPoolsOptions : Instantiate GetWorkerPoolsOptions
func (*KubernetesServiceApiV1) NewGetWorkerPoolsOptions(idOrName string) *GetWorkerPoolsOptions {
	return &GetWorkerPoolsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetWorkerPoolsOptions) SetIdOrName(idOrName string) *GetWorkerPoolsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetWorkerPoolsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetWorkerPoolsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetWorkerPoolsOptions) SetHeaders(param map[string]string) *GetWorkerPoolsOptions {
	options.Headers = param
	return options
}

// GetWorkerResponse : GetWorkerResponse struct
type GetWorkerResponse struct {
	Flavor *string `json:"flavor,omitempty"`

	Health *GetWorkerResponseHealth `json:"health,omitempty"`

	ID *string `json:"id,omitempty"`

	KubeVersion *GetWorkerResponseKubeVersion `json:"kubeVersion,omitempty"`

	Lifecycle *GetWorkerResponseLifecycle `json:"lifecycle,omitempty"`

	Location *string `json:"location,omitempty"`

	NetworkInformation *GetWorkerResponseNetworkInformation `json:"networkInformation,omitempty"`

	PoolID *string `json:"poolID,omitempty"`

	PoolName *string `json:"poolName,omitempty"`
}

// UnmarshalGetWorkerResponse unmarshals an instance of GetWorkerResponse from the specified map of raw messages.
func UnmarshalGetWorkerResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerResponse)
	err = core.UnmarshalPrimitive(m, "flavor", &obj.Flavor)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health", &obj.Health, UnmarshalGetWorkerResponseHealth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "kubeVersion", &obj.KubeVersion, UnmarshalGetWorkerResponseKubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle", &obj.Lifecycle, UnmarshalGetWorkerResponseLifecycle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "networkInformation", &obj.NetworkInformation, UnmarshalGetWorkerResponseNetworkInformation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "poolID", &obj.PoolID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "poolName", &obj.PoolName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkerResponseHealth : GetWorkerResponseHealth struct
type GetWorkerResponseHealth struct {
	Message *string `json:"message,omitempty"`

	State *string `json:"state,omitempty"`
}

// UnmarshalGetWorkerResponseHealth unmarshals an instance of GetWorkerResponseHealth from the specified map of raw messages.
func UnmarshalGetWorkerResponseHealth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerResponseHealth)
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkerResponseKubeVersion : GetWorkerResponseKubeVersion struct
type GetWorkerResponseKubeVersion struct {
	Actual *string `json:"actual,omitempty"`

	Desired *string `json:"desired,omitempty"`

	Eos *string `json:"eos,omitempty"`

	MasterEOS *string `json:"masterEOS,omitempty"`

	Target *string `json:"target,omitempty"`
}

// UnmarshalGetWorkerResponseKubeVersion unmarshals an instance of GetWorkerResponseKubeVersion from the specified map of raw messages.
func UnmarshalGetWorkerResponseKubeVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerResponseKubeVersion)
	err = core.UnmarshalPrimitive(m, "actual", &obj.Actual)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "desired", &obj.Desired)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "eos", &obj.Eos)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterEOS", &obj.MasterEOS)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "target", &obj.Target)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkerResponseLifecycle : GetWorkerResponseLifecycle struct
type GetWorkerResponseLifecycle struct {
	ActualState *string `json:"actualState,omitempty"`

	// Possible state values include critical, deployed, deploying, deploy_failed, normal, provisioning, provision_failed,
	// reloading, reload_failed, reload_pending, unknown, and warning. For more information, see the docs
	// 'http://ibm.biz/worker-health-state'.
	DesiredState *string `json:"desiredState,omitempty"`

	Message *string `json:"message,omitempty"`

	MessageDate *string `json:"messageDate,omitempty"`

	MessageDetails *string `json:"messageDetails,omitempty"`

	MessageDetailsDate *string `json:"messageDetailsDate,omitempty"`

	PendingOperation *string `json:"pendingOperation,omitempty"`

	ReasonForDelete *string `json:"reasonForDelete,omitempty"`
}

// UnmarshalGetWorkerResponseLifecycle unmarshals an instance of GetWorkerResponseLifecycle from the specified map of raw messages.
func UnmarshalGetWorkerResponseLifecycle(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerResponseLifecycle)
	err = core.UnmarshalPrimitive(m, "actualState", &obj.ActualState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "desiredState", &obj.DesiredState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "messageDate", &obj.MessageDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "messageDetails", &obj.MessageDetails)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "messageDetailsDate", &obj.MessageDetailsDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pendingOperation", &obj.PendingOperation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reasonForDelete", &obj.ReasonForDelete)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkerResponseNetworkInformation : GetWorkerResponseNetworkInformation struct
type GetWorkerResponseNetworkInformation struct {
	PrivateIP *string `json:"privateIP,omitempty"`

	PrivateVLAN *string `json:"privateVLAN,omitempty"`

	PublicIP *string `json:"publicIP,omitempty"`

	PublicVLAN *string `json:"publicVLAN,omitempty"`
}

// UnmarshalGetWorkerResponseNetworkInformation unmarshals an instance of GetWorkerResponseNetworkInformation from the specified map of raw messages.
func UnmarshalGetWorkerResponseNetworkInformation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(GetWorkerResponseNetworkInformation)
	err = core.UnmarshalPrimitive(m, "privateIP", &obj.PrivateIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateVLAN", &obj.PrivateVLAN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicIP", &obj.PublicIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicVLAN", &obj.PublicVLAN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// GetWorkers1Options : The GetWorkers1 options.
type GetWorkers1Options struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the VPC clusters that you
	// have access to, use the `GET /v2/vpc/getClusters` API or run `ibmcloud ks cluster ls --provider vpc-classic`.
	Cluster *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster?cluster=idOrName` API.
	XAuthResourceGroup *string

	// true|false Shows deleted workers.
	ShowDeleted *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetWorkers1Options : Instantiate GetWorkers1Options
func (*KubernetesServiceApiV1) NewGetWorkers1Options(cluster string) *GetWorkers1Options {
	return &GetWorkers1Options{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *GetWorkers1Options) SetCluster(cluster string) *GetWorkers1Options {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetWorkers1Options) SetXAuthResourceGroup(xAuthResourceGroup string) *GetWorkers1Options {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetShowDeleted : Allow user to set ShowDeleted
func (options *GetWorkers1Options) SetShowDeleted(showDeleted string) *GetWorkers1Options {
	options.ShowDeleted = core.StringPtr(showDeleted)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetWorkers1Options) SetHeaders(param map[string]string) *GetWorkers1Options {
	options.Headers = param
	return options
}

// GetWorkersOptions : The GetWorkers options.
type GetWorkersOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker node that you want details for. To list all worker nodes for a cluster, use the `GET
	// /v1/clusters/{idOrName}/workers` API or run `ibmcloud ks worker ls --cluster <cluster_name_or_ID>`.
	WorkerID *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetWorkersOptions : Instantiate GetWorkersOptions
func (*KubernetesServiceApiV1) NewGetWorkersOptions(idOrName string, workerID string) *GetWorkersOptions {
	return &GetWorkersOptions{
		IdOrName: core.StringPtr(idOrName),
		WorkerID: core.StringPtr(workerID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *GetWorkersOptions) SetIdOrName(idOrName string) *GetWorkersOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetWorkerID : Allow user to set WorkerID
func (options *GetWorkersOptions) SetWorkerID(workerID string) *GetWorkersOptions {
	options.WorkerID = core.StringPtr(workerID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *GetWorkersOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *GetWorkersOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetWorkersOptions) SetHeaders(param map[string]string) *GetWorkersOptions {
	options.Headers = param
	return options
}

// GetZonesOptions : The GetZones options.
type GetZonesOptions struct {
	// Specify true or false to show the machine types available in each zone.
	ShowFlavors *string

	// Specify a location to filter zones for. To see supported locations, use the `GET /v1/locations` API or run
	// `ibmcloud ks locations`.
	Location *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetZonesOptions : Instantiate GetZonesOptions
func (*KubernetesServiceApiV1) NewGetZonesOptions() *GetZonesOptions {
	return &GetZonesOptions{}
}

// SetShowFlavors : Allow user to set ShowFlavors
func (options *GetZonesOptions) SetShowFlavors(showFlavors string) *GetZonesOptions {
	options.ShowFlavors = core.StringPtr(showFlavors)
	return options
}

// SetLocation : Allow user to set Location
func (options *GetZonesOptions) SetLocation(location string) *GetZonesOptions {
	options.Location = core.StringPtr(location)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *GetZonesOptions) SetHeaders(param map[string]string) *GetZonesOptions {
	options.Headers = param
	return options
}

// HandleMasterAPIServerOptions : The HandleMasterAPIServer options.
type HandleMasterAPIServerOptions struct {
	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string `validate:"required"`

	// The name or ID of the cluster that you want to interact with. To list the clusters that you have access to, use the
	// `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The action to perform on the API Server.
	Action *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewHandleMasterAPIServerOptions : Instantiate HandleMasterAPIServerOptions
func (*KubernetesServiceApiV1) NewHandleMasterAPIServerOptions(xAuthResourceGroup string, idOrName string) *HandleMasterAPIServerOptions {
	return &HandleMasterAPIServerOptions{
		XAuthResourceGroup: core.StringPtr(xAuthResourceGroup),
		IdOrName:           core.StringPtr(idOrName),
	}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *HandleMasterAPIServerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *HandleMasterAPIServerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetIdOrName : Allow user to set IdOrName
func (options *HandleMasterAPIServerOptions) SetIdOrName(idOrName string) *HandleMasterAPIServerOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAction : Allow user to set Action
func (options *HandleMasterAPIServerOptions) SetAction(action string) *HandleMasterAPIServerOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *HandleMasterAPIServerOptions) SetHeaders(param map[string]string) *HandleMasterAPIServerOptions {
	options.Headers = param
	return options
}

// Health : Health is the health status of the host.
type Health struct {
	// A message to describe the health status.
	Message *string `json:"message,omitempty"`

	// The timestamp of the last health status update.
	ModifiedDate *string `json:"modifiedDate,omitempty"`

	// The health status of the workload that runs on the host. Possible values include normal, provisioning, unknown,
	// unresponsive, ready, and reload-required. For more information, see the docs 'http://ibm.biz/sat-host-health'.
	Status *string `json:"status,omitempty"`
}

// UnmarshalHealth unmarshals an instance of Health from the specified map of raw messages.
func UnmarshalHealth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Health)
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "modifiedDate", &obj.ModifiedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HealthcheckProperties : HealthcheckProperties used for storing config provided by user for healthcheck.
type HealthcheckProperties struct {
	AllowInsecure *bool `json:"allow_insecure,omitempty"`

	ExpectedBody *string `json:"expectedBody,omitempty"`

	ExpectedCodes *string `json:"expectedCodes,omitempty"`

	FollowRedirects *bool `json:"follow_redirects,omitempty"`

	Header map[string][]string `json:"header,omitempty"`

	Interval *int64 `json:"interval,omitempty"`

	Method *string `json:"method,omitempty"`

	Name *string `json:"name,omitempty"`

	Path *string `json:"path,omitempty"`

	Port *int64 `json:"port,omitempty"`

	Retries *int64 `json:"retries,omitempty"`

	Timeout *int64 `json:"timeout,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalHealthcheckProperties unmarshals an instance of HealthcheckProperties from the specified map of raw messages.
func UnmarshalHealthcheckProperties(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HealthcheckProperties)
	err = core.UnmarshalPrimitive(m, "allow_insecure", &obj.AllowInsecure)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expectedBody", &obj.ExpectedBody)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expectedCodes", &obj.ExpectedCodes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "follow_redirects", &obj.FollowRedirects)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "header", &obj.Header)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "method", &obj.Method)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "retries", &obj.Retries)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timeout", &obj.Timeout)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Hosts : Hosts lists the hosts belonging to the IBM Cloud Satellite location.
type Hosts struct {
	// The available number of hosts that can be assigned to a cluster resource in the Satellite location.
	Available *int64 `json:"available,omitempty"`

	// The total number of hosts that are attached to the Satellite location.
	Total *int64 `json:"total,omitempty"`
}

// UnmarshalHosts unmarshals an instance of Hosts from the specified map of raw messages.
func UnmarshalHosts(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Hosts)
	err = core.UnmarshalPrimitive(m, "available", &obj.Available)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total", &obj.Total)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IKSLocation : IKSLocation properties.
type IKSLocation struct {
	Country *string `json:"country,omitempty"`

	DisplayName *string `json:"display_name,omitempty"`

	Geography *string `json:"geography,omitempty"`

	ID *string `json:"id,omitempty"`

	Kind *string `json:"kind,omitempty"`

	Metro *string `json:"metro,omitempty"`

	MultizoneMetro *string `json:"multizone_metro,omitempty"`

	Name *string `json:"name,omitempty"`

	SupportsFree *bool `json:"supportsFree,omitempty"`
}

// UnmarshalIKSLocation unmarshals an instance of IKSLocation from the specified map of raw messages.
func UnmarshalIKSLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IKSLocation)
	err = core.UnmarshalPrimitive(m, "country", &obj.Country)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "geography", &obj.Geography)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "kind", &obj.Kind)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metro", &obj.Metro)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "multizone_metro", &obj.MultizoneMetro)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "supportsFree", &obj.SupportsFree)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IKSVersion : IKSVersion the IKS version.
type IKSVersion struct {
	Default *bool `json:"default,omitempty"`

	EndOfService *string `json:"end_of_service,omitempty"`

	Major *int64 `json:"major,omitempty"`

	Minor *int64 `json:"minor,omitempty"`

	Patch *int64 `json:"patch,omitempty"`
}

// UnmarshalIKSVersion unmarshals an instance of IKSVersion from the specified map of raw messages.
func UnmarshalIKSVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IKSVersion)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "end_of_service", &obj.EndOfService)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "major", &obj.Major)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minor", &obj.Minor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "patch", &obj.Patch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IngressStatus : IngressStatus status struct for the top level ingress status for a cluster.
type IngressStatus struct {
	StatusList []ComponentStatus `json:"StatusList,omitempty"`

	Cluster *string `json:"cluster,omitempty"`

	Message *string `json:"message,omitempty"`

	Status *string `json:"status,omitempty"`
}

// UnmarshalIngressStatus unmarshals an instance of IngressStatus from the specified map of raw messages.
func UnmarshalIngressStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IngressStatus)
	err = core.UnmarshalModel(m, "StatusList", &obj.StatusList, UnmarshalComponentStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cluster", &obj.Cluster)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// KmsEnableClusterOptions : The KmsEnableCluster options.
type KmsEnableClusterOptions struct {
	Cluster *string

	CrkID *string

	InstanceID *string

	PrivateEndpoint *bool

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewKmsEnableClusterOptions : Instantiate KmsEnableClusterOptions
func (*KubernetesServiceApiV1) NewKmsEnableClusterOptions() *KmsEnableClusterOptions {
	return &KmsEnableClusterOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *KmsEnableClusterOptions) SetCluster(cluster string) *KmsEnableClusterOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetCrkID : Allow user to set CrkID
func (options *KmsEnableClusterOptions) SetCrkID(crkID string) *KmsEnableClusterOptions {
	options.CrkID = core.StringPtr(crkID)
	return options
}

// SetInstanceID : Allow user to set InstanceID
func (options *KmsEnableClusterOptions) SetInstanceID(instanceID string) *KmsEnableClusterOptions {
	options.InstanceID = core.StringPtr(instanceID)
	return options
}

// SetPrivateEndpoint : Allow user to set PrivateEndpoint
func (options *KmsEnableClusterOptions) SetPrivateEndpoint(privateEndpoint bool) *KmsEnableClusterOptions {
	options.PrivateEndpoint = core.BoolPtr(privateEndpoint)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *KmsEnableClusterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *KmsEnableClusterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *KmsEnableClusterOptions) SetHeaders(param map[string]string) *KmsEnableClusterOptions {
	options.Headers = param
	return options
}

// KmsGetCRKsOptions : The KmsGetCRKs options.
type KmsGetCRKsOptions struct {
	// The KMS instance ID to list root keys for. To list available Key Protect service instances, run 'ibmcloud ks kms
	// instance ls'.
	KmsInstance *string `validate:"required"`

	// The ID of the resource group. To list available resource group IDs, run `ibmcloud resource groups`.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewKmsGetCRKsOptions : Instantiate KmsGetCRKsOptions
func (*KubernetesServiceApiV1) NewKmsGetCRKsOptions(kmsInstance string) *KmsGetCRKsOptions {
	return &KmsGetCRKsOptions{
		KmsInstance: core.StringPtr(kmsInstance),
	}
}

// SetKmsInstance : Allow user to set KmsInstance
func (options *KmsGetCRKsOptions) SetKmsInstance(kmsInstance string) *KmsGetCRKsOptions {
	options.KmsInstance = core.StringPtr(kmsInstance)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *KmsGetCRKsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *KmsGetCRKsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *KmsGetCRKsOptions) SetHeaders(param map[string]string) *KmsGetCRKsOptions {
	options.Headers = param
	return options
}

// KmsGetInstancesOptions : The KmsGetInstances options.
type KmsGetInstancesOptions struct {
	// The ID of the resource group. To list available resource group IDs, run `ibmcloud resource groups`.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewKmsGetInstancesOptions : Instantiate KmsGetInstancesOptions
func (*KubernetesServiceApiV1) NewKmsGetInstancesOptions() *KmsGetInstancesOptions {
	return &KmsGetInstancesOptions{}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *KmsGetInstancesOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *KmsGetInstancesOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *KmsGetInstancesOptions) SetHeaders(param map[string]string) *KmsGetInstancesOptions {
	options.Headers = param
	return options
}

// KubeVersion : KubeVersion the kubernetes version.
type KubeVersion struct {
	Default *bool `json:"default,omitempty"`

	EndOfService *string `json:"end_of_service,omitempty"`

	Major *int64 `json:"major,omitempty"`

	Minor *int64 `json:"minor,omitempty"`

	Patch *int64 `json:"patch,omitempty"`
}

// UnmarshalKubeVersion unmarshals an instance of KubeVersion from the specified map of raw messages.
func UnmarshalKubeVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(KubeVersion)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "end_of_service", &obj.EndOfService)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "major", &obj.Major)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minor", &obj.Minor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "patch", &obj.Patch)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LBConfig : LBConfig struct models load balancer configuration.
type LBConfig struct {
	Cluster *string `json:"cluster,omitempty"`

	// LBProxyProtocolConfig stuct for storing the loadbalancer's proxy protocol config in etcd.
	ProxyProtocol *LBProxyProtocolConfig `json:"proxyProtocol,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalLBConfig unmarshals an instance of LBConfig from the specified map of raw messages.
func UnmarshalLBConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LBConfig)
	err = core.UnmarshalPrimitive(m, "cluster", &obj.Cluster)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "proxyProtocol", &obj.ProxyProtocol, UnmarshalLBProxyProtocolConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LBProxyProtocolConfig : LBProxyProtocolConfig stuct for storing the loadbalancer's proxy protocol config in etcd.
type LBProxyProtocolConfig struct {
	Cidr []string `json:"cidr,omitempty"`

	Enable *bool `json:"enable,omitempty"`

	HeaderTimeout *int64 `json:"headerTimeout,omitempty"`
}

// UnmarshalLBProxyProtocolConfig unmarshals an instance of LBProxyProtocolConfig from the specified map of raw messages.
func UnmarshalLBProxyProtocolConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LBProxyProtocolConfig)
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable", &obj.Enable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "headerTimeout", &obj.HeaderTimeout)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Label : Label a host label key value pair.
type Label struct {
	Key *string `json:"key,omitempty"`

	Value *string `json:"value,omitempty"`
}

// UnmarshalLabel unmarshals an instance of Label from the specified map of raw messages.
func UnmarshalLabel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Label)
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "value", &obj.Value)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ListLocationsOptions : The ListLocations options.
type ListLocationsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListLocationsOptions : Instantiate ListLocationsOptions
func (*KubernetesServiceApiV1) NewListLocationsOptions() *ListLocationsOptions {
	return &ListLocationsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListLocationsOptions) SetHeaders(param map[string]string) *ListLocationsOptions {
	options.Headers = param
	return options
}

// ListNLBIPsForSubdomainOptions : The ListNLBIPsForSubdomain options.
type ListNLBIPsForSubdomainOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListNLBIPsForSubdomainOptions : Instantiate ListNLBIPsForSubdomainOptions
func (*KubernetesServiceApiV1) NewListNLBIPsForSubdomainOptions(idOrName string) *ListNLBIPsForSubdomainOptions {
	return &ListNLBIPsForSubdomainOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ListNLBIPsForSubdomainOptions) SetIdOrName(idOrName string) *ListNLBIPsForSubdomainOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ListNLBIPsForSubdomainOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ListNLBIPsForSubdomainOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNLBIPsForSubdomainOptions) SetHeaders(param map[string]string) *ListNLBIPsForSubdomainOptions {
	options.Headers = param
	return options
}

// ListNlbDNSHealthMonitorStatusOptions : The ListNlbDNSHealthMonitorStatus options.
type ListNlbDNSHealthMonitorStatusOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListNlbDNSHealthMonitorStatusOptions : Instantiate ListNlbDNSHealthMonitorStatusOptions
func (*KubernetesServiceApiV1) NewListNlbDNSHealthMonitorStatusOptions(idOrName string) *ListNlbDNSHealthMonitorStatusOptions {
	return &ListNlbDNSHealthMonitorStatusOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ListNlbDNSHealthMonitorStatusOptions) SetIdOrName(idOrName string) *ListNlbDNSHealthMonitorStatusOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ListNlbDNSHealthMonitorStatusOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ListNlbDNSHealthMonitorStatusOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNlbDNSHealthMonitorStatusOptions) SetHeaders(param map[string]string) *ListNlbDNSHealthMonitorStatusOptions {
	options.Headers = param
	return options
}

// ListNlbDNSHealthMonitorsOptions : The ListNlbDNSHealthMonitors options.
type ListNlbDNSHealthMonitorsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListNlbDNSHealthMonitorsOptions : Instantiate ListNlbDNSHealthMonitorsOptions
func (*KubernetesServiceApiV1) NewListNlbDNSHealthMonitorsOptions(idOrName string) *ListNlbDNSHealthMonitorsOptions {
	return &ListNlbDNSHealthMonitorsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ListNlbDNSHealthMonitorsOptions) SetIdOrName(idOrName string) *ListNlbDNSHealthMonitorsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ListNlbDNSHealthMonitorsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ListNlbDNSHealthMonitorsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListNlbDNSHealthMonitorsOptions) SetHeaders(param map[string]string) *ListNlbDNSHealthMonitorsOptions {
	options.Headers = param
	return options
}

// ListServicesForAllNamespacesOptions : The ListServicesForAllNamespaces options.
type ListServicesForAllNamespacesOptions struct {
	// The name or ID of the cluster where you want to list bound IBM Cloud services. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListServicesForAllNamespacesOptions : Instantiate ListServicesForAllNamespacesOptions
func (*KubernetesServiceApiV1) NewListServicesForAllNamespacesOptions(idOrName string) *ListServicesForAllNamespacesOptions {
	return &ListServicesForAllNamespacesOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ListServicesForAllNamespacesOptions) SetIdOrName(idOrName string) *ListServicesForAllNamespacesOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ListServicesForAllNamespacesOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ListServicesForAllNamespacesOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListServicesForAllNamespacesOptions) SetHeaders(param map[string]string) *ListServicesForAllNamespacesOptions {
	options.Headers = param
	return options
}

// ListServicesInNamespaceOptions : The ListServicesInNamespace options.
type ListServicesInNamespaceOptions struct {
	// The name or ID of the cluster where you want to list bound IBM Cloud services. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The Kubernetes namespace in your cluster where you want to list all bound IBM Cloud services.
	Namespace *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListServicesInNamespaceOptions : Instantiate ListServicesInNamespaceOptions
func (*KubernetesServiceApiV1) NewListServicesInNamespaceOptions(idOrName string, namespace string) *ListServicesInNamespaceOptions {
	return &ListServicesInNamespaceOptions{
		IdOrName:  core.StringPtr(idOrName),
		Namespace: core.StringPtr(namespace),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ListServicesInNamespaceOptions) SetIdOrName(idOrName string) *ListServicesInNamespaceOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *ListServicesInNamespaceOptions) SetNamespace(namespace string) *ListServicesInNamespaceOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ListServicesInNamespaceOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ListServicesInNamespaceOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListServicesInNamespaceOptions) SetHeaders(param map[string]string) *ListServicesInNamespaceOptions {
	options.Headers = param
	return options
}

// ListSubnetsOptions : The ListSubnets options.
type ListSubnetsOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// A comma seperated list of datacenters to filter subnets based off of.
	Datacenters *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListSubnetsOptions : Instantiate ListSubnetsOptions
func (*KubernetesServiceApiV1) NewListSubnetsOptions(xAuthRefreshToken string) *ListSubnetsOptions {
	return &ListSubnetsOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *ListSubnetsOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *ListSubnetsOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ListSubnetsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ListSubnetsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetDatacenters : Allow user to set Datacenters
func (options *ListSubnetsOptions) SetDatacenters(datacenters string) *ListSubnetsOptions {
	options.Datacenters = core.StringPtr(datacenters)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ListSubnetsOptions) SetHeaders(param map[string]string) *ListSubnetsOptions {
	options.Headers = param
	return options
}

// LogConfigResponse : LogConfigResponse is how users will see their logging configs from API responses.
type LogConfigResponse struct {
	// A list of container names that you want to collect logs for.
	AppLogContainers []string `json:"appLogContainers,omitempty"`

	// A list of app paths that you want to collect logs for.
	AppLogPaths []string `json:"appLogPaths,omitempty"`

	// The name of the Kubernetes secret that holds the Certificate Authority certificate that you want to use for the
	// syslog TLS termination.
	CaCert *string `json:"caCert,omitempty"`

	// The IBM Cloud Log Analysis with LogDNA API endpoint that the logging configuration uses.
	Endpoint *string `json:"endpoint,omitempty"`

	// A list of errors that occurred during the last logging config update.
	Errors []string `json:"errors,omitempty"`

	// The unique identifier of the log source.
	ID *string `json:"id,omitempty"`

	// The type of logs that you want to read and forward to the logging server. Supported values are `container`,
	// `kubernetes`, `ingress`, `worker`, and `application`.
	LogSource *string `json:"logSource,omitempty"`

	// A list of container names that logs are collected for and forwarded to the logging server.
	LogSourceContainers []string `json:"logSourceContainers,omitempty"`

	// A list of app paths that logs are collected for and forwarded to the logging server.
	LogSourcePaths []string `json:"logSourcePaths,omitempty"`

	// The logging protocol to use. Supported values are `syslog` and `ibm`.
	LoggingType *string `json:"loggingType,omitempty"`

	// The Kubernetes namespace where the logging type is applied. This parameter is set only when the `container` log
	// source is used.
	Namespace *string `json:"namespace,omitempty"`

	// The name of the Cloud Foundry organization where the logging configuration was created.
	Org *string `json:"org,omitempty"`

	// The GUID of the Cloud Foundry organization where the logging configuration was created.
	OrgGUID *string `json:"orgGUID,omitempty"`

	// The protocol that you want to use for syslog forwarding. Supported values are `TCP` and `UDP`. If no value is
	// provided, the protocol is set to `UDP` by default.
	Protocol *string `json:"protocol,omitempty"`

	// The port of the logging server.
	RemoteLogPort *int64 `json:"remoteLogPort,omitempty"`

	// The hostname or IP address of the logging server.
	RemoteLogServer *string `json:"remoteLogServer,omitempty"`

	// The name of the Cloud Foundry space where the logging configuration was created.
	Space *string `json:"space,omitempty"`

	// The GUID of the Cloud Foundry space where the logging configuration was created.
	SpaceGUID *string `json:"spaceGUID,omitempty"`

	// The verification mode that is used for the syslog TLS protocol.
	VerifyMode *string `json:"verifyMode,omitempty"`

	// Internal use only.
	Version *string `json:"version,omitempty"`
}

// UnmarshalLogConfigResponse unmarshals an instance of LogConfigResponse from the specified map of raw messages.
func UnmarshalLogConfigResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LogConfigResponse)
	err = core.UnmarshalPrimitive(m, "appLogContainers", &obj.AppLogContainers)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "appLogPaths", &obj.AppLogPaths)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "caCert", &obj.CaCert)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "endpoint", &obj.Endpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "errors", &obj.Errors)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "logSource", &obj.LogSource)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "logSourceContainers", &obj.LogSourceContainers)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "logSourcePaths", &obj.LogSourcePaths)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "loggingType", &obj.LoggingType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "namespace", &obj.Namespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "org", &obj.Org)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "orgGUID", &obj.OrgGUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "protocol", &obj.Protocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remoteLogPort", &obj.RemoteLogPort)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remoteLogServer", &obj.RemoteLogServer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "space", &obj.Space)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "spaceGUID", &obj.SpaceGUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verifyMode", &obj.VerifyMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MSCRegisterResp : type MSCRegisterResp returned once multishift controller domains have been registered.
type MSCRegisterResp struct {
	Controller *string `json:"controller,omitempty"`

	DnsRegistrations []DNSRegistration `json:"dnsRegistrations,omitempty"`
}

// UnmarshalMSCRegisterResp unmarshals an instance of MSCRegisterResp from the specified map of raw messages.
func UnmarshalMSCRegisterResp(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MSCRegisterResp)
	err = core.UnmarshalPrimitive(m, "controller", &obj.Controller)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dnsRegistrations", &obj.DnsRegistrations, UnmarshalDNSRegistration)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MachineType : MachineType properties.
type MachineType struct {
	Cores *string `json:"cores,omitempty"`

	CorrespondingMachineType *string `json:"correspondingMachineType,omitempty"`

	Deprecated *bool `json:"deprecated,omitempty"`

	Gpus *string `json:"gpus,omitempty"`

	IsTrusted *bool `json:"isTrusted,omitempty"`

	Memory *string `json:"memory,omitempty"`

	Name *string `json:"name,omitempty"`

	NetworkSpeed *string `json:"networkSpeed,omitempty"`

	OcpUnsupported *bool `json:"ocp_unsupported,omitempty"`

	Os *string `json:"os,omitempty"`

	Provider *string `json:"provider,omitempty"`

	SecondaryStorage *string `json:"secondaryStorage,omitempty"`

	SecondaryStorageEncrypted *bool `json:"secondaryStorageEncrypted,omitempty"`

	ServerType *string `json:"serverType,omitempty"`

	Storage *string `json:"storage,omitempty"`
}

// UnmarshalMachineType unmarshals an instance of MachineType from the specified map of raw messages.
func UnmarshalMachineType(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MachineType)
	err = core.UnmarshalPrimitive(m, "cores", &obj.Cores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "correspondingMachineType", &obj.CorrespondingMachineType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deprecated", &obj.Deprecated)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "gpus", &obj.Gpus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isTrusted", &obj.IsTrusted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkSpeed", &obj.NetworkSpeed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ocp_unsupported", &obj.OcpUnsupported)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "os", &obj.Os)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secondaryStorage", &obj.SecondaryStorage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secondaryStorageEncrypted", &obj.SecondaryStorageEncrypted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serverType", &obj.ServerType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage", &obj.Storage)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ManageClusterAddonsOptions : The ManageClusterAddons options.
type ManageClusterAddonsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The addons to operate on.
	Addons []ClusterAddon `validate:"required"`

	// Indicate if the specified addons should be enabled or disabled.
	Enable *bool

	// Indicate if the specified addons should be updated. Only Update or Enable should be used, not both.
	Update *bool

	// The resource group that the cluster is in. To check the resource group of the cluster, use the `GET
	// /v1/clusters/{idOrName}` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewManageClusterAddonsOptions : Instantiate ManageClusterAddonsOptions
func (*KubernetesServiceApiV1) NewManageClusterAddonsOptions(idOrName string, addons []ClusterAddon) *ManageClusterAddonsOptions {
	return &ManageClusterAddonsOptions{
		IdOrName: core.StringPtr(idOrName),
		Addons:   addons,
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ManageClusterAddonsOptions) SetIdOrName(idOrName string) *ManageClusterAddonsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAddons : Allow user to set Addons
func (options *ManageClusterAddonsOptions) SetAddons(addons []ClusterAddon) *ManageClusterAddonsOptions {
	options.Addons = addons
	return options
}

// SetEnable : Allow user to set Enable
func (options *ManageClusterAddonsOptions) SetEnable(enable bool) *ManageClusterAddonsOptions {
	options.Enable = core.BoolPtr(enable)
	return options
}

// SetUpdate : Allow user to set Update
func (options *ManageClusterAddonsOptions) SetUpdate(update bool) *ManageClusterAddonsOptions {
	options.Update = core.BoolPtr(update)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ManageClusterAddonsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ManageClusterAddonsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ManageClusterAddonsOptions) SetHeaders(param map[string]string) *ManageClusterAddonsOptions {
	options.Headers = param
	return options
}

// MasterLogCollectionStatusResponseBody : MasterLogCollectionStatusResponseBody is the response body format for log collection statuses.
type MasterLogCollectionStatusResponseBody struct {
	// A list of errors that occurred when the log collection request was processed.
	Error *string `json:"error,omitempty"`

	// The timestamp when the log collection request was initiated.
	StartTime *string `json:"startTime,omitempty"`

	// The state of the master log collection request.
	State *string `json:"state,omitempty"`

	// A list of s3 URLs that are used for IBM Cloud Object Storage artifacts that are created by the log collection
	// request.
	Urls []string `json:"urls,omitempty"`
}

// UnmarshalMasterLogCollectionStatusResponseBody unmarshals an instance of MasterLogCollectionStatusResponseBody from the specified map of raw messages.
func UnmarshalMasterLogCollectionStatusResponseBody(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MasterLogCollectionStatusResponseBody)
	err = core.UnmarshalPrimitive(m, "error", &obj.Error)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "startTime", &obj.StartTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "urls", &obj.Urls)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MessageResponse : MessageResponse is a user message returned from the API.
type MessageResponse struct {
	ID *string `json:"id,omitempty"`

	Message *string `json:"message,omitempty"`
}

// UnmarshalMessageResponse unmarshals an instance of MessageResponse from the specified map of raw messages.
func UnmarshalMessageResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MessageResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MigratedResource : MigratedResource represents a single resource that has been migrated.
type MigratedResource struct {
	Kind *string `json:"kind,omitempty"`

	MigratedAs []string `json:"migratedAs,omitempty"`

	Name *string `json:"name,omitempty"`

	Namespace *string `json:"namespace,omitempty"`

	Warnings []string `json:"warnings,omitempty"`
}

// UnmarshalMigratedResource unmarshals an instance of MigratedResource from the specified map of raw messages.
func UnmarshalMigratedResource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MigratedResource)
	err = core.UnmarshalPrimitive(m, "kind", &obj.Kind)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "migratedAs", &obj.MigratedAs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "namespace", &obj.Namespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "warnings", &obj.Warnings)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MigrationStatus : MigrationStatus status of the migration job on cluster.
type MigrationStatus struct {
	Cluster *string `json:"cluster,omitempty"`

	MigratedResources []MigratedResource `json:"migratedResources,omitempty"`

	MigrationMode *string `json:"migrationMode,omitempty"`

	Status *string `json:"status,omitempty"`

	SubdomainMap map[string]string `json:"subdomainMap,omitempty"`

	TestSecret *string `json:"testSecret,omitempty"`

	TestSubdomain *string `json:"testSubdomain,omitempty"`
}

// UnmarshalMigrationStatus unmarshals an instance of MigrationStatus from the specified map of raw messages.
func UnmarshalMigrationStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MigrationStatus)
	err = core.UnmarshalPrimitive(m, "cluster", &obj.Cluster)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "migratedResources", &obj.MigratedResources, UnmarshalMigratedResource)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "migrationMode", &obj.MigrationMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subdomainMap", &obj.SubdomainMap)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "testSecret", &obj.TestSecret)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "testSubdomain", &obj.TestSubdomain)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ModifyLoggingInstanceOptions : The ModifyLoggingInstance options.
type ModifyLoggingInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. Required when the API is invoked through a CURL command.
	XAuthRefreshToken *string `validate:"required"`

	Cluster *string

	IngestionKey *string

	Instance *string

	NewInstance *string

	PrivateEndpoint *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewModifyLoggingInstanceOptions : Instantiate ModifyLoggingInstanceOptions
func (*KubernetesServiceApiV1) NewModifyLoggingInstanceOptions(xAuthRefreshToken string) *ModifyLoggingInstanceOptions {
	return &ModifyLoggingInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *ModifyLoggingInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *ModifyLoggingInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *ModifyLoggingInstanceOptions) SetCluster(cluster string) *ModifyLoggingInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetIngestionKey : Allow user to set IngestionKey
func (options *ModifyLoggingInstanceOptions) SetIngestionKey(ingestionKey string) *ModifyLoggingInstanceOptions {
	options.IngestionKey = core.StringPtr(ingestionKey)
	return options
}

// SetInstance : Allow user to set Instance
func (options *ModifyLoggingInstanceOptions) SetInstance(instance string) *ModifyLoggingInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetNewInstance : Allow user to set NewInstance
func (options *ModifyLoggingInstanceOptions) SetNewInstance(newInstance string) *ModifyLoggingInstanceOptions {
	options.NewInstance = core.StringPtr(newInstance)
	return options
}

// SetPrivateEndpoint : Allow user to set PrivateEndpoint
func (options *ModifyLoggingInstanceOptions) SetPrivateEndpoint(privateEndpoint bool) *ModifyLoggingInstanceOptions {
	options.PrivateEndpoint = core.BoolPtr(privateEndpoint)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ModifyLoggingInstanceOptions) SetHeaders(param map[string]string) *ModifyLoggingInstanceOptions {
	options.Headers = param
	return options
}

// ModifyMonitoringInstanceOptions : The ModifyMonitoringInstance options.
type ModifyMonitoringInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. Required when the API is invoked through a CURL command.
	XAuthRefreshToken *string `validate:"required"`

	Cluster *string

	IngestionKey *string

	Instance *string

	NewInstance *string

	PrivateEndpoint *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewModifyMonitoringInstanceOptions : Instantiate ModifyMonitoringInstanceOptions
func (*KubernetesServiceApiV1) NewModifyMonitoringInstanceOptions(xAuthRefreshToken string) *ModifyMonitoringInstanceOptions {
	return &ModifyMonitoringInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *ModifyMonitoringInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *ModifyMonitoringInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *ModifyMonitoringInstanceOptions) SetCluster(cluster string) *ModifyMonitoringInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetIngestionKey : Allow user to set IngestionKey
func (options *ModifyMonitoringInstanceOptions) SetIngestionKey(ingestionKey string) *ModifyMonitoringInstanceOptions {
	options.IngestionKey = core.StringPtr(ingestionKey)
	return options
}

// SetInstance : Allow user to set Instance
func (options *ModifyMonitoringInstanceOptions) SetInstance(instance string) *ModifyMonitoringInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetNewInstance : Allow user to set NewInstance
func (options *ModifyMonitoringInstanceOptions) SetNewInstance(newInstance string) *ModifyMonitoringInstanceOptions {
	options.NewInstance = core.StringPtr(newInstance)
	return options
}

// SetPrivateEndpoint : Allow user to set PrivateEndpoint
func (options *ModifyMonitoringInstanceOptions) SetPrivateEndpoint(privateEndpoint bool) *ModifyMonitoringInstanceOptions {
	options.PrivateEndpoint = core.BoolPtr(privateEndpoint)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ModifyMonitoringInstanceOptions) SetHeaders(param map[string]string) *ModifyMonitoringInstanceOptions {
	options.Headers = param
	return options
}

// MultishiftClusterHosts : MultishiftClusterHosts describes the hosts assigned to a cluster.
type MultishiftClusterHosts struct {
	Assigned *int64 `json:"assigned,omitempty"`

	UnsatisfiedLabels []UnsatisfiedLabels `json:"unsatisfiedLabels,omitempty"`
}

// UnmarshalMultishiftClusterHosts unmarshals an instance of MultishiftClusterHosts from the specified map of raw messages.
func UnmarshalMultishiftClusterHosts(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultishiftClusterHosts)
	err = core.UnmarshalPrimitive(m, "assigned", &obj.Assigned)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "unsatisfiedLabels", &obj.UnsatisfiedLabels, UnmarshalUnsatisfiedLabels)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MultishiftController : MultishiftController describes an individual controller.
type MultishiftController struct {
	// The timestamp when the Satellite location was created.
	CreatedDate *string `json:"createdDate,omitempty"`

	// The CRN for the Satellite location.
	Crn *string `json:"crn,omitempty"`

	// Deployments reports status of deployments on the IBM Cloud Satellite location.
	Deployments *Deployments `json:"deployments,omitempty"`

	// Hosts lists the hosts belonging to the IBM Cloud Satellite location.
	Hosts *Hosts `json:"hosts,omitempty"`

	// The Satellite location ID.
	ID *string `json:"id,omitempty"`

	// The IBM Cloud metro that the Satellite location is managed from.
	Location *string `json:"location,omitempty"`

	// The Satellite location name.
	Name *string `json:"name,omitempty"`

	// The IBM Cloud region that the Satellite location is managed from.
	Region *string `json:"region,omitempty"`

	// The health state of the Satellite location. Possible values include action required, critical, host required,
	// normal, and provisioning. For more information, see the docs 'http://ibm.biz/sat-loc-health'.
	State *string `json:"state,omitempty"`

	WorkerZones []string `json:"workerZones,omitempty"`
}

// UnmarshalMultishiftController unmarshals an instance of MultishiftController from the specified map of raw messages.
func UnmarshalMultishiftController(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultishiftController)
	err = core.UnmarshalPrimitive(m, "createdDate", &obj.CreatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deployments", &obj.Deployments, UnmarshalDeployments)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "hosts", &obj.Hosts, UnmarshalHosts)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerZones", &obj.WorkerZones)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MultishiftCreateAssignmentResponse : MultishiftCreateAssignment create multishift assignment response.
type MultishiftCreateAssignmentResponse struct {
	HostID *string `json:"hostID,omitempty"`

	ID *string `json:"id,omitempty"`
}

// UnmarshalMultishiftCreateAssignmentResponse unmarshals an instance of MultishiftCreateAssignmentResponse from the specified map of raw messages.
func UnmarshalMultishiftCreateAssignmentResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultishiftCreateAssignmentResponse)
	err = core.UnmarshalPrimitive(m, "hostID", &obj.HostID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MultishiftCreateClusterResponse : MultishiftCreateCluster create multishift cluster response.
type MultishiftCreateClusterResponse struct {
	ID *string `json:"id,omitempty"`
}

// UnmarshalMultishiftCreateClusterResponse unmarshals an instance of MultishiftCreateClusterResponse from the specified map of raw messages.
func UnmarshalMultishiftCreateClusterResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultishiftCreateClusterResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MultishiftCreateControllerResponse : MultishiftCreateController create controller response.
type MultishiftCreateControllerResponse struct {
	Crn *string `json:"crn,omitempty"`

	ID *string `json:"id,omitempty"`
}

// UnmarshalMultishiftCreateControllerResponse unmarshals an instance of MultishiftCreateControllerResponse from the specified map of raw messages.
func UnmarshalMultishiftCreateControllerResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultishiftCreateControllerResponse)
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MultishiftGetController : MultishiftGetController describes a multishift controller.
type MultishiftGetController struct {
	Addons []CommonClusterAddon `json:"addons,omitempty"`

	// CommonClusterCACertRotation CA cert rotation properties.
	CaCertRotationStatus *CommonClusterCACertRotation `json:"caCertRotationStatus,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty"`

	Crn *string `json:"crn,omitempty"`

	Datacenter *string `json:"datacenter,omitempty"`

	// Deployments reports status of deployments on the IBM Cloud Satellite location.
	Deployments *Deployments `json:"deployments,omitempty"`

	Description *string `json:"description,omitempty"`

	DisableAutoUpdate *bool `json:"disableAutoUpdate,omitempty"`

	Entitlement *string `json:"entitlement,omitempty"`

	EtcdPort *string `json:"etcdPort,omitempty"`

	Features *CommonClusterFeatures `json:"features,omitempty"`

	// Hosts lists the hosts belonging to the IBM Cloud Satellite location.
	Hosts *Hosts `json:"hosts,omitempty"`

	ID *string `json:"id,omitempty"`

	ImageSecurityEnabled *bool `json:"imageSecurityEnabled,omitempty"`

	Ingress *CommonClusterIngress `json:"ingress,omitempty"`

	IsPaid *bool `json:"isPaid,omitempty"`

	Lifecycle *CommonClusterLifecycle `json:"lifecycle,omitempty"`

	Location *string `json:"location,omitempty"`

	LocationZones []string `json:"locationZones,omitempty"`

	MasterKubeVersion *string `json:"masterKubeVersion,omitempty"`

	MasterURL *string `json:"masterURL,omitempty"`

	MultiAzCapable *bool `json:"multiAzCapable,omitempty"`

	Name *string `json:"name,omitempty"`

	PodSubnet *string `json:"podSubnet,omitempty"`

	Provider *string `json:"provider,omitempty"`

	Region *string `json:"region,omitempty"`

	ResourceGroup *string `json:"resourceGroup,omitempty"`

	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	ServiceEndpoints *CommonClusterServiceEndpoint `json:"serviceEndpoints,omitempty"`

	ServiceSubnet *string `json:"serviceSubnet,omitempty"`

	// The lifecycle state of the cluster. Possible values include aborted, critical, delete_failed, deleted, deleting,
	// deploy_failed, deploying, normal, pending, requested, updating, unsupported, and warning. For more information, see
	// the docs 'http://ibm.biz/cluster-health-states'.
	State *string `json:"state,omitempty"`

	Status *string `json:"status,omitempty"`

	TargetVersion *string `json:"targetVersion,omitempty"`

	Type *string `json:"type,omitempty"`

	VersionEOS *string `json:"versionEOS,omitempty"`

	Vpcs []string `json:"vpcs,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`

	WorkerZones []string `json:"workerZones,omitempty"`
}

// UnmarshalMultishiftGetController unmarshals an instance of MultishiftGetController from the specified map of raw messages.
func UnmarshalMultishiftGetController(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultishiftGetController)
	err = core.UnmarshalModel(m, "addons", &obj.Addons, UnmarshalCommonClusterAddon)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "caCertRotationStatus", &obj.CaCertRotationStatus, UnmarshalCommonClusterCACertRotation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdDate", &obj.CreatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "datacenter", &obj.Datacenter)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deployments", &obj.Deployments, UnmarshalDeployments)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "disableAutoUpdate", &obj.DisableAutoUpdate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "entitlement", &obj.Entitlement)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "etcdPort", &obj.EtcdPort)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "features", &obj.Features, UnmarshalCommonClusterFeatures)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "hosts", &obj.Hosts, UnmarshalHosts)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageSecurityEnabled", &obj.ImageSecurityEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ingress", &obj.Ingress, UnmarshalCommonClusterIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaid", &obj.IsPaid)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "lifecycle", &obj.Lifecycle, UnmarshalCommonClusterLifecycle)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locationZones", &obj.LocationZones)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterKubeVersion", &obj.MasterKubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterURL", &obj.MasterURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "multiAzCapable", &obj.MultiAzCapable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "podSubnet", &obj.PodSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroup", &obj.ResourceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupName", &obj.ResourceGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "serviceEndpoints", &obj.ServiceEndpoints, UnmarshalCommonClusterServiceEndpoint)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceSubnet", &obj.ServiceSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVersion", &obj.TargetVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "versionEOS", &obj.VersionEOS)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcs", &obj.Vpcs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerZones", &obj.WorkerZones)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MultishiftQueueNode : MultishiftQueueNode describes an individual queue node.
type MultishiftQueueNode struct {
	// Assignment is information about the host assignment.
	Assignment *Assignment `json:"assignment,omitempty"`

	// Health is the health status of the host.
	Health *Health `json:"health,omitempty"`

	// The unique ID of the host.
	ID *string `json:"id,omitempty"`

	// Key-value pairs to label the host, such as cpu=4 to describe the host capabilities.
	Labels map[string]string `json:"labels,omitempty"`

	// The unique name of the host.
	Name *string `json:"name,omitempty"`

	// The availability state of the host. Possible values include assigned and unassigned. For more information, see the
	// docs 'http://ibm.biz/sat-host-health'.
	State *string `json:"state,omitempty"`
}

// UnmarshalMultishiftQueueNode unmarshals an instance of MultishiftQueueNode from the specified map of raw messages.
func UnmarshalMultishiftQueueNode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultishiftQueueNode)
	err = core.UnmarshalModel(m, "assignment", &obj.Assignment, UnmarshalAssignment)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health", &obj.Health, UnmarshalHealth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "labels", &obj.Labels)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NlbConfig : NlbConfig config for NLB configuration.
type NlbConfig struct {
	ClusterID *string `json:"clusterID,omitempty"`

	NlbHost *string `json:"nlbHost,omitempty"`

	NlbIPArray []string `json:"nlbIPArray,omitempty"`

	NlbMonitorState *string `json:"nlbMonitorState,omitempty"`

	NlbSslSecretName *string `json:"nlbSslSecretName,omitempty"`

	NlbSslSecretStatus *string `json:"nlbSslSecretStatus,omitempty"`

	NlbType *string `json:"nlbType,omitempty"`

	SecretNamespace *string `json:"secretNamespace,omitempty"`
}

// UnmarshalNlbConfig unmarshals an instance of NlbConfig from the specified map of raw messages.
func UnmarshalNlbConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NlbConfig)
	err = core.UnmarshalPrimitive(m, "clusterID", &obj.ClusterID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbHost", &obj.NlbHost)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbIPArray", &obj.NlbIPArray)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbMonitorState", &obj.NlbMonitorState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbSslSecretName", &obj.NlbSslSecretName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbSslSecretStatus", &obj.NlbSslSecretStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbType", &obj.NlbType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secretNamespace", &obj.SecretNamespace)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NlbHealthCheckConfig : NlbHealthCheckConfig config for Health check monitor configuration list.
type NlbHealthCheckConfig struct {
	ClusterID *string `json:"clusterID,omitempty"`

	HealthCheckStatus *string `json:"healthCheckStatus,omitempty"`

	NlbHost *string `json:"nlbHost,omitempty"`

	Path *string `json:"path,omitempty"`

	Port *int64 `json:"port,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalNlbHealthCheckConfig unmarshals an instance of NlbHealthCheckConfig from the specified map of raw messages.
func UnmarshalNlbHealthCheckConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NlbHealthCheckConfig)
	err = core.UnmarshalPrimitive(m, "clusterID", &obj.ClusterID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "healthCheckStatus", &obj.HealthCheckStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbHost", &obj.NlbHost)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "path", &obj.Path)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NlbHealthCheckStatus : NlbHealthCheckStatus status of Health check monitors.
type NlbHealthCheckStatus struct {
	ClusterID *string `json:"clusterID,omitempty"`

	MonitorState *string `json:"monitorState,omitempty"`

	MonitorStatus *string `json:"monitorStatus,omitempty"`

	NlbHost *string `json:"nlbHost,omitempty"`

	NlbIP *string `json:"nlbIP,omitempty"`
}

// UnmarshalNlbHealthCheckStatus unmarshals an instance of NlbHealthCheckStatus from the specified map of raw messages.
func UnmarshalNlbHealthCheckStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NlbHealthCheckStatus)
	err = core.UnmarshalPrimitive(m, "clusterID", &obj.ClusterID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "monitorState", &obj.MonitorState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "monitorStatus", &obj.MonitorStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbHost", &obj.NlbHost)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbIP", &obj.NlbIP)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NlbHealthConfig : NlbHealthConfig config for NLB Health configuration.
type NlbHealthConfig struct {
	AllowInsecureSet *string `json:"allowInsecureSet,omitempty"`

	ClusterID *string `json:"clusterID,omitempty"`

	CreatedOn *string `json:"createdOn,omitempty"`

	Desc *string `json:"desc,omitempty"`

	FollowRedirectSet *string `json:"followRedirectSet,omitempty"`

	HealtcheckPropertiesSetStatus *string `json:"healtcheckPropertiesSetStatus,omitempty"`

	// HealthcheckProperties used for storing config provided by user for healthcheck.
	HealthcheckProperties *HealthcheckProperties `json:"healthcheckProperties,omitempty"`

	ModifiedOn *string `json:"modifiedOn,omitempty"`

	MonitorState *string `json:"monitorState,omitempty"`

	NlbHost *string `json:"nlbHost,omitempty"`
}

// UnmarshalNlbHealthConfig unmarshals an instance of NlbHealthConfig from the specified map of raw messages.
func UnmarshalNlbHealthConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NlbHealthConfig)
	err = core.UnmarshalPrimitive(m, "allowInsecureSet", &obj.AllowInsecureSet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "clusterID", &obj.ClusterID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdOn", &obj.CreatedOn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "desc", &obj.Desc)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "followRedirectSet", &obj.FollowRedirectSet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "healtcheckPropertiesSetStatus", &obj.HealtcheckPropertiesSetStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "healthcheckProperties", &obj.HealthcheckProperties, UnmarshalHealthcheckProperties)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "modifiedOn", &obj.ModifiedOn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "monitorState", &obj.MonitorState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbHost", &obj.NlbHost)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NlbVPCConfig : NlbVPCConfig is the request and response body for the v2 vpc apis.
type NlbVPCConfig struct {
	Cluster *string `json:"cluster,omitempty"`

	LbHostname *string `json:"lbHostname,omitempty"`

	NlbSubdomain *string `json:"nlbSubdomain,omitempty"`

	SecretNamespace *string `json:"secretNamespace,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalNlbVPCConfig unmarshals an instance of NlbVPCConfig from the specified map of raw messages.
func UnmarshalNlbVPCConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NlbVPCConfig)
	err = core.UnmarshalPrimitive(m, "cluster", &obj.Cluster)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lbHostname", &obj.LbHostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nlbSubdomain", &obj.NlbSubdomain)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secretNamespace", &obj.SecretNamespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NlbVPCListConfig : NlbVPCListConfig single nlb subdomain in list response.
type NlbVPCListConfig struct {
	// NlbVPCConfig is the request and response body for the v2 vpc apis.
	Nlb *NlbVPCConfig `json:"Nlb,omitempty"`

	SecretName *string `json:"secretName,omitempty"`

	SecretStatus *string `json:"secretStatus,omitempty"`
}

// UnmarshalNlbVPCListConfig unmarshals an instance of NlbVPCListConfig from the specified map of raw messages.
func UnmarshalNlbVPCListConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NlbVPCListConfig)
	err = core.UnmarshalModel(m, "Nlb", &obj.Nlb, UnmarshalNlbVPCConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secretName", &obj.SecretName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secretStatus", &obj.SecretStatus)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObjectFieldSelector : ObjectFieldSelector struct
type ObjectFieldSelector struct {
	// Version of the schema the FieldPath is written in terms of, defaults to "v1".
	// +optional.
	ApiVersion *string `json:"apiVersion,omitempty"`

	// Path of the field to select in the specified API version.
	FieldPath *string `json:"fieldPath,omitempty"`
}

// UnmarshalObjectFieldSelector unmarshals an instance of ObjectFieldSelector from the specified map of raw messages.
func UnmarshalObjectFieldSelector(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObjectFieldSelector)
	err = core.UnmarshalPrimitive(m, "apiVersion", &obj.ApiVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fieldPath", &obj.FieldPath)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ObsConfig : ObsConfig struct
type ObsConfig struct {
	AgentKey *string `json:"agentKey,omitempty"`

	AgentNamespace *string `json:"agentNamespace,omitempty"`

	Crn *string `json:"crn,omitempty"`

	DaemonsetName *string `json:"daemonsetName,omitempty"`

	DiscoveredAgent *bool `json:"discoveredAgent,omitempty"`

	InstanceID *string `json:"instanceId,omitempty"`

	InstanceName *string `json:"instanceName,omitempty"`

	Namespace *string `json:"namespace,omitempty"`

	PrivateEndpoint *bool `json:"privateEndpoint,omitempty"`
}

// UnmarshalObsConfig unmarshals an instance of ObsConfig from the specified map of raw messages.
func UnmarshalObsConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ObsConfig)
	err = core.UnmarshalPrimitive(m, "agentKey", &obj.AgentKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "agentNamespace", &obj.AgentNamespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "daemonsetName", &obj.DaemonsetName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "discoveredAgent", &obj.DiscoveredAgent)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instanceId", &obj.InstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instanceName", &obj.InstanceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "namespace", &obj.Namespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateEndpoint", &obj.PrivateEndpoint)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PatchLBConfigOptions : The PatchLBConfig options.
type PatchLBConfigOptions struct {
	Cluster *string

	// LBProxyProtocolConfig stuct for storing the loadbalancer's proxy protocol config in etcd.
	ProxyProtocol *LBProxyProtocolConfig

	Type *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchLBConfigOptions : Instantiate PatchLBConfigOptions
func (*KubernetesServiceApiV1) NewPatchLBConfigOptions() *PatchLBConfigOptions {
	return &PatchLBConfigOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *PatchLBConfigOptions) SetCluster(cluster string) *PatchLBConfigOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetProxyProtocol : Allow user to set ProxyProtocol
func (options *PatchLBConfigOptions) SetProxyProtocol(proxyProtocol *LBProxyProtocolConfig) *PatchLBConfigOptions {
	options.ProxyProtocol = proxyProtocol
	return options
}

// SetType : Allow user to set Type
func (options *PatchLBConfigOptions) SetType(typeVar string) *PatchLBConfigOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *PatchLBConfigOptions) SetHeaders(param map[string]string) *PatchLBConfigOptions {
	options.Headers = param
	return options
}

// PatchWorkerPoolOptions : The PatchWorkerPool options.
type PatchWorkerPoolOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker pool. To list all worker pools for a cluster, use the `GET /v1/clusters/{idOrName}/workerpools`
	// API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	PoolidOrName *string `validate:"required,ne="`

	AllowSingleOpenShiftWorker *bool

	Labels map[string]string

	ReasonForResize *string

	SizePerZone *int64

	State *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPatchWorkerPoolOptions : Instantiate PatchWorkerPoolOptions
func (*KubernetesServiceApiV1) NewPatchWorkerPoolOptions(idOrName string, poolidOrName string) *PatchWorkerPoolOptions {
	return &PatchWorkerPoolOptions{
		IdOrName:     core.StringPtr(idOrName),
		PoolidOrName: core.StringPtr(poolidOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *PatchWorkerPoolOptions) SetIdOrName(idOrName string) *PatchWorkerPoolOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetPoolidOrName : Allow user to set PoolidOrName
func (options *PatchWorkerPoolOptions) SetPoolidOrName(poolidOrName string) *PatchWorkerPoolOptions {
	options.PoolidOrName = core.StringPtr(poolidOrName)
	return options
}

// SetAllowSingleOpenShiftWorker : Allow user to set AllowSingleOpenShiftWorker
func (options *PatchWorkerPoolOptions) SetAllowSingleOpenShiftWorker(allowSingleOpenShiftWorker bool) *PatchWorkerPoolOptions {
	options.AllowSingleOpenShiftWorker = core.BoolPtr(allowSingleOpenShiftWorker)
	return options
}

// SetLabels : Allow user to set Labels
func (options *PatchWorkerPoolOptions) SetLabels(labels map[string]string) *PatchWorkerPoolOptions {
	options.Labels = labels
	return options
}

// SetReasonForResize : Allow user to set ReasonForResize
func (options *PatchWorkerPoolOptions) SetReasonForResize(reasonForResize string) *PatchWorkerPoolOptions {
	options.ReasonForResize = core.StringPtr(reasonForResize)
	return options
}

// SetSizePerZone : Allow user to set SizePerZone
func (options *PatchWorkerPoolOptions) SetSizePerZone(sizePerZone int64) *PatchWorkerPoolOptions {
	options.SizePerZone = core.Int64Ptr(sizePerZone)
	return options
}

// SetState : Allow user to set State
func (options *PatchWorkerPoolOptions) SetState(state string) *PatchWorkerPoolOptions {
	options.State = core.StringPtr(state)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *PatchWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *PatchWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *PatchWorkerPoolOptions) SetHeaders(param map[string]string) *PatchWorkerPoolOptions {
	options.Headers = param
	return options
}

// Permissions : Permissions describes the result of checking granted permissions Note: the default zero/empty value implies
// sufficient permissions.
type Permissions struct {
	// PermissionsAnalysis describes the result of checking granted permissions
	// Note: the default zero/empty value implies sufficient permissions.
	Recommended *PermissionsAnalysis `json:"recommended,omitempty"`

	// PermissionsAnalysis describes the result of checking granted permissions
	// Note: the default zero/empty value implies sufficient permissions.
	Required *PermissionsAnalysis `json:"required,omitempty"`
}

// UnmarshalPermissions unmarshals an instance of Permissions from the specified map of raw messages.
func UnmarshalPermissions(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Permissions)
	err = core.UnmarshalModel(m, "recommended", &obj.Recommended, UnmarshalPermissionsAnalysis)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "required", &obj.Required, UnmarshalPermissionsAnalysis)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PermissionsAnalysis : PermissionsAnalysis describes the result of checking granted permissions Note: the default zero/empty value implies
// sufficient permissions.
type PermissionsAnalysis struct {
	// Insufficient is true if granted permissions are insufficient Note: the default zero/empty value implies sufficient
	// permissions.
	Insufficient *bool `json:"insufficient,omitempty"`

	// MissingPermissions describes why granted permissions are insufficient, using IaaS-specific terminology (e.g to
	// present to the user in permissions warning or failure messages).
	MissingPermissions []string `json:"missingPermissions,omitempty"`
}

// UnmarshalPermissionsAnalysis unmarshals an instance of PermissionsAnalysis from the specified map of raw messages.
func UnmarshalPermissionsAnalysis(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PermissionsAnalysis)
	err = core.UnmarshalPrimitive(m, "insufficient", &obj.Insufficient)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "missingPermissions", &obj.MissingPermissions)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ProductConfig : ProductConfig properties.
type ProductConfig struct {
	CompanyName *string `json:"company_name,omitempty"`

	ContainerServiceName *string `json:"container_service_name,omitempty"`

	IaasName *string `json:"iaas_name,omitempty"`

	ProductName *string `json:"product_name,omitempty"`

	ProductNameShort *string `json:"product_name_short,omitempty"`
}

// UnmarshalProductConfig unmarshals an instance of ProductConfig from the specified map of raw messages.
func UnmarshalProductConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ProductConfig)
	err = core.UnmarshalPrimitive(m, "company_name", &obj.CompanyName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "container_service_name", &obj.ContainerServiceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iaas_name", &obj.IaasName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "product_name", &obj.ProductName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "product_name_short", &obj.ProductNameShort)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RebalanceWorkerPoolOptions : The RebalanceWorkerPool options.
type RebalanceWorkerPoolOptions struct {
	Cluster *string

	Workerpool *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRebalanceWorkerPoolOptions : Instantiate RebalanceWorkerPoolOptions
func (*KubernetesServiceApiV1) NewRebalanceWorkerPoolOptions() *RebalanceWorkerPoolOptions {
	return &RebalanceWorkerPoolOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *RebalanceWorkerPoolOptions) SetCluster(cluster string) *RebalanceWorkerPoolOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *RebalanceWorkerPoolOptions) SetWorkerpool(workerpool string) *RebalanceWorkerPoolOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RebalanceWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RebalanceWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RebalanceWorkerPoolOptions) SetHeaders(param map[string]string) *RebalanceWorkerPoolOptions {
	options.Headers = param
	return options
}

// RefreshLoggingConfigOptions : The RefreshLoggingConfig options.
type RefreshLoggingConfigOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRefreshLoggingConfigOptions : Instantiate RefreshLoggingConfigOptions
func (*KubernetesServiceApiV1) NewRefreshLoggingConfigOptions(idOrName string) *RefreshLoggingConfigOptions {
	return &RefreshLoggingConfigOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RefreshLoggingConfigOptions) SetIdOrName(idOrName string) *RefreshLoggingConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *RefreshLoggingConfigOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *RefreshLoggingConfigOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *RefreshLoggingConfigOptions) SetForceUpdate(forceUpdate bool) *RefreshLoggingConfigOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RefreshLoggingConfigOptions) SetHeaders(param map[string]string) *RefreshLoggingConfigOptions {
	options.Headers = param
	return options
}

// RegenerateCertOptions : The RegenerateCert options.
type RegenerateCertOptions struct {
	Cluster *string

	Subdomain *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRegenerateCertOptions : Instantiate RegenerateCertOptions
func (*KubernetesServiceApiV1) NewRegenerateCertOptions() *RegenerateCertOptions {
	return &RegenerateCertOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *RegenerateCertOptions) SetCluster(cluster string) *RegenerateCertOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetSubdomain : Allow user to set Subdomain
func (options *RegenerateCertOptions) SetSubdomain(subdomain string) *RegenerateCertOptions {
	options.Subdomain = core.StringPtr(subdomain)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RegenerateCertOptions) SetHeaders(param map[string]string) *RegenerateCertOptions {
	options.Headers = param
	return options
}

// Region : Region represnts information about a region for the cli and ui.
type Region struct {
	Alias *string `json:"alias,omitempty"`

	CfURL *string `json:"cfURL,omitempty"`

	FreeEnabled *bool `json:"freeEnabled,omitempty"`

	Name *string `json:"name,omitempty"`

	Satellite *bool `json:"satellite,omitempty"`
}

// UnmarshalRegion unmarshals an instance of Region from the specified map of raw messages.
func UnmarshalRegion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Region)
	err = core.UnmarshalPrimitive(m, "alias", &obj.Alias)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cfURL", &obj.CfURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "freeEnabled", &obj.FreeEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "satellite", &obj.Satellite)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Regions : Regions represnts information about all the regions for the cli and ui.
type Regions struct {
	Regions []Region `json:"regions,omitempty"`
}

// UnmarshalRegions unmarshals an instance of Regions from the specified map of raw messages.
func UnmarshalRegions(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Regions)
	err = core.UnmarshalModel(m, "regions", &obj.Regions, UnmarshalRegion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegisterDNSWithIPOptions : The RegisterDNSWithIP options.
type RegisterDNSWithIPOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	ClusterID *string

	NlbHost *string

	NlbIPArray []string

	NlbMonitorState *string

	NlbSslSecretName *string

	NlbSslSecretStatus *string

	NlbType *string

	SecretNamespace *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRegisterDNSWithIPOptions : Instantiate RegisterDNSWithIPOptions
func (*KubernetesServiceApiV1) NewRegisterDNSWithIPOptions(idOrName string) *RegisterDNSWithIPOptions {
	return &RegisterDNSWithIPOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RegisterDNSWithIPOptions) SetIdOrName(idOrName string) *RegisterDNSWithIPOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetClusterID : Allow user to set ClusterID
func (options *RegisterDNSWithIPOptions) SetClusterID(clusterID string) *RegisterDNSWithIPOptions {
	options.ClusterID = core.StringPtr(clusterID)
	return options
}

// SetNlbHost : Allow user to set NlbHost
func (options *RegisterDNSWithIPOptions) SetNlbHost(nlbHost string) *RegisterDNSWithIPOptions {
	options.NlbHost = core.StringPtr(nlbHost)
	return options
}

// SetNlbIPArray : Allow user to set NlbIPArray
func (options *RegisterDNSWithIPOptions) SetNlbIPArray(nlbIPArray []string) *RegisterDNSWithIPOptions {
	options.NlbIPArray = nlbIPArray
	return options
}

// SetNlbMonitorState : Allow user to set NlbMonitorState
func (options *RegisterDNSWithIPOptions) SetNlbMonitorState(nlbMonitorState string) *RegisterDNSWithIPOptions {
	options.NlbMonitorState = core.StringPtr(nlbMonitorState)
	return options
}

// SetNlbSslSecretName : Allow user to set NlbSslSecretName
func (options *RegisterDNSWithIPOptions) SetNlbSslSecretName(nlbSslSecretName string) *RegisterDNSWithIPOptions {
	options.NlbSslSecretName = core.StringPtr(nlbSslSecretName)
	return options
}

// SetNlbSslSecretStatus : Allow user to set NlbSslSecretStatus
func (options *RegisterDNSWithIPOptions) SetNlbSslSecretStatus(nlbSslSecretStatus string) *RegisterDNSWithIPOptions {
	options.NlbSslSecretStatus = core.StringPtr(nlbSslSecretStatus)
	return options
}

// SetNlbType : Allow user to set NlbType
func (options *RegisterDNSWithIPOptions) SetNlbType(nlbType string) *RegisterDNSWithIPOptions {
	options.NlbType = core.StringPtr(nlbType)
	return options
}

// SetSecretNamespace : Allow user to set SecretNamespace
func (options *RegisterDNSWithIPOptions) SetSecretNamespace(secretNamespace string) *RegisterDNSWithIPOptions {
	options.SecretNamespace = core.StringPtr(secretNamespace)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RegisterDNSWithIPOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RegisterDNSWithIPOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RegisterDNSWithIPOptions) SetHeaders(param map[string]string) *RegisterDNSWithIPOptions {
	options.Headers = param
	return options
}

// RegisterMultishiftClusterOptions : The RegisterMultishiftCluster options.
type RegisterMultishiftClusterOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `ibmcloud
	// iam oauth-tokens`. This header may be omitted if you use the `POST /v1/credentials` API prior to this request.
	XAuthRefreshToken *string `validate:"required"`

	Controller *string

	Ips []string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRegisterMultishiftClusterOptions : Instantiate RegisterMultishiftClusterOptions
func (*KubernetesServiceApiV1) NewRegisterMultishiftClusterOptions(xAuthRefreshToken string) *RegisterMultishiftClusterOptions {
	return &RegisterMultishiftClusterOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *RegisterMultishiftClusterOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *RegisterMultishiftClusterOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetController : Allow user to set Controller
func (options *RegisterMultishiftClusterOptions) SetController(controller string) *RegisterMultishiftClusterOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetIps : Allow user to set Ips
func (options *RegisterMultishiftClusterOptions) SetIps(ips []string) *RegisterMultishiftClusterOptions {
	options.Ips = ips
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RegisterMultishiftClusterOptions) SetHeaders(param map[string]string) *RegisterMultishiftClusterOptions {
	options.Headers = param
	return options
}

// RegisteredStorage : RegisteredStorage struct
type RegisteredStorage struct {
	DefaultVersion *string `json:"default-version,omitempty"`

	Description *string `json:"description,omitempty"`

	Displayname *string `json:"displayname,omitempty"`

	Enabled *string `json:"enabled,omitempty"`

	Name *string `json:"name,omitempty"`

	Provider *string `json:"provider,omitempty"`

	Versions []RegisteredStorageVersion `json:"versions,omitempty"`
}

// UnmarshalRegisteredStorage unmarshals an instance of RegisteredStorage from the specified map of raw messages.
func UnmarshalRegisteredStorage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegisteredStorage)
	err = core.UnmarshalPrimitive(m, "default-version", &obj.DefaultVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "displayname", &obj.Displayname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "versions", &obj.Versions, UnmarshalRegisteredStorageVersion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RegisteredStorageVersion : RegisteredStorageVersion struct
type RegisteredStorageVersion struct {
	CustomParameters []CustomParameter `json:"custom-parameters,omitempty"`

	DefaultVersion *string `json:"default-version,omitempty"`

	Description *string `json:"description,omitempty"`

	Displayname *string `json:"displayname,omitempty"`

	Enabled *string `json:"enabled,omitempty"`

	Name *string `json:"name,omitempty"`

	Provider *string `json:"provider,omitempty"`

	StorageClassParameters []CustomParameter `json:"storage-class-parameters,omitempty"`

	StorageClassTemplate *string `json:"storage-class-template,omitempty"`

	Tags []EnvVar `json:"tags,omitempty"`

	Template *string `json:"template,omitempty"`

	VendorStorageClassParameters []map[string]string `json:"vendor-storage-class-parameters,omitempty"`

	Versions []RegisteredStorageVersion `json:"versions,omitempty"`
}

// UnmarshalRegisteredStorageVersion unmarshals an instance of RegisteredStorageVersion from the specified map of raw messages.
func UnmarshalRegisteredStorageVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RegisteredStorageVersion)
	err = core.UnmarshalModel(m, "custom-parameters", &obj.CustomParameters, UnmarshalCustomParameter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "default-version", &obj.DefaultVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "displayname", &obj.Displayname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storage-class-parameters", &obj.StorageClassParameters, UnmarshalCustomParameter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage-class-template", &obj.StorageClassTemplate)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "tags", &obj.Tags, UnmarshalEnvVar)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "template", &obj.Template)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vendor-storage-class-parameters", &obj.VendorStorageClassParameters)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "versions", &obj.Versions, UnmarshalRegisteredStorageVersion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RemoveAssignmentOptions : The RemoveAssignment options.
type RemoveAssignmentOptions struct {
	// The UUID of the assignment. To list the assignments that you have access to, run `ibmcloud sat storage assignment
	// ls`.
	UUID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveAssignmentOptions : Instantiate RemoveAssignmentOptions
func (*KubernetesServiceApiV1) NewRemoveAssignmentOptions(uuid string) *RemoveAssignmentOptions {
	return &RemoveAssignmentOptions{
		UUID: core.StringPtr(uuid),
	}
}

// SetUUID : Allow user to set UUID
func (options *RemoveAssignmentOptions) SetUUID(uuid string) *RemoveAssignmentOptions {
	options.UUID = core.StringPtr(uuid)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveAssignmentOptions) SetHeaders(param map[string]string) *RemoveAssignmentOptions {
	options.Headers = param
	return options
}

// RemoveClusterACLsOptions : The RemoveClusterACLs options.
type RemoveClusterACLsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ACL list to patch.
	AclList []string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveClusterACLsOptions : Instantiate RemoveClusterACLsOptions
func (*KubernetesServiceApiV1) NewRemoveClusterACLsOptions(idOrName string) *RemoveClusterACLsOptions {
	return &RemoveClusterACLsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RemoveClusterACLsOptions) SetIdOrName(idOrName string) *RemoveClusterACLsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAclList : Allow user to set AclList
func (options *RemoveClusterACLsOptions) SetAclList(aclList []string) *RemoveClusterACLsOptions {
	options.AclList = aclList
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RemoveClusterACLsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RemoveClusterACLsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveClusterACLsOptions) SetHeaders(param map[string]string) *RemoveClusterACLsOptions {
	options.Headers = param
	return options
}

// RemoveClusterOptions : The RemoveCluster options.
type RemoveClusterOptions struct {
	// The name or ID of the cluster that you want to remove. To list the clusters that you have access to, use the `GET
	// /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// To delete additional resources linked to the cluster such as VLANs, subnets, and storage, pass `true`.
	DeleteResources *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveClusterOptions : Instantiate RemoveClusterOptions
func (*KubernetesServiceApiV1) NewRemoveClusterOptions(idOrName string) *RemoveClusterOptions {
	return &RemoveClusterOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RemoveClusterOptions) SetIdOrName(idOrName string) *RemoveClusterOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RemoveClusterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RemoveClusterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetDeleteResources : Allow user to set DeleteResources
func (options *RemoveClusterOptions) SetDeleteResources(deleteResources string) *RemoveClusterOptions {
	options.DeleteResources = core.StringPtr(deleteResources)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveClusterOptions) SetHeaders(param map[string]string) *RemoveClusterOptions {
	options.Headers = param
	return options
}

// RemoveClusterUserSubnetOptions : The RemoveClusterUserSubnet options.
type RemoveClusterUserSubnetOptions struct {
	// The name or ID of the cluster that you want to remove the user-managed subnet from. To list the clusters that you
	// have access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The GUID of the user-managed subnet that you want to remove from your cluster.
	SubnetID *string `validate:"required,ne="`

	// The ID of the private VLAN that the user-managed subnet is on.
	VlanID *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveClusterUserSubnetOptions : Instantiate RemoveClusterUserSubnetOptions
func (*KubernetesServiceApiV1) NewRemoveClusterUserSubnetOptions(idOrName string, subnetID string, vlanID string) *RemoveClusterUserSubnetOptions {
	return &RemoveClusterUserSubnetOptions{
		IdOrName: core.StringPtr(idOrName),
		SubnetID: core.StringPtr(subnetID),
		VlanID:   core.StringPtr(vlanID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RemoveClusterUserSubnetOptions) SetIdOrName(idOrName string) *RemoveClusterUserSubnetOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetSubnetID : Allow user to set SubnetID
func (options *RemoveClusterUserSubnetOptions) SetSubnetID(subnetID string) *RemoveClusterUserSubnetOptions {
	options.SubnetID = core.StringPtr(subnetID)
	return options
}

// SetVlanID : Allow user to set VlanID
func (options *RemoveClusterUserSubnetOptions) SetVlanID(vlanID string) *RemoveClusterUserSubnetOptions {
	options.VlanID = core.StringPtr(vlanID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RemoveClusterUserSubnetOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RemoveClusterUserSubnetOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveClusterUserSubnetOptions) SetHeaders(param map[string]string) *RemoveClusterUserSubnetOptions {
	options.Headers = param
	return options
}

// RemoveClusterWorkerOptions : The RemoveClusterWorker options.
type RemoveClusterWorkerOptions struct {
	// The name or ID of the cluster to add additional worker nodes to. To list the clusters that you have access to, use
	// the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker node. To list all worker nodes for a cluster, use the `GET /v1/clusters/{idOrName}/workers` API
	// or run `ibmcloud ks worker ls --cluster <cluster_name_or_ID>`.
	WorkerID *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveClusterWorkerOptions : Instantiate RemoveClusterWorkerOptions
func (*KubernetesServiceApiV1) NewRemoveClusterWorkerOptions(idOrName string, workerID string) *RemoveClusterWorkerOptions {
	return &RemoveClusterWorkerOptions{
		IdOrName: core.StringPtr(idOrName),
		WorkerID: core.StringPtr(workerID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RemoveClusterWorkerOptions) SetIdOrName(idOrName string) *RemoveClusterWorkerOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetWorkerID : Allow user to set WorkerID
func (options *RemoveClusterWorkerOptions) SetWorkerID(workerID string) *RemoveClusterWorkerOptions {
	options.WorkerID = core.StringPtr(workerID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RemoveClusterWorkerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RemoveClusterWorkerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveClusterWorkerOptions) SetHeaders(param map[string]string) *RemoveClusterWorkerOptions {
	options.Headers = param
	return options
}

// RemoveLBHostnameOptions : The RemoveLBHostname options.
type RemoveLBHostnameOptions struct {
	Cluster *string

	LbHostname *string

	NlbSubdomain *string

	SecretNamespace *string

	Type *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveLBHostnameOptions : Instantiate RemoveLBHostnameOptions
func (*KubernetesServiceApiV1) NewRemoveLBHostnameOptions() *RemoveLBHostnameOptions {
	return &RemoveLBHostnameOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *RemoveLBHostnameOptions) SetCluster(cluster string) *RemoveLBHostnameOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetLbHostname : Allow user to set LbHostname
func (options *RemoveLBHostnameOptions) SetLbHostname(lbHostname string) *RemoveLBHostnameOptions {
	options.LbHostname = core.StringPtr(lbHostname)
	return options
}

// SetNlbSubdomain : Allow user to set NlbSubdomain
func (options *RemoveLBHostnameOptions) SetNlbSubdomain(nlbSubdomain string) *RemoveLBHostnameOptions {
	options.NlbSubdomain = core.StringPtr(nlbSubdomain)
	return options
}

// SetSecretNamespace : Allow user to set SecretNamespace
func (options *RemoveLBHostnameOptions) SetSecretNamespace(secretNamespace string) *RemoveLBHostnameOptions {
	options.SecretNamespace = core.StringPtr(secretNamespace)
	return options
}

// SetType : Allow user to set Type
func (options *RemoveLBHostnameOptions) SetType(typeVar string) *RemoveLBHostnameOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveLBHostnameOptions) SetHeaders(param map[string]string) *RemoveLBHostnameOptions {
	options.Headers = param
	return options
}

// RemoveLoggingInstanceOptions : The RemoveLoggingInstance options.
type RemoveLoggingInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. Required only in the absense of an IAM cookie and when the API is invoked through a CURL
	// command.
	XAuthRefreshToken *string `validate:"required"`

	Cluster *string

	Instance *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveLoggingInstanceOptions : Instantiate RemoveLoggingInstanceOptions
func (*KubernetesServiceApiV1) NewRemoveLoggingInstanceOptions(xAuthRefreshToken string) *RemoveLoggingInstanceOptions {
	return &RemoveLoggingInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *RemoveLoggingInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *RemoveLoggingInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *RemoveLoggingInstanceOptions) SetCluster(cluster string) *RemoveLoggingInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetInstance : Allow user to set Instance
func (options *RemoveLoggingInstanceOptions) SetInstance(instance string) *RemoveLoggingInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveLoggingInstanceOptions) SetHeaders(param map[string]string) *RemoveLoggingInstanceOptions {
	options.Headers = param
	return options
}

// RemoveMonitoringInstanceOptions : The RemoveMonitoringInstance options.
type RemoveMonitoringInstanceOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`.
	XAuthRefreshToken *string `validate:"required"`

	Cluster *string

	Instance *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveMonitoringInstanceOptions : Instantiate RemoveMonitoringInstanceOptions
func (*KubernetesServiceApiV1) NewRemoveMonitoringInstanceOptions(xAuthRefreshToken string) *RemoveMonitoringInstanceOptions {
	return &RemoveMonitoringInstanceOptions{
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *RemoveMonitoringInstanceOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *RemoveMonitoringInstanceOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *RemoveMonitoringInstanceOptions) SetCluster(cluster string) *RemoveMonitoringInstanceOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetInstance : Allow user to set Instance
func (options *RemoveMonitoringInstanceOptions) SetInstance(instance string) *RemoveMonitoringInstanceOptions {
	options.Instance = core.StringPtr(instance)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveMonitoringInstanceOptions) SetHeaders(param map[string]string) *RemoveMonitoringInstanceOptions {
	options.Headers = param
	return options
}

// RemoveSatelliteHostOptions : The RemoveSatelliteHost options.
type RemoveSatelliteHostOptions struct {
	// The name or ID of the Satellite location.
	Controller *string

	// The ID of the host to remove.
	HostID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveSatelliteHostOptions : Instantiate RemoveSatelliteHostOptions
func (*KubernetesServiceApiV1) NewRemoveSatelliteHostOptions() *RemoveSatelliteHostOptions {
	return &RemoveSatelliteHostOptions{}
}

// SetController : Allow user to set Controller
func (options *RemoveSatelliteHostOptions) SetController(controller string) *RemoveSatelliteHostOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetHostID : Allow user to set HostID
func (options *RemoveSatelliteHostOptions) SetHostID(hostID string) *RemoveSatelliteHostOptions {
	options.HostID = core.StringPtr(hostID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveSatelliteHostOptions) SetHeaders(param map[string]string) *RemoveSatelliteHostOptions {
	options.Headers = param
	return options
}

// RemoveSatelliteLocationOptions : The RemoveSatelliteLocation options.
type RemoveSatelliteLocationOptions struct {
	// The name or ID of the Satellite location.
	Controller *string

	// Optional: The RedHat pull secret to create the OpenShift cluster.
	PullSecret *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveSatelliteLocationOptions : Instantiate RemoveSatelliteLocationOptions
func (*KubernetesServiceApiV1) NewRemoveSatelliteLocationOptions() *RemoveSatelliteLocationOptions {
	return &RemoveSatelliteLocationOptions{}
}

// SetController : Allow user to set Controller
func (options *RemoveSatelliteLocationOptions) SetController(controller string) *RemoveSatelliteLocationOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetPullSecret : Allow user to set PullSecret
func (options *RemoveSatelliteLocationOptions) SetPullSecret(pullSecret string) *RemoveSatelliteLocationOptions {
	options.PullSecret = core.StringPtr(pullSecret)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveSatelliteLocationOptions) SetHeaders(param map[string]string) *RemoveSatelliteLocationOptions {
	options.Headers = param
	return options
}

// RemoveStorageConfigurationOptions : The RemoveStorageConfiguration options.
type RemoveStorageConfigurationOptions struct {
	// The UUID of the storage configuration. To list the storage configurations that you have access to, run `ibmcloud sat
	// storage config ls`. To view the storage assignments associated with a given storage configuration and the storage
	// configuration UUID, run `ibmcloud sat config get --config=<storage-configuration-name>`.
	UUID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveStorageConfigurationOptions : Instantiate RemoveStorageConfigurationOptions
func (*KubernetesServiceApiV1) NewRemoveStorageConfigurationOptions(uuid string) *RemoveStorageConfigurationOptions {
	return &RemoveStorageConfigurationOptions{
		UUID: core.StringPtr(uuid),
	}
}

// SetUUID : Allow user to set UUID
func (options *RemoveStorageConfigurationOptions) SetUUID(uuid string) *RemoveStorageConfigurationOptions {
	options.UUID = core.StringPtr(uuid)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveStorageConfigurationOptions) SetHeaders(param map[string]string) *RemoveStorageConfigurationOptions {
	options.Headers = param
	return options
}

// RemoveSubscriptionData : RemoveSubscriptionData struct
type RemoveSubscriptionData struct {
	RemoveSubscription *RemoveSubscriptionType `json:"removeSubscription,omitempty"`
}

// UnmarshalRemoveSubscriptionData unmarshals an instance of RemoveSubscriptionData from the specified map of raw messages.
func UnmarshalRemoveSubscriptionData(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RemoveSubscriptionData)
	err = core.UnmarshalModel(m, "removeSubscription", &obj.RemoveSubscription, UnmarshalRemoveSubscriptionType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RemoveSubscriptionType : RemoveSubscriptionType struct
type RemoveSubscriptionType struct {
	Success *bool `json:"success,omitempty"`

	UUID *string `json:"uuid,omitempty"`
}

// UnmarshalRemoveSubscriptionType unmarshals an instance of RemoveSubscriptionType from the specified map of raw messages.
func UnmarshalRemoveSubscriptionType(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RemoveSubscriptionType)
	err = core.UnmarshalPrimitive(m, "success", &obj.Success)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RemoveUserCredentialsOptions : The RemoveUserCredentials options.
type RemoveUserCredentialsOptions struct {
	// Target the IBM Cloud Kubernetes Service region where you want to remove infrastructure credentials. To list
	// available regions, use the `GET /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveUserCredentialsOptions : Instantiate RemoveUserCredentialsOptions
func (*KubernetesServiceApiV1) NewRemoveUserCredentialsOptions(xRegion string) *RemoveUserCredentialsOptions {
	return &RemoveUserCredentialsOptions{
		XRegion: core.StringPtr(xRegion),
	}
}

// SetXRegion : Allow user to set XRegion
func (options *RemoveUserCredentialsOptions) SetXRegion(xRegion string) *RemoveUserCredentialsOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveUserCredentialsOptions) SetHeaders(param map[string]string) *RemoveUserCredentialsOptions {
	options.Headers = param
	return options
}

// RemoveWorkerPool1Options : The RemoveWorkerPool1 options.
type RemoveWorkerPool1Options struct {
	Cluster *string

	Workerpool *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveWorkerPool1Options : Instantiate RemoveWorkerPool1Options
func (*KubernetesServiceApiV1) NewRemoveWorkerPool1Options() *RemoveWorkerPool1Options {
	return &RemoveWorkerPool1Options{}
}

// SetCluster : Allow user to set Cluster
func (options *RemoveWorkerPool1Options) SetCluster(cluster string) *RemoveWorkerPool1Options {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *RemoveWorkerPool1Options) SetWorkerpool(workerpool string) *RemoveWorkerPool1Options {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RemoveWorkerPool1Options) SetXAuthResourceGroup(xAuthResourceGroup string) *RemoveWorkerPool1Options {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveWorkerPool1Options) SetHeaders(param map[string]string) *RemoveWorkerPool1Options {
	options.Headers = param
	return options
}

// RemoveWorkerPoolOptions : The RemoveWorkerPool options.
type RemoveWorkerPoolOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker pool. To list all worker pools for a cluster, use the `GET /v1/clusters/{idOrName}/workerpools`
	// API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	PoolidOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveWorkerPoolOptions : Instantiate RemoveWorkerPoolOptions
func (*KubernetesServiceApiV1) NewRemoveWorkerPoolOptions(idOrName string, poolidOrName string) *RemoveWorkerPoolOptions {
	return &RemoveWorkerPoolOptions{
		IdOrName:     core.StringPtr(idOrName),
		PoolidOrName: core.StringPtr(poolidOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RemoveWorkerPoolOptions) SetIdOrName(idOrName string) *RemoveWorkerPoolOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetPoolidOrName : Allow user to set PoolidOrName
func (options *RemoveWorkerPoolOptions) SetPoolidOrName(poolidOrName string) *RemoveWorkerPoolOptions {
	options.PoolidOrName = core.StringPtr(poolidOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RemoveWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RemoveWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveWorkerPoolOptions) SetHeaders(param map[string]string) *RemoveWorkerPoolOptions {
	options.Headers = param
	return options
}

// RemoveWorkerPoolZone1Options : The RemoveWorkerPoolZone1 options.
type RemoveWorkerPoolZone1Options struct {
	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string `validate:"required"`

	Cluster *string

	Workerpool *string

	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveWorkerPoolZone1Options : Instantiate RemoveWorkerPoolZone1Options
func (*KubernetesServiceApiV1) NewRemoveWorkerPoolZone1Options(xAuthResourceGroup string) *RemoveWorkerPoolZone1Options {
	return &RemoveWorkerPoolZone1Options{
		XAuthResourceGroup: core.StringPtr(xAuthResourceGroup),
	}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RemoveWorkerPoolZone1Options) SetXAuthResourceGroup(xAuthResourceGroup string) *RemoveWorkerPoolZone1Options {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *RemoveWorkerPoolZone1Options) SetCluster(cluster string) *RemoveWorkerPoolZone1Options {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *RemoveWorkerPoolZone1Options) SetWorkerpool(workerpool string) *RemoveWorkerPoolZone1Options {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetZone : Allow user to set Zone
func (options *RemoveWorkerPoolZone1Options) SetZone(zone string) *RemoveWorkerPoolZone1Options {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveWorkerPoolZone1Options) SetHeaders(param map[string]string) *RemoveWorkerPoolZone1Options {
	options.Headers = param
	return options
}

// RemoveWorkerPoolZoneOptions : The RemoveWorkerPoolZone options.
type RemoveWorkerPoolZoneOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker pool. To list all worker pools for a cluster, use the `GET /v1/clusters/{idOrName}/workerpools`
	// API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	PoolidOrName *string `validate:"required,ne="`

	// The ID of the zone that you want to remove from the worker pool. To list all worker pools for a cluster, use the
	// `GET /v1/zones` API or run `ibmcloud ks zone ls`.
	Zoneid *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRemoveWorkerPoolZoneOptions : Instantiate RemoveWorkerPoolZoneOptions
func (*KubernetesServiceApiV1) NewRemoveWorkerPoolZoneOptions(idOrName string, poolidOrName string, zoneid string) *RemoveWorkerPoolZoneOptions {
	return &RemoveWorkerPoolZoneOptions{
		IdOrName:     core.StringPtr(idOrName),
		PoolidOrName: core.StringPtr(poolidOrName),
		Zoneid:       core.StringPtr(zoneid),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RemoveWorkerPoolZoneOptions) SetIdOrName(idOrName string) *RemoveWorkerPoolZoneOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetPoolidOrName : Allow user to set PoolidOrName
func (options *RemoveWorkerPoolZoneOptions) SetPoolidOrName(poolidOrName string) *RemoveWorkerPoolZoneOptions {
	options.PoolidOrName = core.StringPtr(poolidOrName)
	return options
}

// SetZoneid : Allow user to set Zoneid
func (options *RemoveWorkerPoolZoneOptions) SetZoneid(zoneid string) *RemoveWorkerPoolZoneOptions {
	options.Zoneid = core.StringPtr(zoneid)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RemoveWorkerPoolZoneOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RemoveWorkerPoolZoneOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RemoveWorkerPoolZoneOptions) SetHeaders(param map[string]string) *RemoveWorkerPoolZoneOptions {
	options.Headers = param
	return options
}

// ReplaceLBHostnameOptions : The ReplaceLBHostname options.
type ReplaceLBHostnameOptions struct {
	Cluster *string

	LbHostname *string

	NlbSubdomain *string

	SecretNamespace *string

	Type *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceLBHostnameOptions : Instantiate ReplaceLBHostnameOptions
func (*KubernetesServiceApiV1) NewReplaceLBHostnameOptions() *ReplaceLBHostnameOptions {
	return &ReplaceLBHostnameOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *ReplaceLBHostnameOptions) SetCluster(cluster string) *ReplaceLBHostnameOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetLbHostname : Allow user to set LbHostname
func (options *ReplaceLBHostnameOptions) SetLbHostname(lbHostname string) *ReplaceLBHostnameOptions {
	options.LbHostname = core.StringPtr(lbHostname)
	return options
}

// SetNlbSubdomain : Allow user to set NlbSubdomain
func (options *ReplaceLBHostnameOptions) SetNlbSubdomain(nlbSubdomain string) *ReplaceLBHostnameOptions {
	options.NlbSubdomain = core.StringPtr(nlbSubdomain)
	return options
}

// SetSecretNamespace : Allow user to set SecretNamespace
func (options *ReplaceLBHostnameOptions) SetSecretNamespace(secretNamespace string) *ReplaceLBHostnameOptions {
	options.SecretNamespace = core.StringPtr(secretNamespace)
	return options
}

// SetType : Allow user to set Type
func (options *ReplaceLBHostnameOptions) SetType(typeVar string) *ReplaceLBHostnameOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceLBHostnameOptions) SetHeaders(param map[string]string) *ReplaceLBHostnameOptions {
	options.Headers = param
	return options
}

// ReplaceWorkerOptions : The ReplaceWorker options.
type ReplaceWorkerOptions struct {
	Cluster *string

	Update *bool

	WorkerID *string

	// The resource group that the cluster is in. To check the resource group ID of a VPC cluster, use the `GET
	// /v2/vpc/getCluster?cluster=idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewReplaceWorkerOptions : Instantiate ReplaceWorkerOptions
func (*KubernetesServiceApiV1) NewReplaceWorkerOptions() *ReplaceWorkerOptions {
	return &ReplaceWorkerOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *ReplaceWorkerOptions) SetCluster(cluster string) *ReplaceWorkerOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetUpdate : Allow user to set Update
func (options *ReplaceWorkerOptions) SetUpdate(update bool) *ReplaceWorkerOptions {
	options.Update = core.BoolPtr(update)
	return options
}

// SetWorkerID : Allow user to set WorkerID
func (options *ReplaceWorkerOptions) SetWorkerID(workerID string) *ReplaceWorkerOptions {
	options.WorkerID = core.StringPtr(workerID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ReplaceWorkerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ReplaceWorkerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ReplaceWorkerOptions) SetHeaders(param map[string]string) *ReplaceWorkerOptions {
	options.Headers = param
	return options
}

// ResetUserAPIKeyOptions : The ResetUserAPIKey options.
type ResetUserAPIKeyOptions struct {
	// Target the IBM Cloud Kubernetes Service region where you want to reset the IAM API key. To list available regions,
	// use the `GET /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string `validate:"required"`

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewResetUserAPIKeyOptions : Instantiate ResetUserAPIKeyOptions
func (*KubernetesServiceApiV1) NewResetUserAPIKeyOptions(xRegion string, xAuthRefreshToken string) *ResetUserAPIKeyOptions {
	return &ResetUserAPIKeyOptions{
		XRegion:           core.StringPtr(xRegion),
		XAuthRefreshToken: core.StringPtr(xAuthRefreshToken),
	}
}

// SetXRegion : Allow user to set XRegion
func (options *ResetUserAPIKeyOptions) SetXRegion(xRegion string) *ResetUserAPIKeyOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *ResetUserAPIKeyOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *ResetUserAPIKeyOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ResetUserAPIKeyOptions) SetHeaders(param map[string]string) *ResetUserAPIKeyOptions {
	options.Headers = param
	return options
}

// ResourceFieldSelector : ResourceFieldSelector represents container resources (cpu, memory) and their output format.
type ResourceFieldSelector struct {
	// Container name: required for volumes, optional for env vars
	// +optional.
	ContainerName *string `json:"containerName,omitempty"`

	// The serialization format is:
	//
	// <quantity>        ::= <signedNumber><suffix>
	// (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
	// <digit>           ::= 0 | 1 | ... | 9
	// <digits>          ::= <digit> | <digit><digits>
	// <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits>
	// <sign>            ::= "+" | "-"
	// <signedNumber>    ::= <number> | <sign><number>
	// <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI>
	// <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
	// (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
	// <decimalSI>       ::= m | "" | k | M | G | T | P | E
	// (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
	// <decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>
	//
	// No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in
	// magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up.
	// (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.
	//
	// When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type
	// again when it is serialized.
	//
	// Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or
	// down (with a corresponding increase or decrease in Mantissa) such that: a. No precision is lost b. No fractional
	// digits will be emitted c. The exponent (or suffix) is as large as possible. The sign will be omitted unless the
	// number is negative.
	//
	// Examples: 1.5 will be serialized as "1500m" 1.5Gi will be serialized as "1536Mi"
	//
	// Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of
	// this exercise.
	//
	// Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical
	// form. (So always use canonical form, or don't diff.)
	//
	// This format is intended to make it difficult to use these numbers without writing some sort of special handling code
	// in the hopes that that will cause implementors to also use a fixed point implementation.
	//
	// +protobuf=true
	// +protobuf.embed=string
	// +protobuf.options.marshal=false
	// +protobuf.options.(gogoproto.goproto_stringer)=false
	// +k8s:deepcopy-gen=true
	// +k8s:openapi-gen=true.
	Divisor interface{} `json:"divisor,omitempty"`

	// Required: resource to select.
	Resource *string `json:"resource,omitempty"`
}

// UnmarshalResourceFieldSelector unmarshals an instance of ResourceFieldSelector from the specified map of raw messages.
func UnmarshalResourceFieldSelector(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResourceFieldSelector)
	err = core.UnmarshalPrimitive(m, "containerName", &obj.ContainerName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "divisor", &obj.Divisor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource", &obj.Resource)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ResponseErrors : ResponseErrors are used to communicate to non-critical errors to end users.
type ResponseErrors struct {
	IncidentID *string `json:"incidentID,omitempty"`

	Items []UserError `json:"items,omitempty"`
}

// UnmarshalResponseErrors unmarshals an instance of ResponseErrors from the specified map of raw messages.
func UnmarshalResponseErrors(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ResponseErrors)
	err = core.UnmarshalPrimitive(m, "incidentID", &obj.IncidentID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "items", &obj.Items, UnmarshalUserError)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RollbackUpdateOptions : The RollbackUpdate options.
type RollbackUpdateOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewRollbackUpdateOptions : Instantiate RollbackUpdateOptions
func (*KubernetesServiceApiV1) NewRollbackUpdateOptions(idOrName string) *RollbackUpdateOptions {
	return &RollbackUpdateOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *RollbackUpdateOptions) SetIdOrName(idOrName string) *RollbackUpdateOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *RollbackUpdateOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *RollbackUpdateOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *RollbackUpdateOptions) SetHeaders(param map[string]string) *RollbackUpdateOptions {
	options.Headers = param
	return options
}

// SatelliteCreateWorkerPoolZone : SatelliteCreateWorkerPoolZone contains all fields in the zones part of all requests to create worker pools.
type SatelliteCreateWorkerPoolZone struct {
	ID *string `json:"id,omitempty"`
}

// UnmarshalSatelliteCreateWorkerPoolZone unmarshals an instance of SatelliteCreateWorkerPoolZone from the specified map of raw messages.
func UnmarshalSatelliteCreateWorkerPoolZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SatelliteCreateWorkerPoolZone)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Secret : Secret struct holding details for a single secret.
type Secret struct {
	Cluster *string `json:"cluster,omitempty"`

	Crn *string `json:"crn,omitempty"`

	Domain *string `json:"domain,omitempty"`

	ExpiresOn *string `json:"expiresOn,omitempty"`

	Name *string `json:"name,omitempty"`

	Namespace *string `json:"namespace,omitempty"`

	Persistence *bool `json:"persistence,omitempty"`

	Status *string `json:"status,omitempty"`

	UserManaged *bool `json:"userManaged,omitempty"`
}

// UnmarshalSecret unmarshals an instance of Secret from the specified map of raw messages.
func UnmarshalSecret(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Secret)
	err = core.UnmarshalPrimitive(m, "cluster", &obj.Cluster)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.Crn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "domain", &obj.Domain)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expiresOn", &obj.ExpiresOn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "namespace", &obj.Namespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "persistence", &obj.Persistence)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "userManaged", &obj.UserManaged)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SecretKeySelector : SecretKeySelector struct
type SecretKeySelector struct {
	// The key of the secret to select from.  Must be a valid secret key.
	Key *string `json:"key,omitempty"`

	// Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
	// TODO: Add other useful fields. apiVersion, kind, uid?
	// +optional.
	Name *string `json:"name,omitempty"`

	// Specify whether the Secret or it's key must be defined
	// +optional.
	Optional *bool `json:"optional,omitempty"`
}

// UnmarshalSecretKeySelector unmarshals an instance of SecretKeySelector from the specified map of raw messages.
func UnmarshalSecretKeySelector(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SecretKeySelector)
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "optional", &obj.Optional)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StartMigrationOptions : The StartMigration options.
type StartMigrationOptions struct {
	Cluster *string

	Options []string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewStartMigrationOptions : Instantiate StartMigrationOptions
func (*KubernetesServiceApiV1) NewStartMigrationOptions() *StartMigrationOptions {
	return &StartMigrationOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *StartMigrationOptions) SetCluster(cluster string) *StartMigrationOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *StartMigrationOptions) SetHeaders(param map[string]string) *StartMigrationOptions {
	options.Headers = param
	return options
}

// StorageConfig : StorageConfig struct
type StorageConfig struct {
	ConfigName *string `json:"config-name,omitempty"`

	ConfigVersion *string `json:"config-version,omitempty"`

	SourceBranch *string `json:"source-branch,omitempty"`

	SourceOrg *string `json:"source-org,omitempty"`

	StorageClassParameters []map[string]string `json:"storage-class-parameters,omitempty"`

	StorageTemplateName *string `json:"storage-template-name,omitempty"`

	StorageTemplateVersion *string `json:"storage-template-version,omitempty"`

	UserConfigParameters map[string]string `json:"user-config-parameters,omitempty"`

	UserSecretParameters map[string]string `json:"user-secret-parameters,omitempty"`

	UUID *string `json:"uuid,omitempty"`
}

// UnmarshalStorageConfig unmarshals an instance of StorageConfig from the specified map of raw messages.
func UnmarshalStorageConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageConfig)
	err = core.UnmarshalPrimitive(m, "config-name", &obj.ConfigName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "config-version", &obj.ConfigVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source-branch", &obj.SourceBranch)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "source-org", &obj.SourceOrg)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage-class-parameters", &obj.StorageClassParameters)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage-template-name", &obj.StorageTemplateName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage-template-version", &obj.StorageTemplateVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user-config-parameters", &obj.UserConfigParameters)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "user-secret-parameters", &obj.UserSecretParameters)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StoreUserCredentialsOptions : The StoreUserCredentials options.
type StoreUserCredentialsOptions struct {
	// Target the IBM Cloud Kubernetes Service region where you want to set infrastructure credentials. To list available
	// regions, use the `GET /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string `validate:"required"`

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string `validate:"required"`

	// The user name of the IBM Cloud infrastructure (SoftLayer) account that you want to use with Kubernetes Service. To
	// retrieve your user name, log into your SoftLayer account, click your profile name, and click the API Account
	// Information section.
	XAuthSoftlayerUsername *string `validate:"required"`

	// The API key of the IBM Cloud infrastructure (SoftLayer) account that you want to use with Kubernetes Service. To
	// retrieve your API key, log into your SoftLayer account, click your profile name, and click the API Account
	// Information section.
	XAuthSoftlayerAPIKey *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewStoreUserCredentialsOptions : Instantiate StoreUserCredentialsOptions
func (*KubernetesServiceApiV1) NewStoreUserCredentialsOptions(xRegion string, xAuthRefreshToken string, xAuthSoftlayerUsername string, xAuthSoftlayerAPIKey string) *StoreUserCredentialsOptions {
	return &StoreUserCredentialsOptions{
		XRegion:                core.StringPtr(xRegion),
		XAuthRefreshToken:      core.StringPtr(xAuthRefreshToken),
		XAuthSoftlayerUsername: core.StringPtr(xAuthSoftlayerUsername),
		XAuthSoftlayerAPIKey:   core.StringPtr(xAuthSoftlayerAPIKey),
	}
}

// SetXRegion : Allow user to set XRegion
func (options *StoreUserCredentialsOptions) SetXRegion(xRegion string) *StoreUserCredentialsOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *StoreUserCredentialsOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *StoreUserCredentialsOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetXAuthSoftlayerUsername : Allow user to set XAuthSoftlayerUsername
func (options *StoreUserCredentialsOptions) SetXAuthSoftlayerUsername(xAuthSoftlayerUsername string) *StoreUserCredentialsOptions {
	options.XAuthSoftlayerUsername = core.StringPtr(xAuthSoftlayerUsername)
	return options
}

// SetXAuthSoftlayerAPIKey : Allow user to set XAuthSoftlayerAPIKey
func (options *StoreUserCredentialsOptions) SetXAuthSoftlayerAPIKey(xAuthSoftlayerAPIKey string) *StoreUserCredentialsOptions {
	options.XAuthSoftlayerAPIKey = core.StringPtr(xAuthSoftlayerAPIKey)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *StoreUserCredentialsOptions) SetHeaders(param map[string]string) *StoreUserCredentialsOptions {
	options.Headers = param
	return options
}

// Subnet : Subnet provides information about a vpc subnet.
type Subnet struct {
	AvailableIPv4AddressCount *int64 `json:"availableIPv4AddressCount,omitempty"`

	ID *string `json:"id,omitempty"`

	Ipv4CIDRBlock *string `json:"ipv4CIDRBlock,omitempty"`

	Name *string `json:"name,omitempty"`

	PublicGatewayID *string `json:"publicGatewayID,omitempty"`

	PublicGatewayName *string `json:"publicGatewayName,omitempty"`

	VpcID *string `json:"vpcID,omitempty"`

	VpcName *string `json:"vpcName,omitempty"`

	Zone *string `json:"zone,omitempty"`
}

// UnmarshalSubnet unmarshals an instance of Subnet from the specified map of raw messages.
func UnmarshalSubnet(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subnet)
	err = core.UnmarshalPrimitive(m, "availableIPv4AddressCount", &obj.AvailableIPv4AddressCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipv4CIDRBlock", &obj.Ipv4CIDRBlock)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicGatewayID", &obj.PublicGatewayID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicGatewayName", &obj.PublicGatewayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcID", &obj.VpcID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcName", &obj.VpcName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "zone", &obj.Zone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubnetConfigField : SubnetConfigField TODO provide a meaningful comment.
type SubnetConfigField struct {
	Cidr *string `json:"cidr,omitempty"`

	ID *string `json:"id,omitempty"`

	Ips []string `json:"ips,omitempty"`

	IsByoip *bool `json:"is_byoip,omitempty"`

	IsPublic *bool `json:"is_public,omitempty"`
}

// UnmarshalSubnetConfigField unmarshals an instance of SubnetConfigField from the specified map of raw messages.
func UnmarshalSubnetConfigField(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubnetConfigField)
	err = core.UnmarshalPrimitive(m, "cidr", &obj.Cidr)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ips", &obj.Ips)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_byoip", &obj.IsByoip)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "is_public", &obj.IsPublic)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Subscription : Subscription struct
type Subscription struct {
	ChannelName *string `json:"channelName,omitempty"`

	ChannelUUID *string `json:"channelUuid,omitempty"`

	Created *string `json:"created,omitempty"`

	Groups []string `json:"groups,omitempty"`

	Name *string `json:"name,omitempty"`

	OrgID *string `json:"orgId,omitempty"`

	Owner *SubscriptionOwner `json:"owner,omitempty"`

	Updated *string `json:"updated,omitempty"`

	UUID *string `json:"uuid,omitempty"`

	Version *string `json:"version,omitempty"`

	VersionUUID *string `json:"versionUuid,omitempty"`
}

// UnmarshalSubscription unmarshals an instance of Subscription from the specified map of raw messages.
func UnmarshalSubscription(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Subscription)
	err = core.UnmarshalPrimitive(m, "channelName", &obj.ChannelName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "channelUuid", &obj.ChannelUUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created", &obj.Created)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "groups", &obj.Groups)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "orgId", &obj.OrgID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "owner", &obj.Owner, UnmarshalSubscriptionOwner)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updated", &obj.Updated)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "versionUuid", &obj.VersionUUID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SubscriptionOwner : SubscriptionOwner struct
type SubscriptionOwner struct {
	ID *string `json:"id,omitempty"`

	Name *string `json:"name,omitempty"`
}

// UnmarshalSubscriptionOwner unmarshals an instance of SubscriptionOwner from the specified map of raw messages.
func UnmarshalSubscriptionOwner(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SubscriptionOwner)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UnbindServiceFromNamespaceOptions : The UnbindServiceFromNamespace options.
type UnbindServiceFromNamespaceOptions struct {
	// The name or ID of the cluster where you want to unbind your IBM Cloud service instance. To list bound IBM Cloud
	// services and their namespaces, use the `GET /v1/clusters/{nameOrId}/services` API or run `ibmcloud ks cluster
	// service ls --cluster <cluster_name_or_ID>`.
	IdOrName *string `validate:"required,ne="`

	// The Kubernetes namespace where your IBM Cloud service was bound to. To list bound IBM Cloud services and their
	// namespaces, use the `GET /v1/clusters/{nameOrId}/services` API or run `ibmcloud ks cluster service ls --cluster
	// <cluster_name_or_ID>`.
	Namespace *string `validate:"required,ne="`

	// The name or ID of the IBM Cloud service instance that was bound to your cluster. To list bound IBM Cloud services
	// and their namespaces, use the `GET /v1/clusters/{nameOrId}/services` API or run `ibmcloud ks cluster service ls
	// --cluster <cluster_name_or_ID>`.
	ServiceInstanceID *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUnbindServiceFromNamespaceOptions : Instantiate UnbindServiceFromNamespaceOptions
func (*KubernetesServiceApiV1) NewUnbindServiceFromNamespaceOptions(idOrName string, namespace string, serviceInstanceID string) *UnbindServiceFromNamespaceOptions {
	return &UnbindServiceFromNamespaceOptions{
		IdOrName:          core.StringPtr(idOrName),
		Namespace:         core.StringPtr(namespace),
		ServiceInstanceID: core.StringPtr(serviceInstanceID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UnbindServiceFromNamespaceOptions) SetIdOrName(idOrName string) *UnbindServiceFromNamespaceOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *UnbindServiceFromNamespaceOptions) SetNamespace(namespace string) *UnbindServiceFromNamespaceOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetServiceInstanceID : Allow user to set ServiceInstanceID
func (options *UnbindServiceFromNamespaceOptions) SetServiceInstanceID(serviceInstanceID string) *UnbindServiceFromNamespaceOptions {
	options.ServiceInstanceID = core.StringPtr(serviceInstanceID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *UnbindServiceFromNamespaceOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *UnbindServiceFromNamespaceOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UnbindServiceFromNamespaceOptions) SetHeaders(param map[string]string) *UnbindServiceFromNamespaceOptions {
	options.Headers = param
	return options
}

// UnregisterDNSWithIPOptions : The UnregisterDNSWithIP options.
type UnregisterDNSWithIPOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The existing NLB subdomain from which you want remove an NLB IP. To list existing NLB subdomains, use the `GET
	// /clusters/{idOrName}/list` API or run `ibmcloud ks nlb-dns ls --cluster <cluster_name_or_ID>`.
	NlbHost *string `validate:"required,ne="`

	// The NLB IP address that you want to unregister from the DNS record for the hostname. To list the NLB IPs registered
	// with NLB subdomains, use the `GET /clusters/{idOrName}/list` API or run `ibmcloud ks nlb-dns ls --cluster
	// <cluster_name_or_ID>`.
	NlbIP *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUnregisterDNSWithIPOptions : Instantiate UnregisterDNSWithIPOptions
func (*KubernetesServiceApiV1) NewUnregisterDNSWithIPOptions(idOrName string, nlbHost string, nlbIP string) *UnregisterDNSWithIPOptions {
	return &UnregisterDNSWithIPOptions{
		IdOrName: core.StringPtr(idOrName),
		NlbHost:  core.StringPtr(nlbHost),
		NlbIP:    core.StringPtr(nlbIP),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UnregisterDNSWithIPOptions) SetIdOrName(idOrName string) *UnregisterDNSWithIPOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetNlbHost : Allow user to set NlbHost
func (options *UnregisterDNSWithIPOptions) SetNlbHost(nlbHost string) *UnregisterDNSWithIPOptions {
	options.NlbHost = core.StringPtr(nlbHost)
	return options
}

// SetNlbIP : Allow user to set NlbIP
func (options *UnregisterDNSWithIPOptions) SetNlbIP(nlbIP string) *UnregisterDNSWithIPOptions {
	options.NlbIP = core.StringPtr(nlbIP)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *UnregisterDNSWithIPOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *UnregisterDNSWithIPOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UnregisterDNSWithIPOptions) SetHeaders(param map[string]string) *UnregisterDNSWithIPOptions {
	options.Headers = param
	return options
}

// UnsatisfiedLabels : UnsatisfiedLabels describes any host labels that must be created to fulfill pending worker pool assignments.
type UnsatisfiedLabels struct {
	Labels []Label `json:"labels,omitempty"`

	Pending *int64 `json:"pending,omitempty"`

	WorkerPoolID *string `json:"workerPoolID,omitempty"`

	WorkerPoolName *string `json:"workerPoolName,omitempty"`
}

// UnmarshalUnsatisfiedLabels unmarshals an instance of UnsatisfiedLabels from the specified map of raw messages.
func UnmarshalUnsatisfiedLabels(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UnsatisfiedLabels)
	err = core.UnmarshalModel(m, "labels", &obj.Labels, UnmarshalLabel)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pending", &obj.Pending)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerPoolID", &obj.WorkerPoolID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerPoolName", &obj.WorkerPoolName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateALBSecretOptions : The UpdateALBSecret options.
type UpdateALBSecretOptions struct {
	// The CRN of the Certificate Manager instance where the TLS certificate is downloaded from.
	CertCrn *string

	// The Certificate Manager instance ID where the TLS certificate is downloaded from.
	CloudCertInstanceID *string

	// The CRN of the cluster where the ALB secret was created.
	ClusterCrn *string

	// The ID of the cluster where the ALB secret was created.
	ClusterID *string

	// The domain name of the TLS certficate that the ALB uses.
	DomainName *string

	// The expiration date of the certficate.
	ExpiresOn *string

	// The name of the issuer of the certficate.
	IssuerName *string

	// The name of the ALB secret.
	SecretName *string

	// The state of ALB secret.
	State *string

	// The status of ALB secret.
	Status *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateALBSecretOptions : Instantiate UpdateALBSecretOptions
func (*KubernetesServiceApiV1) NewUpdateALBSecretOptions() *UpdateALBSecretOptions {
	return &UpdateALBSecretOptions{}
}

// SetCertCrn : Allow user to set CertCrn
func (options *UpdateALBSecretOptions) SetCertCrn(certCrn string) *UpdateALBSecretOptions {
	options.CertCrn = core.StringPtr(certCrn)
	return options
}

// SetCloudCertInstanceID : Allow user to set CloudCertInstanceID
func (options *UpdateALBSecretOptions) SetCloudCertInstanceID(cloudCertInstanceID string) *UpdateALBSecretOptions {
	options.CloudCertInstanceID = core.StringPtr(cloudCertInstanceID)
	return options
}

// SetClusterCrn : Allow user to set ClusterCrn
func (options *UpdateALBSecretOptions) SetClusterCrn(clusterCrn string) *UpdateALBSecretOptions {
	options.ClusterCrn = core.StringPtr(clusterCrn)
	return options
}

// SetClusterID : Allow user to set ClusterID
func (options *UpdateALBSecretOptions) SetClusterID(clusterID string) *UpdateALBSecretOptions {
	options.ClusterID = core.StringPtr(clusterID)
	return options
}

// SetDomainName : Allow user to set DomainName
func (options *UpdateALBSecretOptions) SetDomainName(domainName string) *UpdateALBSecretOptions {
	options.DomainName = core.StringPtr(domainName)
	return options
}

// SetExpiresOn : Allow user to set ExpiresOn
func (options *UpdateALBSecretOptions) SetExpiresOn(expiresOn string) *UpdateALBSecretOptions {
	options.ExpiresOn = core.StringPtr(expiresOn)
	return options
}

// SetIssuerName : Allow user to set IssuerName
func (options *UpdateALBSecretOptions) SetIssuerName(issuerName string) *UpdateALBSecretOptions {
	options.IssuerName = core.StringPtr(issuerName)
	return options
}

// SetSecretName : Allow user to set SecretName
func (options *UpdateALBSecretOptions) SetSecretName(secretName string) *UpdateALBSecretOptions {
	options.SecretName = core.StringPtr(secretName)
	return options
}

// SetState : Allow user to set State
func (options *UpdateALBSecretOptions) SetState(state string) *UpdateALBSecretOptions {
	options.State = core.StringPtr(state)
	return options
}

// SetStatus : Allow user to set Status
func (options *UpdateALBSecretOptions) SetStatus(status string) *UpdateALBSecretOptions {
	options.Status = core.StringPtr(status)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateALBSecretOptions) SetHeaders(param map[string]string) *UpdateALBSecretOptions {
	options.Headers = param
	return options
}

// UpdateALBsOptions : The UpdateALBs options.
type UpdateALBsOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateALBsOptions : Instantiate UpdateALBsOptions
func (*KubernetesServiceApiV1) NewUpdateALBsOptions(idOrName string) *UpdateALBsOptions {
	return &UpdateALBsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UpdateALBsOptions) SetIdOrName(idOrName string) *UpdateALBsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *UpdateALBsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *UpdateALBsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateALBsOptions) SetHeaders(param map[string]string) *UpdateALBsOptions {
	options.Headers = param
	return options
}

// UpdateAssignmentOptions : The UpdateAssignment options.
type UpdateAssignmentOptions struct {
	ChannelUUID *string

	Groups []string

	Name *string

	UUID *string

	VersionUUID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateAssignmentOptions : Instantiate UpdateAssignmentOptions
func (*KubernetesServiceApiV1) NewUpdateAssignmentOptions() *UpdateAssignmentOptions {
	return &UpdateAssignmentOptions{}
}

// SetChannelUUID : Allow user to set ChannelUUID
func (options *UpdateAssignmentOptions) SetChannelUUID(channelUUID string) *UpdateAssignmentOptions {
	options.ChannelUUID = core.StringPtr(channelUUID)
	return options
}

// SetGroups : Allow user to set Groups
func (options *UpdateAssignmentOptions) SetGroups(groups []string) *UpdateAssignmentOptions {
	options.Groups = groups
	return options
}

// SetName : Allow user to set Name
func (options *UpdateAssignmentOptions) SetName(name string) *UpdateAssignmentOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetUUID : Allow user to set UUID
func (options *UpdateAssignmentOptions) SetUUID(uuid string) *UpdateAssignmentOptions {
	options.UUID = core.StringPtr(uuid)
	return options
}

// SetVersionUUID : Allow user to set VersionUUID
func (options *UpdateAssignmentOptions) SetVersionUUID(versionUUID string) *UpdateAssignmentOptions {
	options.VersionUUID = core.StringPtr(versionUUID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateAssignmentOptions) SetHeaders(param map[string]string) *UpdateAssignmentOptions {
	options.Headers = param
	return options
}

// UpdateAssignmentVersionOptions : The UpdateAssignmentVersion options.
type UpdateAssignmentVersionOptions struct {
	UUID *string

	VersionUUID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateAssignmentVersionOptions : Instantiate UpdateAssignmentVersionOptions
func (*KubernetesServiceApiV1) NewUpdateAssignmentVersionOptions() *UpdateAssignmentVersionOptions {
	return &UpdateAssignmentVersionOptions{}
}

// SetUUID : Allow user to set UUID
func (options *UpdateAssignmentVersionOptions) SetUUID(uuid string) *UpdateAssignmentVersionOptions {
	options.UUID = core.StringPtr(uuid)
	return options
}

// SetVersionUUID : Allow user to set VersionUUID
func (options *UpdateAssignmentVersionOptions) SetVersionUUID(versionUUID string) *UpdateAssignmentVersionOptions {
	options.VersionUUID = core.StringPtr(versionUUID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateAssignmentVersionOptions) SetHeaders(param map[string]string) *UpdateAssignmentVersionOptions {
	options.Headers = param
	return options
}

// UpdateAuditWebhookOptions : The UpdateAuditWebhook options.
type UpdateAuditWebhookOptions struct {
	// The name or ID of the cluster where you want to add an audit configuration or change the audit configuration. To
	// list the clusters that you have access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The URL of the server to send audit logs to.
	AuditServer *string

	// The Certificate Authority certificate that is used to connect to the audit server.
	CaCertificate *string

	// The client certificate that is used to connect to the audit server.
	ClientCertificate *string

	// The client key that is used to connect to the audit server.
	ClientKey *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateAuditWebhookOptions : Instantiate UpdateAuditWebhookOptions
func (*KubernetesServiceApiV1) NewUpdateAuditWebhookOptions(idOrName string) *UpdateAuditWebhookOptions {
	return &UpdateAuditWebhookOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UpdateAuditWebhookOptions) SetIdOrName(idOrName string) *UpdateAuditWebhookOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAuditServer : Allow user to set AuditServer
func (options *UpdateAuditWebhookOptions) SetAuditServer(auditServer string) *UpdateAuditWebhookOptions {
	options.AuditServer = core.StringPtr(auditServer)
	return options
}

// SetCaCertificate : Allow user to set CaCertificate
func (options *UpdateAuditWebhookOptions) SetCaCertificate(caCertificate string) *UpdateAuditWebhookOptions {
	options.CaCertificate = core.StringPtr(caCertificate)
	return options
}

// SetClientCertificate : Allow user to set ClientCertificate
func (options *UpdateAuditWebhookOptions) SetClientCertificate(clientCertificate string) *UpdateAuditWebhookOptions {
	options.ClientCertificate = core.StringPtr(clientCertificate)
	return options
}

// SetClientKey : Allow user to set ClientKey
func (options *UpdateAuditWebhookOptions) SetClientKey(clientKey string) *UpdateAuditWebhookOptions {
	options.ClientKey = core.StringPtr(clientKey)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *UpdateAuditWebhookOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *UpdateAuditWebhookOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateAuditWebhookOptions) SetHeaders(param map[string]string) *UpdateAuditWebhookOptions {
	options.Headers = param
	return options
}

// UpdateClusterOptions : The UpdateCluster options.
type UpdateClusterOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The action to perform on the master.
	Action *string

	// If set to true, any warnings during the update process are ignored.
	Force *bool

	// The Kubernetes version to use for the update.
	Version *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateClusterOptions : Instantiate UpdateClusterOptions
func (*KubernetesServiceApiV1) NewUpdateClusterOptions(idOrName string) *UpdateClusterOptions {
	return &UpdateClusterOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UpdateClusterOptions) SetIdOrName(idOrName string) *UpdateClusterOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetAction : Allow user to set Action
func (options *UpdateClusterOptions) SetAction(action string) *UpdateClusterOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetForce : Allow user to set Force
func (options *UpdateClusterOptions) SetForce(force bool) *UpdateClusterOptions {
	options.Force = core.BoolPtr(force)
	return options
}

// SetVersion : Allow user to set Version
func (options *UpdateClusterOptions) SetVersion(version string) *UpdateClusterOptions {
	options.Version = core.StringPtr(version)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *UpdateClusterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *UpdateClusterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateClusterOptions) SetHeaders(param map[string]string) *UpdateClusterOptions {
	options.Headers = param
	return options
}

// UpdateClusterWorkerOptions : The UpdateClusterWorker options.
type UpdateClusterWorkerOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The ID of the worker node. To list all worker nodes for a cluster, use the `GET /v1/clusters/{idOrName}/workers` API
	// or run `ibmcloud ks worker ls --cluster <cluster_name_or_ID>`.
	WorkerID *string `validate:"required,ne="`

	// The action to perform on the worker node.
	Action *string

	// Setting force flag to true will ignore if the master is unavailable during 'os_reboot" and 'reload' action.
	Force *bool

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateClusterWorkerOptions : Instantiate UpdateClusterWorkerOptions
func (*KubernetesServiceApiV1) NewUpdateClusterWorkerOptions(idOrName string, workerID string) *UpdateClusterWorkerOptions {
	return &UpdateClusterWorkerOptions{
		IdOrName: core.StringPtr(idOrName),
		WorkerID: core.StringPtr(workerID),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UpdateClusterWorkerOptions) SetIdOrName(idOrName string) *UpdateClusterWorkerOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetWorkerID : Allow user to set WorkerID
func (options *UpdateClusterWorkerOptions) SetWorkerID(workerID string) *UpdateClusterWorkerOptions {
	options.WorkerID = core.StringPtr(workerID)
	return options
}

// SetAction : Allow user to set Action
func (options *UpdateClusterWorkerOptions) SetAction(action string) *UpdateClusterWorkerOptions {
	options.Action = core.StringPtr(action)
	return options
}

// SetForce : Allow user to set Force
func (options *UpdateClusterWorkerOptions) SetForce(force bool) *UpdateClusterWorkerOptions {
	options.Force = core.BoolPtr(force)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *UpdateClusterWorkerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *UpdateClusterWorkerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateClusterWorkerOptions) SetHeaders(param map[string]string) *UpdateClusterWorkerOptions {
	options.Headers = param
	return options
}

// UpdateDNSWithIPOptions : The UpdateDNSWithIP options.
type UpdateDNSWithIPOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	ClusterID *string

	NlbHost *string

	NlbIPArray []string

	NlbMonitorState *string

	NlbSslSecretName *string

	NlbSslSecretStatus *string

	NlbType *string

	SecretNamespace *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateDNSWithIPOptions : Instantiate UpdateDNSWithIPOptions
func (*KubernetesServiceApiV1) NewUpdateDNSWithIPOptions(idOrName string) *UpdateDNSWithIPOptions {
	return &UpdateDNSWithIPOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UpdateDNSWithIPOptions) SetIdOrName(idOrName string) *UpdateDNSWithIPOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetClusterID : Allow user to set ClusterID
func (options *UpdateDNSWithIPOptions) SetClusterID(clusterID string) *UpdateDNSWithIPOptions {
	options.ClusterID = core.StringPtr(clusterID)
	return options
}

// SetNlbHost : Allow user to set NlbHost
func (options *UpdateDNSWithIPOptions) SetNlbHost(nlbHost string) *UpdateDNSWithIPOptions {
	options.NlbHost = core.StringPtr(nlbHost)
	return options
}

// SetNlbIPArray : Allow user to set NlbIPArray
func (options *UpdateDNSWithIPOptions) SetNlbIPArray(nlbIPArray []string) *UpdateDNSWithIPOptions {
	options.NlbIPArray = nlbIPArray
	return options
}

// SetNlbMonitorState : Allow user to set NlbMonitorState
func (options *UpdateDNSWithIPOptions) SetNlbMonitorState(nlbMonitorState string) *UpdateDNSWithIPOptions {
	options.NlbMonitorState = core.StringPtr(nlbMonitorState)
	return options
}

// SetNlbSslSecretName : Allow user to set NlbSslSecretName
func (options *UpdateDNSWithIPOptions) SetNlbSslSecretName(nlbSslSecretName string) *UpdateDNSWithIPOptions {
	options.NlbSslSecretName = core.StringPtr(nlbSslSecretName)
	return options
}

// SetNlbSslSecretStatus : Allow user to set NlbSslSecretStatus
func (options *UpdateDNSWithIPOptions) SetNlbSslSecretStatus(nlbSslSecretStatus string) *UpdateDNSWithIPOptions {
	options.NlbSslSecretStatus = core.StringPtr(nlbSslSecretStatus)
	return options
}

// SetNlbType : Allow user to set NlbType
func (options *UpdateDNSWithIPOptions) SetNlbType(nlbType string) *UpdateDNSWithIPOptions {
	options.NlbType = core.StringPtr(nlbType)
	return options
}

// SetSecretNamespace : Allow user to set SecretNamespace
func (options *UpdateDNSWithIPOptions) SetSecretNamespace(secretNamespace string) *UpdateDNSWithIPOptions {
	options.SecretNamespace = core.StringPtr(secretNamespace)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *UpdateDNSWithIPOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *UpdateDNSWithIPOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateDNSWithIPOptions) SetHeaders(param map[string]string) *UpdateDNSWithIPOptions {
	options.Headers = param
	return options
}

// UpdateFilterConfigOptions : The UpdateFilterConfig options.
type UpdateFilterConfigOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The UUID for the filterConfig that you want to update.
	ID *string `validate:"required,ne="`

	// The name of the container where you want to apply the logging filter.
	Container *string

	// The log level that you want to apply to your logging filter.
	LogLevel *string

	// A list of logging configuration IDs where you want to apply the logging filter.
	LoggingConfigs []string

	// A string in a message to which you want to apply the logging filter.
	Message *string

	// The Kubernetes namespace where you want to apply the logging filter.
	Namespace *string

	// Set this value to `true` if you want the message field to be interpreted as a regular expression.
	RegexMessageEnabled *bool

	// The type of the logging filter.
	Type *string

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateFilterConfigOptions : Instantiate UpdateFilterConfigOptions
func (*KubernetesServiceApiV1) NewUpdateFilterConfigOptions(idOrName string, id string) *UpdateFilterConfigOptions {
	return &UpdateFilterConfigOptions{
		IdOrName: core.StringPtr(idOrName),
		ID:       core.StringPtr(id),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UpdateFilterConfigOptions) SetIdOrName(idOrName string) *UpdateFilterConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateFilterConfigOptions) SetID(id string) *UpdateFilterConfigOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetContainer : Allow user to set Container
func (options *UpdateFilterConfigOptions) SetContainer(container string) *UpdateFilterConfigOptions {
	options.Container = core.StringPtr(container)
	return options
}

// SetLogLevel : Allow user to set LogLevel
func (options *UpdateFilterConfigOptions) SetLogLevel(logLevel string) *UpdateFilterConfigOptions {
	options.LogLevel = core.StringPtr(logLevel)
	return options
}

// SetLoggingConfigs : Allow user to set LoggingConfigs
func (options *UpdateFilterConfigOptions) SetLoggingConfigs(loggingConfigs []string) *UpdateFilterConfigOptions {
	options.LoggingConfigs = loggingConfigs
	return options
}

// SetMessage : Allow user to set Message
func (options *UpdateFilterConfigOptions) SetMessage(message string) *UpdateFilterConfigOptions {
	options.Message = core.StringPtr(message)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *UpdateFilterConfigOptions) SetNamespace(namespace string) *UpdateFilterConfigOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetRegexMessageEnabled : Allow user to set RegexMessageEnabled
func (options *UpdateFilterConfigOptions) SetRegexMessageEnabled(regexMessageEnabled bool) *UpdateFilterConfigOptions {
	options.RegexMessageEnabled = core.BoolPtr(regexMessageEnabled)
	return options
}

// SetType : Allow user to set Type
func (options *UpdateFilterConfigOptions) SetType(typeVar string) *UpdateFilterConfigOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *UpdateFilterConfigOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *UpdateFilterConfigOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *UpdateFilterConfigOptions) SetForceUpdate(forceUpdate bool) *UpdateFilterConfigOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateFilterConfigOptions) SetHeaders(param map[string]string) *UpdateFilterConfigOptions {
	options.Headers = param
	return options
}

// UpdateLoggingConfigOptions : The UpdateLoggingConfig options.
type UpdateLoggingConfigOptions struct {
	// The name or ID of the target cluster. To list the clusters that you have access to, run `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The log source from which you want to forward logs. Supported values are `container`, `worker`, `kubernetes`,
	// `ingress`, and `application`. If you do not provide a namespace for log source `container`, then all namespaces use
	// this configuration.
	LogSource *string `validate:"required,ne="`

	// The UUID of the logging configuration that you want to update.
	ID *string `validate:"required,ne="`

	// A list of container names that you want to collect logs for.
	AppLogContainers []string

	// A list of app paths that you want to collect logs for.
	AppLogPaths []string

	// The name of the Kubernetes secret that holds the Certificate Authority certificate that you want to use for the
	// syslog TLS termination.
	CaCert *string

	// The logging type that you want to use. Supported values are `syslog` and `ibm`.
	LoggingType *string

	// The Kubernetes namespace where the logging configuration is applied.
	Namespace *string

	// The name of the Cloud Foundry organization where the logging configuration is created.
	Org *string

	// The protocol that you want to use for syslog forwarding. Supported values are TCP, TLS and UDP. If no value is
	// provided, the protocol is set to UDP by default.
	Protocol *string

	// The port that the logging server uses. This value is required only when `LoggingType` is set to `syslog`.
	RemoteLogPort *int64

	// The hostname or IP address of the logging server. This values is required only if `LoggingType` is set to `syslog`.
	RemoteLogServer *string

	// The name of the Cloud Foundry space where the logging configuration is created.
	Space *string

	// The verification mode that you want to use for the syslog TLS protocol. By default, `verify-none` is used. Other
	// supported values include `verify-peer`, `verify-client-once`, and `verify-if-no-peer-cert`.
	VerifyMode *string

	// The unique ID of your IBM Cloud resource group when you created your cluster. To see the cluster's resource group
	// ID, run `ibmcloud ks cluster get --cluster <cluster_name_or_ID>`.
	XAuthResourceGroupID *string

	// Forces the request which may cause a new fluentd version to be deployed to the cluster.
	ForceUpdate *bool

	// Set to `true` to skip validation of the space and org Cloud Foundry properties. Skipping validation decreases
	// processing time, but an invalid logging configuration will not correctly forward logs.
	SkipValidation *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateLoggingConfigOptions : Instantiate UpdateLoggingConfigOptions
func (*KubernetesServiceApiV1) NewUpdateLoggingConfigOptions(idOrName string, logSource string, id string) *UpdateLoggingConfigOptions {
	return &UpdateLoggingConfigOptions{
		IdOrName:  core.StringPtr(idOrName),
		LogSource: core.StringPtr(logSource),
		ID:        core.StringPtr(id),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UpdateLoggingConfigOptions) SetIdOrName(idOrName string) *UpdateLoggingConfigOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetLogSource : Allow user to set LogSource
func (options *UpdateLoggingConfigOptions) SetLogSource(logSource string) *UpdateLoggingConfigOptions {
	options.LogSource = core.StringPtr(logSource)
	return options
}

// SetID : Allow user to set ID
func (options *UpdateLoggingConfigOptions) SetID(id string) *UpdateLoggingConfigOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetAppLogContainers : Allow user to set AppLogContainers
func (options *UpdateLoggingConfigOptions) SetAppLogContainers(appLogContainers []string) *UpdateLoggingConfigOptions {
	options.AppLogContainers = appLogContainers
	return options
}

// SetAppLogPaths : Allow user to set AppLogPaths
func (options *UpdateLoggingConfigOptions) SetAppLogPaths(appLogPaths []string) *UpdateLoggingConfigOptions {
	options.AppLogPaths = appLogPaths
	return options
}

// SetCaCert : Allow user to set CaCert
func (options *UpdateLoggingConfigOptions) SetCaCert(caCert string) *UpdateLoggingConfigOptions {
	options.CaCert = core.StringPtr(caCert)
	return options
}

// SetLoggingType : Allow user to set LoggingType
func (options *UpdateLoggingConfigOptions) SetLoggingType(loggingType string) *UpdateLoggingConfigOptions {
	options.LoggingType = core.StringPtr(loggingType)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *UpdateLoggingConfigOptions) SetNamespace(namespace string) *UpdateLoggingConfigOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetOrg : Allow user to set Org
func (options *UpdateLoggingConfigOptions) SetOrg(org string) *UpdateLoggingConfigOptions {
	options.Org = core.StringPtr(org)
	return options
}

// SetProtocol : Allow user to set Protocol
func (options *UpdateLoggingConfigOptions) SetProtocol(protocol string) *UpdateLoggingConfigOptions {
	options.Protocol = core.StringPtr(protocol)
	return options
}

// SetRemoteLogPort : Allow user to set RemoteLogPort
func (options *UpdateLoggingConfigOptions) SetRemoteLogPort(remoteLogPort int64) *UpdateLoggingConfigOptions {
	options.RemoteLogPort = core.Int64Ptr(remoteLogPort)
	return options
}

// SetRemoteLogServer : Allow user to set RemoteLogServer
func (options *UpdateLoggingConfigOptions) SetRemoteLogServer(remoteLogServer string) *UpdateLoggingConfigOptions {
	options.RemoteLogServer = core.StringPtr(remoteLogServer)
	return options
}

// SetSpace : Allow user to set Space
func (options *UpdateLoggingConfigOptions) SetSpace(space string) *UpdateLoggingConfigOptions {
	options.Space = core.StringPtr(space)
	return options
}

// SetVerifyMode : Allow user to set VerifyMode
func (options *UpdateLoggingConfigOptions) SetVerifyMode(verifyMode string) *UpdateLoggingConfigOptions {
	options.VerifyMode = core.StringPtr(verifyMode)
	return options
}

// SetXAuthResourceGroupID : Allow user to set XAuthResourceGroupID
func (options *UpdateLoggingConfigOptions) SetXAuthResourceGroupID(xAuthResourceGroupID string) *UpdateLoggingConfigOptions {
	options.XAuthResourceGroupID = core.StringPtr(xAuthResourceGroupID)
	return options
}

// SetForceUpdate : Allow user to set ForceUpdate
func (options *UpdateLoggingConfigOptions) SetForceUpdate(forceUpdate bool) *UpdateLoggingConfigOptions {
	options.ForceUpdate = core.BoolPtr(forceUpdate)
	return options
}

// SetSkipValidation : Allow user to set SkipValidation
func (options *UpdateLoggingConfigOptions) SetSkipValidation(skipValidation bool) *UpdateLoggingConfigOptions {
	options.SkipValidation = core.BoolPtr(skipValidation)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateLoggingConfigOptions) SetHeaders(param map[string]string) *UpdateLoggingConfigOptions {
	options.Headers = param
	return options
}

// UpdateNlbDNSHealthMonitorOptions : The UpdateNlbDNSHealthMonitor options.
type UpdateNlbDNSHealthMonitorOptions struct {
	// The name or ID of the cluster. To list the clusters that you have access to, use the `GET /v1/clusters` API or run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	ClusterID *string

	NlbHost *string

	NlbIPArray []string

	NlbMonitorState *string

	NlbSslSecretName *string

	NlbSslSecretStatus *string

	NlbType *string

	SecretNamespace *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateNlbDNSHealthMonitorOptions : Instantiate UpdateNlbDNSHealthMonitorOptions
func (*KubernetesServiceApiV1) NewUpdateNlbDNSHealthMonitorOptions(idOrName string) *UpdateNlbDNSHealthMonitorOptions {
	return &UpdateNlbDNSHealthMonitorOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *UpdateNlbDNSHealthMonitorOptions) SetIdOrName(idOrName string) *UpdateNlbDNSHealthMonitorOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetClusterID : Allow user to set ClusterID
func (options *UpdateNlbDNSHealthMonitorOptions) SetClusterID(clusterID string) *UpdateNlbDNSHealthMonitorOptions {
	options.ClusterID = core.StringPtr(clusterID)
	return options
}

// SetNlbHost : Allow user to set NlbHost
func (options *UpdateNlbDNSHealthMonitorOptions) SetNlbHost(nlbHost string) *UpdateNlbDNSHealthMonitorOptions {
	options.NlbHost = core.StringPtr(nlbHost)
	return options
}

// SetNlbIPArray : Allow user to set NlbIPArray
func (options *UpdateNlbDNSHealthMonitorOptions) SetNlbIPArray(nlbIPArray []string) *UpdateNlbDNSHealthMonitorOptions {
	options.NlbIPArray = nlbIPArray
	return options
}

// SetNlbMonitorState : Allow user to set NlbMonitorState
func (options *UpdateNlbDNSHealthMonitorOptions) SetNlbMonitorState(nlbMonitorState string) *UpdateNlbDNSHealthMonitorOptions {
	options.NlbMonitorState = core.StringPtr(nlbMonitorState)
	return options
}

// SetNlbSslSecretName : Allow user to set NlbSslSecretName
func (options *UpdateNlbDNSHealthMonitorOptions) SetNlbSslSecretName(nlbSslSecretName string) *UpdateNlbDNSHealthMonitorOptions {
	options.NlbSslSecretName = core.StringPtr(nlbSslSecretName)
	return options
}

// SetNlbSslSecretStatus : Allow user to set NlbSslSecretStatus
func (options *UpdateNlbDNSHealthMonitorOptions) SetNlbSslSecretStatus(nlbSslSecretStatus string) *UpdateNlbDNSHealthMonitorOptions {
	options.NlbSslSecretStatus = core.StringPtr(nlbSslSecretStatus)
	return options
}

// SetNlbType : Allow user to set NlbType
func (options *UpdateNlbDNSHealthMonitorOptions) SetNlbType(nlbType string) *UpdateNlbDNSHealthMonitorOptions {
	options.NlbType = core.StringPtr(nlbType)
	return options
}

// SetSecretNamespace : Allow user to set SecretNamespace
func (options *UpdateNlbDNSHealthMonitorOptions) SetSecretNamespace(secretNamespace string) *UpdateNlbDNSHealthMonitorOptions {
	options.SecretNamespace = core.StringPtr(secretNamespace)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *UpdateNlbDNSHealthMonitorOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *UpdateNlbDNSHealthMonitorOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateNlbDNSHealthMonitorOptions) SetHeaders(param map[string]string) *UpdateNlbDNSHealthMonitorOptions {
	options.Headers = param
	return options
}

// UpdatePolicy : UpdatePolicy struct
type UpdatePolicy struct {
	// If set to true, automatic updates for the ALBs are enabled.
	AutoUpdate *bool `json:"autoUpdate,omitempty"`

	// If set to true, all ALBs in the cluster run the latest ALB version.
	LatestVersion *bool `json:"latestVersion,omitempty"`
}

// UnmarshalUpdatePolicy unmarshals an instance of UpdatePolicy from the specified map of raw messages.
func UnmarshalUpdatePolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdatePolicy)
	err = core.UnmarshalPrimitive(m, "autoUpdate", &obj.AutoUpdate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "latestVersion", &obj.LatestVersion)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateSatelliteHostOptions : The UpdateSatelliteHost options.
type UpdateSatelliteHostOptions struct {
	// The name or ID of the Satellite location.
	Controller *string

	// The ID of the host to update.
	HostID *string

	// Key-value pairs to label the host, such as cpu=4 to describe the host capabilities.
	Labels map[string]string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSatelliteHostOptions : Instantiate UpdateSatelliteHostOptions
func (*KubernetesServiceApiV1) NewUpdateSatelliteHostOptions() *UpdateSatelliteHostOptions {
	return &UpdateSatelliteHostOptions{}
}

// SetController : Allow user to set Controller
func (options *UpdateSatelliteHostOptions) SetController(controller string) *UpdateSatelliteHostOptions {
	options.Controller = core.StringPtr(controller)
	return options
}

// SetHostID : Allow user to set HostID
func (options *UpdateSatelliteHostOptions) SetHostID(hostID string) *UpdateSatelliteHostOptions {
	options.HostID = core.StringPtr(hostID)
	return options
}

// SetLabels : Allow user to set Labels
func (options *UpdateSatelliteHostOptions) SetLabels(labels map[string]string) *UpdateSatelliteHostOptions {
	options.Labels = labels
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSatelliteHostOptions) SetHeaders(param map[string]string) *UpdateSatelliteHostOptions {
	options.Headers = param
	return options
}

// UpdateSecretOptions : The UpdateSecret options.
type UpdateSecretOptions struct {
	Cluster *string

	Crn *string

	Name *string

	Namespace *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateSecretOptions : Instantiate UpdateSecretOptions
func (*KubernetesServiceApiV1) NewUpdateSecretOptions() *UpdateSecretOptions {
	return &UpdateSecretOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *UpdateSecretOptions) SetCluster(cluster string) *UpdateSecretOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetCrn : Allow user to set Crn
func (options *UpdateSecretOptions) SetCrn(crn string) *UpdateSecretOptions {
	options.Crn = core.StringPtr(crn)
	return options
}

// SetName : Allow user to set Name
func (options *UpdateSecretOptions) SetName(name string) *UpdateSecretOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNamespace : Allow user to set Namespace
func (options *UpdateSecretOptions) SetNamespace(namespace string) *UpdateSecretOptions {
	options.Namespace = core.StringPtr(namespace)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateSecretOptions) SetHeaders(param map[string]string) *UpdateSecretOptions {
	options.Headers = param
	return options
}

// UpdateStorageConfigurationOptions : The UpdateStorageConfiguration options.
type UpdateStorageConfigurationOptions struct {
	ConfigName *string

	ConfigVersion *string

	SourceBranch *string

	SourceOrg *string

	StorageClassParameters []map[string]string

	StorageTemplateName *string

	StorageTemplateVersion *string

	UserConfigParameters map[string]string

	UserSecretParameters map[string]string

	UUID *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewUpdateStorageConfigurationOptions : Instantiate UpdateStorageConfigurationOptions
func (*KubernetesServiceApiV1) NewUpdateStorageConfigurationOptions() *UpdateStorageConfigurationOptions {
	return &UpdateStorageConfigurationOptions{}
}

// SetConfigName : Allow user to set ConfigName
func (options *UpdateStorageConfigurationOptions) SetConfigName(configName string) *UpdateStorageConfigurationOptions {
	options.ConfigName = core.StringPtr(configName)
	return options
}

// SetConfigVersion : Allow user to set ConfigVersion
func (options *UpdateStorageConfigurationOptions) SetConfigVersion(configVersion string) *UpdateStorageConfigurationOptions {
	options.ConfigVersion = core.StringPtr(configVersion)
	return options
}

// SetSourceBranch : Allow user to set SourceBranch
func (options *UpdateStorageConfigurationOptions) SetSourceBranch(sourceBranch string) *UpdateStorageConfigurationOptions {
	options.SourceBranch = core.StringPtr(sourceBranch)
	return options
}

// SetSourceOrg : Allow user to set SourceOrg
func (options *UpdateStorageConfigurationOptions) SetSourceOrg(sourceOrg string) *UpdateStorageConfigurationOptions {
	options.SourceOrg = core.StringPtr(sourceOrg)
	return options
}

// SetStorageClassParameters : Allow user to set StorageClassParameters
func (options *UpdateStorageConfigurationOptions) SetStorageClassParameters(storageClassParameters []map[string]string) *UpdateStorageConfigurationOptions {
	options.StorageClassParameters = storageClassParameters
	return options
}

// SetStorageTemplateName : Allow user to set StorageTemplateName
func (options *UpdateStorageConfigurationOptions) SetStorageTemplateName(storageTemplateName string) *UpdateStorageConfigurationOptions {
	options.StorageTemplateName = core.StringPtr(storageTemplateName)
	return options
}

// SetStorageTemplateVersion : Allow user to set StorageTemplateVersion
func (options *UpdateStorageConfigurationOptions) SetStorageTemplateVersion(storageTemplateVersion string) *UpdateStorageConfigurationOptions {
	options.StorageTemplateVersion = core.StringPtr(storageTemplateVersion)
	return options
}

// SetUserConfigParameters : Allow user to set UserConfigParameters
func (options *UpdateStorageConfigurationOptions) SetUserConfigParameters(userConfigParameters map[string]string) *UpdateStorageConfigurationOptions {
	options.UserConfigParameters = userConfigParameters
	return options
}

// SetUserSecretParameters : Allow user to set UserSecretParameters
func (options *UpdateStorageConfigurationOptions) SetUserSecretParameters(userSecretParameters map[string]string) *UpdateStorageConfigurationOptions {
	options.UserSecretParameters = userSecretParameters
	return options
}

// SetUUID : Allow user to set UUID
func (options *UpdateStorageConfigurationOptions) SetUUID(uuid string) *UpdateStorageConfigurationOptions {
	options.UUID = core.StringPtr(uuid)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *UpdateStorageConfigurationOptions) SetHeaders(param map[string]string) *UpdateStorageConfigurationOptions {
	options.Headers = param
	return options
}

// UpdateSubscriptionData : UpdateSubscriptionData struct
type UpdateSubscriptionData struct {
	EditSubscription *UpdateSubscriptionType `json:"editSubscription,omitempty"`
}

// UnmarshalUpdateSubscriptionData unmarshals an instance of UpdateSubscriptionData from the specified map of raw messages.
func UnmarshalUpdateSubscriptionData(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateSubscriptionData)
	err = core.UnmarshalModel(m, "editSubscription", &obj.EditSubscription, UnmarshalUpdateSubscriptionType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateSubscriptionType : UpdateSubscriptionType struct
type UpdateSubscriptionType struct {
	Success *bool `json:"success,omitempty"`

	UUID *string `json:"uuid,omitempty"`
}

// UnmarshalUpdateSubscriptionType unmarshals an instance of UpdateSubscriptionType from the specified map of raw messages.
func UnmarshalUpdateSubscriptionType(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateSubscriptionType)
	err = core.UnmarshalPrimitive(m, "success", &obj.Success)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateSubscriptionVersionData : UpdateSubscriptionVersionData struct
type UpdateSubscriptionVersionData struct {
	SetSubscription *UpdateSubscriptionVersionType `json:"setSubscription,omitempty"`
}

// UnmarshalUpdateSubscriptionVersionData unmarshals an instance of UpdateSubscriptionVersionData from the specified map of raw messages.
func UnmarshalUpdateSubscriptionVersionData(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateSubscriptionVersionData)
	err = core.UnmarshalModel(m, "setSubscription", &obj.SetSubscription, UnmarshalUpdateSubscriptionVersionType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UpdateSubscriptionVersionType : UpdateSubscriptionVersionType struct
type UpdateSubscriptionVersionType struct {
	Success *bool `json:"success,omitempty"`

	UUID *string `json:"uuid,omitempty"`
}

// UnmarshalUpdateSubscriptionVersionType unmarshals an instance of UpdateSubscriptionVersionType from the specified map of raw messages.
func UnmarshalUpdateSubscriptionVersionType(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UpdateSubscriptionVersionType)
	err = core.UnmarshalPrimitive(m, "success", &obj.Success)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "uuid", &obj.UUID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UserConfig : UserConfig describes the config values applicable to a user account.
type UserConfig struct {
	FreeEnabled *bool `json:"freeEnabled,omitempty"`

	StoredIaasCredentials *bool `json:"storedIaasCredentials,omitempty"`
}

// UnmarshalUserConfig unmarshals an instance of UserConfig from the specified map of raw messages.
func UnmarshalUserConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UserConfig)
	err = core.UnmarshalPrimitive(m, "freeEnabled", &obj.FreeEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storedIaasCredentials", &obj.StoredIaasCredentials)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UserError : UserError struct
type UserError struct {
	Code *string `json:"code,omitempty"`

	Description *string `json:"description,omitempty"`

	RecoveryCLI *string `json:"recoveryCLI,omitempty"`

	TerseDescription *string `json:"terseDescription,omitempty"`

	// ErrorType error type.
	Type *string `json:"type,omitempty"`
}

// UnmarshalUserError unmarshals an instance of UserError from the specified map of raw messages.
func UnmarshalUserError(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UserError)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "recoveryCLI", &obj.RecoveryCLI)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "terseDescription", &obj.TerseDescription)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UserMessage : UserMessage is used to provide human-readable text to convey useful, non-error information to users when a request
// was successfully completed.
type UserMessage struct {
	Level *string `json:"level,omitempty"`

	Text *string `json:"text,omitempty"`
}

// UnmarshalUserMessage unmarshals an instance of UserMessage from the specified map of raw messages.
func UnmarshalUserMessage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UserMessage)
	err = core.UnmarshalPrimitive(m, "level", &obj.Level)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "text", &obj.Text)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UserMessageResponse : UserMessageResponse is a user message returned from the API.
type UserMessageResponse struct {
	ID *string `json:"id,omitempty"`

	Message *string `json:"message,omitempty"`
}

// UnmarshalUserMessageResponse unmarshals an instance of UserMessageResponse from the specified map of raw messages.
func UnmarshalUserMessageResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UserMessageResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// V2DisablePrivateServiceEndpointOptions : The V2DisablePrivateServiceEndpoint options.
type V2DisablePrivateServiceEndpointOptions struct {
	Cluster *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2DisablePrivateServiceEndpointOptions : Instantiate V2DisablePrivateServiceEndpointOptions
func (*KubernetesServiceApiV1) NewV2DisablePrivateServiceEndpointOptions() *V2DisablePrivateServiceEndpointOptions {
	return &V2DisablePrivateServiceEndpointOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2DisablePrivateServiceEndpointOptions) SetCluster(cluster string) *V2DisablePrivateServiceEndpointOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2DisablePrivateServiceEndpointOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2DisablePrivateServiceEndpointOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2DisablePrivateServiceEndpointOptions) SetHeaders(param map[string]string) *V2DisablePrivateServiceEndpointOptions {
	options.Headers = param
	return options
}

// V2DisablePublicServiceEndpointOptions : The V2DisablePublicServiceEndpoint options.
type V2DisablePublicServiceEndpointOptions struct {
	Cluster *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2DisablePublicServiceEndpointOptions : Instantiate V2DisablePublicServiceEndpointOptions
func (*KubernetesServiceApiV1) NewV2DisablePublicServiceEndpointOptions() *V2DisablePublicServiceEndpointOptions {
	return &V2DisablePublicServiceEndpointOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2DisablePublicServiceEndpointOptions) SetCluster(cluster string) *V2DisablePublicServiceEndpointOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2DisablePublicServiceEndpointOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2DisablePublicServiceEndpointOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2DisablePublicServiceEndpointOptions) SetHeaders(param map[string]string) *V2DisablePublicServiceEndpointOptions {
	options.Headers = param
	return options
}

// V2EnablePrivateServiceEndpointOptions : The V2EnablePrivateServiceEndpoint options.
type V2EnablePrivateServiceEndpointOptions struct {
	Cluster *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2EnablePrivateServiceEndpointOptions : Instantiate V2EnablePrivateServiceEndpointOptions
func (*KubernetesServiceApiV1) NewV2EnablePrivateServiceEndpointOptions() *V2EnablePrivateServiceEndpointOptions {
	return &V2EnablePrivateServiceEndpointOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2EnablePrivateServiceEndpointOptions) SetCluster(cluster string) *V2EnablePrivateServiceEndpointOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2EnablePrivateServiceEndpointOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2EnablePrivateServiceEndpointOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2EnablePrivateServiceEndpointOptions) SetHeaders(param map[string]string) *V2EnablePrivateServiceEndpointOptions {
	options.Headers = param
	return options
}

// V2EnablePublicServiceEndpointOptions : The V2EnablePublicServiceEndpoint options.
type V2EnablePublicServiceEndpointOptions struct {
	Cluster *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2EnablePublicServiceEndpointOptions : Instantiate V2EnablePublicServiceEndpointOptions
func (*KubernetesServiceApiV1) NewV2EnablePublicServiceEndpointOptions() *V2EnablePublicServiceEndpointOptions {
	return &V2EnablePublicServiceEndpointOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2EnablePublicServiceEndpointOptions) SetCluster(cluster string) *V2EnablePublicServiceEndpointOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2EnablePublicServiceEndpointOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2EnablePublicServiceEndpointOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2EnablePublicServiceEndpointOptions) SetHeaders(param map[string]string) *V2EnablePublicServiceEndpointOptions {
	options.Headers = param
	return options
}

// V2EnablePullSecretOptions : The V2EnablePullSecret options.
type V2EnablePullSecretOptions struct {
	Cluster *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2EnablePullSecretOptions : Instantiate V2EnablePullSecretOptions
func (*KubernetesServiceApiV1) NewV2EnablePullSecretOptions() *V2EnablePullSecretOptions {
	return &V2EnablePullSecretOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2EnablePullSecretOptions) SetCluster(cluster string) *V2EnablePullSecretOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2EnablePullSecretOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2EnablePullSecretOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2EnablePullSecretOptions) SetHeaders(param map[string]string) *V2EnablePullSecretOptions {
	options.Headers = param
	return options
}

// V2GetClusterALBOptions : The V2GetClusterALB options.
type V2GetClusterALBOptions struct {
	// The ID of the ALB that you want details for. To list the IDs for the ALBs in a cluster, use the `GET
	// /v2/alb/getClusterAlbs` API or run `ibmcloud ks alb ls --cluster <cluster_name_or_ID>`.
	AlbID *string `validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2GetClusterALBOptions : Instantiate V2GetClusterALBOptions
func (*KubernetesServiceApiV1) NewV2GetClusterALBOptions(albID string) *V2GetClusterALBOptions {
	return &V2GetClusterALBOptions{
		AlbID: core.StringPtr(albID),
	}
}

// SetAlbID : Allow user to set AlbID
func (options *V2GetClusterALBOptions) SetAlbID(albID string) *V2GetClusterALBOptions {
	options.AlbID = core.StringPtr(albID)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2GetClusterALBOptions) SetHeaders(param map[string]string) *V2GetClusterALBOptions {
	options.Headers = param
	return options
}

// V2GetClusterALBsOptions : The V2GetClusterALBs options.
type V2GetClusterALBsOptions struct {
	// To list the classic clusters that you have access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster
	// ls`. To list the VPC clusters that you have access to, use the `GET /v2/vpc/getClusters` API or run `ibmcloud ks
	// cluster ls --provider vpc-classic`.
	Cluster *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2GetClusterALBsOptions : Instantiate V2GetClusterALBsOptions
func (*KubernetesServiceApiV1) NewV2GetClusterALBsOptions(cluster string) *V2GetClusterALBsOptions {
	return &V2GetClusterALBsOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *V2GetClusterALBsOptions) SetCluster(cluster string) *V2GetClusterALBsOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2GetClusterALBsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2GetClusterALBsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2GetClusterALBsOptions) SetHeaders(param map[string]string) *V2GetClusterALBsOptions {
	options.Headers = param
	return options
}

// V2GetClusterAddonsOptions : The V2GetClusterAddons options.
type V2GetClusterAddonsOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group of the cluster, use the `GET
	// /v1/clusters/{idOrName}` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2GetClusterAddonsOptions : Instantiate V2GetClusterAddonsOptions
func (*KubernetesServiceApiV1) NewV2GetClusterAddonsOptions(cluster string) *V2GetClusterAddonsOptions {
	return &V2GetClusterAddonsOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *V2GetClusterAddonsOptions) SetCluster(cluster string) *V2GetClusterAddonsOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2GetClusterAddonsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2GetClusterAddonsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2GetClusterAddonsOptions) SetHeaders(param map[string]string) *V2GetClusterAddonsOptions {
	options.Headers = param
	return options
}

// V2GetFlavorsOptions : The V2GetFlavors options.
type V2GetFlavorsOptions struct {
	// The ID of the location for which you want to list available flavors. To list available locations, run `ibmcloud ks
	// zone ls` or use the `GET /v2/zones` API.
	Zone *string `validate:"required"`

	// Filters the flavors to match the provider type specified.
	Provider *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2GetFlavorsOptions : Instantiate V2GetFlavorsOptions
func (*KubernetesServiceApiV1) NewV2GetFlavorsOptions(zone string) *V2GetFlavorsOptions {
	return &V2GetFlavorsOptions{
		Zone: core.StringPtr(zone),
	}
}

// SetZone : Allow user to set Zone
func (options *V2GetFlavorsOptions) SetZone(zone string) *V2GetFlavorsOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetProvider : Allow user to set Provider
func (options *V2GetFlavorsOptions) SetProvider(provider string) *V2GetFlavorsOptions {
	options.Provider = core.StringPtr(provider)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2GetFlavorsOptions) SetHeaders(param map[string]string) *V2GetFlavorsOptions {
	options.Headers = param
	return options
}

// V2GetMessagesOptions : The V2GetMessages options.
type V2GetMessagesOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2GetMessagesOptions : Instantiate V2GetMessagesOptions
func (*KubernetesServiceApiV1) NewV2GetMessagesOptions() *V2GetMessagesOptions {
	return &V2GetMessagesOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *V2GetMessagesOptions) SetHeaders(param map[string]string) *V2GetMessagesOptions {
	options.Headers = param
	return options
}

// V2GetVersionsOptions : The V2GetVersions options.
type V2GetVersionsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2GetVersionsOptions : Instantiate V2GetVersionsOptions
func (*KubernetesServiceApiV1) NewV2GetVersionsOptions() *V2GetVersionsOptions {
	return &V2GetVersionsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *V2GetVersionsOptions) SetHeaders(param map[string]string) *V2GetVersionsOptions {
	options.Headers = param
	return options
}

// V2RemoveWorkerOptions : The V2RemoveWorker options.
type V2RemoveWorkerOptions struct {
	Cluster *string

	WorkerID *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2RemoveWorkerOptions : Instantiate V2RemoveWorkerOptions
func (*KubernetesServiceApiV1) NewV2RemoveWorkerOptions() *V2RemoveWorkerOptions {
	return &V2RemoveWorkerOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2RemoveWorkerOptions) SetCluster(cluster string) *V2RemoveWorkerOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorkerID : Allow user to set WorkerID
func (options *V2RemoveWorkerOptions) SetWorkerID(workerID string) *V2RemoveWorkerOptions {
	options.WorkerID = core.StringPtr(workerID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2RemoveWorkerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2RemoveWorkerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2RemoveWorkerOptions) SetHeaders(param map[string]string) *V2RemoveWorkerOptions {
	options.Headers = param
	return options
}

// V2ResizeWorkerPoolOptions : The V2ResizeWorkerPool options.
type V2ResizeWorkerPoolOptions struct {
	AllowSingleOpenShiftWorker *bool

	Cluster *string

	Size *int64

	Workerpool *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2ResizeWorkerPoolOptions : Instantiate V2ResizeWorkerPoolOptions
func (*KubernetesServiceApiV1) NewV2ResizeWorkerPoolOptions() *V2ResizeWorkerPoolOptions {
	return &V2ResizeWorkerPoolOptions{}
}

// SetAllowSingleOpenShiftWorker : Allow user to set AllowSingleOpenShiftWorker
func (options *V2ResizeWorkerPoolOptions) SetAllowSingleOpenShiftWorker(allowSingleOpenShiftWorker bool) *V2ResizeWorkerPoolOptions {
	options.AllowSingleOpenShiftWorker = core.BoolPtr(allowSingleOpenShiftWorker)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *V2ResizeWorkerPoolOptions) SetCluster(cluster string) *V2ResizeWorkerPoolOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetSize : Allow user to set Size
func (options *V2ResizeWorkerPoolOptions) SetSize(size int64) *V2ResizeWorkerPoolOptions {
	options.Size = core.Int64Ptr(size)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *V2ResizeWorkerPoolOptions) SetWorkerpool(workerpool string) *V2ResizeWorkerPoolOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2ResizeWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2ResizeWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2ResizeWorkerPoolOptions) SetHeaders(param map[string]string) *V2ResizeWorkerPoolOptions {
	options.Headers = param
	return options
}

// V2SetWorkerPoolLabelsOptions : The V2SetWorkerPoolLabels options.
type V2SetWorkerPoolLabelsOptions struct {
	Cluster *string

	Labels map[string]string

	Workerpool *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2SetWorkerPoolLabelsOptions : Instantiate V2SetWorkerPoolLabelsOptions
func (*KubernetesServiceApiV1) NewV2SetWorkerPoolLabelsOptions() *V2SetWorkerPoolLabelsOptions {
	return &V2SetWorkerPoolLabelsOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2SetWorkerPoolLabelsOptions) SetCluster(cluster string) *V2SetWorkerPoolLabelsOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetLabels : Allow user to set Labels
func (options *V2SetWorkerPoolLabelsOptions) SetLabels(labels map[string]string) *V2SetWorkerPoolLabelsOptions {
	options.Labels = labels
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *V2SetWorkerPoolLabelsOptions) SetWorkerpool(workerpool string) *V2SetWorkerPoolLabelsOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2SetWorkerPoolLabelsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2SetWorkerPoolLabelsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2SetWorkerPoolLabelsOptions) SetHeaders(param map[string]string) *V2SetWorkerPoolLabelsOptions {
	options.Headers = param
	return options
}

// V2SetWorkerPoolTaintsOptions : The V2SetWorkerPoolTaints options.
type V2SetWorkerPoolTaintsOptions struct {
	Cluster *string

	Taints map[string]string

	Workerpool *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v2/getCluster` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2SetWorkerPoolTaintsOptions : Instantiate V2SetWorkerPoolTaintsOptions
func (*KubernetesServiceApiV1) NewV2SetWorkerPoolTaintsOptions() *V2SetWorkerPoolTaintsOptions {
	return &V2SetWorkerPoolTaintsOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2SetWorkerPoolTaintsOptions) SetCluster(cluster string) *V2SetWorkerPoolTaintsOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetTaints : Allow user to set Taints
func (options *V2SetWorkerPoolTaintsOptions) SetTaints(taints map[string]string) *V2SetWorkerPoolTaintsOptions {
	options.Taints = taints
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *V2SetWorkerPoolTaintsOptions) SetWorkerpool(workerpool string) *V2SetWorkerPoolTaintsOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2SetWorkerPoolTaintsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2SetWorkerPoolTaintsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2SetWorkerPoolTaintsOptions) SetHeaders(param map[string]string) *V2SetWorkerPoolTaintsOptions {
	options.Headers = param
	return options
}

// V2UpdateALBOptions : The V2UpdateALB options.
type V2UpdateALBOptions struct {
	AlbBuild *string

	AlbList []string

	Cluster *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2UpdateALBOptions : Instantiate V2UpdateALBOptions
func (*KubernetesServiceApiV1) NewV2UpdateALBOptions() *V2UpdateALBOptions {
	return &V2UpdateALBOptions{}
}

// SetAlbBuild : Allow user to set AlbBuild
func (options *V2UpdateALBOptions) SetAlbBuild(albBuild string) *V2UpdateALBOptions {
	options.AlbBuild = core.StringPtr(albBuild)
	return options
}

// SetAlbList : Allow user to set AlbList
func (options *V2UpdateALBOptions) SetAlbList(albList []string) *V2UpdateALBOptions {
	options.AlbList = albList
	return options
}

// SetCluster : Allow user to set Cluster
func (options *V2UpdateALBOptions) SetCluster(cluster string) *V2UpdateALBOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2UpdateALBOptions) SetHeaders(param map[string]string) *V2UpdateALBOptions {
	options.Headers = param
	return options
}

// V2UpdateMasterOptions : The V2UpdateMaster options.
type V2UpdateMasterOptions struct {
	Cluster *string

	Force *bool

	Version *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV2UpdateMasterOptions : Instantiate V2UpdateMasterOptions
func (*KubernetesServiceApiV1) NewV2UpdateMasterOptions() *V2UpdateMasterOptions {
	return &V2UpdateMasterOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *V2UpdateMasterOptions) SetCluster(cluster string) *V2UpdateMasterOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetForce : Allow user to set Force
func (options *V2UpdateMasterOptions) SetForce(force bool) *V2UpdateMasterOptions {
	options.Force = core.BoolPtr(force)
	return options
}

// SetVersion : Allow user to set Version
func (options *V2UpdateMasterOptions) SetVersion(version string) *V2UpdateMasterOptions {
	options.Version = core.StringPtr(version)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *V2UpdateMasterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *V2UpdateMasterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *V2UpdateMasterOptions) SetHeaders(param map[string]string) *V2UpdateMasterOptions {
	options.Headers = param
	return options
}

// VLAN : VLAN contains properties for VLANs.
type VLAN struct {
	ID *string `json:"id,omitempty"`

	// VLANProperties contains SoftLayer-specific properties for VLANs.
	Properties *VLANProperties `json:"properties,omitempty"`

	Type *string `json:"type,omitempty"`
}

// UnmarshalVLAN unmarshals an instance of VLAN from the specified map of raw messages.
func UnmarshalVLAN(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VLAN)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "properties", &obj.Properties, UnmarshalVLANProperties)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VLANProperties : VLANProperties contains SoftLayer-specific properties for VLANs.
type VLANProperties struct {
	LocalDiskStorageCapability *string `json:"local_disk_storage_capability,omitempty"`

	Location *string `json:"location,omitempty"`

	Name *string `json:"name,omitempty"`

	Note *string `json:"note,omitempty"`

	PrimaryRouter *string `json:"primary_router,omitempty"`

	SanStorageCapability *string `json:"san_storage_capability,omitempty"`

	VlanNumber *string `json:"vlan_number,omitempty"`

	VlanType *string `json:"vlan_type,omitempty"`
}

// UnmarshalVLANProperties unmarshals an instance of VLANProperties from the specified map of raw messages.
func UnmarshalVLANProperties(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VLANProperties)
	err = core.UnmarshalPrimitive(m, "local_disk_storage_capability", &obj.LocalDiskStorageCapability)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "note", &obj.Note)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primary_router", &obj.PrimaryRouter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "san_storage_capability", &obj.SanStorageCapability)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan_number", &obj.VlanNumber)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlan_type", &obj.VlanType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCCreateClusterWorkerPool : VPCCreateClusterWorkerPool is the vpc version of the worker pool part of a create cluster request.
type VPCCreateClusterWorkerPool struct {
	DiskEncryption *bool `json:"diskEncryption,omitempty"`

	Flavor *string `json:"flavor,omitempty"`

	Isolation *string `json:"isolation,omitempty"`

	Labels map[string]string `json:"labels,omitempty"`

	Name *string `json:"name,omitempty"`

	VpcID *string `json:"vpcID,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`

	Zones []VPCCreateClusterWorkerPoolZone `json:"zones,omitempty"`
}

// UnmarshalVPCCreateClusterWorkerPool unmarshals an instance of VPCCreateClusterWorkerPool from the specified map of raw messages.
func UnmarshalVPCCreateClusterWorkerPool(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCCreateClusterWorkerPool)
	err = core.UnmarshalPrimitive(m, "diskEncryption", &obj.DiskEncryption)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "flavor", &obj.Flavor)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isolation", &obj.Isolation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "labels", &obj.Labels)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcID", &obj.VpcID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalVPCCreateClusterWorkerPoolZone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPCCreateClusterWorkerPoolZone : VPCCreateClusterWorkerPoolZone is the vpc version of the worker pool zone part of a create cluster request.
type VPCCreateClusterWorkerPoolZone struct {
	ID *string `json:"id,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// UnmarshalVPCCreateClusterWorkerPoolZone unmarshals an instance of VPCCreateClusterWorkerPoolZone from the specified map of raw messages.
func UnmarshalVPCCreateClusterWorkerPoolZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPCCreateClusterWorkerPoolZone)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subnetID", &obj.SubnetID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ViewClusterALBSecretsOptions : The ViewClusterALBSecrets options.
type ViewClusterALBSecretsOptions struct {
	// The name or ID of the cluster where the ALB secret is deployed. To list the clusters that you have access to, run
	// `ibmcloud ks cluster ls`.
	IdOrName *string `validate:"required,ne="`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the GET
	// /v1/clusters/idOrName API. To list available resource group IDs, run ibmcloud resource groups.
	XAuthResourceGroup *string

	// The name of the ALB secret that you details for. To list the ALB secrets available in the cluster, use the `GET
	// /clusters/{idOrName}/albsecrets` API or run `ibmcloud ks alb cert ls --cluster <cluster_name_or_ID>`.
	AlbSecretName *string

	// The CRN of the certificate that you want details for.
	CertCrn *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewViewClusterALBSecretsOptions : Instantiate ViewClusterALBSecretsOptions
func (*KubernetesServiceApiV1) NewViewClusterALBSecretsOptions(idOrName string) *ViewClusterALBSecretsOptions {
	return &ViewClusterALBSecretsOptions{
		IdOrName: core.StringPtr(idOrName),
	}
}

// SetIdOrName : Allow user to set IdOrName
func (options *ViewClusterALBSecretsOptions) SetIdOrName(idOrName string) *ViewClusterALBSecretsOptions {
	options.IdOrName = core.StringPtr(idOrName)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *ViewClusterALBSecretsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *ViewClusterALBSecretsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetAlbSecretName : Allow user to set AlbSecretName
func (options *ViewClusterALBSecretsOptions) SetAlbSecretName(albSecretName string) *ViewClusterALBSecretsOptions {
	options.AlbSecretName = core.StringPtr(albSecretName)
	return options
}

// SetCertCrn : Allow user to set CertCrn
func (options *ViewClusterALBSecretsOptions) SetCertCrn(certCrn string) *ViewClusterALBSecretsOptions {
	options.CertCrn = core.StringPtr(certCrn)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *ViewClusterALBSecretsOptions) SetHeaders(param map[string]string) *ViewClusterALBSecretsOptions {
	options.Headers = param
	return options
}

// VirtualPrivateCloudResponse : Using the full name to avoid the linter complaining about stutter.
type VirtualPrivateCloudResponse struct {
	ID *string `json:"id,omitempty"`

	Name *string `json:"name,omitempty"`

	Provider *string `json:"provider,omitempty"`

	ResourceGroup *string `json:"resourceGroup,omitempty"`

	Zones []string `json:"zones,omitempty"`
}

// UnmarshalVirtualPrivateCloudResponse unmarshals an instance of VirtualPrivateCloudResponse from the specified map of raw messages.
func UnmarshalVirtualPrivateCloudResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualPrivateCloudResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroup", &obj.ResourceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "zones", &obj.Zones)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VlanConfigField : VlanConfigField TODO provide meaningful comment.
type VlanConfigField struct {
	ID *string `json:"id,omitempty"`

	Region *string `json:"region,omitempty"`

	Subnets []SubnetConfigField `json:"subnets,omitempty"`

	Zone *string `json:"zone,omitempty"`
}

// UnmarshalVlanConfigField unmarshals an instance of VlanConfigField from the specified map of raw messages.
func UnmarshalVlanConfigField(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VlanConfigField)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "subnets", &obj.Subnets, UnmarshalSubnetConfigField)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "zone", &obj.Zone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VlanSpan : VlanSpan struct
type VlanSpan struct {
	Enabled *bool `json:"enabled,omitempty"`

	ModifiedDate *string `json:"modifiedDate,omitempty"`
}

// UnmarshalVlanSpan unmarshals an instance of VlanSpan from the specified map of raw messages.
func UnmarshalVlanSpan(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VlanSpan)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "modifiedDate", &obj.ModifiedDate)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Volume : Volume struct
type Volume struct {
	// ID .. id is of a volume.
	ID *string `json:"id,omitempty"`

	// Name .. Name of the volume.
	Name *string `json:"name,omitempty"`
}

// UnmarshalVolume unmarshals an instance of Volume from the specified map of raw messages.
func UnmarshalVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Volume)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachment : VolumeAttachment struct
type VolumeAttachment struct {
	Device *Device `json:"device,omitempty"`

	ID *string `json:"id,omitempty"`

	Name *string `json:"name,omitempty"`

	Status *string `json:"status,omitempty"`

	Type *string `json:"type,omitempty"`

	Volume *Volume `json:"volume,omitempty"`
}

// UnmarshalVolumeAttachment unmarshals an instance of VolumeAttachment from the specified map of raw messages.
func UnmarshalVolumeAttachment(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachment)
	err = core.UnmarshalModel(m, "device", &obj.Device, UnmarshalDevice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume", &obj.Volume, UnmarshalVolume)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeAttachmentList : VolumeAttachmentList struct
type VolumeAttachmentList struct {
	VolumeAttachments []VolumeAttachment `json:"volume_attachments,omitempty"`
}

// UnmarshalVolumeAttachmentList unmarshals an instance of VolumeAttachmentList from the specified map of raw messages.
func UnmarshalVolumeAttachmentList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeAttachmentList)
	err = core.UnmarshalModel(m, "volume_attachments", &obj.VolumeAttachments, UnmarshalVolumeAttachment)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumesList : VolumesList struct
type VolumesList struct {
	Volumes []Volume `json:"volumes,omitempty"`
}

// UnmarshalVolumesList unmarshals an instance of VolumesList from the specified map of raw messages.
func UnmarshalVolumesList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumesList)
	err = core.UnmarshalModel(m, "volumes", &obj.Volumes, UnmarshalVolume)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcALBConfig : ALBConfig config for alb configuration.
type VpcALBConfig struct {
	AlbBuild *string `json:"albBuild,omitempty"`

	AlbID *string `json:"albID,omitempty"`

	AlbType *string `json:"albType,omitempty"`

	AuthBuild *string `json:"authBuild,omitempty"`

	Cluster *string `json:"cluster,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty"`

	DisableDeployment *bool `json:"disableDeployment,omitempty"`

	Enable *bool `json:"enable,omitempty"`

	LoadBalancerHostname *string `json:"loadBalancerHostname,omitempty"`

	Name *string `json:"name,omitempty"`

	NumOfInstances *string `json:"numOfInstances,omitempty"`

	Resize *bool `json:"resize,omitempty"`

	State *string `json:"state,omitempty"`

	Status *string `json:"status,omitempty"`

	Zone *string `json:"zone,omitempty"`
}

// UnmarshalVpcALBConfig unmarshals an instance of VpcALBConfig from the specified map of raw messages.
func UnmarshalVpcALBConfig(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcALBConfig)
	err = core.UnmarshalPrimitive(m, "albBuild", &obj.AlbBuild)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "albID", &obj.AlbID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "albType", &obj.AlbType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "authBuild", &obj.AuthBuild)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cluster", &obj.Cluster)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdDate", &obj.CreatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "disableDeployment", &obj.DisableDeployment)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable", &obj.Enable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "loadBalancerHostname", &obj.LoadBalancerHostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "numOfInstances", &obj.NumOfInstances)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resize", &obj.Resize)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "zone", &obj.Zone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcClusterALB : VpcClusterALB alb related information for vpc cluster.
type VpcClusterALB struct {
	// PrivateIngressHostname   string         `json:"privateIngressHostname"` PrivateIngressSecretName       string
	//  `json:"privateIngressSecretName"`.
	Alb []VpcALBConfig `json:"alb,omitempty"`

	DataCenter *string `json:"dataCenter,omitempty"`

	ID *string `json:"id,omitempty"`

	IsPaid *bool `json:"isPaid,omitempty"`

	PublicIngressHostname *string `json:"publicIngressHostname,omitempty"`

	PublicIngressSecretName *string `json:"publicIngressSecretName,omitempty"`

	Region *string `json:"region,omitempty"`
}

// UnmarshalVpcClusterALB unmarshals an instance of VpcClusterALB from the specified map of raw messages.
func UnmarshalVpcClusterALB(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VpcClusterALB)
	err = core.UnmarshalModel(m, "alb", &obj.Alb, UnmarshalVpcALBConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dataCenter", &obj.DataCenter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaid", &obj.IsPaid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicIngressHostname", &obj.PublicIngressHostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicIngressSecretName", &obj.PublicIngressSecretName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VpcCreateALBOptions : The VpcCreateALB options.
type VpcCreateALBOptions struct {
	Cluster *string

	EnableByDefault *bool

	IngressImage *string

	Type *string

	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcCreateALBOptions : Instantiate VpcCreateALBOptions
func (*KubernetesServiceApiV1) NewVpcCreateALBOptions() *VpcCreateALBOptions {
	return &VpcCreateALBOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *VpcCreateALBOptions) SetCluster(cluster string) *VpcCreateALBOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetEnableByDefault : Allow user to set EnableByDefault
func (options *VpcCreateALBOptions) SetEnableByDefault(enableByDefault bool) *VpcCreateALBOptions {
	options.EnableByDefault = core.BoolPtr(enableByDefault)
	return options
}

// SetIngressImage : Allow user to set IngressImage
func (options *VpcCreateALBOptions) SetIngressImage(ingressImage string) *VpcCreateALBOptions {
	options.IngressImage = core.StringPtr(ingressImage)
	return options
}

// SetType : Allow user to set Type
func (options *VpcCreateALBOptions) SetType(typeVar string) *VpcCreateALBOptions {
	options.Type = core.StringPtr(typeVar)
	return options
}

// SetZone : Allow user to set Zone
func (options *VpcCreateALBOptions) SetZone(zone string) *VpcCreateALBOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcCreateALBOptions) SetHeaders(param map[string]string) *VpcCreateALBOptions {
	options.Headers = param
	return options
}

// VpcCreateClusterOptions : The VpcCreateCluster options.
type VpcCreateClusterOptions struct {
	// The resource group that you want to create the cluster in. To list available resource groups, run `ibmcloud resource
	// groups`. If you don't include this header, the cluster is created in the default resource group. After you create a
	// cluster, you cannot change the resource group. Note that if you plan to integrate IBM Cloud services with the
	// cluster, all the resources must be in the same group.
	XAuthResourceGroup *string `validate:"required"`

	CosInstanceCRN *string

	CseACLEnabled *bool

	DefaultWorkerPoolEntitlement *string

	DisablePublicServiceEndpoint *bool

	KubeVersion *string

	Name *string

	PodSubnet *string

	Provider *string

	ServiceSubnet *string

	// VPCCreateClusterWorkerPool is the vpc version of the worker pool part of a create cluster
	// request.
	WorkerPool *VPCCreateClusterWorkerPool

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcCreateClusterOptions : Instantiate VpcCreateClusterOptions
func (*KubernetesServiceApiV1) NewVpcCreateClusterOptions(xAuthResourceGroup string) *VpcCreateClusterOptions {
	return &VpcCreateClusterOptions{
		XAuthResourceGroup: core.StringPtr(xAuthResourceGroup),
	}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcCreateClusterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcCreateClusterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetCosInstanceCRN : Allow user to set CosInstanceCRN
func (options *VpcCreateClusterOptions) SetCosInstanceCRN(cosInstanceCRN string) *VpcCreateClusterOptions {
	options.CosInstanceCRN = core.StringPtr(cosInstanceCRN)
	return options
}

// SetCseACLEnabled : Allow user to set CseACLEnabled
func (options *VpcCreateClusterOptions) SetCseACLEnabled(cseACLEnabled bool) *VpcCreateClusterOptions {
	options.CseACLEnabled = core.BoolPtr(cseACLEnabled)
	return options
}

// SetDefaultWorkerPoolEntitlement : Allow user to set DefaultWorkerPoolEntitlement
func (options *VpcCreateClusterOptions) SetDefaultWorkerPoolEntitlement(defaultWorkerPoolEntitlement string) *VpcCreateClusterOptions {
	options.DefaultWorkerPoolEntitlement = core.StringPtr(defaultWorkerPoolEntitlement)
	return options
}

// SetDisablePublicServiceEndpoint : Allow user to set DisablePublicServiceEndpoint
func (options *VpcCreateClusterOptions) SetDisablePublicServiceEndpoint(disablePublicServiceEndpoint bool) *VpcCreateClusterOptions {
	options.DisablePublicServiceEndpoint = core.BoolPtr(disablePublicServiceEndpoint)
	return options
}

// SetKubeVersion : Allow user to set KubeVersion
func (options *VpcCreateClusterOptions) SetKubeVersion(kubeVersion string) *VpcCreateClusterOptions {
	options.KubeVersion = core.StringPtr(kubeVersion)
	return options
}

// SetName : Allow user to set Name
func (options *VpcCreateClusterOptions) SetName(name string) *VpcCreateClusterOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetPodSubnet : Allow user to set PodSubnet
func (options *VpcCreateClusterOptions) SetPodSubnet(podSubnet string) *VpcCreateClusterOptions {
	options.PodSubnet = core.StringPtr(podSubnet)
	return options
}

// SetProvider : Allow user to set Provider
func (options *VpcCreateClusterOptions) SetProvider(provider string) *VpcCreateClusterOptions {
	options.Provider = core.StringPtr(provider)
	return options
}

// SetServiceSubnet : Allow user to set ServiceSubnet
func (options *VpcCreateClusterOptions) SetServiceSubnet(serviceSubnet string) *VpcCreateClusterOptions {
	options.ServiceSubnet = core.StringPtr(serviceSubnet)
	return options
}

// SetWorkerPool : Allow user to set WorkerPool
func (options *VpcCreateClusterOptions) SetWorkerPool(workerPool *VPCCreateClusterWorkerPool) *VpcCreateClusterOptions {
	options.WorkerPool = workerPool
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *VpcCreateClusterOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *VpcCreateClusterOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcCreateClusterOptions) SetHeaders(param map[string]string) *VpcCreateClusterOptions {
	options.Headers = param
	return options
}

// VpcCreateWorkerPoolOptions : The VpcCreateWorkerPool options.
type VpcCreateWorkerPoolOptions struct {
	Cluster *string

	DiskEncryption *bool

	Entitlement *string

	Flavor *string

	Isolation *string

	Labels map[string]string

	Name *string

	VpcID *string

	WorkerCount *int64

	Zones []Zone

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcCreateWorkerPoolOptions : Instantiate VpcCreateWorkerPoolOptions
func (*KubernetesServiceApiV1) NewVpcCreateWorkerPoolOptions() *VpcCreateWorkerPoolOptions {
	return &VpcCreateWorkerPoolOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *VpcCreateWorkerPoolOptions) SetCluster(cluster string) *VpcCreateWorkerPoolOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetDiskEncryption : Allow user to set DiskEncryption
func (options *VpcCreateWorkerPoolOptions) SetDiskEncryption(diskEncryption bool) *VpcCreateWorkerPoolOptions {
	options.DiskEncryption = core.BoolPtr(diskEncryption)
	return options
}

// SetEntitlement : Allow user to set Entitlement
func (options *VpcCreateWorkerPoolOptions) SetEntitlement(entitlement string) *VpcCreateWorkerPoolOptions {
	options.Entitlement = core.StringPtr(entitlement)
	return options
}

// SetFlavor : Allow user to set Flavor
func (options *VpcCreateWorkerPoolOptions) SetFlavor(flavor string) *VpcCreateWorkerPoolOptions {
	options.Flavor = core.StringPtr(flavor)
	return options
}

// SetIsolation : Allow user to set Isolation
func (options *VpcCreateWorkerPoolOptions) SetIsolation(isolation string) *VpcCreateWorkerPoolOptions {
	options.Isolation = core.StringPtr(isolation)
	return options
}

// SetLabels : Allow user to set Labels
func (options *VpcCreateWorkerPoolOptions) SetLabels(labels map[string]string) *VpcCreateWorkerPoolOptions {
	options.Labels = labels
	return options
}

// SetName : Allow user to set Name
func (options *VpcCreateWorkerPoolOptions) SetName(name string) *VpcCreateWorkerPoolOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetVpcID : Allow user to set VpcID
func (options *VpcCreateWorkerPoolOptions) SetVpcID(vpcID string) *VpcCreateWorkerPoolOptions {
	options.VpcID = core.StringPtr(vpcID)
	return options
}

// SetWorkerCount : Allow user to set WorkerCount
func (options *VpcCreateWorkerPoolOptions) SetWorkerCount(workerCount int64) *VpcCreateWorkerPoolOptions {
	options.WorkerCount = core.Int64Ptr(workerCount)
	return options
}

// SetZones : Allow user to set Zones
func (options *VpcCreateWorkerPoolOptions) SetZones(zones []Zone) *VpcCreateWorkerPoolOptions {
	options.Zones = zones
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *VpcCreateWorkerPoolOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *VpcCreateWorkerPoolOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcCreateWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcCreateWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcCreateWorkerPoolOptions) SetHeaders(param map[string]string) *VpcCreateWorkerPoolOptions {
	options.Headers = param
	return options
}

// VpcCreateWorkerPoolZoneOptions : The VpcCreateWorkerPoolZone options.
type VpcCreateWorkerPoolZoneOptions struct {
	Cluster *string

	ID *string

	SubnetID *string

	Workerpool *string

	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// The resource group that you want to create the cluster in. To list available resource groups, run `ibmcloud resource
	// groups`. If you don't include this header, the cluster is created in the default resource group. After you create a
	// cluster, you cannot change the resource group. Note that if you plan to integrate IBM Cloud services with the
	// cluster, all the resources must be in the same group.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcCreateWorkerPoolZoneOptions : Instantiate VpcCreateWorkerPoolZoneOptions
func (*KubernetesServiceApiV1) NewVpcCreateWorkerPoolZoneOptions() *VpcCreateWorkerPoolZoneOptions {
	return &VpcCreateWorkerPoolZoneOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *VpcCreateWorkerPoolZoneOptions) SetCluster(cluster string) *VpcCreateWorkerPoolZoneOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetID : Allow user to set ID
func (options *VpcCreateWorkerPoolZoneOptions) SetID(id string) *VpcCreateWorkerPoolZoneOptions {
	options.ID = core.StringPtr(id)
	return options
}

// SetSubnetID : Allow user to set SubnetID
func (options *VpcCreateWorkerPoolZoneOptions) SetSubnetID(subnetID string) *VpcCreateWorkerPoolZoneOptions {
	options.SubnetID = core.StringPtr(subnetID)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *VpcCreateWorkerPoolZoneOptions) SetWorkerpool(workerpool string) *VpcCreateWorkerPoolZoneOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *VpcCreateWorkerPoolZoneOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *VpcCreateWorkerPoolZoneOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcCreateWorkerPoolZoneOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcCreateWorkerPoolZoneOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcCreateWorkerPoolZoneOptions) SetHeaders(param map[string]string) *VpcCreateWorkerPoolZoneOptions {
	options.Headers = param
	return options
}

// VpcDisableALBOptions : The VpcDisableALB options.
type VpcDisableALBOptions struct {
	AlbBuild *string

	AlbID *string

	AlbType *string

	AuthBuild *string

	Cluster *string

	CreatedDate *string

	DisableDeployment *bool

	Enable *bool

	LoadBalancerHostname *string

	Name *string

	NumOfInstances *string

	Resize *bool

	State *string

	Status *string

	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcDisableALBOptions : Instantiate VpcDisableALBOptions
func (*KubernetesServiceApiV1) NewVpcDisableALBOptions() *VpcDisableALBOptions {
	return &VpcDisableALBOptions{}
}

// SetAlbBuild : Allow user to set AlbBuild
func (options *VpcDisableALBOptions) SetAlbBuild(albBuild string) *VpcDisableALBOptions {
	options.AlbBuild = core.StringPtr(albBuild)
	return options
}

// SetAlbID : Allow user to set AlbID
func (options *VpcDisableALBOptions) SetAlbID(albID string) *VpcDisableALBOptions {
	options.AlbID = core.StringPtr(albID)
	return options
}

// SetAlbType : Allow user to set AlbType
func (options *VpcDisableALBOptions) SetAlbType(albType string) *VpcDisableALBOptions {
	options.AlbType = core.StringPtr(albType)
	return options
}

// SetAuthBuild : Allow user to set AuthBuild
func (options *VpcDisableALBOptions) SetAuthBuild(authBuild string) *VpcDisableALBOptions {
	options.AuthBuild = core.StringPtr(authBuild)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *VpcDisableALBOptions) SetCluster(cluster string) *VpcDisableALBOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetCreatedDate : Allow user to set CreatedDate
func (options *VpcDisableALBOptions) SetCreatedDate(createdDate string) *VpcDisableALBOptions {
	options.CreatedDate = core.StringPtr(createdDate)
	return options
}

// SetDisableDeployment : Allow user to set DisableDeployment
func (options *VpcDisableALBOptions) SetDisableDeployment(disableDeployment bool) *VpcDisableALBOptions {
	options.DisableDeployment = core.BoolPtr(disableDeployment)
	return options
}

// SetEnable : Allow user to set Enable
func (options *VpcDisableALBOptions) SetEnable(enable bool) *VpcDisableALBOptions {
	options.Enable = core.BoolPtr(enable)
	return options
}

// SetLoadBalancerHostname : Allow user to set LoadBalancerHostname
func (options *VpcDisableALBOptions) SetLoadBalancerHostname(loadBalancerHostname string) *VpcDisableALBOptions {
	options.LoadBalancerHostname = core.StringPtr(loadBalancerHostname)
	return options
}

// SetName : Allow user to set Name
func (options *VpcDisableALBOptions) SetName(name string) *VpcDisableALBOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNumOfInstances : Allow user to set NumOfInstances
func (options *VpcDisableALBOptions) SetNumOfInstances(numOfInstances string) *VpcDisableALBOptions {
	options.NumOfInstances = core.StringPtr(numOfInstances)
	return options
}

// SetResize : Allow user to set Resize
func (options *VpcDisableALBOptions) SetResize(resize bool) *VpcDisableALBOptions {
	options.Resize = core.BoolPtr(resize)
	return options
}

// SetState : Allow user to set State
func (options *VpcDisableALBOptions) SetState(state string) *VpcDisableALBOptions {
	options.State = core.StringPtr(state)
	return options
}

// SetStatus : Allow user to set Status
func (options *VpcDisableALBOptions) SetStatus(status string) *VpcDisableALBOptions {
	options.Status = core.StringPtr(status)
	return options
}

// SetZone : Allow user to set Zone
func (options *VpcDisableALBOptions) SetZone(zone string) *VpcDisableALBOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcDisableALBOptions) SetHeaders(param map[string]string) *VpcDisableALBOptions {
	options.Headers = param
	return options
}

// VpcEnableALBOptions : The VpcEnableALB options.
type VpcEnableALBOptions struct {
	AlbBuild *string

	AlbID *string

	AlbType *string

	AuthBuild *string

	Cluster *string

	CreatedDate *string

	DisableDeployment *bool

	Enable *bool

	LoadBalancerHostname *string

	Name *string

	NumOfInstances *string

	Resize *bool

	State *string

	Status *string

	Zone *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcEnableALBOptions : Instantiate VpcEnableALBOptions
func (*KubernetesServiceApiV1) NewVpcEnableALBOptions() *VpcEnableALBOptions {
	return &VpcEnableALBOptions{}
}

// SetAlbBuild : Allow user to set AlbBuild
func (options *VpcEnableALBOptions) SetAlbBuild(albBuild string) *VpcEnableALBOptions {
	options.AlbBuild = core.StringPtr(albBuild)
	return options
}

// SetAlbID : Allow user to set AlbID
func (options *VpcEnableALBOptions) SetAlbID(albID string) *VpcEnableALBOptions {
	options.AlbID = core.StringPtr(albID)
	return options
}

// SetAlbType : Allow user to set AlbType
func (options *VpcEnableALBOptions) SetAlbType(albType string) *VpcEnableALBOptions {
	options.AlbType = core.StringPtr(albType)
	return options
}

// SetAuthBuild : Allow user to set AuthBuild
func (options *VpcEnableALBOptions) SetAuthBuild(authBuild string) *VpcEnableALBOptions {
	options.AuthBuild = core.StringPtr(authBuild)
	return options
}

// SetCluster : Allow user to set Cluster
func (options *VpcEnableALBOptions) SetCluster(cluster string) *VpcEnableALBOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetCreatedDate : Allow user to set CreatedDate
func (options *VpcEnableALBOptions) SetCreatedDate(createdDate string) *VpcEnableALBOptions {
	options.CreatedDate = core.StringPtr(createdDate)
	return options
}

// SetDisableDeployment : Allow user to set DisableDeployment
func (options *VpcEnableALBOptions) SetDisableDeployment(disableDeployment bool) *VpcEnableALBOptions {
	options.DisableDeployment = core.BoolPtr(disableDeployment)
	return options
}

// SetEnable : Allow user to set Enable
func (options *VpcEnableALBOptions) SetEnable(enable bool) *VpcEnableALBOptions {
	options.Enable = core.BoolPtr(enable)
	return options
}

// SetLoadBalancerHostname : Allow user to set LoadBalancerHostname
func (options *VpcEnableALBOptions) SetLoadBalancerHostname(loadBalancerHostname string) *VpcEnableALBOptions {
	options.LoadBalancerHostname = core.StringPtr(loadBalancerHostname)
	return options
}

// SetName : Allow user to set Name
func (options *VpcEnableALBOptions) SetName(name string) *VpcEnableALBOptions {
	options.Name = core.StringPtr(name)
	return options
}

// SetNumOfInstances : Allow user to set NumOfInstances
func (options *VpcEnableALBOptions) SetNumOfInstances(numOfInstances string) *VpcEnableALBOptions {
	options.NumOfInstances = core.StringPtr(numOfInstances)
	return options
}

// SetResize : Allow user to set Resize
func (options *VpcEnableALBOptions) SetResize(resize bool) *VpcEnableALBOptions {
	options.Resize = core.BoolPtr(resize)
	return options
}

// SetState : Allow user to set State
func (options *VpcEnableALBOptions) SetState(state string) *VpcEnableALBOptions {
	options.State = core.StringPtr(state)
	return options
}

// SetStatus : Allow user to set Status
func (options *VpcEnableALBOptions) SetStatus(status string) *VpcEnableALBOptions {
	options.Status = core.StringPtr(status)
	return options
}

// SetZone : Allow user to set Zone
func (options *VpcEnableALBOptions) SetZone(zone string) *VpcEnableALBOptions {
	options.Zone = core.StringPtr(zone)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcEnableALBOptions) SetHeaders(param map[string]string) *VpcEnableALBOptions {
	options.Headers = param
	return options
}

// VpcGetClusterOptions : The VpcGetCluster options.
type VpcGetClusterOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// To view additional cluster resources like addons, VLANs, subnets, and storage, pass `true`.
	ShowResources *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcGetClusterOptions : Instantiate VpcGetClusterOptions
func (*KubernetesServiceApiV1) NewVpcGetClusterOptions(cluster string) *VpcGetClusterOptions {
	return &VpcGetClusterOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *VpcGetClusterOptions) SetCluster(cluster string) *VpcGetClusterOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcGetClusterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcGetClusterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetShowResources : Allow user to set ShowResources
func (options *VpcGetClusterOptions) SetShowResources(showResources string) *VpcGetClusterOptions {
	options.ShowResources = core.StringPtr(showResources)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcGetClusterOptions) SetHeaders(param map[string]string) *VpcGetClusterOptions {
	options.Headers = param
	return options
}

// VpcGetClustersOptions : The VpcGetClusters options.
type VpcGetClustersOptions struct {
	// The resource group that you want to list clusters for. To list available resource groups, run `ibmcloud resource
	// groups`. If you don't include this header, all the clusters in the account that you have access to are listed.
	XAuthResourceGroup *string

	// Specify a location to filter clusters for. To see supported locations, use the `GET /v1/locations` API or run
	// `ibmcloud ks locations`.
	Location *string

	// The name of the provider to filter the clusters by.
	Provider *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcGetClustersOptions : Instantiate VpcGetClustersOptions
func (*KubernetesServiceApiV1) NewVpcGetClustersOptions() *VpcGetClustersOptions {
	return &VpcGetClustersOptions{}
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcGetClustersOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcGetClustersOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetLocation : Allow user to set Location
func (options *VpcGetClustersOptions) SetLocation(location string) *VpcGetClustersOptions {
	options.Location = core.StringPtr(location)
	return options
}

// SetProvider : Allow user to set Provider
func (options *VpcGetClustersOptions) SetProvider(provider string) *VpcGetClustersOptions {
	options.Provider = core.StringPtr(provider)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcGetClustersOptions) SetHeaders(param map[string]string) *VpcGetClustersOptions {
	options.Headers = param
	return options
}

// VpcGetWorkerOptions : The VpcGetWorker options.
type VpcGetWorkerOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The ID of the worker node that you want details for. To list all worker nodes for a cluster, use the `GET
	// /v1/clusters/{idOrName}/workers` API or run `ibmcloud ks worker ls --cluster <cluster_name_or_ID>`.
	Worker *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcGetWorkerOptions : Instantiate VpcGetWorkerOptions
func (*KubernetesServiceApiV1) NewVpcGetWorkerOptions(cluster string, worker string) *VpcGetWorkerOptions {
	return &VpcGetWorkerOptions{
		Cluster: core.StringPtr(cluster),
		Worker:  core.StringPtr(worker),
	}
}

// SetCluster : Allow user to set Cluster
func (options *VpcGetWorkerOptions) SetCluster(cluster string) *VpcGetWorkerOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorker : Allow user to set Worker
func (options *VpcGetWorkerOptions) SetWorker(worker string) *VpcGetWorkerOptions {
	options.Worker = core.StringPtr(worker)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcGetWorkerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcGetWorkerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcGetWorkerOptions) SetHeaders(param map[string]string) *VpcGetWorkerOptions {
	options.Headers = param
	return options
}

// VpcGetWorkerPoolOptions : The VpcGetWorkerPool options.
type VpcGetWorkerPoolOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The ID of the worker pool that you want details for. To list all worker pools for a cluster, use the `GET
	// /v1/clusters/{idOrName}/workerpools` API or run `ibmcloud ks worker-pool ls --cluster <cluster_name_or_ID>`.
	Workerpool *string `validate:"required"`

	// If you are using the global endpoint, target the Kubernetes Service region. To list available regions, use the `GET
	// /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcGetWorkerPoolOptions : Instantiate VpcGetWorkerPoolOptions
func (*KubernetesServiceApiV1) NewVpcGetWorkerPoolOptions(cluster string, workerpool string) *VpcGetWorkerPoolOptions {
	return &VpcGetWorkerPoolOptions{
		Cluster:    core.StringPtr(cluster),
		Workerpool: core.StringPtr(workerpool),
	}
}

// SetCluster : Allow user to set Cluster
func (options *VpcGetWorkerPoolOptions) SetCluster(cluster string) *VpcGetWorkerPoolOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetWorkerpool : Allow user to set Workerpool
func (options *VpcGetWorkerPoolOptions) SetWorkerpool(workerpool string) *VpcGetWorkerPoolOptions {
	options.Workerpool = core.StringPtr(workerpool)
	return options
}

// SetXRegion : Allow user to set XRegion
func (options *VpcGetWorkerPoolOptions) SetXRegion(xRegion string) *VpcGetWorkerPoolOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcGetWorkerPoolOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcGetWorkerPoolOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcGetWorkerPoolOptions) SetHeaders(param map[string]string) *VpcGetWorkerPoolOptions {
	options.Headers = param
	return options
}

// VpcGetWorkerPoolsOptions : The VpcGetWorkerPools options.
type VpcGetWorkerPoolsOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// If you are using the global endpoint, target the Kubernetes Service region. To list available regions, use the `GET
	// /v1/regions` API or run `ibmcloud ks region ls`.
	XRegion *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcGetWorkerPoolsOptions : Instantiate VpcGetWorkerPoolsOptions
func (*KubernetesServiceApiV1) NewVpcGetWorkerPoolsOptions(cluster string) *VpcGetWorkerPoolsOptions {
	return &VpcGetWorkerPoolsOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *VpcGetWorkerPoolsOptions) SetCluster(cluster string) *VpcGetWorkerPoolsOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXRegion : Allow user to set XRegion
func (options *VpcGetWorkerPoolsOptions) SetXRegion(xRegion string) *VpcGetWorkerPoolsOptions {
	options.XRegion = core.StringPtr(xRegion)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcGetWorkerPoolsOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcGetWorkerPoolsOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcGetWorkerPoolsOptions) SetHeaders(param map[string]string) *VpcGetWorkerPoolsOptions {
	options.Headers = param
	return options
}

// VpcGetWorkersOptions : The VpcGetWorkers options.
type VpcGetWorkersOptions struct {
	// The name or ID of the cluster that you want to get the worker node details from. To list the clusters that you have
	// access to, use the `GET /v1/clusters` API or run `ibmcloud ks cluster ls`.
	Cluster *string `validate:"required"`

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// true|false Shows deleted workers.
	ShowDeleted *string

	// The name or ID of the worker pool to filter results for. Run `ibmcloud ks worker-pool ls --cluster <cluster name>`.
	Pool *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcGetWorkersOptions : Instantiate VpcGetWorkersOptions
func (*KubernetesServiceApiV1) NewVpcGetWorkersOptions(cluster string) *VpcGetWorkersOptions {
	return &VpcGetWorkersOptions{
		Cluster: core.StringPtr(cluster),
	}
}

// SetCluster : Allow user to set Cluster
func (options *VpcGetWorkersOptions) SetCluster(cluster string) *VpcGetWorkersOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcGetWorkersOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcGetWorkersOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetShowDeleted : Allow user to set ShowDeleted
func (options *VpcGetWorkersOptions) SetShowDeleted(showDeleted string) *VpcGetWorkersOptions {
	options.ShowDeleted = core.StringPtr(showDeleted)
	return options
}

// SetPool : Allow user to set Pool
func (options *VpcGetWorkersOptions) SetPool(pool string) *VpcGetWorkersOptions {
	options.Pool = core.StringPtr(pool)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcGetWorkersOptions) SetHeaders(param map[string]string) *VpcGetWorkersOptions {
	options.Headers = param
	return options
}

// VpcGetZonesOptions : The VpcGetZones options.
type VpcGetZonesOptions struct {
	// Your IBM Cloud Identity and Access Management (IAM) refresh token. To retrieve your IAM refresh token, run `cat
	// ~/.bluemix/config.json`. To use the `POST https://iam.bluemix.net/identity/token` API to create a token, see
	// https://ibm.biz/iks-tokens for the required request headers. This header can be omitted if you use the `POST
	// /v1/credentials` API before this request.
	XAuthRefreshToken *string

	// The provider for which to list zones. Defaults to vpc-classic.
	Provider *string

	// Determines whether to show the flavors for the returned zones.
	ShowFlavors *bool

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcGetZonesOptions : Instantiate VpcGetZonesOptions
func (*KubernetesServiceApiV1) NewVpcGetZonesOptions() *VpcGetZonesOptions {
	return &VpcGetZonesOptions{}
}

// SetXAuthRefreshToken : Allow user to set XAuthRefreshToken
func (options *VpcGetZonesOptions) SetXAuthRefreshToken(xAuthRefreshToken string) *VpcGetZonesOptions {
	options.XAuthRefreshToken = core.StringPtr(xAuthRefreshToken)
	return options
}

// SetProvider : Allow user to set Provider
func (options *VpcGetZonesOptions) SetProvider(provider string) *VpcGetZonesOptions {
	options.Provider = core.StringPtr(provider)
	return options
}

// SetShowFlavors : Allow user to set ShowFlavors
func (options *VpcGetZonesOptions) SetShowFlavors(showFlavors bool) *VpcGetZonesOptions {
	options.ShowFlavors = core.BoolPtr(showFlavors)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcGetZonesOptions) SetHeaders(param map[string]string) *VpcGetZonesOptions {
	options.Headers = param
	return options
}

// VpcRefreshMasterOptions : The VpcRefreshMaster options.
type VpcRefreshMasterOptions struct {
	Cluster *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcRefreshMasterOptions : Instantiate VpcRefreshMasterOptions
func (*KubernetesServiceApiV1) NewVpcRefreshMasterOptions() *VpcRefreshMasterOptions {
	return &VpcRefreshMasterOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *VpcRefreshMasterOptions) SetCluster(cluster string) *VpcRefreshMasterOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcRefreshMasterOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcRefreshMasterOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcRefreshMasterOptions) SetHeaders(param map[string]string) *VpcRefreshMasterOptions {
	options.Headers = param
	return options
}

// VpcReplaceWorkerOptions : The VpcReplaceWorker options.
type VpcReplaceWorkerOptions struct {
	Cluster *string

	Update *bool

	WorkerID *string

	// The resource group that the cluster is in. To check the resource group ID of the cluster, use the `GET
	// /v1/clusters/idOrName` API.
	XAuthResourceGroup *string

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewVpcReplaceWorkerOptions : Instantiate VpcReplaceWorkerOptions
func (*KubernetesServiceApiV1) NewVpcReplaceWorkerOptions() *VpcReplaceWorkerOptions {
	return &VpcReplaceWorkerOptions{}
}

// SetCluster : Allow user to set Cluster
func (options *VpcReplaceWorkerOptions) SetCluster(cluster string) *VpcReplaceWorkerOptions {
	options.Cluster = core.StringPtr(cluster)
	return options
}

// SetUpdate : Allow user to set Update
func (options *VpcReplaceWorkerOptions) SetUpdate(update bool) *VpcReplaceWorkerOptions {
	options.Update = core.BoolPtr(update)
	return options
}

// SetWorkerID : Allow user to set WorkerID
func (options *VpcReplaceWorkerOptions) SetWorkerID(workerID string) *VpcReplaceWorkerOptions {
	options.WorkerID = core.StringPtr(workerID)
	return options
}

// SetXAuthResourceGroup : Allow user to set XAuthResourceGroup
func (options *VpcReplaceWorkerOptions) SetXAuthResourceGroup(xAuthResourceGroup string) *VpcReplaceWorkerOptions {
	options.XAuthResourceGroup = core.StringPtr(xAuthResourceGroup)
	return options
}

// SetHeaders : Allow user to set Headers
func (options *VpcReplaceWorkerOptions) SetHeaders(param map[string]string) *VpcReplaceWorkerOptions {
	options.Headers = param
	return options
}

// Worker : Worker properties.
type Worker struct {
	ErrorMessage *string `json:"errorMessage,omitempty"`

	ErrorMessageDate *string `json:"errorMessageDate,omitempty"`

	ID *string `json:"id,omitempty"`

	Isolation *string `json:"isolation,omitempty"`

	KubeVersion *string `json:"kubeVersion,omitempty"`

	Location *string `json:"location,omitempty"`

	MachineType *string `json:"machineType,omitempty"`

	MasterVersionEOS *string `json:"masterVersionEOS,omitempty"`

	PendingOperation *string `json:"pendingOperation,omitempty"`

	PoolName *string `json:"poolName,omitempty"`

	Poolid *string `json:"poolid,omitempty"`

	PrivateIP *string `json:"privateIP,omitempty"`

	PrivateVlan *string `json:"privateVlan,omitempty"`

	PublicIP *string `json:"publicIP,omitempty"`

	PublicVlan *string `json:"publicVlan,omitempty"`

	ReasonForDelete *string `json:"reasonForDelete,omitempty"`

	State *string `json:"state,omitempty"`

	Status *string `json:"status,omitempty"`

	StatusDate *string `json:"statusDate,omitempty"`

	StatusDetails *string `json:"statusDetails,omitempty"`

	TargetVersion *string `json:"targetVersion,omitempty"`

	TrustedStatus *string `json:"trustedStatus,omitempty"`

	VersionEOS *string `json:"versionEOS,omitempty"`
}

// UnmarshalWorker unmarshals an instance of Worker from the specified map of raw messages.
func UnmarshalWorker(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Worker)
	err = core.UnmarshalPrimitive(m, "errorMessage", &obj.ErrorMessage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "errorMessageDate", &obj.ErrorMessageDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isolation", &obj.Isolation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "kubeVersion", &obj.KubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "machineType", &obj.MachineType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterVersionEOS", &obj.MasterVersionEOS)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pendingOperation", &obj.PendingOperation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "poolName", &obj.PoolName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "poolid", &obj.Poolid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateIP", &obj.PrivateIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateVlan", &obj.PrivateVlan)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicIP", &obj.PublicIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicVlan", &obj.PublicVlan)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reasonForDelete", &obj.ReasonForDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "statusDate", &obj.StatusDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "statusDetails", &obj.StatusDetails)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVersion", &obj.TargetVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "trustedStatus", &obj.TrustedStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "versionEOS", &obj.VersionEOS)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WorkerPool : WorkerPool common worker pool data.
type WorkerPool struct {
	Isolation *string `json:"isolation,omitempty"`

	Labels map[string]string `json:"labels,omitempty"`

	MachineType *string `json:"machineType,omitempty"`

	Name *string `json:"name,omitempty"`

	SizePerZone *int64 `json:"sizePerZone,omitempty"`
}

// UnmarshalWorkerPool unmarshals an instance of WorkerPool from the specified map of raw messages.
func UnmarshalWorkerPool(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WorkerPool)
	err = core.UnmarshalPrimitive(m, "isolation", &obj.Isolation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "labels", &obj.Labels)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "machineType", &obj.MachineType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sizePerZone", &obj.SizePerZone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WorkerPoolResponse : WorkerPoolResponse provides worker pool data.
type WorkerPoolResponse struct {
	AutoscaleEnabled *bool `json:"autoscaleEnabled,omitempty"`

	ID *string `json:"id,omitempty"`

	IsBalanced *bool `json:"isBalanced,omitempty"`

	Isolation *string `json:"isolation,omitempty"`

	Labels map[string]string `json:"labels,omitempty"`

	MachineType *string `json:"machineType,omitempty"`

	Name *string `json:"name,omitempty"`

	ReasonForDelete *string `json:"reasonForDelete,omitempty"`

	Region *string `json:"region,omitempty"`

	SizePerZone *int64 `json:"sizePerZone,omitempty"`

	State *string `json:"state,omitempty"`

	Zones []WorkerPoolZoneResponse `json:"zones,omitempty"`
}

// UnmarshalWorkerPoolResponse unmarshals an instance of WorkerPoolResponse from the specified map of raw messages.
func UnmarshalWorkerPoolResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WorkerPoolResponse)
	err = core.UnmarshalPrimitive(m, "autoscaleEnabled", &obj.AutoscaleEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isBalanced", &obj.IsBalanced)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isolation", &obj.Isolation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "labels", &obj.Labels)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "machineType", &obj.MachineType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reasonForDelete", &obj.ReasonForDelete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sizePerZone", &obj.SizePerZone)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "zones", &obj.Zones, UnmarshalWorkerPoolZoneResponse)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WorkerPoolZone : WorkerPoolZone provides zone data.
type WorkerPoolZone struct {
	ID *string `json:"id,omitempty"`

	PrivateVlan *string `json:"privateVlan,omitempty"`

	PublicVlan *string `json:"publicVlan,omitempty"`
}

// UnmarshalWorkerPoolZone unmarshals an instance of WorkerPoolZone from the specified map of raw messages.
func UnmarshalWorkerPoolZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WorkerPoolZone)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateVlan", &obj.PrivateVlan)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicVlan", &obj.PublicVlan)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WorkerPoolZoneResponse : WorkerPoolZoneResponse response contents for zone.
type WorkerPoolZoneResponse struct {
	AutobalanceEnabled *bool `json:"autobalanceEnabled,omitempty"`

	ID *string `json:"id,omitempty"`

	Messages []string `json:"messages,omitempty"`

	PrivateVLAN *string `json:"privateVLAN,omitempty"`

	PublicVLAN *string `json:"publicVLAN,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`
}

// UnmarshalWorkerPoolZoneResponse unmarshals an instance of WorkerPoolZoneResponse from the specified map of raw messages.
func UnmarshalWorkerPoolZoneResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WorkerPoolZoneResponse)
	err = core.UnmarshalPrimitive(m, "autobalanceEnabled", &obj.AutobalanceEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "messages", &obj.Messages)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateVLAN", &obj.PrivateVLAN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "publicVLAN", &obj.PublicVLAN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Zone : Zone shared zone definition.
type Zone struct {
	ID *string `json:"id,omitempty"`

	SubnetID *string `json:"subnetID,omitempty"`
}

// UnmarshalZone unmarshals an instance of Zone from the specified map of raw messages.
func UnmarshalZone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Zone)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "subnetID", &obj.SubnetID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ZoneResponse : ZoneResponse response definition for retrieving a zone.
type ZoneResponse struct {
	Flavors []FlavorResponse `json:"flavors,omitempty"`

	ID *string `json:"id,omitempty"`

	Metro *string `json:"metro,omitempty"`

	Name *string `json:"name,omitempty"`
}

// UnmarshalZoneResponse unmarshals an instance of ZoneResponse from the specified map of raw messages.
func UnmarshalZoneResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ZoneResponse)
	err = core.UnmarshalModel(m, "flavors", &obj.Flavors, UnmarshalFlavorResponse)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metro", &obj.Metro)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MultishiftClustersResponse : MultishiftGetServiceClusters describes a multishift service clusters response.
type MultishiftClustersResponse struct {
	Addons []CommonClusterAddon `json:"addons,omitempty"`

	// CommonClusterCACertRotation CA cert rotation properties.
	CaCertRotationStatus *CommonClusterCACertRotation `json:"caCertRotationStatus,omitempty"`

	CreatedDate *string `json:"createdDate,omitempty"`

	Datacenter *string `json:"datacenter,omitempty"`

	Entitlement *string `json:"entitlement,omitempty"`

	EtcdPort *string `json:"etcdPort,omitempty"`

	// MultishiftClusterHosts describes the hosts assigned to a cluster.
	Hosts *MultishiftClusterHosts `json:"hosts,omitempty"`

	ID *string `json:"id,omitempty"`

	ImageSecurityEnabled *bool `json:"imageSecurityEnabled,omitempty"`

	Ingress *CommonClusterIngress `json:"ingress,omitempty"`

	IsPaid *bool `json:"isPaid,omitempty"`

	Location *string `json:"location,omitempty"`

	LocationZones []string `json:"locationZones,omitempty"`

	MasterKubeVersion *string `json:"masterKubeVersion,omitempty"`

	MasterURL *string `json:"masterURL,omitempty"`

	MultiAzCapable *bool `json:"multiAzCapable,omitempty"`

	Name *string `json:"name,omitempty"`

	PodSubnet *string `json:"podSubnet,omitempty"`

	Provider *string `json:"provider,omitempty"`

	Region *string `json:"region,omitempty"`

	ResourceGroup *string `json:"resourceGroup,omitempty"`

	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	ServiceID *string `json:"serviceID,omitempty"`

	ServiceName *string `json:"serviceName,omitempty"`

	ServiceSubnet *string `json:"serviceSubnet,omitempty"`

	// The lifecycle state of the cluster. Possible values include aborted, critical, delete_failed, deleted, deleting,
	// deploy_failed, deploying, normal, pending, requested, updating, unsupported, and warning. For more information, see
	// the docs 'http://ibm.biz/cluster-health-states'.
	State *string `json:"state,omitempty"`

	Status *string `json:"status,omitempty"`

	TargetVersion *string `json:"targetVersion,omitempty"`

	Type *string `json:"type,omitempty"`

	VersionEOS *string `json:"versionEOS,omitempty"`

	Viewable *bool `json:"viewable,omitempty"`

	WorkerCount *int64 `json:"workerCount,omitempty"`

	WorkerPools []WorkerPool `json:"workerPools,omitempty"`
}

// UnmarshalMultishiftClustersResponse unmarshals an instance of MultishiftClustersResponse from the specified map of raw messages.
func UnmarshalMultishiftClustersResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MultishiftClustersResponse)
	err = core.UnmarshalModel(m, "addons", &obj.Addons, UnmarshalCommonClusterAddon)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "caCertRotationStatus", &obj.CaCertRotationStatus, UnmarshalCommonClusterCACertRotation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "createdDate", &obj.CreatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "datacenter", &obj.Datacenter)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "entitlement", &obj.Entitlement)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "etcdPort", &obj.EtcdPort)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "hosts", &obj.Hosts, UnmarshalMultishiftClusterHosts)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageSecurityEnabled", &obj.ImageSecurityEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ingress", &obj.Ingress, UnmarshalCommonClusterIngress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isPaid", &obj.IsPaid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locationZones", &obj.LocationZones)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterKubeVersion", &obj.MasterKubeVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterURL", &obj.MasterURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "multiAzCapable", &obj.MultiAzCapable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "podSubnet", &obj.PodSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provider", &obj.Provider)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroup", &obj.ResourceGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupName", &obj.ResourceGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceID", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceName", &obj.ServiceName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceSubnet", &obj.ServiceSubnet)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVersion", &obj.TargetVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "versionEOS", &obj.VersionEOS)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "viewable", &obj.Viewable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "workerCount", &obj.WorkerCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "workerPools", &obj.WorkerPools, UnmarshalWorkerPool)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
